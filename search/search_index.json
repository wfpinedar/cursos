{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenido a Mis Cursos \u00b6 \u00a1Hola! Este sitio re\u00fane la documentaci\u00f3n y el material de varios cursos, organizados por niveles y t\u00f3picos. Aqu\u00ed encontrar\u00e1s explicaciones te\u00f3ricas, ejercicios pr\u00e1cticos y buenas pr\u00e1cticas de lenguajes y frameworks como Clojure , Elixir (WIP), Go (WIP), Haskell (WIP), Luminus (WIP), y Phoenix (WIP), entre otros. \u00bfQu\u00e9 encontrar\u00e1s aqu\u00ed? \u00b6 Lecciones Te\u00f3ricas Cada curso incluye lecciones te\u00f3ricas con explicaciones claras y concisas sobre la tem\u00e1tica principal, as\u00ed como enlaces a recursos adicionales para profundizar. Ejemplos de C\u00f3digo Se incluyen fragmentos de c\u00f3digo para ilustrar c\u00f3mo funcionan los conceptos en la pr\u00e1ctica. Puedes copiar y modificar los ejemplos para experimentar por tu cuenta. Ejercicios Pr\u00e1cticos Al final de cada tema, ver\u00e1s ejercicios que te ayudar\u00e1n a reforzar lo aprendido y a desarrollar tus habilidades de programaci\u00f3n. Buenas Pr\u00e1cticas y Consejos Adem\u00e1s de la teor\u00eda, se ofrecen recomendaciones sobre estilo de c\u00f3digo, patrones comunes y consejos \u00fatiles para desarrollar aplicaciones robustas. Cursos Disponibles \u00b6 Clojure Elixir GO (WIP) Haskell (WIP) Luminus (WIP) Phoenix (WIP) \u00a1Elige el curso que m\u00e1s te interese y comienza a explorar! \u00bfC\u00f3mo navegar? \u00b6 En la barra de navegaci\u00f3n superior (o lateral, seg\u00fan tu configuraci\u00f3n), encontrar\u00e1s cada curso. Dentro de cada uno, ver\u00e1s una Introducci\u00f3n y varios niveles de dificultad. Escoge el nivel apropiado (Junior, Mid o Senior) seg\u00fan tu experiencia o tus objetivos de aprendizaje. Recomendaciones Generales \u00b6 Si eres totalmente principiante en un lenguaje o framework, revisa primero los temas de nivel Junior. Si ya cuentas con experiencia previa, posiblemente te interesen directamente los niveles Mid o Senior. Usa la barra de navegaci\u00f3n o los enlaces al final de cada p\u00e1gina para moverte de una lecci\u00f3n a otra. Contribuciones y Retroalimentaci\u00f3n \u00b6 Si encuentras un error, tienes sugerencias de mejora o deseas contribuir con nuevo contenido, si\u00e9ntete libre de hacerlo a trav\u00e9s del repositorio en GitHub. Tu retroalimentaci\u00f3n es muy valiosa para mantener estos cursos actualizados y \u00fatiles para toda la comunidad. \u00a1Gracias por visitar este sitio! Esperamos que cada curso te ayude a profundizar en tus conocimientos de programaci\u00f3n y te inspire a crear aplicaciones incre\u00edbles.","title":"Introducci\u00f3n"},{"location":"#bienvenido-a-mis-cursos","text":"\u00a1Hola! Este sitio re\u00fane la documentaci\u00f3n y el material de varios cursos, organizados por niveles y t\u00f3picos. Aqu\u00ed encontrar\u00e1s explicaciones te\u00f3ricas, ejercicios pr\u00e1cticos y buenas pr\u00e1cticas de lenguajes y frameworks como Clojure , Elixir (WIP), Go (WIP), Haskell (WIP), Luminus (WIP), y Phoenix (WIP), entre otros.","title":"Bienvenido a Mis Cursos"},{"location":"#que-encontraras-aqui","text":"Lecciones Te\u00f3ricas Cada curso incluye lecciones te\u00f3ricas con explicaciones claras y concisas sobre la tem\u00e1tica principal, as\u00ed como enlaces a recursos adicionales para profundizar. Ejemplos de C\u00f3digo Se incluyen fragmentos de c\u00f3digo para ilustrar c\u00f3mo funcionan los conceptos en la pr\u00e1ctica. Puedes copiar y modificar los ejemplos para experimentar por tu cuenta. Ejercicios Pr\u00e1cticos Al final de cada tema, ver\u00e1s ejercicios que te ayudar\u00e1n a reforzar lo aprendido y a desarrollar tus habilidades de programaci\u00f3n. Buenas Pr\u00e1cticas y Consejos Adem\u00e1s de la teor\u00eda, se ofrecen recomendaciones sobre estilo de c\u00f3digo, patrones comunes y consejos \u00fatiles para desarrollar aplicaciones robustas.","title":"\u00bfQu\u00e9 encontrar\u00e1s aqu\u00ed?"},{"location":"#cursos-disponibles","text":"Clojure Elixir GO (WIP) Haskell (WIP) Luminus (WIP) Phoenix (WIP) \u00a1Elige el curso que m\u00e1s te interese y comienza a explorar!","title":"Cursos Disponibles"},{"location":"#como-navegar","text":"En la barra de navegaci\u00f3n superior (o lateral, seg\u00fan tu configuraci\u00f3n), encontrar\u00e1s cada curso. Dentro de cada uno, ver\u00e1s una Introducci\u00f3n y varios niveles de dificultad. Escoge el nivel apropiado (Junior, Mid o Senior) seg\u00fan tu experiencia o tus objetivos de aprendizaje.","title":"\u00bfC\u00f3mo navegar?"},{"location":"#recomendaciones-generales","text":"Si eres totalmente principiante en un lenguaje o framework, revisa primero los temas de nivel Junior. Si ya cuentas con experiencia previa, posiblemente te interesen directamente los niveles Mid o Senior. Usa la barra de navegaci\u00f3n o los enlaces al final de cada p\u00e1gina para moverte de una lecci\u00f3n a otra.","title":"Recomendaciones Generales"},{"location":"#contribuciones-y-retroalimentacion","text":"Si encuentras un error, tienes sugerencias de mejora o deseas contribuir con nuevo contenido, si\u00e9ntete libre de hacerlo a trav\u00e9s del repositorio en GitHub. Tu retroalimentaci\u00f3n es muy valiosa para mantener estos cursos actualizados y \u00fatiles para toda la comunidad. \u00a1Gracias por visitar este sitio! Esperamos que cada curso te ayude a profundizar en tus conocimientos de programaci\u00f3n y te inspire a crear aplicaciones incre\u00edbles.","title":"Contribuciones y Retroalimentaci\u00f3n"},{"location":"clojure/","text":"Curso de Clojure \u00b6 \u00a1Bienvenido(a) al curso de Clojure ! En este curso encontrar\u00e1s material organizado en tres niveles de dificultad. Selecciona el nivel que se ajuste a tus necesidades de aprendizaje: Junior Middle Senior Cada nivel incluye temas como sintaxis, estructuras de datos, desarrollo de aplicaciones, optimizaci\u00f3n y m\u00e1s. \u00a1Explora cada secci\u00f3n para dominar Clojure paso a paso!","title":"Introducci\u00f3n"},{"location":"clojure/#curso-de-clojure","text":"\u00a1Bienvenido(a) al curso de Clojure ! En este curso encontrar\u00e1s material organizado en tres niveles de dificultad. Selecciona el nivel que se ajuste a tus necesidades de aprendizaje: Junior Middle Senior Cada nivel incluye temas como sintaxis, estructuras de datos, desarrollo de aplicaciones, optimizaci\u00f3n y m\u00e1s. \u00a1Explora cada secci\u00f3n para dominar Clojure paso a paso!","title":"Curso de Clojure"},{"location":"clojure/Junior/","text":"Clojure - Nivel Junior \u00b6 En esta secci\u00f3n encontrar\u00e1s: Introducci\u00f3n a Clojure Instalaci\u00f3n y configuraci\u00f3n Sintaxis y estructuras de datos Funciones y recursi\u00f3n Colecciones Control de flujo y estructuras de control Programaci\u00f3n funcional Gesti\u00f3n de errores y depuraci\u00f3n M\u00f3dulos y namespaces Trabajo con archivos y bases de datos Creaci\u00f3n de aplicaciones web con Clojure \u00a1Selecciona el tema que te interese para comenzar!","title":"Nivel Junior"},{"location":"clojure/Junior/#clojure-nivel-junior","text":"En esta secci\u00f3n encontrar\u00e1s: Introducci\u00f3n a Clojure Instalaci\u00f3n y configuraci\u00f3n Sintaxis y estructuras de datos Funciones y recursi\u00f3n Colecciones Control de flujo y estructuras de control Programaci\u00f3n funcional Gesti\u00f3n de errores y depuraci\u00f3n M\u00f3dulos y namespaces Trabajo con archivos y bases de datos Creaci\u00f3n de aplicaciones web con Clojure \u00a1Selecciona el tema que te interese para comenzar!","title":"Clojure - Nivel Junior"},{"location":"clojure/Junior/colecciones/","text":"Colecciones en Clojure \u00b6 Las colecciones son estructuras de datos fundamentales en Clojure que permiten almacenar y manipular m\u00faltiples valores de forma eficiente. Son inmutables, lo que significa que no se pueden modificar una vez creadas, pero se pueden crear nuevas colecciones a partir de las existentes mediante operaciones de transformaci\u00f3n. Palabras clave y definiciones \u00b6 Listas: estructuras de datos secuenciales y ordenadas que pueden contener cualquier tipo de valor. Se crean con la funci\u00f3n list o utilizando la sintaxis '(elemento1 elemento2 ...) . Vectores: estructuras de datos secuenciales y ordenadas que se pueden acceder eficientemente por \u00edndice. Se crean con la funci\u00f3n vector o utilizando la sintaxis [elemento1 elemento2 ...] . Conjuntos: estructuras de datos no ordenadas que no permiten duplicados. Se crean con la funci\u00f3n set o utilizando la sintaxis #{elemento1 elemento2 ...} . Mapas: estructuras de datos que asocian claves con valores. Se crean con la funci\u00f3n hash-map o utilizando la sintaxis {:clave1 valor1 :clave2 valor2 ...} . Preguntas de repaso \u00b6 \u00bfQu\u00e9 son las colecciones en Clojure? \u00bfCu\u00e1les son las caracter\u00edsticas de las colecciones en Clojure? \u00bfQu\u00e9 funciones se utilizan para crear listas, vectores, conjuntos y mapas? \u00bfC\u00f3mo se puede acceder a un elemento de un vector en Clojure? \u00bfQu\u00e9 diferencia hay entre un conjunto y un mapa en Clojure? Ejemplos de c\u00f3digo \u00b6 Creaci\u00f3n de listas \u00b6 ( def lista1 ( list 1 2 3 )) ; utilizando la funci\u00f3n list ( def lista2 ' ( 4 5 6 )) ; utilizando la sintaxis Creaci\u00f3n de vectores \u00b6 ( def vector1 ( vector 1 2 3 )) ; utilizando la funci\u00f3n vector ( def vector2 [ 4 5 6 ]) ; utilizando la sintaxis Creaci\u00f3n de conjuntos \u00b6 ( def set1 ( set [ 1 2 3 ])) ; utilizando la funci\u00f3n set ( def set2 # { 4 5 6 }) ; utilizando la sintaxis Creaci\u00f3n de mapas \u00b6 ( def mapa1 ( hash-map :nombre \"Juan\" :edad 30 )) ; utilizando la funci\u00f3n hash-map ( def mapa2 { :nombre \"Mar\u00eda\" :edad 25 }) ; utilizando la sintaxis Ejercicios pr\u00e1cticos \u00b6 Crea una lista que contenga los n\u00fameros del 1 al 10. Crea un vector con los d\u00edas de la semana. Crea un conjunto con los colores del arco\u00edris. Crea un mapa que asocie nombres de frutas con su precio. Utiliza la funci\u00f3n conj para agregar un elemento a un conjunto existente. Utiliza la funci\u00f3n assoc para agregar una nueva clave y valor a un mapa existente. Consejos y mejores pr\u00e1cticas \u00b6 Utiliza listas para datos que se acceden secuencialmente y no necesitas acceder por \u00edndice. Utiliza vectores para datos que necesitas acceder por \u00edndice. Utiliza conjuntos para datos que no necesitan un orden espec\u00edfico y no permiten duplicados. Utiliza mapas para datos que necesitas asociar claves con valores. Utiliza la sintaxis abreviada siempre que sea posible para crear colecciones. Utiliza las funciones de transformaci\u00f3n como map , filter y reduce para manipular colecciones de forma funcional. Evita modificar colecciones existentes, en su lugar crea nuevas colecciones a partir de ellas. <- Lecci\u00f3n anterior : Funciones y recursi\u00f3n Siguiente lecci\u00f3n -> : Control de flujo y estructuras de control","title":"Colecciones en Clojure"},{"location":"clojure/Junior/colecciones/#colecciones-en-clojure","text":"Las colecciones son estructuras de datos fundamentales en Clojure que permiten almacenar y manipular m\u00faltiples valores de forma eficiente. Son inmutables, lo que significa que no se pueden modificar una vez creadas, pero se pueden crear nuevas colecciones a partir de las existentes mediante operaciones de transformaci\u00f3n.","title":"Colecciones en Clojure"},{"location":"clojure/Junior/colecciones/#palabras-clave-y-definiciones","text":"Listas: estructuras de datos secuenciales y ordenadas que pueden contener cualquier tipo de valor. Se crean con la funci\u00f3n list o utilizando la sintaxis '(elemento1 elemento2 ...) . Vectores: estructuras de datos secuenciales y ordenadas que se pueden acceder eficientemente por \u00edndice. Se crean con la funci\u00f3n vector o utilizando la sintaxis [elemento1 elemento2 ...] . Conjuntos: estructuras de datos no ordenadas que no permiten duplicados. Se crean con la funci\u00f3n set o utilizando la sintaxis #{elemento1 elemento2 ...} . Mapas: estructuras de datos que asocian claves con valores. Se crean con la funci\u00f3n hash-map o utilizando la sintaxis {:clave1 valor1 :clave2 valor2 ...} .","title":"Palabras clave y definiciones"},{"location":"clojure/Junior/colecciones/#preguntas-de-repaso","text":"\u00bfQu\u00e9 son las colecciones en Clojure? \u00bfCu\u00e1les son las caracter\u00edsticas de las colecciones en Clojure? \u00bfQu\u00e9 funciones se utilizan para crear listas, vectores, conjuntos y mapas? \u00bfC\u00f3mo se puede acceder a un elemento de un vector en Clojure? \u00bfQu\u00e9 diferencia hay entre un conjunto y un mapa en Clojure?","title":"Preguntas de repaso"},{"location":"clojure/Junior/colecciones/#ejemplos-de-codigo","text":"","title":"Ejemplos de c\u00f3digo"},{"location":"clojure/Junior/colecciones/#creacion-de-listas","text":"( def lista1 ( list 1 2 3 )) ; utilizando la funci\u00f3n list ( def lista2 ' ( 4 5 6 )) ; utilizando la sintaxis","title":"Creaci\u00f3n de listas"},{"location":"clojure/Junior/colecciones/#creacion-de-vectores","text":"( def vector1 ( vector 1 2 3 )) ; utilizando la funci\u00f3n vector ( def vector2 [ 4 5 6 ]) ; utilizando la sintaxis","title":"Creaci\u00f3n de vectores"},{"location":"clojure/Junior/colecciones/#creacion-de-conjuntos","text":"( def set1 ( set [ 1 2 3 ])) ; utilizando la funci\u00f3n set ( def set2 # { 4 5 6 }) ; utilizando la sintaxis","title":"Creaci\u00f3n de conjuntos"},{"location":"clojure/Junior/colecciones/#creacion-de-mapas","text":"( def mapa1 ( hash-map :nombre \"Juan\" :edad 30 )) ; utilizando la funci\u00f3n hash-map ( def mapa2 { :nombre \"Mar\u00eda\" :edad 25 }) ; utilizando la sintaxis","title":"Creaci\u00f3n de mapas"},{"location":"clojure/Junior/colecciones/#ejercicios-practicos","text":"Crea una lista que contenga los n\u00fameros del 1 al 10. Crea un vector con los d\u00edas de la semana. Crea un conjunto con los colores del arco\u00edris. Crea un mapa que asocie nombres de frutas con su precio. Utiliza la funci\u00f3n conj para agregar un elemento a un conjunto existente. Utiliza la funci\u00f3n assoc para agregar una nueva clave y valor a un mapa existente.","title":"Ejercicios pr\u00e1cticos"},{"location":"clojure/Junior/colecciones/#consejos-y-mejores-practicas","text":"Utiliza listas para datos que se acceden secuencialmente y no necesitas acceder por \u00edndice. Utiliza vectores para datos que necesitas acceder por \u00edndice. Utiliza conjuntos para datos que no necesitan un orden espec\u00edfico y no permiten duplicados. Utiliza mapas para datos que necesitas asociar claves con valores. Utiliza la sintaxis abreviada siempre que sea posible para crear colecciones. Utiliza las funciones de transformaci\u00f3n como map , filter y reduce para manipular colecciones de forma funcional. Evita modificar colecciones existentes, en su lugar crea nuevas colecciones a partir de ellas. <- Lecci\u00f3n anterior : Funciones y recursi\u00f3n Siguiente lecci\u00f3n -> : Control de flujo y estructuras de control","title":"Consejos y mejores pr\u00e1cticas"},{"location":"clojure/Junior/control_de_flujo_y_estructuras_de_control/","text":"Control de flujo y estructuras de control \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 El control de flujo en un programa se refiere a la capacidad de dirigir la ejecuci\u00f3n del c\u00f3digo en diferentes direcciones, dependiendo de ciertas condiciones o situaciones. En Clojure, existen diversas estructuras de control que nos permiten controlar el flujo de ejecuci\u00f3n, como if, while y for. La estructura de control \"if\" nos permite ejecutar un bloque de c\u00f3digo si se cumple una determinada condici\u00f3n. En caso de que no se cumpla, se puede incluir un bloque \"else\" con un c\u00f3digo alternativo. Esta estructura se utiliza para tomar decisiones en el programa, por ejemplo, si una variable es mayor o menor que un valor determinado. La estructura de control \"while\" nos permite ejecutar un bloque de c\u00f3digo mientras se cumpla una condici\u00f3n espec\u00edfica. Esto nos permite repetir una acci\u00f3n hasta que se alcance un resultado deseado. La estructura de control \"for\" se utiliza para iterar sobre una colecci\u00f3n de datos, ejecutando un bloque de c\u00f3digo para cada elemento de la colecci\u00f3n. Esto nos permite trabajar con listas, vectores, mapas y otros tipos de datos de manera m\u00e1s eficiente. Palabras clave y su definici\u00f3n \u00b6 if: Estructura de control que permite ejecutar un bloque de c\u00f3digo si se cumple una determinada condici\u00f3n. else: Palabra clave utilizada en conjunci\u00f3n con \"if\", que permite incluir un bloque de c\u00f3digo alternativo en caso de que no se cumpla la condici\u00f3n. while: Estructura de control que permite ejecutar un bloque de c\u00f3digo mientras se cumpla una condici\u00f3n espec\u00edfica. for: Estructura de control utilizada para iterar sobre una colecci\u00f3n de datos y ejecutar un bloque de c\u00f3digo para cada elemento de la colecci\u00f3n. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es el control de flujo en un programa? \u00bfQu\u00e9 estructura de control se utiliza para tomar decisiones en un programa? \u00bfCu\u00e1l es la diferencia entre \"if\" y \"while\" en Clojure? \u00bfQu\u00e9 es lo que hace la estructura de control \"for\"? \u00bfCu\u00e1l es la palabra clave utilizada en conjunci\u00f3n con \"if\" para incluir un bloque de c\u00f3digo alternativo? Ejemplos de c\u00f3digo en Clojure \u00b6 ;; Ejemplo de estructura \"if\" ( def edad 25 ) ( if ( < edad 18 ) ( println \"Eres menor de edad\" ) ( println \"Eres mayor de edad\" )) ;; Ejemplo de estructura \"while\" ( def contador 0 ) ( while ( < contador 5 ) ( println contador ) ( def contador ( inc contador ))) ;; Ejemplo de estructura \"for\" ( def numeros [ 1 2 3 4 5 ]) ( for [ num numeros ] ( println ( * num 2 ))) Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Utilizando la estructura \"if\", crea una funci\u00f3n que reciba como par\u00e1metro el n\u00famero de un mes y devuelva el nombre del mes correspondiente. Si el n\u00famero no est\u00e1 entre 1 y 12, mostrar un mensaje de error. Utilizando la estructura \"while\", crea una funci\u00f3n que reciba como par\u00e1metro un n\u00famero y muestre por pantalla todos los n\u00fameros pares desde 0 hasta ese n\u00famero. Utilizando la estructura \"for\", crea una funci\u00f3n que reciba como par\u00e1metro una lista de palabras y devuelva una lista con las mismas palabras en may\u00fasculas. Consejos o mejores pr\u00e1cticas \u00b6 Utilizar correctamente las estructuras de control para mejorar la eficiencia y legibilidad del c\u00f3digo. Evitar anidar demasiadas estructuras de control, ya que puede hacer el c\u00f3digo dif\u00edcil de entender y mantener. Utilizar nombres descriptivos para las variables y par\u00e1metros en las estructuras de control, para que sea m\u00e1s f\u00e1cil de entender su funci\u00f3n en el c\u00f3digo. Navegaci\u00f3n de lecciones \u00b6 <- Lecci\u00f3n anterior : Colecciones Siguiente lecci\u00f3n -> : Programaci\u00f3n funcional","title":"Control de flujo y estructuras de control"},{"location":"clojure/Junior/control_de_flujo_y_estructuras_de_control/#control-de-flujo-y-estructuras-de-control","text":"","title":"Control de flujo y estructuras de control"},{"location":"clojure/Junior/control_de_flujo_y_estructuras_de_control/#explicacion-teorica","text":"El control de flujo en un programa se refiere a la capacidad de dirigir la ejecuci\u00f3n del c\u00f3digo en diferentes direcciones, dependiendo de ciertas condiciones o situaciones. En Clojure, existen diversas estructuras de control que nos permiten controlar el flujo de ejecuci\u00f3n, como if, while y for. La estructura de control \"if\" nos permite ejecutar un bloque de c\u00f3digo si se cumple una determinada condici\u00f3n. En caso de que no se cumpla, se puede incluir un bloque \"else\" con un c\u00f3digo alternativo. Esta estructura se utiliza para tomar decisiones en el programa, por ejemplo, si una variable es mayor o menor que un valor determinado. La estructura de control \"while\" nos permite ejecutar un bloque de c\u00f3digo mientras se cumpla una condici\u00f3n espec\u00edfica. Esto nos permite repetir una acci\u00f3n hasta que se alcance un resultado deseado. La estructura de control \"for\" se utiliza para iterar sobre una colecci\u00f3n de datos, ejecutando un bloque de c\u00f3digo para cada elemento de la colecci\u00f3n. Esto nos permite trabajar con listas, vectores, mapas y otros tipos de datos de manera m\u00e1s eficiente.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"clojure/Junior/control_de_flujo_y_estructuras_de_control/#palabras-clave-y-su-definicion","text":"if: Estructura de control que permite ejecutar un bloque de c\u00f3digo si se cumple una determinada condici\u00f3n. else: Palabra clave utilizada en conjunci\u00f3n con \"if\", que permite incluir un bloque de c\u00f3digo alternativo en caso de que no se cumpla la condici\u00f3n. while: Estructura de control que permite ejecutar un bloque de c\u00f3digo mientras se cumpla una condici\u00f3n espec\u00edfica. for: Estructura de control utilizada para iterar sobre una colecci\u00f3n de datos y ejecutar un bloque de c\u00f3digo para cada elemento de la colecci\u00f3n.","title":"Palabras clave y su definici\u00f3n"},{"location":"clojure/Junior/control_de_flujo_y_estructuras_de_control/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es el control de flujo en un programa? \u00bfQu\u00e9 estructura de control se utiliza para tomar decisiones en un programa? \u00bfCu\u00e1l es la diferencia entre \"if\" y \"while\" en Clojure? \u00bfQu\u00e9 es lo que hace la estructura de control \"for\"? \u00bfCu\u00e1l es la palabra clave utilizada en conjunci\u00f3n con \"if\" para incluir un bloque de c\u00f3digo alternativo?","title":"Preguntas de repaso"},{"location":"clojure/Junior/control_de_flujo_y_estructuras_de_control/#ejemplos-de-codigo-en-clojure","text":";; Ejemplo de estructura \"if\" ( def edad 25 ) ( if ( < edad 18 ) ( println \"Eres menor de edad\" ) ( println \"Eres mayor de edad\" )) ;; Ejemplo de estructura \"while\" ( def contador 0 ) ( while ( < contador 5 ) ( println contador ) ( def contador ( inc contador ))) ;; Ejemplo de estructura \"for\" ( def numeros [ 1 2 3 4 5 ]) ( for [ num numeros ] ( println ( * num 2 )))","title":"Ejemplos de c\u00f3digo en Clojure"},{"location":"clojure/Junior/control_de_flujo_y_estructuras_de_control/#ejercicios-practicos-con-instrucciones-claras","text":"Utilizando la estructura \"if\", crea una funci\u00f3n que reciba como par\u00e1metro el n\u00famero de un mes y devuelva el nombre del mes correspondiente. Si el n\u00famero no est\u00e1 entre 1 y 12, mostrar un mensaje de error. Utilizando la estructura \"while\", crea una funci\u00f3n que reciba como par\u00e1metro un n\u00famero y muestre por pantalla todos los n\u00fameros pares desde 0 hasta ese n\u00famero. Utilizando la estructura \"for\", crea una funci\u00f3n que reciba como par\u00e1metro una lista de palabras y devuelva una lista con las mismas palabras en may\u00fasculas.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"clojure/Junior/control_de_flujo_y_estructuras_de_control/#consejos-o-mejores-practicas","text":"Utilizar correctamente las estructuras de control para mejorar la eficiencia y legibilidad del c\u00f3digo. Evitar anidar demasiadas estructuras de control, ya que puede hacer el c\u00f3digo dif\u00edcil de entender y mantener. Utilizar nombres descriptivos para las variables y par\u00e1metros en las estructuras de control, para que sea m\u00e1s f\u00e1cil de entender su funci\u00f3n en el c\u00f3digo.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"clojure/Junior/control_de_flujo_y_estructuras_de_control/#navegacion-de-lecciones","text":"<- Lecci\u00f3n anterior : Colecciones Siguiente lecci\u00f3n -> : Programaci\u00f3n funcional","title":"Navegaci\u00f3n de lecciones"},{"location":"clojure/Junior/creacion_de_aplicaciones_web_con_clojure/","text":"Creaci\u00f3n de aplicaciones web con Clojure \u00b6 Introducci\u00f3n \u00b6 Clojure es un lenguaje de programaci\u00f3n funcional din\u00e1mico que se ejecuta en la plataforma Java Virtual Machine (JVM). Una de las \u00e1reas en las que se ha vuelto muy popular es en el desarrollo de aplicaciones web, gracias a su enfoque en la concurrencia y la inmutabilidad, as\u00ed como a las herramientas y frameworks disponibles para facilitar el proceso de creaci\u00f3n de aplicaciones web. Herramientas y frameworks para aplicaciones web en Clojure \u00b6 Ring \u00b6 Ring es una librer\u00eda para el manejo de peticiones HTTP en Clojure. Proporciona una abstracci\u00f3n simple y coherente para trabajar con peticiones y respuestas, y permite la creaci\u00f3n de aplicaciones web de manera modular y extensible. Ring se encarga de la comunicaci\u00f3n con el servidor web, mientras que el desarrollador puede enfocarse en la l\u00f3gica de la aplicaci\u00f3n. Compojure \u00b6 Compojure es un framework para la creaci\u00f3n de aplicaciones web en Clojure, construido sobre Ring. Proporciona una sintaxis concisa y elegante para definir rutas y manejar peticiones, y tambi\u00e9n incluye herramientas para el manejo de par\u00e1metros, cookies y sesiones. Otros frameworks \u00b6 Adem\u00e1s de Ring y Compojure, existen otros frameworks para el desarrollo de aplicaciones web en Clojure, como Luminus, Pedestal y Reitit. Cada uno ofrece diferentes caracter\u00edsticas y enfoques, por lo que es importante investigar y elegir el que mejor se adapte a las necesidades del proyecto. Palabras clave \u00b6 Aplicaci\u00f3n web: una aplicaci\u00f3n que se ejecuta en un servidor web y es accesible a trav\u00e9s de internet. Framework: un conjunto de herramientas y librer\u00edas que proporcionan una estructura y funcionalidades para facilitar el desarrollo de aplicaciones. Librer\u00eda: un conjunto de funciones y clases que pueden ser utilizadas por el desarrollador en su aplicaci\u00f3n. Peticiones HTTP: solicitudes realizadas por el cliente al servidor web para obtener informaci\u00f3n o realizar acciones. Respuestas HTTP: la informaci\u00f3n que el servidor web env\u00eda al cliente como resultado de una petici\u00f3n. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es Ring y c\u00f3mo se relaciona con Compojure? \u00bfCu\u00e1l es la funci\u00f3n de un framework en el desarrollo de aplicaciones web? \u00bfQu\u00e9 es una petici\u00f3n HTTP y cu\u00e1l es su relaci\u00f3n con una respuesta HTTP? Ejemplos de c\u00f3digo en Clojure \u00b6 Definir una ruta en Compojure \u00b6 ( defroutes app ( GET \"/\" [] \"\u00a1Bienvenido a mi aplicaci\u00f3n web!\" ) ( GET \"/usuarios\" [] ( list-users )) ( GET \"/usuarios/:id\" [ id ] ( get-user id ))) Manejar una petici\u00f3n en Ring \u00b6 ( defn handler [ request ] { :status 200 :headers { \"Content-Type\" \"text/html\" } :body \"<h1>Hola, mundo!</h1>\" }) Ejercicios pr\u00e1cticos \u00b6 Crea una aplicaci\u00f3n web utilizando Ring y Compojure que tenga una ruta para mostrar una lista de usuarios y otra ruta para mostrar la informaci\u00f3n de un usuario en particular. Utiliza una librer\u00eda de manejo de base de datos (como HoneySQL o Korma) para a\u00f1adir funcionalidad de persistencia a tu aplicaci\u00f3n web. Consejos y mejores pr\u00e1cticas \u00b6 Utiliza la documentaci\u00f3n oficial de Ring y Compojure para familiarizarte con sus funcionalidades y opciones de configuraci\u00f3n. Investiga y compara diferentes frameworks antes de elegir uno para tu proyecto. Utiliza librer\u00edas de manejo de base de datos para facilitar la persistencia de datos en tu aplicaci\u00f3n web. Aprovecha la inmutabilidad y la concurrencia de Clojure para crear aplicaciones web m\u00e1s robustas y escalables. Navegaci\u00f3n de lecciones \u00b6 <- Lecci\u00f3n anterior : Trabajo con archivos y bases de datos","title":"Creaci\u00f3n de aplicaciones web con Clojure"},{"location":"clojure/Junior/creacion_de_aplicaciones_web_con_clojure/#creacion-de-aplicaciones-web-con-clojure","text":"","title":"Creaci\u00f3n de aplicaciones web con Clojure"},{"location":"clojure/Junior/creacion_de_aplicaciones_web_con_clojure/#introduccion","text":"Clojure es un lenguaje de programaci\u00f3n funcional din\u00e1mico que se ejecuta en la plataforma Java Virtual Machine (JVM). Una de las \u00e1reas en las que se ha vuelto muy popular es en el desarrollo de aplicaciones web, gracias a su enfoque en la concurrencia y la inmutabilidad, as\u00ed como a las herramientas y frameworks disponibles para facilitar el proceso de creaci\u00f3n de aplicaciones web.","title":"Introducci\u00f3n"},{"location":"clojure/Junior/creacion_de_aplicaciones_web_con_clojure/#herramientas-y-frameworks-para-aplicaciones-web-en-clojure","text":"","title":"Herramientas y frameworks para aplicaciones web en Clojure"},{"location":"clojure/Junior/creacion_de_aplicaciones_web_con_clojure/#ring","text":"Ring es una librer\u00eda para el manejo de peticiones HTTP en Clojure. Proporciona una abstracci\u00f3n simple y coherente para trabajar con peticiones y respuestas, y permite la creaci\u00f3n de aplicaciones web de manera modular y extensible. Ring se encarga de la comunicaci\u00f3n con el servidor web, mientras que el desarrollador puede enfocarse en la l\u00f3gica de la aplicaci\u00f3n.","title":"Ring"},{"location":"clojure/Junior/creacion_de_aplicaciones_web_con_clojure/#compojure","text":"Compojure es un framework para la creaci\u00f3n de aplicaciones web en Clojure, construido sobre Ring. Proporciona una sintaxis concisa y elegante para definir rutas y manejar peticiones, y tambi\u00e9n incluye herramientas para el manejo de par\u00e1metros, cookies y sesiones.","title":"Compojure"},{"location":"clojure/Junior/creacion_de_aplicaciones_web_con_clojure/#otros-frameworks","text":"Adem\u00e1s de Ring y Compojure, existen otros frameworks para el desarrollo de aplicaciones web en Clojure, como Luminus, Pedestal y Reitit. Cada uno ofrece diferentes caracter\u00edsticas y enfoques, por lo que es importante investigar y elegir el que mejor se adapte a las necesidades del proyecto.","title":"Otros frameworks"},{"location":"clojure/Junior/creacion_de_aplicaciones_web_con_clojure/#palabras-clave","text":"Aplicaci\u00f3n web: una aplicaci\u00f3n que se ejecuta en un servidor web y es accesible a trav\u00e9s de internet. Framework: un conjunto de herramientas y librer\u00edas que proporcionan una estructura y funcionalidades para facilitar el desarrollo de aplicaciones. Librer\u00eda: un conjunto de funciones y clases que pueden ser utilizadas por el desarrollador en su aplicaci\u00f3n. Peticiones HTTP: solicitudes realizadas por el cliente al servidor web para obtener informaci\u00f3n o realizar acciones. Respuestas HTTP: la informaci\u00f3n que el servidor web env\u00eda al cliente como resultado de una petici\u00f3n.","title":"Palabras clave"},{"location":"clojure/Junior/creacion_de_aplicaciones_web_con_clojure/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Ring y c\u00f3mo se relaciona con Compojure? \u00bfCu\u00e1l es la funci\u00f3n de un framework en el desarrollo de aplicaciones web? \u00bfQu\u00e9 es una petici\u00f3n HTTP y cu\u00e1l es su relaci\u00f3n con una respuesta HTTP?","title":"Preguntas de repaso"},{"location":"clojure/Junior/creacion_de_aplicaciones_web_con_clojure/#ejemplos-de-codigo-en-clojure","text":"","title":"Ejemplos de c\u00f3digo en Clojure"},{"location":"clojure/Junior/creacion_de_aplicaciones_web_con_clojure/#definir-una-ruta-en-compojure","text":"( defroutes app ( GET \"/\" [] \"\u00a1Bienvenido a mi aplicaci\u00f3n web!\" ) ( GET \"/usuarios\" [] ( list-users )) ( GET \"/usuarios/:id\" [ id ] ( get-user id )))","title":"Definir una ruta en Compojure"},{"location":"clojure/Junior/creacion_de_aplicaciones_web_con_clojure/#manejar-una-peticion-en-ring","text":"( defn handler [ request ] { :status 200 :headers { \"Content-Type\" \"text/html\" } :body \"<h1>Hola, mundo!</h1>\" })","title":"Manejar una petici\u00f3n en Ring"},{"location":"clojure/Junior/creacion_de_aplicaciones_web_con_clojure/#ejercicios-practicos","text":"Crea una aplicaci\u00f3n web utilizando Ring y Compojure que tenga una ruta para mostrar una lista de usuarios y otra ruta para mostrar la informaci\u00f3n de un usuario en particular. Utiliza una librer\u00eda de manejo de base de datos (como HoneySQL o Korma) para a\u00f1adir funcionalidad de persistencia a tu aplicaci\u00f3n web.","title":"Ejercicios pr\u00e1cticos"},{"location":"clojure/Junior/creacion_de_aplicaciones_web_con_clojure/#consejos-y-mejores-practicas","text":"Utiliza la documentaci\u00f3n oficial de Ring y Compojure para familiarizarte con sus funcionalidades y opciones de configuraci\u00f3n. Investiga y compara diferentes frameworks antes de elegir uno para tu proyecto. Utiliza librer\u00edas de manejo de base de datos para facilitar la persistencia de datos en tu aplicaci\u00f3n web. Aprovecha la inmutabilidad y la concurrencia de Clojure para crear aplicaciones web m\u00e1s robustas y escalables.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"clojure/Junior/creacion_de_aplicaciones_web_con_clojure/#navegacion-de-lecciones","text":"<- Lecci\u00f3n anterior : Trabajo con archivos y bases de datos","title":"Navegaci\u00f3n de lecciones"},{"location":"clojure/Junior/funciones_y_recursion/","text":"Funciones y Recursi\u00f3n \u00b6 Teor\u00eda \u00b6 En Clojure, las funciones son un elemento fundamental y poderoso de su lenguaje de programaci\u00f3n funcional. Son bloques de c\u00f3digo que pueden recibir datos, procesarlos y devolver un resultado. Las funciones en Clojure son objetos de primera clase, lo que significa que pueden ser asignadas a variables, pasadas como argumentos y devueltas como resultado de otras funciones. En Clojure, una funci\u00f3n es una expresi\u00f3n que toma uno o m\u00e1s argumentos y devuelve un resultado. Las funciones en Clojure son inmutables, lo que significa que una vez definidas, no pueden ser modificadas. La recursi\u00f3n es una t\u00e9cnica de programaci\u00f3n en la que una funci\u00f3n se llama a s\u00ed misma para resolver un problema. En Clojure, la recursi\u00f3n se utiliza para iterar sobre estructuras de datos y realizar operaciones repetitivas. Palabras clave \u00b6 Funci\u00f3n: Una expresi\u00f3n que toma uno o m\u00e1s argumentos y devuelve un resultado. Par\u00e1metros: Variables que se utilizan para recibir datos en una funci\u00f3n. Retorno: El resultado que devuelve una funci\u00f3n despu\u00e9s de procesar los datos recibidos. Objetos de primera clase: Elementos que pueden ser asignados a variables, pasados como argumentos y devueltos como resultado de otras funciones. Recursi\u00f3n: T\u00e9cnica de programaci\u00f3n en la que una funci\u00f3n se llama a s\u00ed misma para resolver un problema. Inmutabilidad: Caracter\u00edstica de las funciones en Clojure que indica que no pueden ser modificadas una vez definidas. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es una funci\u00f3n en Clojure? \u00bfQu\u00e9 es la recursi\u00f3n y para qu\u00e9 se utiliza en Clojure? \u00bfCu\u00e1l es la caracter\u00edstica de las funciones en Clojure que las hace diferentes de otros lenguajes de programaci\u00f3n? Ejemplos de c\u00f3digo en Clojure \u00b6 Definici\u00f3n de una funci\u00f3n simple: ( defn suma [ a b ] ( + a b )) ; llamada a la funci\u00f3n ( suma 5 3 ) ; resultado:8 ; Declaraci\u00f3n de una funci\u00f3n que devuelve el cuadrado de un n\u00famero ( defn cuadrado [ num ] ( * num num )) ; Llamada a la funci\u00f3n ( cuadrado 4 ) ; resultado: 16 Ejemplo de recursi\u00f3n para calcular el factorial de un n\u00famero: ( defn factorial [ n ] ( if ( = n 0 ) 1 ( * n ( factorial ( - n 1 ))))) Ejercicios pr\u00e1cticos \u00b6 Escribe una funci\u00f3n en Clojure que calcule el \u00e1rea de un c\u00edrculo, utilizando la f\u00f3rmula \u03c0 * r^2 donde r es el radio. Utiliza recursi\u00f3n para definir una funci\u00f3n en Clojure que calcule la suma de los primeros n n\u00fameros naturales. Escribe una funci\u00f3n que determine si un n\u00famero es par o impar y devuelva \"par\" o \"impar\" respectivamente. Escribe una funci\u00f3n que reciba una lista de palabras y devuelva una lista con las mismas palabras en may\u00fasculas. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza nombres descriptivos para tus funciones. Evita la recursi\u00f3n infinita definiendo un caso base en tus funciones recursivas. Utiliza la funci\u00f3n recur en lugar de la llamada a s\u00ed misma para optimizar el rendimiento de tus funciones recursivas. Aprovecha las funciones de orden superior para escribir c\u00f3digo m\u00e1s conciso y legible. Navegaci\u00f3n de lecciones \u00b6 <- Lecci\u00f3n anterior : Sintaxis y estructuras de datos Siguiente lecci\u00f3n -> : Colecciones","title":"Funciones y Recursi\u00f3n"},{"location":"clojure/Junior/funciones_y_recursion/#funciones-y-recursion","text":"","title":"Funciones y Recursi\u00f3n"},{"location":"clojure/Junior/funciones_y_recursion/#teoria","text":"En Clojure, las funciones son un elemento fundamental y poderoso de su lenguaje de programaci\u00f3n funcional. Son bloques de c\u00f3digo que pueden recibir datos, procesarlos y devolver un resultado. Las funciones en Clojure son objetos de primera clase, lo que significa que pueden ser asignadas a variables, pasadas como argumentos y devueltas como resultado de otras funciones. En Clojure, una funci\u00f3n es una expresi\u00f3n que toma uno o m\u00e1s argumentos y devuelve un resultado. Las funciones en Clojure son inmutables, lo que significa que una vez definidas, no pueden ser modificadas. La recursi\u00f3n es una t\u00e9cnica de programaci\u00f3n en la que una funci\u00f3n se llama a s\u00ed misma para resolver un problema. En Clojure, la recursi\u00f3n se utiliza para iterar sobre estructuras de datos y realizar operaciones repetitivas.","title":"Teor\u00eda"},{"location":"clojure/Junior/funciones_y_recursion/#palabras-clave","text":"Funci\u00f3n: Una expresi\u00f3n que toma uno o m\u00e1s argumentos y devuelve un resultado. Par\u00e1metros: Variables que se utilizan para recibir datos en una funci\u00f3n. Retorno: El resultado que devuelve una funci\u00f3n despu\u00e9s de procesar los datos recibidos. Objetos de primera clase: Elementos que pueden ser asignados a variables, pasados como argumentos y devueltos como resultado de otras funciones. Recursi\u00f3n: T\u00e9cnica de programaci\u00f3n en la que una funci\u00f3n se llama a s\u00ed misma para resolver un problema. Inmutabilidad: Caracter\u00edstica de las funciones en Clojure que indica que no pueden ser modificadas una vez definidas.","title":"Palabras clave"},{"location":"clojure/Junior/funciones_y_recursion/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es una funci\u00f3n en Clojure? \u00bfQu\u00e9 es la recursi\u00f3n y para qu\u00e9 se utiliza en Clojure? \u00bfCu\u00e1l es la caracter\u00edstica de las funciones en Clojure que las hace diferentes de otros lenguajes de programaci\u00f3n?","title":"Preguntas de repaso"},{"location":"clojure/Junior/funciones_y_recursion/#ejemplos-de-codigo-en-clojure","text":"Definici\u00f3n de una funci\u00f3n simple: ( defn suma [ a b ] ( + a b )) ; llamada a la funci\u00f3n ( suma 5 3 ) ; resultado:8 ; Declaraci\u00f3n de una funci\u00f3n que devuelve el cuadrado de un n\u00famero ( defn cuadrado [ num ] ( * num num )) ; Llamada a la funci\u00f3n ( cuadrado 4 ) ; resultado: 16 Ejemplo de recursi\u00f3n para calcular el factorial de un n\u00famero: ( defn factorial [ n ] ( if ( = n 0 ) 1 ( * n ( factorial ( - n 1 )))))","title":"Ejemplos de c\u00f3digo en Clojure"},{"location":"clojure/Junior/funciones_y_recursion/#ejercicios-practicos","text":"Escribe una funci\u00f3n en Clojure que calcule el \u00e1rea de un c\u00edrculo, utilizando la f\u00f3rmula \u03c0 * r^2 donde r es el radio. Utiliza recursi\u00f3n para definir una funci\u00f3n en Clojure que calcule la suma de los primeros n n\u00fameros naturales. Escribe una funci\u00f3n que determine si un n\u00famero es par o impar y devuelva \"par\" o \"impar\" respectivamente. Escribe una funci\u00f3n que reciba una lista de palabras y devuelva una lista con las mismas palabras en may\u00fasculas.","title":"Ejercicios pr\u00e1cticos"},{"location":"clojure/Junior/funciones_y_recursion/#consejos-o-mejores-practicas","text":"Utiliza nombres descriptivos para tus funciones. Evita la recursi\u00f3n infinita definiendo un caso base en tus funciones recursivas. Utiliza la funci\u00f3n recur en lugar de la llamada a s\u00ed misma para optimizar el rendimiento de tus funciones recursivas. Aprovecha las funciones de orden superior para escribir c\u00f3digo m\u00e1s conciso y legible.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"clojure/Junior/funciones_y_recursion/#navegacion-de-lecciones","text":"<- Lecci\u00f3n anterior : Sintaxis y estructuras de datos Siguiente lecci\u00f3n -> : Colecciones","title":"Navegaci\u00f3n de lecciones"},{"location":"clojure/Junior/gestion_de_errores_y_depuracion/","text":"Gesti\u00f3n de errores y depuraci\u00f3n en Clojure \u00b6 En cualquier lenguaje de programaci\u00f3n, es inevitable encontrarse con errores en el c\u00f3digo. Estos pueden surgir por diversos motivos, como errores de sintaxis, problemas de l\u00f3gica o errores en la entrada de datos. Por lo tanto, es esencial saber c\u00f3mo manejar y solucionar estos errores de manera eficiente. En este m\u00f3dulo, aprenderemos c\u00f3mo gestionar errores y depurar c\u00f3digo en Clojure. Palabras clave \u00b6 Try/catch: Estructura de control utilizada para manejar excepciones en Clojure. catch: Bloque de c\u00f3digo donde se define el manejo de la excepci\u00f3n. finally: Bloque de c\u00f3digo que se ejecuta siempre, independientemente de si se produce una excepci\u00f3n o no. Excepci\u00f3n: Un evento inesperado que interrumpe el flujo normal de ejecuci\u00f3n de un programa. Depuraci\u00f3n: Proceso de identificar y corregir errores en el c\u00f3digo. Traza: Informaci\u00f3n detallada sobre el flujo de ejecuci\u00f3n del programa, incluyendo los errores que han ocurrido. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es una excepci\u00f3n en Clojure? \u00bfCu\u00e1l es la estructura de control utilizada para manejar excepciones en Clojure? \u00bfQu\u00e9 es la depuraci\u00f3n y por qu\u00e9 es importante? \u00bfQu\u00e9 es una traza y c\u00f3mo puede ser \u00fatil en la depuraci\u00f3n? \u00bfCu\u00e1l es la funci\u00f3n del bloque finally ? \u00bfC\u00f3mo se desv\u00eda el programa al bloque catch ? Ejemplos de c\u00f3digo \u00b6 Utilizando try/catch para manejar excepciones \u00b6 Manejo de una excepci\u00f3n aritm\u00e9tica. ( defn divide [ num1 num2 ] ( try ( / num1 num2 ) ( catch ArithmeticException e ( println \"Error: No se puede dividir por cero.\" )))) Manejo de una excepci\u00f3n espec\u00edfica ( try ( throw ( Exception. \"Este es un ejemplo de excepci\u00f3n\" )) ( catch Exception e ( println \"Se ha producido una excepci\u00f3n:\" ( .getMessage e )))) Manejo de cualquier excepci\u00f3n ( try ( / 5 0 ) ( catch Exception e ( println \"Se ha producido una excepci\u00f3n:\" ( .getMessage e )))) Uso del bloque finally ( try ( / 5 0 ) ( catch Exception e ( println \"Se ha producido una excepci\u00f3n:\" ( .getMessage e ))) ( finally ( println \"Este bloque se ejecuta siempre\" ))) En este ultimo ejemplo, utilizamos la estructura de control try/catch para manejar la excepci\u00f3n de divisi\u00f3n por cero. Si el c\u00f3digo dentro de la cl\u00e1usula try se ejecuta sin problemas, el resultado de la divisi\u00f3n se devuelve. Sin embargo, si ocurre una excepci\u00f3n, el c\u00f3digo dentro de la cl\u00e1usula catch se ejecuta y se imprime un mensaje de error. Imprimir una traza para depurar c\u00f3digo \u00b6 ( defn sum [ nums ] ( if ( empty? nums ) ( throw ( Exception. \"La lista est\u00e1 vac\u00eda.\" )) ( reduce + nums ))) ( sum [ 1 2 3 4 5 ]) En este ejemplo, creamos una funci\u00f3n que suma todos los elementos de una lista. Sin embargo, si la lista est\u00e1 vac\u00eda, lanzamos una excepci\u00f3n. Si ejecutamos esta funci\u00f3n con una lista vac\u00eda, obtendremos el siguiente mensaje de error: Exception : La lista est\u00e1 vac\u00eda . Para obtener m\u00e1s informaci\u00f3n sobre d\u00f3nde ocurri\u00f3 el error, podemos imprimir una traza utilizando la funci\u00f3n print-stack-trace : ( defn sum [ nums ] ( if ( empty? nums ) ( throw ( Exception. \"La lista est\u00e1 vac\u00eda.\" )) ( reduce + nums ))) ( try ( sum []) ( catch Exception e ( println ( .printStackTrace e )))) Esto nos dar\u00e1 una traza m\u00e1s detallada sobre el error: java . lang . Exception : La lista est\u00e1 vac\u00eda . at user / sum ( REPL : 1 ) at user / eval325 ( REPL : 1 ) at clojure . lang . Compiler . eval ( Compiler . java : 7177 ) at clojure . lang . Compiler . eval ( Compiler . java : 7167 ) at clojure . lang . Compiler . load ( Compiler . java : 7635 ) at clojure . lang . Compiler . loadFile ( Compiler . java : 7573 ) at clojure . main $ load_script . invokeStatic ( main . clj : 452 ) at clojure . main $ init_opt . invokeStatic ( main . clj : 454 ) at clojure . main $ init_opt . invoke ( main . clj : 454 ) at clojure . main $ initialize . invokeStatic ( main . clj : 485 ) at clojure . main $ null_opt . invokeStatic ( main . clj : 519 ) at clojure . main $ null_opt . invoke ( main . clj : 516 ) at clojure . main $ main . invokeStatic ( main . clj : 598 ) at clojure . main $ main . doInvoke ( main . clj : 561 ) at clojure . lang . RestFn . applyTo ( RestFn . java : 137 ) at clojure . lang . Var . applyTo ( Var . java : 705 ) at clojure . main . main ( main . java : 37 ) Esta informaci\u00f3n puede ser \u00fatil para identificar d\u00f3nde ocurri\u00f3 exactamente el error y solucionarlo. Ejercicios pr\u00e1cticos \u00b6 Crea una funci\u00f3n que calcule el promedio de una lista de n\u00fameros. Si la lista est\u00e1 vac\u00eda, lanza una excepci\u00f3n y muestra un mensaje de error. Crea una funci\u00f3n que encuentre el n\u00famero m\u00e1s grande en una lista de n\u00fameros. Si la lista est\u00e1 vac\u00eda, lanza una excepci\u00f3n y muestra un mensaje de error. Escribe un programa que solicite al usuario ingresar un n\u00famero y lo multiplique por 10. Si el usuario ingresa un valor no num\u00e9rico, muestra un mensaje de error y solicita nuevamente el n\u00famero. Modifica el programa anterior para que, en caso de que se produzca un error, solicite al usuario que ingrese un n\u00famero diferente y lo multiplique por 10. Consejos y mejores pr\u00e1cticas \u00b6 Utiliza try/catch para manejar excepciones en lugar de dejar que el programa se bloquee. Imprime trazas para obtener informaci\u00f3n detallada sobre los errores y facilitar la depuraci\u00f3n. Aseg\u00farate de manejar todas las posibles excepciones en tu c\u00f3digo para evitar que el programa se bloquee o produzca resultados inesperados. Utilizar el bloque finally para realizar tareas de limpieza o cierre de recursos, como cerrar archivos o conexiones a bases de datos. Evitar el uso excesivo de try-catch y en su lugar, utilizar funciones que manejen de forma m\u00e1s adecuada los posibles errores. Navegaci\u00f3n de lecciones \u00b6 <- Lecci\u00f3n anterior : Programaci\u00f3n funcional Siguiente lecci\u00f3n -> : M\u00f3dulos y namespaces","title":"Gesti\u00f3n de errores y depuraci\u00f3n en Clojure"},{"location":"clojure/Junior/gestion_de_errores_y_depuracion/#gestion-de-errores-y-depuracion-en-clojure","text":"En cualquier lenguaje de programaci\u00f3n, es inevitable encontrarse con errores en el c\u00f3digo. Estos pueden surgir por diversos motivos, como errores de sintaxis, problemas de l\u00f3gica o errores en la entrada de datos. Por lo tanto, es esencial saber c\u00f3mo manejar y solucionar estos errores de manera eficiente. En este m\u00f3dulo, aprenderemos c\u00f3mo gestionar errores y depurar c\u00f3digo en Clojure.","title":"Gesti\u00f3n de errores y depuraci\u00f3n en Clojure"},{"location":"clojure/Junior/gestion_de_errores_y_depuracion/#palabras-clave","text":"Try/catch: Estructura de control utilizada para manejar excepciones en Clojure. catch: Bloque de c\u00f3digo donde se define el manejo de la excepci\u00f3n. finally: Bloque de c\u00f3digo que se ejecuta siempre, independientemente de si se produce una excepci\u00f3n o no. Excepci\u00f3n: Un evento inesperado que interrumpe el flujo normal de ejecuci\u00f3n de un programa. Depuraci\u00f3n: Proceso de identificar y corregir errores en el c\u00f3digo. Traza: Informaci\u00f3n detallada sobre el flujo de ejecuci\u00f3n del programa, incluyendo los errores que han ocurrido.","title":"Palabras clave"},{"location":"clojure/Junior/gestion_de_errores_y_depuracion/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es una excepci\u00f3n en Clojure? \u00bfCu\u00e1l es la estructura de control utilizada para manejar excepciones en Clojure? \u00bfQu\u00e9 es la depuraci\u00f3n y por qu\u00e9 es importante? \u00bfQu\u00e9 es una traza y c\u00f3mo puede ser \u00fatil en la depuraci\u00f3n? \u00bfCu\u00e1l es la funci\u00f3n del bloque finally ? \u00bfC\u00f3mo se desv\u00eda el programa al bloque catch ?","title":"Preguntas de repaso"},{"location":"clojure/Junior/gestion_de_errores_y_depuracion/#ejemplos-de-codigo","text":"","title":"Ejemplos de c\u00f3digo"},{"location":"clojure/Junior/gestion_de_errores_y_depuracion/#utilizando-trycatch-para-manejar-excepciones","text":"Manejo de una excepci\u00f3n aritm\u00e9tica. ( defn divide [ num1 num2 ] ( try ( / num1 num2 ) ( catch ArithmeticException e ( println \"Error: No se puede dividir por cero.\" )))) Manejo de una excepci\u00f3n espec\u00edfica ( try ( throw ( Exception. \"Este es un ejemplo de excepci\u00f3n\" )) ( catch Exception e ( println \"Se ha producido una excepci\u00f3n:\" ( .getMessage e )))) Manejo de cualquier excepci\u00f3n ( try ( / 5 0 ) ( catch Exception e ( println \"Se ha producido una excepci\u00f3n:\" ( .getMessage e )))) Uso del bloque finally ( try ( / 5 0 ) ( catch Exception e ( println \"Se ha producido una excepci\u00f3n:\" ( .getMessage e ))) ( finally ( println \"Este bloque se ejecuta siempre\" ))) En este ultimo ejemplo, utilizamos la estructura de control try/catch para manejar la excepci\u00f3n de divisi\u00f3n por cero. Si el c\u00f3digo dentro de la cl\u00e1usula try se ejecuta sin problemas, el resultado de la divisi\u00f3n se devuelve. Sin embargo, si ocurre una excepci\u00f3n, el c\u00f3digo dentro de la cl\u00e1usula catch se ejecuta y se imprime un mensaje de error.","title":"Utilizando try/catch para manejar excepciones"},{"location":"clojure/Junior/gestion_de_errores_y_depuracion/#imprimir-una-traza-para-depurar-codigo","text":"( defn sum [ nums ] ( if ( empty? nums ) ( throw ( Exception. \"La lista est\u00e1 vac\u00eda.\" )) ( reduce + nums ))) ( sum [ 1 2 3 4 5 ]) En este ejemplo, creamos una funci\u00f3n que suma todos los elementos de una lista. Sin embargo, si la lista est\u00e1 vac\u00eda, lanzamos una excepci\u00f3n. Si ejecutamos esta funci\u00f3n con una lista vac\u00eda, obtendremos el siguiente mensaje de error: Exception : La lista est\u00e1 vac\u00eda . Para obtener m\u00e1s informaci\u00f3n sobre d\u00f3nde ocurri\u00f3 el error, podemos imprimir una traza utilizando la funci\u00f3n print-stack-trace : ( defn sum [ nums ] ( if ( empty? nums ) ( throw ( Exception. \"La lista est\u00e1 vac\u00eda.\" )) ( reduce + nums ))) ( try ( sum []) ( catch Exception e ( println ( .printStackTrace e )))) Esto nos dar\u00e1 una traza m\u00e1s detallada sobre el error: java . lang . Exception : La lista est\u00e1 vac\u00eda . at user / sum ( REPL : 1 ) at user / eval325 ( REPL : 1 ) at clojure . lang . Compiler . eval ( Compiler . java : 7177 ) at clojure . lang . Compiler . eval ( Compiler . java : 7167 ) at clojure . lang . Compiler . load ( Compiler . java : 7635 ) at clojure . lang . Compiler . loadFile ( Compiler . java : 7573 ) at clojure . main $ load_script . invokeStatic ( main . clj : 452 ) at clojure . main $ init_opt . invokeStatic ( main . clj : 454 ) at clojure . main $ init_opt . invoke ( main . clj : 454 ) at clojure . main $ initialize . invokeStatic ( main . clj : 485 ) at clojure . main $ null_opt . invokeStatic ( main . clj : 519 ) at clojure . main $ null_opt . invoke ( main . clj : 516 ) at clojure . main $ main . invokeStatic ( main . clj : 598 ) at clojure . main $ main . doInvoke ( main . clj : 561 ) at clojure . lang . RestFn . applyTo ( RestFn . java : 137 ) at clojure . lang . Var . applyTo ( Var . java : 705 ) at clojure . main . main ( main . java : 37 ) Esta informaci\u00f3n puede ser \u00fatil para identificar d\u00f3nde ocurri\u00f3 exactamente el error y solucionarlo.","title":"Imprimir una traza para depurar c\u00f3digo"},{"location":"clojure/Junior/gestion_de_errores_y_depuracion/#ejercicios-practicos","text":"Crea una funci\u00f3n que calcule el promedio de una lista de n\u00fameros. Si la lista est\u00e1 vac\u00eda, lanza una excepci\u00f3n y muestra un mensaje de error. Crea una funci\u00f3n que encuentre el n\u00famero m\u00e1s grande en una lista de n\u00fameros. Si la lista est\u00e1 vac\u00eda, lanza una excepci\u00f3n y muestra un mensaje de error. Escribe un programa que solicite al usuario ingresar un n\u00famero y lo multiplique por 10. Si el usuario ingresa un valor no num\u00e9rico, muestra un mensaje de error y solicita nuevamente el n\u00famero. Modifica el programa anterior para que, en caso de que se produzca un error, solicite al usuario que ingrese un n\u00famero diferente y lo multiplique por 10.","title":"Ejercicios pr\u00e1cticos"},{"location":"clojure/Junior/gestion_de_errores_y_depuracion/#consejos-y-mejores-practicas","text":"Utiliza try/catch para manejar excepciones en lugar de dejar que el programa se bloquee. Imprime trazas para obtener informaci\u00f3n detallada sobre los errores y facilitar la depuraci\u00f3n. Aseg\u00farate de manejar todas las posibles excepciones en tu c\u00f3digo para evitar que el programa se bloquee o produzca resultados inesperados. Utilizar el bloque finally para realizar tareas de limpieza o cierre de recursos, como cerrar archivos o conexiones a bases de datos. Evitar el uso excesivo de try-catch y en su lugar, utilizar funciones que manejen de forma m\u00e1s adecuada los posibles errores.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"clojure/Junior/gestion_de_errores_y_depuracion/#navegacion-de-lecciones","text":"<- Lecci\u00f3n anterior : Programaci\u00f3n funcional Siguiente lecci\u00f3n -> : M\u00f3dulos y namespaces","title":"Navegaci\u00f3n de lecciones"},{"location":"clojure/Junior/instalacion_y_configuracion/","text":"Instalaci\u00f3n y configuraci\u00f3n \u00b6 Introducci\u00f3n \u00b6 Clojure es un lenguaje de programaci\u00f3n funcional que se ejecuta en la plataforma Java Virtual Machine (JVM). Esto significa que para poder utilizar Clojure, es necesario tener instalado el Java Development Kit (JDK) en nuestro sistema. Una vez que tengamos el JDK instalado, podremos proceder a instalar y configurar Clojure en nuestro entorno de desarrollo. Palabras clave \u00b6 Clojure: lenguaje de programaci\u00f3n funcional que se ejecuta en la JVM. JVM: Java Virtual Machine, plataforma de ejecuci\u00f3n para lenguajes de programaci\u00f3n basados en Java. JDK: Java Development Kit, conjunto de herramientas necesarias para desarrollar aplicaciones en Java. Preguntas de repaso \u00b6 \u00bfEn qu\u00e9 plataforma se ejecuta Clojure? \u00bfQu\u00e9 es el JDK y por qu\u00e9 es necesario para utilizar Clojure? \u00bfQu\u00e9 es la JVM y qu\u00e9 funci\u00f3n cumple en la ejecuci\u00f3n de Clojure? Ejemplos de c\u00f3digo \u00b6 ;; Hola mundo en Clojure ( println \"Hola mundo\" ) ;; Funci\u00f3n que calcula el cuadrado de un n\u00famero ( defn cuadrado [ x ] ( * x x )) Ejercicios pr\u00e1cticos \u00b6 Instalar el JDK en tu sistema. Descargar e instalar Leiningen, un gestor de proyectos y dependencias para Clojure. Crear y ejecutar un proyecto b\u00e1sico en Clojure utilizando Leiningen. Consejos y mejores pr\u00e1cticas \u00b6 Si eres nuevo en Clojure, es recomendable empezar con una distribuci\u00f3n de Clojure que incluya todas las librer\u00edas y herramientas necesarias para comenzar a programar de forma r\u00e1pida y sencilla. Utiliza un editor de texto o un IDE que tenga soporte para Clojure, como Atom, Emacs o IntelliJ. Familiar\u00edzate con las herramientas y librer\u00edas m\u00e1s populares de Clojure, como Ring, Compojure y Hiccup, para poder desarrollar aplicaciones web de forma eficiente. <- Lecci\u00f3n anterior : Introducci\u00f3n a Clojure Siguiente lecci\u00f3n -> : Sintaxis y estructuras de datos","title":"Instalaci\u00f3n y configuraci\u00f3n"},{"location":"clojure/Junior/instalacion_y_configuracion/#instalacion-y-configuracion","text":"","title":"Instalaci\u00f3n y configuraci\u00f3n"},{"location":"clojure/Junior/instalacion_y_configuracion/#introduccion","text":"Clojure es un lenguaje de programaci\u00f3n funcional que se ejecuta en la plataforma Java Virtual Machine (JVM). Esto significa que para poder utilizar Clojure, es necesario tener instalado el Java Development Kit (JDK) en nuestro sistema. Una vez que tengamos el JDK instalado, podremos proceder a instalar y configurar Clojure en nuestro entorno de desarrollo.","title":"Introducci\u00f3n"},{"location":"clojure/Junior/instalacion_y_configuracion/#palabras-clave","text":"Clojure: lenguaje de programaci\u00f3n funcional que se ejecuta en la JVM. JVM: Java Virtual Machine, plataforma de ejecuci\u00f3n para lenguajes de programaci\u00f3n basados en Java. JDK: Java Development Kit, conjunto de herramientas necesarias para desarrollar aplicaciones en Java.","title":"Palabras clave"},{"location":"clojure/Junior/instalacion_y_configuracion/#preguntas-de-repaso","text":"\u00bfEn qu\u00e9 plataforma se ejecuta Clojure? \u00bfQu\u00e9 es el JDK y por qu\u00e9 es necesario para utilizar Clojure? \u00bfQu\u00e9 es la JVM y qu\u00e9 funci\u00f3n cumple en la ejecuci\u00f3n de Clojure?","title":"Preguntas de repaso"},{"location":"clojure/Junior/instalacion_y_configuracion/#ejemplos-de-codigo","text":";; Hola mundo en Clojure ( println \"Hola mundo\" ) ;; Funci\u00f3n que calcula el cuadrado de un n\u00famero ( defn cuadrado [ x ] ( * x x ))","title":"Ejemplos de c\u00f3digo"},{"location":"clojure/Junior/instalacion_y_configuracion/#ejercicios-practicos","text":"Instalar el JDK en tu sistema. Descargar e instalar Leiningen, un gestor de proyectos y dependencias para Clojure. Crear y ejecutar un proyecto b\u00e1sico en Clojure utilizando Leiningen.","title":"Ejercicios pr\u00e1cticos"},{"location":"clojure/Junior/instalacion_y_configuracion/#consejos-y-mejores-practicas","text":"Si eres nuevo en Clojure, es recomendable empezar con una distribuci\u00f3n de Clojure que incluya todas las librer\u00edas y herramientas necesarias para comenzar a programar de forma r\u00e1pida y sencilla. Utiliza un editor de texto o un IDE que tenga soporte para Clojure, como Atom, Emacs o IntelliJ. Familiar\u00edzate con las herramientas y librer\u00edas m\u00e1s populares de Clojure, como Ring, Compojure y Hiccup, para poder desarrollar aplicaciones web de forma eficiente. <- Lecci\u00f3n anterior : Introducci\u00f3n a Clojure Siguiente lecci\u00f3n -> : Sintaxis y estructuras de datos","title":"Consejos y mejores pr\u00e1cticas"},{"location":"clojure/Junior/introduccion_a_clojure/","text":"Introducci\u00f3n a Clojure \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 Clojure es un lenguaje de programaci\u00f3n funcional y din\u00e1mico, creado por Rich Hickey en 2007. Est\u00e1 basado en el lenguaje de programaci\u00f3n Lisp y se ejecuta sobre la m\u00e1quina virtual de Java, lo que le permite aprovechar la potencia de la plataforma Java y su ecosistema de librer\u00edas. A diferencia de otros lenguajes de programaci\u00f3n funcional, Clojure est\u00e1 dise\u00f1ado para ser pr\u00e1ctico y f\u00e1cil de aprender, permitiendo a los desarrolladores escribir c\u00f3digo conciso y eficiente. Clojure fue creado en 2007 por Rich Hickey, quien buscaba un lenguaje que combinara la simplicidad y la flexibilidad de Lisp con la eficiencia y la interoperabilidad de la JVM. Desde entonces, ha ganado popularidad por su capacidad para manejar grandes vol\u00famenes de datos, su enfoque en la programaci\u00f3n funcional y su capacidad para crear aplicaciones web y m\u00f3viles. Clojure se basa en el lenguaje Lisp, lo que significa que utiliza una sintaxis basada en par\u00e9ntesis y se enfoca en estructuras de datos inmutables y funciones puras. Adem\u00e1s, es un lenguaje din\u00e1mico, lo que significa que no es necesario declarar tipos de datos antes de utilizarlos, lo que facilita la escritura de c\u00f3digo y permite una mayor flexibilidad. Palabras clave y su definici\u00f3n \u00b6 Lenguaje de programaci\u00f3n funcional: un paradigma de programaci\u00f3n en el que se enfatiza la aplicaci\u00f3n de funciones para resolver problemas. Lenguaje din\u00e1mico: un lenguaje en el que los tipos de datos son inferidos en tiempo de ejecuci\u00f3n. Lisp: un lenguaje de programaci\u00f3n basado en la notaci\u00f3n polaca inversa, que se caracteriza por su simplicidad y flexibilidad. Conciso: un c\u00f3digo que es breve y f\u00e1cil de leer. Eficiente: un c\u00f3digo que utiliza los recursos de manera \u00f3ptima. def : se utiliza para definir una variable global y asignarle un valor. let : se utiliza para definir una variable local dentro de una funci\u00f3n. fn : se utiliza para definir una funci\u00f3n an\u00f3nima. map : se utiliza para aplicar una funci\u00f3n a cada elemento de una colecci\u00f3n y devolver una nueva colecci\u00f3n con los resultados. filter : se utiliza para filtrar una colecci\u00f3n bas\u00e1ndose en una condici\u00f3n y devolver una nueva colecci\u00f3n con los elementos que cumplan con dicha condici\u00f3n. Preguntas de repaso \u00b6 \u00bfQui\u00e9n es el creador de Clojure? \u00bfEn qu\u00e9 se basa Clojure? \u00bfCu\u00e1l es la plataforma en la que se ejecuta Clojure? \u00bfQu\u00e9 ventajas tiene Clojure en comparaci\u00f3n con otros lenguajes funcionales? \u00bfQu\u00e9 significa que un lenguaje sea din\u00e1mico? \u00bfPara qu\u00e9 se utiliza la funci\u00f3n \"map\" en Clojure? \u00bfPor qu\u00e9 se le llama a Clojure un lenguaje conciso y eficiente? Ejemplos de c\u00f3digo en Clojure \u00b6 Definir una funci\u00f3n que suma dos n\u00fameros ( def sum [ a b ] ( + a b )) Llamar a la funci\u00f3n y asignar el resultado a una variable ( def resultado ( sum 5 7 )) Imprimir el resultado por consola ( println resultado ) Definir una variable global llamada \"nombre\" con el valor \"Juan\": ( def nombre \"Juan\" ) Definir una funci\u00f3n que calcule el doble de un n\u00famero: ( fn [ x ] ( * 2 x )) Utilizar la funci\u00f3n \"map\" para multiplicar por 2 cada elemento de una lista: ( map # ( * 2 % ) [ 1 2 3 4 ]) Ejercicios pr\u00e1cticos \u00b6 Define una funci\u00f3n que calcule el \u00e1rea de un c\u00edrculo, recibiendo como par\u00e1metro su radio. Crea una funci\u00f3n que determine si un n\u00famero es par o impar. Escribe una funci\u00f3n que reciba una lista de n\u00fameros y devuelva la suma de los n\u00fameros pares. Crea una funci\u00f3n que reciba una lista de cadenas de texto y devuelva una cadena \u00fanica con todos los elementos unidos y separados por un espacio. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza funciones puras siempre que sea posible, ya que facilitan la comprensi\u00f3n y depuraci\u00f3n del c\u00f3digo. Aprende a utilizar las estructuras de datos inmutables de Clojure para evitar efectos secundarios no deseados. Utiliza la funci\u00f3n \"map\" en lugar de bucles para aplicar una transformaci\u00f3n a una colecci\u00f3n, ya que es m\u00e1s eficiente. Practica la programaci\u00f3n funcional y el uso de funciones de orden superior para aprovechar al m\u00e1ximo las capacidades de Clojure. Aprovecha la inmutabilidad: en Clojure, los datos son inmutables, lo que significa que una vez creados, no pueden ser modificados. Esto permite una mayor seguridad y control en el c\u00f3digo. Utiliza recursi\u00f3n: en lugar de utilizar ciclos, en Clojure se promueve el uso de recursi\u00f3n para iterar sobre colecciones de datos. Conoce las estructuras de datos: Clojure cuenta con una amplia variedad de estructuras de datos, como listas, vectores, mapas y conjuntos, que pueden ser utilizados de manera eficiente para diferentes casos de uso.<|endoftext|> nextflow Navegaci\u00f3n de lecciones \u00b6 Siguiente lecci\u00f3n -> : Instalaci\u00f3n y configuraci\u00f3n","title":"Introduccion a clojure"},{"location":"clojure/Junior/introduccion_a_clojure/#introduccion-a-clojure","text":"","title":"Introducci\u00f3n a Clojure"},{"location":"clojure/Junior/introduccion_a_clojure/#explicacion-teorica","text":"Clojure es un lenguaje de programaci\u00f3n funcional y din\u00e1mico, creado por Rich Hickey en 2007. Est\u00e1 basado en el lenguaje de programaci\u00f3n Lisp y se ejecuta sobre la m\u00e1quina virtual de Java, lo que le permite aprovechar la potencia de la plataforma Java y su ecosistema de librer\u00edas. A diferencia de otros lenguajes de programaci\u00f3n funcional, Clojure est\u00e1 dise\u00f1ado para ser pr\u00e1ctico y f\u00e1cil de aprender, permitiendo a los desarrolladores escribir c\u00f3digo conciso y eficiente. Clojure fue creado en 2007 por Rich Hickey, quien buscaba un lenguaje que combinara la simplicidad y la flexibilidad de Lisp con la eficiencia y la interoperabilidad de la JVM. Desde entonces, ha ganado popularidad por su capacidad para manejar grandes vol\u00famenes de datos, su enfoque en la programaci\u00f3n funcional y su capacidad para crear aplicaciones web y m\u00f3viles. Clojure se basa en el lenguaje Lisp, lo que significa que utiliza una sintaxis basada en par\u00e9ntesis y se enfoca en estructuras de datos inmutables y funciones puras. Adem\u00e1s, es un lenguaje din\u00e1mico, lo que significa que no es necesario declarar tipos de datos antes de utilizarlos, lo que facilita la escritura de c\u00f3digo y permite una mayor flexibilidad.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"clojure/Junior/introduccion_a_clojure/#palabras-clave-y-su-definicion","text":"Lenguaje de programaci\u00f3n funcional: un paradigma de programaci\u00f3n en el que se enfatiza la aplicaci\u00f3n de funciones para resolver problemas. Lenguaje din\u00e1mico: un lenguaje en el que los tipos de datos son inferidos en tiempo de ejecuci\u00f3n. Lisp: un lenguaje de programaci\u00f3n basado en la notaci\u00f3n polaca inversa, que se caracteriza por su simplicidad y flexibilidad. Conciso: un c\u00f3digo que es breve y f\u00e1cil de leer. Eficiente: un c\u00f3digo que utiliza los recursos de manera \u00f3ptima. def : se utiliza para definir una variable global y asignarle un valor. let : se utiliza para definir una variable local dentro de una funci\u00f3n. fn : se utiliza para definir una funci\u00f3n an\u00f3nima. map : se utiliza para aplicar una funci\u00f3n a cada elemento de una colecci\u00f3n y devolver una nueva colecci\u00f3n con los resultados. filter : se utiliza para filtrar una colecci\u00f3n bas\u00e1ndose en una condici\u00f3n y devolver una nueva colecci\u00f3n con los elementos que cumplan con dicha condici\u00f3n.","title":"Palabras clave y su definici\u00f3n"},{"location":"clojure/Junior/introduccion_a_clojure/#preguntas-de-repaso","text":"\u00bfQui\u00e9n es el creador de Clojure? \u00bfEn qu\u00e9 se basa Clojure? \u00bfCu\u00e1l es la plataforma en la que se ejecuta Clojure? \u00bfQu\u00e9 ventajas tiene Clojure en comparaci\u00f3n con otros lenguajes funcionales? \u00bfQu\u00e9 significa que un lenguaje sea din\u00e1mico? \u00bfPara qu\u00e9 se utiliza la funci\u00f3n \"map\" en Clojure? \u00bfPor qu\u00e9 se le llama a Clojure un lenguaje conciso y eficiente?","title":"Preguntas de repaso"},{"location":"clojure/Junior/introduccion_a_clojure/#ejemplos-de-codigo-en-clojure","text":"Definir una funci\u00f3n que suma dos n\u00fameros ( def sum [ a b ] ( + a b )) Llamar a la funci\u00f3n y asignar el resultado a una variable ( def resultado ( sum 5 7 )) Imprimir el resultado por consola ( println resultado ) Definir una variable global llamada \"nombre\" con el valor \"Juan\": ( def nombre \"Juan\" ) Definir una funci\u00f3n que calcule el doble de un n\u00famero: ( fn [ x ] ( * 2 x )) Utilizar la funci\u00f3n \"map\" para multiplicar por 2 cada elemento de una lista: ( map # ( * 2 % ) [ 1 2 3 4 ])","title":"Ejemplos de c\u00f3digo en Clojure"},{"location":"clojure/Junior/introduccion_a_clojure/#ejercicios-practicos","text":"Define una funci\u00f3n que calcule el \u00e1rea de un c\u00edrculo, recibiendo como par\u00e1metro su radio. Crea una funci\u00f3n que determine si un n\u00famero es par o impar. Escribe una funci\u00f3n que reciba una lista de n\u00fameros y devuelva la suma de los n\u00fameros pares. Crea una funci\u00f3n que reciba una lista de cadenas de texto y devuelva una cadena \u00fanica con todos los elementos unidos y separados por un espacio.","title":"Ejercicios pr\u00e1cticos"},{"location":"clojure/Junior/introduccion_a_clojure/#consejos-o-mejores-practicas","text":"Utiliza funciones puras siempre que sea posible, ya que facilitan la comprensi\u00f3n y depuraci\u00f3n del c\u00f3digo. Aprende a utilizar las estructuras de datos inmutables de Clojure para evitar efectos secundarios no deseados. Utiliza la funci\u00f3n \"map\" en lugar de bucles para aplicar una transformaci\u00f3n a una colecci\u00f3n, ya que es m\u00e1s eficiente. Practica la programaci\u00f3n funcional y el uso de funciones de orden superior para aprovechar al m\u00e1ximo las capacidades de Clojure. Aprovecha la inmutabilidad: en Clojure, los datos son inmutables, lo que significa que una vez creados, no pueden ser modificados. Esto permite una mayor seguridad y control en el c\u00f3digo. Utiliza recursi\u00f3n: en lugar de utilizar ciclos, en Clojure se promueve el uso de recursi\u00f3n para iterar sobre colecciones de datos. Conoce las estructuras de datos: Clojure cuenta con una amplia variedad de estructuras de datos, como listas, vectores, mapas y conjuntos, que pueden ser utilizados de manera eficiente para diferentes casos de uso.<|endoftext|> nextflow","title":"Consejos o mejores pr\u00e1cticas"},{"location":"clojure/Junior/introduccion_a_clojure/#navegacion-de-lecciones","text":"Siguiente lecci\u00f3n -> : Instalaci\u00f3n y configuraci\u00f3n","title":"Navegaci\u00f3n de lecciones"},{"location":"clojure/Junior/modulos_y_namespaces/","text":"M\u00f3dulos y namespaces \u00b6 En Clojure, los m\u00f3dulos y namespaces son herramientas fundamentales para organizar y estructurar el c\u00f3digo de manera eficiente y escalable. Un m\u00f3dulo es una colecci\u00f3n de c\u00f3digo relacionado que puede ser reutilizado en diferentes partes de una aplicaci\u00f3n. Por otro lado, un namespace es un espacio de nombres que permite agrupar y distinguir diferentes elementos dentro de un m\u00f3dulo. Esto ayuda a evitar conflictos de nombres y a facilitar la navegaci\u00f3n y comprensi\u00f3n del c\u00f3digo. Palabras clave y su definici\u00f3n \u00b6 M\u00f3dulo: Colecci\u00f3n de c\u00f3digo relacionado que puede ser reutilizado en diferentes partes de una aplicaci\u00f3n. Namespace: Espacio de nombres que permite agrupar y distinguir diferentes elementos dentro de un m\u00f3dulo. require: Funci\u00f3n utilizada para cargar un m\u00f3dulo o namespace en el contexto actual. use: Funci\u00f3n utilizada para cargar un m\u00f3dulo o namespace y ejecutar su c\u00f3digo en el contexto actual. import: Funci\u00f3n utilizada para importar una clase de Java en un namespace de Clojure. Preguntas de repaso \u00b6 \u00bfCu\u00e1l es la diferencia entre un m\u00f3dulo y un namespace? \u00bfQu\u00e9 funci\u00f3n se utiliza para cargar un m\u00f3dulo o namespace en el contexto actual? \u00bfC\u00f3mo se importa una clase de Java en un namespace de Clojure? Ejemplos de c\u00f3digo en Clojure \u00b6 ( ns mi-app.modulo ) ( defn suma [ a b ] ( + a b )) ( defn resta [ a b ] ( - a b )) En este ejemplo, definimos un m\u00f3dulo llamado \"mi-app.modulo\" que contiene dos funciones: suma y resta. Ahora, podemos utilizar estas funciones en cualquier otro namespace de nuestra aplicaci\u00f3n utilizando la funci\u00f3n \"require\". ( ns mi-app.otro-namespace ( :require [ mi-app.modulo :as mod ])) ( def resultado ( mod/suma 5 3 )) En este caso, utilizamos la funci\u00f3n \"require\" para cargar el m\u00f3dulo \"mi-app.modulo\" con el alias \"mod\". Luego, podemos llamar a las funciones del m\u00f3dulo utilizando el alias y el nombre de la funci\u00f3n. Ejercicios pr\u00e1cticos \u00b6 Crea un m\u00f3dulo llamado \"matematicas\" con las funciones \"multiplicacion\" y \"division\". Importa este m\u00f3dulo en otro namespace y utiliza sus funciones para realizar operaciones matem\u00e1ticas. Crea un namespace llamado \"utilidades\" y utiliza la funci\u00f3n \"import\" para importar la clase \"Date\" de Java. Luego, utiliza esta clase para obtener la fecha actual y mostrarla por pantalla. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza nombres descriptivos y significativos para tus m\u00f3dulos y namespaces. Evita utilizar el mismo nombre para diferentes m\u00f3dulos o namespaces, ya que podr\u00eda generar conflictos. Si tienes una gran cantidad de funciones en un namespace, considera dividirlo en sub-namespaces para una mejor organizaci\u00f3n. Al importar clases de Java, utiliza nombres de namespace espec\u00edficos para evitar posibles conflictos de nombres. <- Lecci\u00f3n anterior : Gesti\u00f3n de errores y depuraci\u00f3n Siguiente lecci\u00f3n -> : Trabajo con archivos y bases de datos","title":"M\u00f3dulos y namespaces"},{"location":"clojure/Junior/modulos_y_namespaces/#modulos-y-namespaces","text":"En Clojure, los m\u00f3dulos y namespaces son herramientas fundamentales para organizar y estructurar el c\u00f3digo de manera eficiente y escalable. Un m\u00f3dulo es una colecci\u00f3n de c\u00f3digo relacionado que puede ser reutilizado en diferentes partes de una aplicaci\u00f3n. Por otro lado, un namespace es un espacio de nombres que permite agrupar y distinguir diferentes elementos dentro de un m\u00f3dulo. Esto ayuda a evitar conflictos de nombres y a facilitar la navegaci\u00f3n y comprensi\u00f3n del c\u00f3digo.","title":"M\u00f3dulos y namespaces"},{"location":"clojure/Junior/modulos_y_namespaces/#palabras-clave-y-su-definicion","text":"M\u00f3dulo: Colecci\u00f3n de c\u00f3digo relacionado que puede ser reutilizado en diferentes partes de una aplicaci\u00f3n. Namespace: Espacio de nombres que permite agrupar y distinguir diferentes elementos dentro de un m\u00f3dulo. require: Funci\u00f3n utilizada para cargar un m\u00f3dulo o namespace en el contexto actual. use: Funci\u00f3n utilizada para cargar un m\u00f3dulo o namespace y ejecutar su c\u00f3digo en el contexto actual. import: Funci\u00f3n utilizada para importar una clase de Java en un namespace de Clojure.","title":"Palabras clave y su definici\u00f3n"},{"location":"clojure/Junior/modulos_y_namespaces/#preguntas-de-repaso","text":"\u00bfCu\u00e1l es la diferencia entre un m\u00f3dulo y un namespace? \u00bfQu\u00e9 funci\u00f3n se utiliza para cargar un m\u00f3dulo o namespace en el contexto actual? \u00bfC\u00f3mo se importa una clase de Java en un namespace de Clojure?","title":"Preguntas de repaso"},{"location":"clojure/Junior/modulos_y_namespaces/#ejemplos-de-codigo-en-clojure","text":"( ns mi-app.modulo ) ( defn suma [ a b ] ( + a b )) ( defn resta [ a b ] ( - a b )) En este ejemplo, definimos un m\u00f3dulo llamado \"mi-app.modulo\" que contiene dos funciones: suma y resta. Ahora, podemos utilizar estas funciones en cualquier otro namespace de nuestra aplicaci\u00f3n utilizando la funci\u00f3n \"require\". ( ns mi-app.otro-namespace ( :require [ mi-app.modulo :as mod ])) ( def resultado ( mod/suma 5 3 )) En este caso, utilizamos la funci\u00f3n \"require\" para cargar el m\u00f3dulo \"mi-app.modulo\" con el alias \"mod\". Luego, podemos llamar a las funciones del m\u00f3dulo utilizando el alias y el nombre de la funci\u00f3n.","title":"Ejemplos de c\u00f3digo en Clojure"},{"location":"clojure/Junior/modulos_y_namespaces/#ejercicios-practicos","text":"Crea un m\u00f3dulo llamado \"matematicas\" con las funciones \"multiplicacion\" y \"division\". Importa este m\u00f3dulo en otro namespace y utiliza sus funciones para realizar operaciones matem\u00e1ticas. Crea un namespace llamado \"utilidades\" y utiliza la funci\u00f3n \"import\" para importar la clase \"Date\" de Java. Luego, utiliza esta clase para obtener la fecha actual y mostrarla por pantalla.","title":"Ejercicios pr\u00e1cticos"},{"location":"clojure/Junior/modulos_y_namespaces/#consejos-o-mejores-practicas","text":"Utiliza nombres descriptivos y significativos para tus m\u00f3dulos y namespaces. Evita utilizar el mismo nombre para diferentes m\u00f3dulos o namespaces, ya que podr\u00eda generar conflictos. Si tienes una gran cantidad de funciones en un namespace, considera dividirlo en sub-namespaces para una mejor organizaci\u00f3n. Al importar clases de Java, utiliza nombres de namespace espec\u00edficos para evitar posibles conflictos de nombres. <- Lecci\u00f3n anterior : Gesti\u00f3n de errores y depuraci\u00f3n Siguiente lecci\u00f3n -> : Trabajo con archivos y bases de datos","title":"Consejos o mejores pr\u00e1cticas"},{"location":"clojure/Junior/programacion_funcional/","text":"Programaci\u00f3n funcional \u00b6 La programaci\u00f3n funcional es un estilo de programaci\u00f3n que se basa en el uso de funciones como bloques de construcci\u00f3n fundamentales en el desarrollo de software. En lugar de modificar datos, la programaci\u00f3n funcional se enfoca en crear funciones que toman datos de entrada y producen una salida, sin efectos secundarios en otros datos o variables. Esta forma de programar se basa en los principios de la programaci\u00f3n declarativa y en el uso de expresiones y funciones puras. Palabras clave \u00b6 Funciones puras: son funciones que siempre producen el mismo resultado para una misma entrada y no tienen efectos secundarios en otras variables o datos. Inmutabilidad: se refiere a la caracter\u00edstica de los datos o variables que no pueden ser modificados despu\u00e9s de su creaci\u00f3n. Recursividad: es la t\u00e9cnica de llamar a una funci\u00f3n a s\u00ed misma para resolver un problema de manera iterativa. Composici\u00f3n de funciones: es la combinaci\u00f3n de dos o m\u00e1s funciones para obtener una nueva funci\u00f3n. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la programaci\u00f3n funcional? \u00bfCu\u00e1les son los principios de la programaci\u00f3n funcional? \u00bfQu\u00e9 son las funciones puras? \u00bfQu\u00e9 es la inmutabilidad? \u00bfCu\u00e1l es la t\u00e9cnica utilizada en la programaci\u00f3n funcional para resolver problemas de manera iterativa? \u00bfQu\u00e9 es la composici\u00f3n de funciones? Ejemplos de c\u00f3digo en Clojure \u00b6 ; funci\u00f3n pura ( defn suma [ x y ] ( + x y )) ; inmutabilidad ( def lista [ 1 2 3 ]) ; lista original ; (conj lista 4) ; agregando un elemento a la lista original ( conj [ 1 2 3 ] 4 ) ; creando una nueva lista con el elemento agregado ; recursividad ( defn factorial [ n ] ( if ( <= n 1 ) 1 ( * n ( factorial ( - n 1 ))))) ; composici\u00f3n de funciones ( defn duplicar [ x ] ( * x 2 )) ( defn sumar-uno [ x ] ( + x 1 )) ( defn duplicar-y-sumar [ x ] ( duplicar ( sumar-uno x ))) Ejercicios pr\u00e1cticos \u00b6 Crea una funci\u00f3n que tome un n\u00famero como par\u00e1metro y devuelva su cuadrado. Crear una funci\u00f3n que calcule el \u00e1rea de un c\u00edrculo. Crea una funci\u00f3n recursiva que calcule el factorial de un n\u00famero. Crea una funci\u00f3n que tome una lista de n\u00fameros y devuelva una nueva lista con el doble de cada elemento. Utiliza la composici\u00f3n de funciones para crear una funci\u00f3n que tome una lista de n\u00fameros y devuelva una nueva lista con el doble de cada elemento y luego le sume 10 a cada uno. Consejos y mejores pr\u00e1cticas \u00b6 Utiliza funciones puras siempre que sea posible para evitar efectos secundarios y hacer que tu c\u00f3digo sea m\u00e1s f\u00e1cil de entender y depurar. Aprovecha la inmutabilidad de los datos en Clojure para evitar errores y mejorar la eficiencia de tu c\u00f3digo. Utiliza la recursividad en lugar de bucles para resolver problemas de manera iterativa. Practica la composici\u00f3n de funciones para crear funciones m\u00e1s complejas a partir de funciones m\u00e1s simples. Evita la mutaci\u00f3n de datos y variables en tu c\u00f3digo, en su lugar, utiliza la funci\u00f3n let para crear nuevas variables con valores modificados a partir de las originales. Navegaci\u00f3n de lecciones \u00b6 <- Lecci\u00f3n anterior : Control de flujo y estructuras de control Siguiente lecci\u00f3n -> : Gesti\u00f3n de errores y depuraci\u00f3n","title":"Programaci\u00f3n funcional"},{"location":"clojure/Junior/programacion_funcional/#programacion-funcional","text":"La programaci\u00f3n funcional es un estilo de programaci\u00f3n que se basa en el uso de funciones como bloques de construcci\u00f3n fundamentales en el desarrollo de software. En lugar de modificar datos, la programaci\u00f3n funcional se enfoca en crear funciones que toman datos de entrada y producen una salida, sin efectos secundarios en otros datos o variables. Esta forma de programar se basa en los principios de la programaci\u00f3n declarativa y en el uso de expresiones y funciones puras.","title":"Programaci\u00f3n funcional"},{"location":"clojure/Junior/programacion_funcional/#palabras-clave","text":"Funciones puras: son funciones que siempre producen el mismo resultado para una misma entrada y no tienen efectos secundarios en otras variables o datos. Inmutabilidad: se refiere a la caracter\u00edstica de los datos o variables que no pueden ser modificados despu\u00e9s de su creaci\u00f3n. Recursividad: es la t\u00e9cnica de llamar a una funci\u00f3n a s\u00ed misma para resolver un problema de manera iterativa. Composici\u00f3n de funciones: es la combinaci\u00f3n de dos o m\u00e1s funciones para obtener una nueva funci\u00f3n.","title":"Palabras clave"},{"location":"clojure/Junior/programacion_funcional/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la programaci\u00f3n funcional? \u00bfCu\u00e1les son los principios de la programaci\u00f3n funcional? \u00bfQu\u00e9 son las funciones puras? \u00bfQu\u00e9 es la inmutabilidad? \u00bfCu\u00e1l es la t\u00e9cnica utilizada en la programaci\u00f3n funcional para resolver problemas de manera iterativa? \u00bfQu\u00e9 es la composici\u00f3n de funciones?","title":"Preguntas de repaso"},{"location":"clojure/Junior/programacion_funcional/#ejemplos-de-codigo-en-clojure","text":"; funci\u00f3n pura ( defn suma [ x y ] ( + x y )) ; inmutabilidad ( def lista [ 1 2 3 ]) ; lista original ; (conj lista 4) ; agregando un elemento a la lista original ( conj [ 1 2 3 ] 4 ) ; creando una nueva lista con el elemento agregado ; recursividad ( defn factorial [ n ] ( if ( <= n 1 ) 1 ( * n ( factorial ( - n 1 ))))) ; composici\u00f3n de funciones ( defn duplicar [ x ] ( * x 2 )) ( defn sumar-uno [ x ] ( + x 1 )) ( defn duplicar-y-sumar [ x ] ( duplicar ( sumar-uno x )))","title":"Ejemplos de c\u00f3digo en Clojure"},{"location":"clojure/Junior/programacion_funcional/#ejercicios-practicos","text":"Crea una funci\u00f3n que tome un n\u00famero como par\u00e1metro y devuelva su cuadrado. Crear una funci\u00f3n que calcule el \u00e1rea de un c\u00edrculo. Crea una funci\u00f3n recursiva que calcule el factorial de un n\u00famero. Crea una funci\u00f3n que tome una lista de n\u00fameros y devuelva una nueva lista con el doble de cada elemento. Utiliza la composici\u00f3n de funciones para crear una funci\u00f3n que tome una lista de n\u00fameros y devuelva una nueva lista con el doble de cada elemento y luego le sume 10 a cada uno.","title":"Ejercicios pr\u00e1cticos"},{"location":"clojure/Junior/programacion_funcional/#consejos-y-mejores-practicas","text":"Utiliza funciones puras siempre que sea posible para evitar efectos secundarios y hacer que tu c\u00f3digo sea m\u00e1s f\u00e1cil de entender y depurar. Aprovecha la inmutabilidad de los datos en Clojure para evitar errores y mejorar la eficiencia de tu c\u00f3digo. Utiliza la recursividad en lugar de bucles para resolver problemas de manera iterativa. Practica la composici\u00f3n de funciones para crear funciones m\u00e1s complejas a partir de funciones m\u00e1s simples. Evita la mutaci\u00f3n de datos y variables en tu c\u00f3digo, en su lugar, utiliza la funci\u00f3n let para crear nuevas variables con valores modificados a partir de las originales.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"clojure/Junior/programacion_funcional/#navegacion-de-lecciones","text":"<- Lecci\u00f3n anterior : Control de flujo y estructuras de control Siguiente lecci\u00f3n -> : Gesti\u00f3n de errores y depuraci\u00f3n","title":"Navegaci\u00f3n de lecciones"},{"location":"clojure/Junior/sintaxis_y_estructuras_de_datos/","text":"Sintaxis y estructuras de datos en Clojure \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 Clojure es un lenguaje de programaci\u00f3n funcional que se basa en la sintaxis de Lisp. Esto significa que su sintaxis es simple y consiste en listas de datos que se pueden manipular y evaluar utilizando funciones. En Clojure, todo es una lista, incluso las estructuras de datos m\u00e1s complejas, como los mapas y vectores. Esto permite una gran flexibilidad y expresividad en la escritura de c\u00f3digo. Las estructuras de datos en Clojure son inmutables, lo que significa que no se pueden cambiar una vez que se han creado. En lugar de eso, se crean nuevas versiones de la estructura de datos al aplicar funciones a ellas. Esto ayuda a prevenir errores y hace que el c\u00f3digo sea m\u00e1s seguro y f\u00e1cil de entender. Estructura de un programa en Clojure \u00b6 Un programa en Clojure est\u00e1 compuesto por una serie de expresiones, que pueden ser datos, operaciones o estructuras de control. Estas expresiones est\u00e1n organizadas en una lista, que se llama \"forma\". La forma se eval\u00faa y devuelve un resultado. Para definir una forma en Clojure, utilizamos par\u00e9ntesis y separamos cada elemento con un espacio. Por ejemplo: (def x 10) define una forma llamada \"x\" con el valor de 10. Palabras clave y su definici\u00f3n \u00b6 Lista: una estructura de datos en Clojure que contiene una secuencia de elementos ordenados. Vector: similar a una lista, pero se accede a los elementos mediante \u00edndices num\u00e9ricos. Mapa: una estructura de datos que contiene pares clave-valor, similar a un diccionario en otros lenguajes de programaci\u00f3n. Sintaxis: conjunto de reglas para escribir c\u00f3digo en un lenguaje de programaci\u00f3n. Forma: lista de expresiones que se eval\u00faan y devuelven un resultado. Inmutable: una propiedad de las estructuras de datos en Clojure que significa que no se pueden cambiar una vez creadas. Funci\u00f3n: una secuencia de instrucciones que realizan una tarea espec\u00edfica y pueden ser aplicadas a estructuras de datos. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la sintaxis en Clojure? \u00bfQu\u00e9 significa que las estructuras de datos en Clojure sean inmutables? \u00bfQu\u00e9 son las funciones en Clojure? \u00bfC\u00f3mo se accede a los elementos en un vector? \u00bfC\u00f3mo se accede a los valores en un mapa? \u00bfQu\u00e9 es una forma en Clojure? Tipos de datos \u00b6 Clojure cuenta con varios tipos de datos, entre ellos: - N\u00fameros: enteros, decimales y fracciones. - Strings: cadenas de texto. - Booleanos: verdadero o falso. - Listas: colecci\u00f3n ordenada de elementos. - Vectores: colecci\u00f3n ordenada de elementos, pero de acceso m\u00e1s r\u00e1pido que las listas. - Mapas: colecci\u00f3n de pares clave-valor. - Sets: colecci\u00f3n de elementos \u00fanicos. Operadores \u00b6 En Clojure, podemos utilizar operadores para realizar operaciones matem\u00e1ticas, comparaciones y otras tareas. Algunos de los operadores m\u00e1s comunes son: - Aritm\u00e9ticos: + , - , * , / - Comparaci\u00f3n: = , < , > , <= , >= - L\u00f3gicos: and , or , not Estructuras de control \u00b6 Las estructuras de control nos permiten controlar el flujo de nuestro c\u00f3digo. Algunas de las m\u00e1s utilizadas en Clojure son: - if : eval\u00faa una expresi\u00f3n y, si es verdadera, ejecuta un bloque de c\u00f3digo. Si es falsa, ejecuta otro bloque de c\u00f3digo. - when : similar a if , pero solo ejecuta un bloque de c\u00f3digo si la expresi\u00f3n es verdadera. - cond : eval\u00faa una serie de expresiones y ejecuta el bloque de c\u00f3digo de la primera que sea verdadera. - loop : ejecuta un bloque de c\u00f3digo varias veces hasta que se cumpla una condici\u00f3n. - recur : permite que una funci\u00f3n se llame a s\u00ed misma de forma recursiva. Ejemplos de c\u00f3digo en Clojure \u00b6 Crear una lista \u00b6 ( def lista-numeros [ 1 2 3 4 5 ]) Crear un vector \u00b6 ( def vector-nombres [ \"Ana\" \"Juan\" \"Mar\u00eda\" ]) Crear un mapa \u00b6 ( def mapa-edades { :Ana 26 :Juan 30 :Mar\u00eda 28 }) Acceder a elementos en un vector \u00b6 ( nth vector-nombres 1 ) ; devuelve \"Juan\" Acceder a valores en un mapa \u00b6 ( get mapa-edades :Mar\u00eda ) ; devuelve 28 Ejercicios pr\u00e1cticos \u00b6 Crea una lista con tus colores favoritos y muestra el primer y \u00faltimo elemento. Crea un vector con los nombres de tus amigos y agrega tu nombre al final. Crea un mapa con las edades de tus familiares y muestra la edad de tu hermano/a. Crea una funci\u00f3n que tome una lista de n\u00fameros y devuelva la suma de todos ellos. Crea una funci\u00f3n que tome un mapa con nombres y edades y devuelva una lista de nombres ordenados alfab\u00e9ticamente. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza nombres significativos para tus variables y estructuras de datos. Esto har\u00e1 que tu c\u00f3digo sea m\u00e1s f\u00e1cil de entender y mantener. Aprovecha la inmutabilidad de las estructuras de datos en Clojure y evita modificarlas directamente. Utiliza las funciones integradas en Clojure para manipular tus estructuras de datos en lugar de escribir tu propio c\u00f3digo. Practica la escritura de c\u00f3digo funcional en lugar de imperativo, ya que es la forma m\u00e1s com\u00fan de programar en Clojure. Aprende sobre las funciones de orden superior, como map y filter , para escribir c\u00f3digo m\u00e1s conciso y elegante. Navegaci\u00f3n de lecciones \u00b6 <- Lecci\u00f3n anterior : Instalaci\u00f3n y configuraci\u00f3n Siguiente lecci\u00f3n -> : Funciones y recursi\u00f3n","title":"Sintaxis y estructuras de datos en Clojure"},{"location":"clojure/Junior/sintaxis_y_estructuras_de_datos/#sintaxis-y-estructuras-de-datos-en-clojure","text":"","title":"Sintaxis y estructuras de datos en Clojure"},{"location":"clojure/Junior/sintaxis_y_estructuras_de_datos/#explicacion-teorica","text":"Clojure es un lenguaje de programaci\u00f3n funcional que se basa en la sintaxis de Lisp. Esto significa que su sintaxis es simple y consiste en listas de datos que se pueden manipular y evaluar utilizando funciones. En Clojure, todo es una lista, incluso las estructuras de datos m\u00e1s complejas, como los mapas y vectores. Esto permite una gran flexibilidad y expresividad en la escritura de c\u00f3digo. Las estructuras de datos en Clojure son inmutables, lo que significa que no se pueden cambiar una vez que se han creado. En lugar de eso, se crean nuevas versiones de la estructura de datos al aplicar funciones a ellas. Esto ayuda a prevenir errores y hace que el c\u00f3digo sea m\u00e1s seguro y f\u00e1cil de entender.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"clojure/Junior/sintaxis_y_estructuras_de_datos/#estructura-de-un-programa-en-clojure","text":"Un programa en Clojure est\u00e1 compuesto por una serie de expresiones, que pueden ser datos, operaciones o estructuras de control. Estas expresiones est\u00e1n organizadas en una lista, que se llama \"forma\". La forma se eval\u00faa y devuelve un resultado. Para definir una forma en Clojure, utilizamos par\u00e9ntesis y separamos cada elemento con un espacio. Por ejemplo: (def x 10) define una forma llamada \"x\" con el valor de 10.","title":"Estructura de un programa en Clojure"},{"location":"clojure/Junior/sintaxis_y_estructuras_de_datos/#palabras-clave-y-su-definicion","text":"Lista: una estructura de datos en Clojure que contiene una secuencia de elementos ordenados. Vector: similar a una lista, pero se accede a los elementos mediante \u00edndices num\u00e9ricos. Mapa: una estructura de datos que contiene pares clave-valor, similar a un diccionario en otros lenguajes de programaci\u00f3n. Sintaxis: conjunto de reglas para escribir c\u00f3digo en un lenguaje de programaci\u00f3n. Forma: lista de expresiones que se eval\u00faan y devuelven un resultado. Inmutable: una propiedad de las estructuras de datos en Clojure que significa que no se pueden cambiar una vez creadas. Funci\u00f3n: una secuencia de instrucciones que realizan una tarea espec\u00edfica y pueden ser aplicadas a estructuras de datos.","title":"Palabras clave y su definici\u00f3n"},{"location":"clojure/Junior/sintaxis_y_estructuras_de_datos/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la sintaxis en Clojure? \u00bfQu\u00e9 significa que las estructuras de datos en Clojure sean inmutables? \u00bfQu\u00e9 son las funciones en Clojure? \u00bfC\u00f3mo se accede a los elementos en un vector? \u00bfC\u00f3mo se accede a los valores en un mapa? \u00bfQu\u00e9 es una forma en Clojure?","title":"Preguntas de repaso"},{"location":"clojure/Junior/sintaxis_y_estructuras_de_datos/#tipos-de-datos","text":"Clojure cuenta con varios tipos de datos, entre ellos: - N\u00fameros: enteros, decimales y fracciones. - Strings: cadenas de texto. - Booleanos: verdadero o falso. - Listas: colecci\u00f3n ordenada de elementos. - Vectores: colecci\u00f3n ordenada de elementos, pero de acceso m\u00e1s r\u00e1pido que las listas. - Mapas: colecci\u00f3n de pares clave-valor. - Sets: colecci\u00f3n de elementos \u00fanicos.","title":"Tipos de datos"},{"location":"clojure/Junior/sintaxis_y_estructuras_de_datos/#operadores","text":"En Clojure, podemos utilizar operadores para realizar operaciones matem\u00e1ticas, comparaciones y otras tareas. Algunos de los operadores m\u00e1s comunes son: - Aritm\u00e9ticos: + , - , * , / - Comparaci\u00f3n: = , < , > , <= , >= - L\u00f3gicos: and , or , not","title":"Operadores"},{"location":"clojure/Junior/sintaxis_y_estructuras_de_datos/#estructuras-de-control","text":"Las estructuras de control nos permiten controlar el flujo de nuestro c\u00f3digo. Algunas de las m\u00e1s utilizadas en Clojure son: - if : eval\u00faa una expresi\u00f3n y, si es verdadera, ejecuta un bloque de c\u00f3digo. Si es falsa, ejecuta otro bloque de c\u00f3digo. - when : similar a if , pero solo ejecuta un bloque de c\u00f3digo si la expresi\u00f3n es verdadera. - cond : eval\u00faa una serie de expresiones y ejecuta el bloque de c\u00f3digo de la primera que sea verdadera. - loop : ejecuta un bloque de c\u00f3digo varias veces hasta que se cumpla una condici\u00f3n. - recur : permite que una funci\u00f3n se llame a s\u00ed misma de forma recursiva.","title":"Estructuras de control"},{"location":"clojure/Junior/sintaxis_y_estructuras_de_datos/#ejemplos-de-codigo-en-clojure","text":"","title":"Ejemplos de c\u00f3digo en Clojure"},{"location":"clojure/Junior/sintaxis_y_estructuras_de_datos/#crear-una-lista","text":"( def lista-numeros [ 1 2 3 4 5 ])","title":"Crear una lista"},{"location":"clojure/Junior/sintaxis_y_estructuras_de_datos/#crear-un-vector","text":"( def vector-nombres [ \"Ana\" \"Juan\" \"Mar\u00eda\" ])","title":"Crear un vector"},{"location":"clojure/Junior/sintaxis_y_estructuras_de_datos/#crear-un-mapa","text":"( def mapa-edades { :Ana 26 :Juan 30 :Mar\u00eda 28 })","title":"Crear un mapa"},{"location":"clojure/Junior/sintaxis_y_estructuras_de_datos/#acceder-a-elementos-en-un-vector","text":"( nth vector-nombres 1 ) ; devuelve \"Juan\"","title":"Acceder a elementos en un vector"},{"location":"clojure/Junior/sintaxis_y_estructuras_de_datos/#acceder-a-valores-en-un-mapa","text":"( get mapa-edades :Mar\u00eda ) ; devuelve 28","title":"Acceder a valores en un mapa"},{"location":"clojure/Junior/sintaxis_y_estructuras_de_datos/#ejercicios-practicos","text":"Crea una lista con tus colores favoritos y muestra el primer y \u00faltimo elemento. Crea un vector con los nombres de tus amigos y agrega tu nombre al final. Crea un mapa con las edades de tus familiares y muestra la edad de tu hermano/a. Crea una funci\u00f3n que tome una lista de n\u00fameros y devuelva la suma de todos ellos. Crea una funci\u00f3n que tome un mapa con nombres y edades y devuelva una lista de nombres ordenados alfab\u00e9ticamente.","title":"Ejercicios pr\u00e1cticos"},{"location":"clojure/Junior/sintaxis_y_estructuras_de_datos/#consejos-o-mejores-practicas","text":"Utiliza nombres significativos para tus variables y estructuras de datos. Esto har\u00e1 que tu c\u00f3digo sea m\u00e1s f\u00e1cil de entender y mantener. Aprovecha la inmutabilidad de las estructuras de datos en Clojure y evita modificarlas directamente. Utiliza las funciones integradas en Clojure para manipular tus estructuras de datos en lugar de escribir tu propio c\u00f3digo. Practica la escritura de c\u00f3digo funcional en lugar de imperativo, ya que es la forma m\u00e1s com\u00fan de programar en Clojure. Aprende sobre las funciones de orden superior, como map y filter , para escribir c\u00f3digo m\u00e1s conciso y elegante.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"clojure/Junior/sintaxis_y_estructuras_de_datos/#navegacion-de-lecciones","text":"<- Lecci\u00f3n anterior : Instalaci\u00f3n y configuraci\u00f3n Siguiente lecci\u00f3n -> : Funciones y recursi\u00f3n","title":"Navegaci\u00f3n de lecciones"},{"location":"clojure/Junior/trabajo_con_archivos_y_bases_de_datos/","text":"Trabajo con archivos y bases de datos en Clojure \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 Clojure ofrece varias herramientas para trabajar con archivos y bases de datos en una aplicaci\u00f3n. Estas herramientas son esenciales para almacenar y recuperar informaci\u00f3n de manera eficiente. Algunas de las caracter\u00edsticas m\u00e1s importantes de Clojure para el manejo de archivos y bases de datos son: Inmutabilidad: en Clojure, los datos son inmutables por defecto, lo que significa que no se pueden modificar despu\u00e9s de ser creados. Esto es \u00fatil para garantizar la integridad de los datos almacenados en archivos y bases de datos. Funciones de alto orden: Clojure permite el uso de funciones de alto orden, lo que significa que las funciones pueden ser tratadas como datos y pasadas como argumentos a otras funciones. Esto facilita la manipulaci\u00f3n y transformaci\u00f3n de datos almacenados en archivos y bases de datos. Estructuras de datos persistentes: Clojure ofrece estructuras de datos persistentes, que son versiones inmutables de estructuras de datos tradicionales. Estas estructuras son eficientes para la manipulaci\u00f3n y almacenamiento de grandes cantidades de datos, lo que las hace ideales para trabajar con archivos y bases de datos. Palabras clave y su definici\u00f3n \u00b6 with-open : es una macro que permite abrir y cerrar autom\u00e1ticamente un archivo o una conexi\u00f3n de base de datos. Esto garantiza que los recursos sean liberados correctamente despu\u00e9s de su uso. slurp : es una funci\u00f3n que lee todo el contenido de un archivo y lo devuelve como una cadena de texto. spit : es una funci\u00f3n que escribe una cadena de texto en un archivo. jdbc : es una biblioteca de Clojure que permite la conexi\u00f3n y ejecuci\u00f3n de consultas en bases de datos relacionales. defdb : es una macro que define una conexi\u00f3n de base de datos y la registra bajo un nombre en un \u00e1mbito espec\u00edfico. Preguntas de repaso \u00b6 \u00bfQu\u00e9 significa que los datos sean inmutables en Clojure? \u00bfQu\u00e9 es una funci\u00f3n de alto orden y c\u00f3mo se utiliza en Clojure? \u00bfCu\u00e1les son las ventajas de usar estructuras de datos persistentes en Clojure? \u00bfQu\u00e9 es la macro with-open y c\u00f3mo se utiliza? \u00bfQu\u00e9 funci\u00f3n se utiliza para leer el contenido de un archivo en Clojure? \u00bfQu\u00e9 biblioteca de Clojure se utiliza para trabajar con bases de datos relacionales? \u00bfC\u00f3mo se define una conexi\u00f3n de base de datos en Clojure? \u00bfCu\u00e1l es la funci\u00f3n utilizada para escribir en un archivo en Clojure? Ejemplos de c\u00f3digo en Clojure \u00b6 Leer el contenido de un archivo y mostrarlo en la consola \u00b6 ( with-open [ file ( clojure.java.io/reader \"archivo.txt\" )] ( println ( slurp file ))) Escribir en un archivo \u00b6 ( spit \"archivo.txt\" \"Este es un ejemplo de texto que se escribir\u00e1 en el archivo.\" ) Conexi\u00f3n y consulta a una base de datos utilizando la biblioteca jdbc \u00b6 ( require ' [ jdbc.core :as jdbc ]) ( defdb db ( jdbc/db-spec \"jdbc:postgresql://localhost:5432/mi_base_de_datos\" \"usuario\" \"contrase\u00f1a\" )) ( jdbc/execute! db [ \"INSERT INTO usuarios (nombre, edad) VALUES (?, ?)\" \"Juan\" 30 ]) ( def usuarios ( jdbc/query db [ \"SELECT * FROM usuarios\" ])) ( println usuarios ) Ejercicios pr\u00e1cticos \u00b6 Crea un programa que lea el contenido de un archivo y lo muestre en la consola. Escribe una funci\u00f3n que tome una lista de nombres y los escriba en un archivo, cada nombre en una l\u00ednea diferente. Modifica el c\u00f3digo del ejemplo de conexi\u00f3n y consulta a una base de datos para que muestre \u00fanicamente los usuarios mayores de 18 a\u00f1os. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza la macro with-open para asegurarte de que los recursos sean liberados correctamente despu\u00e9s de su uso. Utiliza estructuras de datos persistentes para un mejor rendimiento al trabajar con grandes cantidades de datos. Utiliza funciones de alto orden para manipular y transformar datos almacenados en archivos y bases de datos de manera eficiente. Utiliza nombres descriptivos para las conexiones de base de datos y registra estas conexiones en un \u00e1mbito espec\u00edfico para facilitar su uso en diferentes partes de la aplicaci\u00f3n. Navegaci\u00f3n de lecciones \u00b6 <- Lecci\u00f3n anterior : M\u00f3dulos y namespaces Siguiente lecci\u00f3n -> : Creaci\u00f3n de aplicaciones web con Clojure","title":"Trabajo con archivos y bases de datos en Clojure"},{"location":"clojure/Junior/trabajo_con_archivos_y_bases_de_datos/#trabajo-con-archivos-y-bases-de-datos-en-clojure","text":"","title":"Trabajo con archivos y bases de datos en Clojure"},{"location":"clojure/Junior/trabajo_con_archivos_y_bases_de_datos/#explicacion-teorica","text":"Clojure ofrece varias herramientas para trabajar con archivos y bases de datos en una aplicaci\u00f3n. Estas herramientas son esenciales para almacenar y recuperar informaci\u00f3n de manera eficiente. Algunas de las caracter\u00edsticas m\u00e1s importantes de Clojure para el manejo de archivos y bases de datos son: Inmutabilidad: en Clojure, los datos son inmutables por defecto, lo que significa que no se pueden modificar despu\u00e9s de ser creados. Esto es \u00fatil para garantizar la integridad de los datos almacenados en archivos y bases de datos. Funciones de alto orden: Clojure permite el uso de funciones de alto orden, lo que significa que las funciones pueden ser tratadas como datos y pasadas como argumentos a otras funciones. Esto facilita la manipulaci\u00f3n y transformaci\u00f3n de datos almacenados en archivos y bases de datos. Estructuras de datos persistentes: Clojure ofrece estructuras de datos persistentes, que son versiones inmutables de estructuras de datos tradicionales. Estas estructuras son eficientes para la manipulaci\u00f3n y almacenamiento de grandes cantidades de datos, lo que las hace ideales para trabajar con archivos y bases de datos.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"clojure/Junior/trabajo_con_archivos_y_bases_de_datos/#palabras-clave-y-su-definicion","text":"with-open : es una macro que permite abrir y cerrar autom\u00e1ticamente un archivo o una conexi\u00f3n de base de datos. Esto garantiza que los recursos sean liberados correctamente despu\u00e9s de su uso. slurp : es una funci\u00f3n que lee todo el contenido de un archivo y lo devuelve como una cadena de texto. spit : es una funci\u00f3n que escribe una cadena de texto en un archivo. jdbc : es una biblioteca de Clojure que permite la conexi\u00f3n y ejecuci\u00f3n de consultas en bases de datos relacionales. defdb : es una macro que define una conexi\u00f3n de base de datos y la registra bajo un nombre en un \u00e1mbito espec\u00edfico.","title":"Palabras clave y su definici\u00f3n"},{"location":"clojure/Junior/trabajo_con_archivos_y_bases_de_datos/#preguntas-de-repaso","text":"\u00bfQu\u00e9 significa que los datos sean inmutables en Clojure? \u00bfQu\u00e9 es una funci\u00f3n de alto orden y c\u00f3mo se utiliza en Clojure? \u00bfCu\u00e1les son las ventajas de usar estructuras de datos persistentes en Clojure? \u00bfQu\u00e9 es la macro with-open y c\u00f3mo se utiliza? \u00bfQu\u00e9 funci\u00f3n se utiliza para leer el contenido de un archivo en Clojure? \u00bfQu\u00e9 biblioteca de Clojure se utiliza para trabajar con bases de datos relacionales? \u00bfC\u00f3mo se define una conexi\u00f3n de base de datos en Clojure? \u00bfCu\u00e1l es la funci\u00f3n utilizada para escribir en un archivo en Clojure?","title":"Preguntas de repaso"},{"location":"clojure/Junior/trabajo_con_archivos_y_bases_de_datos/#ejemplos-de-codigo-en-clojure","text":"","title":"Ejemplos de c\u00f3digo en Clojure"},{"location":"clojure/Junior/trabajo_con_archivos_y_bases_de_datos/#leer-el-contenido-de-un-archivo-y-mostrarlo-en-la-consola","text":"( with-open [ file ( clojure.java.io/reader \"archivo.txt\" )] ( println ( slurp file )))","title":"Leer el contenido de un archivo y mostrarlo en la consola"},{"location":"clojure/Junior/trabajo_con_archivos_y_bases_de_datos/#escribir-en-un-archivo","text":"( spit \"archivo.txt\" \"Este es un ejemplo de texto que se escribir\u00e1 en el archivo.\" )","title":"Escribir en un archivo"},{"location":"clojure/Junior/trabajo_con_archivos_y_bases_de_datos/#conexion-y-consulta-a-una-base-de-datos-utilizando-la-biblioteca-jdbc","text":"( require ' [ jdbc.core :as jdbc ]) ( defdb db ( jdbc/db-spec \"jdbc:postgresql://localhost:5432/mi_base_de_datos\" \"usuario\" \"contrase\u00f1a\" )) ( jdbc/execute! db [ \"INSERT INTO usuarios (nombre, edad) VALUES (?, ?)\" \"Juan\" 30 ]) ( def usuarios ( jdbc/query db [ \"SELECT * FROM usuarios\" ])) ( println usuarios )","title":"Conexi\u00f3n y consulta a una base de datos utilizando la biblioteca jdbc"},{"location":"clojure/Junior/trabajo_con_archivos_y_bases_de_datos/#ejercicios-practicos","text":"Crea un programa que lea el contenido de un archivo y lo muestre en la consola. Escribe una funci\u00f3n que tome una lista de nombres y los escriba en un archivo, cada nombre en una l\u00ednea diferente. Modifica el c\u00f3digo del ejemplo de conexi\u00f3n y consulta a una base de datos para que muestre \u00fanicamente los usuarios mayores de 18 a\u00f1os.","title":"Ejercicios pr\u00e1cticos"},{"location":"clojure/Junior/trabajo_con_archivos_y_bases_de_datos/#consejos-o-mejores-practicas","text":"Utiliza la macro with-open para asegurarte de que los recursos sean liberados correctamente despu\u00e9s de su uso. Utiliza estructuras de datos persistentes para un mejor rendimiento al trabajar con grandes cantidades de datos. Utiliza funciones de alto orden para manipular y transformar datos almacenados en archivos y bases de datos de manera eficiente. Utiliza nombres descriptivos para las conexiones de base de datos y registra estas conexiones en un \u00e1mbito espec\u00edfico para facilitar su uso en diferentes partes de la aplicaci\u00f3n.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"clojure/Junior/trabajo_con_archivos_y_bases_de_datos/#navegacion-de-lecciones","text":"<- Lecci\u00f3n anterior : M\u00f3dulos y namespaces Siguiente lecci\u00f3n -> : Creaci\u00f3n de aplicaciones web con Clojure","title":"Navegaci\u00f3n de lecciones"},{"location":"clojure/mid/","text":"Clojure - Nivel Mid \u00b6 \u00a1Bienvenido/a al nivel Mid del curso de Clojure! En esta secci\u00f3n profundizar\u00e1s en conceptos intermedios y buenas pr\u00e1cticas de Clojure: Estructuras de datos avanzadas Funciones de orden superior Programaci\u00f3n funcional avanzada Programaci\u00f3n concurrente y paralela Testing y depuraci\u00f3n Desarrollo guiado por pruebas Interoperabilidad con Java Persistencia de datos Optimizaci\u00f3n de c\u00f3digo Optimizaci\u00f3n de rendimiento Despliegue y gesti\u00f3n de aplicaciones Creaci\u00f3n de librer\u00edas y m\u00f3dulos Siguiente lecci\u00f3n -> : Estructuras de datos avanzadas","title":"Nivel Middle"},{"location":"clojure/mid/#clojure-nivel-mid","text":"\u00a1Bienvenido/a al nivel Mid del curso de Clojure! En esta secci\u00f3n profundizar\u00e1s en conceptos intermedios y buenas pr\u00e1cticas de Clojure: Estructuras de datos avanzadas Funciones de orden superior Programaci\u00f3n funcional avanzada Programaci\u00f3n concurrente y paralela Testing y depuraci\u00f3n Desarrollo guiado por pruebas Interoperabilidad con Java Persistencia de datos Optimizaci\u00f3n de c\u00f3digo Optimizaci\u00f3n de rendimiento Despliegue y gesti\u00f3n de aplicaciones Creaci\u00f3n de librer\u00edas y m\u00f3dulos Siguiente lecci\u00f3n -> : Estructuras de datos avanzadas","title":"Clojure - Nivel Mid"},{"location":"clojure/mid/creacion_de_librerias_y_modulos/","text":"Creaci\u00f3n de librer\u00edas y m\u00f3dulos en Clojure \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 Clojure es un lenguaje funcional y din\u00e1mico que se ejecuta sobre la plataforma de Java. Una de las ventajas de Clojure es su capacidad para trabajar con m\u00f3dulos y librer\u00edas, lo que permite reutilizar c\u00f3digo en diferentes proyectos y facilita la colaboraci\u00f3n en equipo. Los m\u00f3dulos y librer\u00edas son componentes esenciales en el desarrollo de software, ya que nos permiten dividir nuestro c\u00f3digo en piezas m\u00e1s peque\u00f1as y manejables, lo que a su vez mejora la legibilidad y mantenibilidad del mismo. M\u00f3dulos en Clojure \u00b6 Un m\u00f3dulo en Clojure es un conjunto de funciones, variables y/o datos relacionados que se agrupan en un archivo con extensi\u00f3n .clj o .cljc. Estos m\u00f3dulos pueden ser utilizados para dividir un proyecto en diferentes partes funcionales, o para encapsular una funcionalidad espec\u00edfica que pueda ser utilizada en diferentes proyectos. Librer\u00edas en Clojure \u00b6 Las librer\u00edas en Clojure son m\u00f3dulos que se pueden compartir y reutilizar en diferentes proyectos. Estas librer\u00edas pueden ser publicadas en repositorios p\u00fablicos para que otros desarrolladores puedan utilizarlas en sus proyectos. Las librer\u00edas pueden ser agregadas a un proyecto de Clojure mediante un gestor de dependencias, como Leiningen o Boot. Palabras clave y su definici\u00f3n \u00b6 M\u00f3dulo: conjunto de funciones, variables y/o datos relacionados que se agrupan en un archivo con extensi\u00f3n .clj o .cljc. Librer\u00eda: m\u00f3dulo que se puede compartir y reutilizar en diferentes proyectos. Gestor de dependencias: herramienta que permite administrar las dependencias de un proyecto y agregar librer\u00edas externas. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es un m\u00f3dulo en Clojure? \u00bfCu\u00e1l es la diferencia entre un m\u00f3dulo y una librer\u00eda? \u00bfC\u00f3mo se pueden agregar librer\u00edas a un proyecto de Clojure? \u00bfQu\u00e9 es un gestor de dependencias? Ejemplos de c\u00f3digo en Clojure \u00b6 ;; Ejemplo de un m\u00f3dulo en Clojure ( ns mi-modulo ( :require [ otro-modulo :refer [ funcion-1 funcion-2 ]])) ( defn funcion-3 [ parametro ] ( str \"Hola \" parametro )) ( def data [ 1 2 3 ]) ( defn funcion-4 [] ( map funcion-1 data )) ;; Ejemplo de una librer\u00eda en Clojure ( ns mi-libreria ( :require [ otra-libreria :as ol ])) ( defn funcion-5 [ parametro ] ( ol/funcion-6 parametro )) ( defn funcion-6 [ parametro ] ( str \"Hola \" parametro )) Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea un m\u00f3dulo en Clojure con una funci\u00f3n que reciba un n\u00famero como par\u00e1metro y devuelva su cuadrado. Crea una librer\u00eda en Clojure con una funci\u00f3n que reciba una cadena de texto como par\u00e1metro y devuelva la misma cadena en may\u00fasculas. Agrega la librer\u00eda creada en el ejercicio 2 a un proyecto de Clojure y utiliza la funci\u00f3n en tu c\u00f3digo. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza nombres descriptivos y significativos para tus m\u00f3dulos y funciones. Divide tu c\u00f3digo en m\u00f3dulos peque\u00f1os y bien definidos para facilitar su mantenimiento. Publica tus librer\u00edas en repositorios p\u00fablicos para que otros desarrolladores puedan utilizarlas. Utiliza un gestor de dependencias para administrar las librer\u00edas externas en tus proyectos. <- Lecci\u00f3n anterior : Despliegue y gesti\u00f3n de aplicaciones","title":"Creaci\u00f3n de librer\u00edas y m\u00f3dulos en Clojure"},{"location":"clojure/mid/creacion_de_librerias_y_modulos/#creacion-de-librerias-y-modulos-en-clojure","text":"","title":"Creaci\u00f3n de librer\u00edas y m\u00f3dulos en Clojure"},{"location":"clojure/mid/creacion_de_librerias_y_modulos/#explicacion-teorica","text":"Clojure es un lenguaje funcional y din\u00e1mico que se ejecuta sobre la plataforma de Java. Una de las ventajas de Clojure es su capacidad para trabajar con m\u00f3dulos y librer\u00edas, lo que permite reutilizar c\u00f3digo en diferentes proyectos y facilita la colaboraci\u00f3n en equipo. Los m\u00f3dulos y librer\u00edas son componentes esenciales en el desarrollo de software, ya que nos permiten dividir nuestro c\u00f3digo en piezas m\u00e1s peque\u00f1as y manejables, lo que a su vez mejora la legibilidad y mantenibilidad del mismo.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"clojure/mid/creacion_de_librerias_y_modulos/#modulos-en-clojure","text":"Un m\u00f3dulo en Clojure es un conjunto de funciones, variables y/o datos relacionados que se agrupan en un archivo con extensi\u00f3n .clj o .cljc. Estos m\u00f3dulos pueden ser utilizados para dividir un proyecto en diferentes partes funcionales, o para encapsular una funcionalidad espec\u00edfica que pueda ser utilizada en diferentes proyectos.","title":"M\u00f3dulos en Clojure"},{"location":"clojure/mid/creacion_de_librerias_y_modulos/#librerias-en-clojure","text":"Las librer\u00edas en Clojure son m\u00f3dulos que se pueden compartir y reutilizar en diferentes proyectos. Estas librer\u00edas pueden ser publicadas en repositorios p\u00fablicos para que otros desarrolladores puedan utilizarlas en sus proyectos. Las librer\u00edas pueden ser agregadas a un proyecto de Clojure mediante un gestor de dependencias, como Leiningen o Boot.","title":"Librer\u00edas en Clojure"},{"location":"clojure/mid/creacion_de_librerias_y_modulos/#palabras-clave-y-su-definicion","text":"M\u00f3dulo: conjunto de funciones, variables y/o datos relacionados que se agrupan en un archivo con extensi\u00f3n .clj o .cljc. Librer\u00eda: m\u00f3dulo que se puede compartir y reutilizar en diferentes proyectos. Gestor de dependencias: herramienta que permite administrar las dependencias de un proyecto y agregar librer\u00edas externas.","title":"Palabras clave y su definici\u00f3n"},{"location":"clojure/mid/creacion_de_librerias_y_modulos/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es un m\u00f3dulo en Clojure? \u00bfCu\u00e1l es la diferencia entre un m\u00f3dulo y una librer\u00eda? \u00bfC\u00f3mo se pueden agregar librer\u00edas a un proyecto de Clojure? \u00bfQu\u00e9 es un gestor de dependencias?","title":"Preguntas de repaso"},{"location":"clojure/mid/creacion_de_librerias_y_modulos/#ejemplos-de-codigo-en-clojure","text":";; Ejemplo de un m\u00f3dulo en Clojure ( ns mi-modulo ( :require [ otro-modulo :refer [ funcion-1 funcion-2 ]])) ( defn funcion-3 [ parametro ] ( str \"Hola \" parametro )) ( def data [ 1 2 3 ]) ( defn funcion-4 [] ( map funcion-1 data )) ;; Ejemplo de una librer\u00eda en Clojure ( ns mi-libreria ( :require [ otra-libreria :as ol ])) ( defn funcion-5 [ parametro ] ( ol/funcion-6 parametro )) ( defn funcion-6 [ parametro ] ( str \"Hola \" parametro ))","title":"Ejemplos de c\u00f3digo en Clojure"},{"location":"clojure/mid/creacion_de_librerias_y_modulos/#ejercicios-practicos-con-instrucciones-claras","text":"Crea un m\u00f3dulo en Clojure con una funci\u00f3n que reciba un n\u00famero como par\u00e1metro y devuelva su cuadrado. Crea una librer\u00eda en Clojure con una funci\u00f3n que reciba una cadena de texto como par\u00e1metro y devuelva la misma cadena en may\u00fasculas. Agrega la librer\u00eda creada en el ejercicio 2 a un proyecto de Clojure y utiliza la funci\u00f3n en tu c\u00f3digo.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"clojure/mid/creacion_de_librerias_y_modulos/#consejos-o-mejores-practicas","text":"Utiliza nombres descriptivos y significativos para tus m\u00f3dulos y funciones. Divide tu c\u00f3digo en m\u00f3dulos peque\u00f1os y bien definidos para facilitar su mantenimiento. Publica tus librer\u00edas en repositorios p\u00fablicos para que otros desarrolladores puedan utilizarlas. Utiliza un gestor de dependencias para administrar las librer\u00edas externas en tus proyectos. <- Lecci\u00f3n anterior : Despliegue y gesti\u00f3n de aplicaciones","title":"Consejos o mejores pr\u00e1cticas"},{"location":"clojure/mid/desarrollo_guiado_por_pruebas/","text":"Desarrollo guiado por pruebas en Clojure \u00b6 El desarrollo guiado por pruebas (TDD, por sus siglas en ingl\u00e9s) es una metodolog\u00eda de desarrollo de software que se basa en escribir las pruebas antes de escribir el c\u00f3digo de la aplicaci\u00f3n. Esta forma de trabajar asegura que el c\u00f3digo est\u00e9 bien probado y funcione correctamente antes de ser implementado, lo que reduce los errores y facilita la detecci\u00f3n de posibles problemas. En Clojure, existen varias herramientas disponibles para el desarrollo guiado por pruebas, entre las m\u00e1s populares se encuentran Clojure.test y Midje. Palabras clave y su definici\u00f3n \u00b6 Desarrollo guiado por pruebas (TDD): Metodolog\u00eda de desarrollo de software que se basa en escribir las pruebas antes de escribir el c\u00f3digo de la aplicaci\u00f3n. Clojure.test: Biblioteca de Clojure para escribir y ejecutar pruebas unitarias. Midje: Biblioteca de Clojure para escribir y ejecutar pruebas en un estilo de lenguaje natural. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es el desarrollo guiado por pruebas y por qu\u00e9 es importante? \u00bfCu\u00e1les son las herramientas disponibles en Clojure para el desarrollo guiado por pruebas? \u00bfQu\u00e9 es Clojure.test y para qu\u00e9 se utiliza? \u00bfQu\u00e9 es Midje y qu\u00e9 ventajas ofrece en comparaci\u00f3n con Clojure.test? Ejemplos de c\u00f3digo en Clojure \u00b6 Clojure.test \u00b6 ( ns ejemplo.test ( :require [ clojure.test :refer :all ])) ( deftest suma-test ( testing \"Prueba de suma\" ( is ( = 4 ( + 2 2 ))))) ( run-tests ) Midje \u00b6 ( ns ejemplo.test ( :require [ midje.sweet :refer :all ])) ( fact \"Prueba de suma\" ( + 2 2 ) => 4 ) Ejercicios pr\u00e1cticos \u00b6 Utilizando Clojure.test, escribe una prueba para la funci\u00f3n \"restar\" que acepte dos par\u00e1metros y devuelva la resta de ambos. Utilizando Midje, escribe una prueba para la funci\u00f3n \"multiplicar\" que acepte dos par\u00e1metros y devuelva la multiplicaci\u00f3n de ambos. Escribe una funci\u00f3n en Clojure llamada \"es-par\" que acepte un n\u00famero como par\u00e1metro y devuelva true si es par y false si es impar. Escribe una prueba para la funci\u00f3n \"es-par\" utilizando Midje. Consejos y mejores pr\u00e1cticas \u00b6 Escribir pruebas simples y espec\u00edficas. Utilizar nombres descriptivos para las pruebas. Escribir las pruebas antes de escribir el c\u00f3digo de la funci\u00f3n. Utilizar herramientas de an\u00e1lisis de c\u00f3digo est\u00e1tico, como Eastwood o Kibit, para mejorar la calidad del c\u00f3digo. <- Lecci\u00f3n anterior : Testing y depuraci\u00f3n Siguiente lecci\u00f3n -> : Interoperabilidad con Java","title":"Desarrollo guiado por pruebas en Clojure"},{"location":"clojure/mid/desarrollo_guiado_por_pruebas/#desarrollo-guiado-por-pruebas-en-clojure","text":"El desarrollo guiado por pruebas (TDD, por sus siglas en ingl\u00e9s) es una metodolog\u00eda de desarrollo de software que se basa en escribir las pruebas antes de escribir el c\u00f3digo de la aplicaci\u00f3n. Esta forma de trabajar asegura que el c\u00f3digo est\u00e9 bien probado y funcione correctamente antes de ser implementado, lo que reduce los errores y facilita la detecci\u00f3n de posibles problemas. En Clojure, existen varias herramientas disponibles para el desarrollo guiado por pruebas, entre las m\u00e1s populares se encuentran Clojure.test y Midje.","title":"Desarrollo guiado por pruebas en Clojure"},{"location":"clojure/mid/desarrollo_guiado_por_pruebas/#palabras-clave-y-su-definicion","text":"Desarrollo guiado por pruebas (TDD): Metodolog\u00eda de desarrollo de software que se basa en escribir las pruebas antes de escribir el c\u00f3digo de la aplicaci\u00f3n. Clojure.test: Biblioteca de Clojure para escribir y ejecutar pruebas unitarias. Midje: Biblioteca de Clojure para escribir y ejecutar pruebas en un estilo de lenguaje natural.","title":"Palabras clave y su definici\u00f3n"},{"location":"clojure/mid/desarrollo_guiado_por_pruebas/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es el desarrollo guiado por pruebas y por qu\u00e9 es importante? \u00bfCu\u00e1les son las herramientas disponibles en Clojure para el desarrollo guiado por pruebas? \u00bfQu\u00e9 es Clojure.test y para qu\u00e9 se utiliza? \u00bfQu\u00e9 es Midje y qu\u00e9 ventajas ofrece en comparaci\u00f3n con Clojure.test?","title":"Preguntas de repaso"},{"location":"clojure/mid/desarrollo_guiado_por_pruebas/#ejemplos-de-codigo-en-clojure","text":"","title":"Ejemplos de c\u00f3digo en Clojure"},{"location":"clojure/mid/desarrollo_guiado_por_pruebas/#clojuretest","text":"( ns ejemplo.test ( :require [ clojure.test :refer :all ])) ( deftest suma-test ( testing \"Prueba de suma\" ( is ( = 4 ( + 2 2 ))))) ( run-tests )","title":"Clojure.test"},{"location":"clojure/mid/desarrollo_guiado_por_pruebas/#midje","text":"( ns ejemplo.test ( :require [ midje.sweet :refer :all ])) ( fact \"Prueba de suma\" ( + 2 2 ) => 4 )","title":"Midje"},{"location":"clojure/mid/desarrollo_guiado_por_pruebas/#ejercicios-practicos","text":"Utilizando Clojure.test, escribe una prueba para la funci\u00f3n \"restar\" que acepte dos par\u00e1metros y devuelva la resta de ambos. Utilizando Midje, escribe una prueba para la funci\u00f3n \"multiplicar\" que acepte dos par\u00e1metros y devuelva la multiplicaci\u00f3n de ambos. Escribe una funci\u00f3n en Clojure llamada \"es-par\" que acepte un n\u00famero como par\u00e1metro y devuelva true si es par y false si es impar. Escribe una prueba para la funci\u00f3n \"es-par\" utilizando Midje.","title":"Ejercicios pr\u00e1cticos"},{"location":"clojure/mid/desarrollo_guiado_por_pruebas/#consejos-y-mejores-practicas","text":"Escribir pruebas simples y espec\u00edficas. Utilizar nombres descriptivos para las pruebas. Escribir las pruebas antes de escribir el c\u00f3digo de la funci\u00f3n. Utilizar herramientas de an\u00e1lisis de c\u00f3digo est\u00e1tico, como Eastwood o Kibit, para mejorar la calidad del c\u00f3digo. <- Lecci\u00f3n anterior : Testing y depuraci\u00f3n Siguiente lecci\u00f3n -> : Interoperabilidad con Java","title":"Consejos y mejores pr\u00e1cticas"},{"location":"clojure/mid/despliegue_y_gestion_de_aplicaciones/","text":"Despliegue y gesti\u00f3n de aplicaciones en Clojure \u00b6 En el desarrollo de aplicaciones, no es suficiente con escribir un buen c\u00f3digo. Tambi\u00e9n es importante saber c\u00f3mo desplegar y gestionar la aplicaci\u00f3n en un entorno real. En este m\u00f3dulo, exploraremos las t\u00e9cnicas y herramientas utilizadas para desplegar y gestionar aplicaciones en Clojure. Explicaci\u00f3n te\u00f3rica \u00b6 El despliegue de una aplicaci\u00f3n se refiere al proceso de trasladar el c\u00f3digo de una aplicaci\u00f3n desde el entorno de desarrollo al entorno de producci\u00f3n, donde los usuarios pueden interactuar con ella. La gesti\u00f3n de aplicaciones se refiere a todas las tareas necesarias para mantener la aplicaci\u00f3n en funcionamiento, como la configuraci\u00f3n de entornos, la integraci\u00f3n con herramientas de automatizaci\u00f3n y la monitorizaci\u00f3n y resoluci\u00f3n de problemas. En Clojure, el despliegue y la gesti\u00f3n de aplicaciones se pueden realizar de varias maneras, dependiendo del tama\u00f1o y complejidad del proyecto. Algunas opciones comunes incluyen: Despliegue manual: Este m\u00e9todo implica copiar manualmente el c\u00f3digo de la aplicaci\u00f3n en el servidor de producci\u00f3n y configurar los entornos necesarios. Puede ser adecuado para proyectos peque\u00f1os, pero puede ser propenso a errores y llevar mucho tiempo. Despliegue automatizado: Utilizando herramientas de automatizaci\u00f3n como Ansible, Chef o Puppet, podemos escribir scripts que automatizan el proceso de despliegue y gesti\u00f3n de aplicaciones. Estas herramientas pueden ser especialmente \u00fatiles para proyectos m\u00e1s grandes y complejos. Despliegue en la nube: Con la creciente popularidad de la nube, muchas aplicaciones se despliegan y gestionan en plataformas en la nube como AWS, Google Cloud o Microsoft Azure. Estas plataformas ofrecen herramientas y servicios para facilitar el despliegue y la gesti\u00f3n de aplicaciones en la nube. Palabras clave y su definici\u00f3n \u00b6 Despliegue: Proceso de trasladar el c\u00f3digo de una aplicaci\u00f3n desde el entorno de desarrollo al entorno de producci\u00f3n. Gesti\u00f3n de aplicaciones: Tareas necesarias para mantener una aplicaci\u00f3n en funcionamiento en un entorno de producci\u00f3n. Entorno de producci\u00f3n: Entorno real donde los usuarios pueden interactuar con la aplicaci\u00f3n. Configuraci\u00f3n de entornos: Proceso de establecer las variables y configuraciones necesarias para que la aplicaci\u00f3n funcione correctamente en un entorno espec\u00edfico. Automatizaci\u00f3n: Uso de herramientas y scripts para realizar tareas de forma autom\u00e1tica. Ansible, Chef, Puppet: Herramientas de automatizaci\u00f3n populares utilizadas en el despliegue y gesti\u00f3n de aplicaciones. Plataforma en la nube: Servicio en l\u00ednea que proporciona recursos y herramientas para desplegar y gestionar aplicaciones en la nube. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es el despliegue de una aplicaci\u00f3n? \u00bfPor qu\u00e9 es importante la gesti\u00f3n de aplicaciones? \u00bfCu\u00e1les son algunas opciones comunes para desplegar y gestionar aplicaciones en Clojure? \u00bfQu\u00e9 es la configuraci\u00f3n de entornos? Nombra al menos tres herramientas de automatizaci\u00f3n utilizadas en el despliegue y gesti\u00f3n de aplicaciones. Ejemplos de c\u00f3digo en Clojure \u00b6 Despliegue manual \u00b6 ; Copia del c\u00f3digo de la aplicaci\u00f3n en el servidor de producci\u00f3n cp / ruta / del / codigo / var / www / aplicacion ; Configuraci\u00f3n de variables de entorno export HOST = mihost . com export PORT = 8080 Despliegue automatizado con Ansible \u00b6 ; Instalaci\u00f3n de Ansible apt - get install ansible ; Creaci\u00f3n de un playbook para el despliegue - name : Desplegar aplicaci\u00f3n hosts : produccion tasks : - name : Copiar c\u00f3digo de la aplicaci\u00f3n copy : src : / ruta / del / codigo dest : / var / www / aplicacion - name : Configurar variables de entorno shell : export HOST = mihost . com ; export PORT = 8080 Despliegue en la nube con AWS \u00b6 ; Creaci\u00f3n de una instancia en AWS aws ec2 create - instance -- image - id ami - 123456 -- instance - type t2 . micro -- key - name mi - clave ; Despliegue de la aplicaci\u00f3n en la instancia scp / ruta / del / codigo usuario @ ip - de - la - instancia : / var / www / aplicacion ; Configuraci\u00f3n de variables de entorno en la instancia ssh usuario @ ip - de - la - instancia \"export HOST=mihost.com; export PORT=8080\" Ejercicios pr\u00e1cticos \u00b6 Crea un script de Ansible para desplegar una aplicaci\u00f3n de Clojure en un servidor de producci\u00f3n. Utilizando AWS, crea una instancia y despliega una aplicaci\u00f3n de Clojure en ella. Configura las variables de entorno necesarias para que la aplicaci\u00f3n funcione correctamente en la instancia de AWS. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza herramientas de automatizaci\u00f3n para facilitar el proceso de despliegue y gesti\u00f3n de aplicaciones. Realiza pruebas de despliegue en entornos de prueba antes de hacerlo en producci\u00f3n. Utiliza plataformas en la nube para desplegar y gestionar aplicaciones en la nube. Documenta el proceso de despliegue y gesti\u00f3n de aplicaciones para futuras referencias. <- Lecci\u00f3n anterior : Optimizaci\u00f3n de rendimiento Siguiente lecci\u00f3n -> : Creaci\u00f3n de librer\u00edas y m\u00f3dulos","title":"Despliegue y gesti\u00f3n de aplicaciones en Clojure"},{"location":"clojure/mid/despliegue_y_gestion_de_aplicaciones/#despliegue-y-gestion-de-aplicaciones-en-clojure","text":"En el desarrollo de aplicaciones, no es suficiente con escribir un buen c\u00f3digo. Tambi\u00e9n es importante saber c\u00f3mo desplegar y gestionar la aplicaci\u00f3n en un entorno real. En este m\u00f3dulo, exploraremos las t\u00e9cnicas y herramientas utilizadas para desplegar y gestionar aplicaciones en Clojure.","title":"Despliegue y gesti\u00f3n de aplicaciones en Clojure"},{"location":"clojure/mid/despliegue_y_gestion_de_aplicaciones/#explicacion-teorica","text":"El despliegue de una aplicaci\u00f3n se refiere al proceso de trasladar el c\u00f3digo de una aplicaci\u00f3n desde el entorno de desarrollo al entorno de producci\u00f3n, donde los usuarios pueden interactuar con ella. La gesti\u00f3n de aplicaciones se refiere a todas las tareas necesarias para mantener la aplicaci\u00f3n en funcionamiento, como la configuraci\u00f3n de entornos, la integraci\u00f3n con herramientas de automatizaci\u00f3n y la monitorizaci\u00f3n y resoluci\u00f3n de problemas. En Clojure, el despliegue y la gesti\u00f3n de aplicaciones se pueden realizar de varias maneras, dependiendo del tama\u00f1o y complejidad del proyecto. Algunas opciones comunes incluyen: Despliegue manual: Este m\u00e9todo implica copiar manualmente el c\u00f3digo de la aplicaci\u00f3n en el servidor de producci\u00f3n y configurar los entornos necesarios. Puede ser adecuado para proyectos peque\u00f1os, pero puede ser propenso a errores y llevar mucho tiempo. Despliegue automatizado: Utilizando herramientas de automatizaci\u00f3n como Ansible, Chef o Puppet, podemos escribir scripts que automatizan el proceso de despliegue y gesti\u00f3n de aplicaciones. Estas herramientas pueden ser especialmente \u00fatiles para proyectos m\u00e1s grandes y complejos. Despliegue en la nube: Con la creciente popularidad de la nube, muchas aplicaciones se despliegan y gestionan en plataformas en la nube como AWS, Google Cloud o Microsoft Azure. Estas plataformas ofrecen herramientas y servicios para facilitar el despliegue y la gesti\u00f3n de aplicaciones en la nube.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"clojure/mid/despliegue_y_gestion_de_aplicaciones/#palabras-clave-y-su-definicion","text":"Despliegue: Proceso de trasladar el c\u00f3digo de una aplicaci\u00f3n desde el entorno de desarrollo al entorno de producci\u00f3n. Gesti\u00f3n de aplicaciones: Tareas necesarias para mantener una aplicaci\u00f3n en funcionamiento en un entorno de producci\u00f3n. Entorno de producci\u00f3n: Entorno real donde los usuarios pueden interactuar con la aplicaci\u00f3n. Configuraci\u00f3n de entornos: Proceso de establecer las variables y configuraciones necesarias para que la aplicaci\u00f3n funcione correctamente en un entorno espec\u00edfico. Automatizaci\u00f3n: Uso de herramientas y scripts para realizar tareas de forma autom\u00e1tica. Ansible, Chef, Puppet: Herramientas de automatizaci\u00f3n populares utilizadas en el despliegue y gesti\u00f3n de aplicaciones. Plataforma en la nube: Servicio en l\u00ednea que proporciona recursos y herramientas para desplegar y gestionar aplicaciones en la nube.","title":"Palabras clave y su definici\u00f3n"},{"location":"clojure/mid/despliegue_y_gestion_de_aplicaciones/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es el despliegue de una aplicaci\u00f3n? \u00bfPor qu\u00e9 es importante la gesti\u00f3n de aplicaciones? \u00bfCu\u00e1les son algunas opciones comunes para desplegar y gestionar aplicaciones en Clojure? \u00bfQu\u00e9 es la configuraci\u00f3n de entornos? Nombra al menos tres herramientas de automatizaci\u00f3n utilizadas en el despliegue y gesti\u00f3n de aplicaciones.","title":"Preguntas de repaso"},{"location":"clojure/mid/despliegue_y_gestion_de_aplicaciones/#ejemplos-de-codigo-en-clojure","text":"","title":"Ejemplos de c\u00f3digo en Clojure"},{"location":"clojure/mid/despliegue_y_gestion_de_aplicaciones/#despliegue-manual","text":"; Copia del c\u00f3digo de la aplicaci\u00f3n en el servidor de producci\u00f3n cp / ruta / del / codigo / var / www / aplicacion ; Configuraci\u00f3n de variables de entorno export HOST = mihost . com export PORT = 8080","title":"Despliegue manual"},{"location":"clojure/mid/despliegue_y_gestion_de_aplicaciones/#despliegue-automatizado-con-ansible","text":"; Instalaci\u00f3n de Ansible apt - get install ansible ; Creaci\u00f3n de un playbook para el despliegue - name : Desplegar aplicaci\u00f3n hosts : produccion tasks : - name : Copiar c\u00f3digo de la aplicaci\u00f3n copy : src : / ruta / del / codigo dest : / var / www / aplicacion - name : Configurar variables de entorno shell : export HOST = mihost . com ; export PORT = 8080","title":"Despliegue automatizado con Ansible"},{"location":"clojure/mid/despliegue_y_gestion_de_aplicaciones/#despliegue-en-la-nube-con-aws","text":"; Creaci\u00f3n de una instancia en AWS aws ec2 create - instance -- image - id ami - 123456 -- instance - type t2 . micro -- key - name mi - clave ; Despliegue de la aplicaci\u00f3n en la instancia scp / ruta / del / codigo usuario @ ip - de - la - instancia : / var / www / aplicacion ; Configuraci\u00f3n de variables de entorno en la instancia ssh usuario @ ip - de - la - instancia \"export HOST=mihost.com; export PORT=8080\"","title":"Despliegue en la nube con AWS"},{"location":"clojure/mid/despliegue_y_gestion_de_aplicaciones/#ejercicios-practicos","text":"Crea un script de Ansible para desplegar una aplicaci\u00f3n de Clojure en un servidor de producci\u00f3n. Utilizando AWS, crea una instancia y despliega una aplicaci\u00f3n de Clojure en ella. Configura las variables de entorno necesarias para que la aplicaci\u00f3n funcione correctamente en la instancia de AWS.","title":"Ejercicios pr\u00e1cticos"},{"location":"clojure/mid/despliegue_y_gestion_de_aplicaciones/#consejos-o-mejores-practicas","text":"Utiliza herramientas de automatizaci\u00f3n para facilitar el proceso de despliegue y gesti\u00f3n de aplicaciones. Realiza pruebas de despliegue en entornos de prueba antes de hacerlo en producci\u00f3n. Utiliza plataformas en la nube para desplegar y gestionar aplicaciones en la nube. Documenta el proceso de despliegue y gesti\u00f3n de aplicaciones para futuras referencias. <- Lecci\u00f3n anterior : Optimizaci\u00f3n de rendimiento Siguiente lecci\u00f3n -> : Creaci\u00f3n de librer\u00edas y m\u00f3dulos","title":"Consejos o mejores pr\u00e1cticas"},{"location":"clojure/mid/estructuras_de_datos_avanzadas/","text":"Estructuras de datos avanzadas en Clojure \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 Clojure es un lenguaje de programaci\u00f3n funcional que se basa en la idea de que los datos y las funciones son tratados de la misma manera. Esto significa que las estructuras de datos son fundamentales en Clojure, ya que permiten almacenar y manipular informaci\u00f3n de manera eficiente. Las estructuras de datos en Clojure son inmutables, lo que significa que no se pueden modificar una vez que han sido creadas. En lugar de eso, se crean nuevas versiones de la estructura de datos, lo que garantiza una mayor seguridad y consistencia en el c\u00f3digo. En este m\u00f3dulo, nos enfocaremos en las estructuras de datos m\u00e1s avanzadas en Clojure, que incluyen conjuntos, \u00e1rboles y secuencias infinitas. Estas estructuras de datos tienen caracter\u00edsticas \u00fanicas y proporcionan formas m\u00e1s eficientes de almacenar y manipular informaci\u00f3n en programas complejos. Palabras clave y su definici\u00f3n \u00b6 Conjuntos: una estructura de datos que almacena elementos de forma desordenada y no permite elementos duplicados. \u00c1rboles: una estructura de datos jer\u00e1rquica que consta de nodos conectados por relaciones padre-hijo. Secuencias infinitas: una estructura de datos que permite la generaci\u00f3n de una secuencia de elementos de forma infinita. Preguntas de repaso \u00b6 \u00bfQu\u00e9 significa que las estructuras de datos en Clojure sean inmutables? \u00bfCu\u00e1l es la diferencia entre una estructura de datos ordenada y una desordenada? \u00bfQu\u00e9 es un \u00e1rbol binario? \u00bfCu\u00e1l es la ventaja de usar secuencias infinitas en programas complejos? Ejemplos de c\u00f3digo en Clojure \u00b6 Conjuntos \u00b6 ( def conjunto ( hash-set 1 2 3 4 5 )) ; creaci\u00f3n de un conjunto con elementos ( conjunto 2 ) ; acceso al elemento \"2\" ( conjunto 6 ) ; el resultado es nil ya que no existe el elemento \"6\" en el conjunto ( conjunto 3 4 5 ) ; creaci\u00f3n de un nuevo conjunto con elementos del conjunto original \u00c1rboles \u00b6 ( def \u00e1rbol { :ra\u00edz \"A\" :hijo-izquierdo { :ra\u00edz \"B\" :hijo-izquierdo { :ra\u00edz \"D\" } :hijo-derecho { :ra\u00edz \"E\" }} :hijo-derecho { :ra\u00edz \"C\" :hijo-izquierdo { :ra\u00edz \"F\" }}) ; creaci\u00f3n de un \u00e1rbol ( get-in \u00e1rbol [ :hijo-izquierdo :hijo-izquierdo :ra\u00edz ]) ; acceso al elemento \"D\" ( assoc-in \u00e1rbol [ :hijo-derecho :hijo-derecho ] { :ra\u00edz \"G\" }) ; actualizaci\u00f3n del \u00e1rbol con un nuevo elemento Secuencias infinitas \u00b6 ( def numeros ( iterate inc 1 )) ; creaci\u00f3n de una secuencia infinita de n\u00fameros ( take 10 numeros ) ; toma los primeros 10 elementos de la secuencia ( filter even? numeros ) ; filtro para obtener solo los n\u00fameros pares de la secuencia ( take 5 ( drop 10 numeros )) ; toma los primeros 5 elementos despu\u00e9s de los primeros 10 de la secuencia Ejercicios pr\u00e1cticos \u00b6 Crea un conjunto con los n\u00fameros del 1 al 10 y comprueba si el n\u00famero 8 est\u00e1 incluido en \u00e9l. Crea un \u00e1rbol binario con letras del alfabeto y accede al \u00faltimo elemento. Crea una secuencia infinita de n\u00fameros pares y calcula la suma de los primeros 20 elementos. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza conjuntos cuando necesites almacenar elementos de forma desordenada y evitar duplicados. Utiliza \u00e1rboles cuando necesites almacenar datos jer\u00e1rquicamente. Utiliza secuencias infinitas cuando necesites trabajar con una gran cantidad de datos de forma eficiente. Siempre utiliza funciones de alto orden como map , filter y reduce para manipular estructuras de datos en lugar de recorrerlas manualmente. Siguiente lecci\u00f3n -> : Funciones de orden superior","title":"Estructuras de datos avanzadas en Clojure"},{"location":"clojure/mid/estructuras_de_datos_avanzadas/#estructuras-de-datos-avanzadas-en-clojure","text":"","title":"Estructuras de datos avanzadas en Clojure"},{"location":"clojure/mid/estructuras_de_datos_avanzadas/#explicacion-teorica","text":"Clojure es un lenguaje de programaci\u00f3n funcional que se basa en la idea de que los datos y las funciones son tratados de la misma manera. Esto significa que las estructuras de datos son fundamentales en Clojure, ya que permiten almacenar y manipular informaci\u00f3n de manera eficiente. Las estructuras de datos en Clojure son inmutables, lo que significa que no se pueden modificar una vez que han sido creadas. En lugar de eso, se crean nuevas versiones de la estructura de datos, lo que garantiza una mayor seguridad y consistencia en el c\u00f3digo. En este m\u00f3dulo, nos enfocaremos en las estructuras de datos m\u00e1s avanzadas en Clojure, que incluyen conjuntos, \u00e1rboles y secuencias infinitas. Estas estructuras de datos tienen caracter\u00edsticas \u00fanicas y proporcionan formas m\u00e1s eficientes de almacenar y manipular informaci\u00f3n en programas complejos.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"clojure/mid/estructuras_de_datos_avanzadas/#palabras-clave-y-su-definicion","text":"Conjuntos: una estructura de datos que almacena elementos de forma desordenada y no permite elementos duplicados. \u00c1rboles: una estructura de datos jer\u00e1rquica que consta de nodos conectados por relaciones padre-hijo. Secuencias infinitas: una estructura de datos que permite la generaci\u00f3n de una secuencia de elementos de forma infinita.","title":"Palabras clave y su definici\u00f3n"},{"location":"clojure/mid/estructuras_de_datos_avanzadas/#preguntas-de-repaso","text":"\u00bfQu\u00e9 significa que las estructuras de datos en Clojure sean inmutables? \u00bfCu\u00e1l es la diferencia entre una estructura de datos ordenada y una desordenada? \u00bfQu\u00e9 es un \u00e1rbol binario? \u00bfCu\u00e1l es la ventaja de usar secuencias infinitas en programas complejos?","title":"Preguntas de repaso"},{"location":"clojure/mid/estructuras_de_datos_avanzadas/#ejemplos-de-codigo-en-clojure","text":"","title":"Ejemplos de c\u00f3digo en Clojure"},{"location":"clojure/mid/estructuras_de_datos_avanzadas/#conjuntos","text":"( def conjunto ( hash-set 1 2 3 4 5 )) ; creaci\u00f3n de un conjunto con elementos ( conjunto 2 ) ; acceso al elemento \"2\" ( conjunto 6 ) ; el resultado es nil ya que no existe el elemento \"6\" en el conjunto ( conjunto 3 4 5 ) ; creaci\u00f3n de un nuevo conjunto con elementos del conjunto original","title":"Conjuntos"},{"location":"clojure/mid/estructuras_de_datos_avanzadas/#arboles","text":"( def \u00e1rbol { :ra\u00edz \"A\" :hijo-izquierdo { :ra\u00edz \"B\" :hijo-izquierdo { :ra\u00edz \"D\" } :hijo-derecho { :ra\u00edz \"E\" }} :hijo-derecho { :ra\u00edz \"C\" :hijo-izquierdo { :ra\u00edz \"F\" }}) ; creaci\u00f3n de un \u00e1rbol ( get-in \u00e1rbol [ :hijo-izquierdo :hijo-izquierdo :ra\u00edz ]) ; acceso al elemento \"D\" ( assoc-in \u00e1rbol [ :hijo-derecho :hijo-derecho ] { :ra\u00edz \"G\" }) ; actualizaci\u00f3n del \u00e1rbol con un nuevo elemento","title":"\u00c1rboles"},{"location":"clojure/mid/estructuras_de_datos_avanzadas/#secuencias-infinitas","text":"( def numeros ( iterate inc 1 )) ; creaci\u00f3n de una secuencia infinita de n\u00fameros ( take 10 numeros ) ; toma los primeros 10 elementos de la secuencia ( filter even? numeros ) ; filtro para obtener solo los n\u00fameros pares de la secuencia ( take 5 ( drop 10 numeros )) ; toma los primeros 5 elementos despu\u00e9s de los primeros 10 de la secuencia","title":"Secuencias infinitas"},{"location":"clojure/mid/estructuras_de_datos_avanzadas/#ejercicios-practicos","text":"Crea un conjunto con los n\u00fameros del 1 al 10 y comprueba si el n\u00famero 8 est\u00e1 incluido en \u00e9l. Crea un \u00e1rbol binario con letras del alfabeto y accede al \u00faltimo elemento. Crea una secuencia infinita de n\u00fameros pares y calcula la suma de los primeros 20 elementos.","title":"Ejercicios pr\u00e1cticos"},{"location":"clojure/mid/estructuras_de_datos_avanzadas/#consejos-o-mejores-practicas","text":"Utiliza conjuntos cuando necesites almacenar elementos de forma desordenada y evitar duplicados. Utiliza \u00e1rboles cuando necesites almacenar datos jer\u00e1rquicamente. Utiliza secuencias infinitas cuando necesites trabajar con una gran cantidad de datos de forma eficiente. Siempre utiliza funciones de alto orden como map , filter y reduce para manipular estructuras de datos en lugar de recorrerlas manualmente. Siguiente lecci\u00f3n -> : Funciones de orden superior","title":"Consejos o mejores pr\u00e1cticas"},{"location":"clojure/mid/funciones_de_orden_superior/","text":"Funciones de orden superior en Clojure \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 Las funciones de orden superior son aquellas que reciben como argumento o devuelven como resultado otras funciones. Esto permite una mayor flexibilidad en la programaci\u00f3n y una forma m\u00e1s elegante y legible de escribir c\u00f3digo. En Clojure, las funciones son ciudadanos de primera clase, lo que significa que pueden ser tratadas como cualquier otro valor. Por lo tanto, las funciones de orden superior son una parte fundamental del lenguaje. Palabras clave y su definici\u00f3n \u00b6 Funci\u00f3n de orden superior: funci\u00f3n que recibe como argumento o devuelve como resultado otra funci\u00f3n. Funci\u00f3n an\u00f3nima: funci\u00f3n sin nombre que puede ser asignada a una variable o pasada como argumento a otra funci\u00f3n. Map: funci\u00f3n de orden superior que aplica una funci\u00f3n a cada elemento de una colecci\u00f3n y devuelve una nueva colecci\u00f3n con los resultados. Filter: funci\u00f3n de orden superior que filtra una colecci\u00f3n seg\u00fan una condici\u00f3n dada y devuelve una nueva colecci\u00f3n con los elementos que cumplen dicha condici\u00f3n. Reduce: funci\u00f3n de orden superior que combina todos los elementos de una colecci\u00f3n en un \u00fanico valor, utilizando una funci\u00f3n de combinaci\u00f3n. Preguntas de repaso \u00b6 \u00bfQu\u00e9 son las funciones de orden superior? \u00bfPor qu\u00e9 son importantes en Clojure? \u00bfQu\u00e9 es una funci\u00f3n an\u00f3nima? \u00bfCu\u00e1l es la diferencia entre map, filter y reduce? \u00bfC\u00f3mo se pueden utilizar las funciones de orden superior para escribir c\u00f3digo m\u00e1s legible y elegante? Ejemplos de c\u00f3digo en Clojure \u00b6 Funci\u00f3n an\u00f3nima \u00b6 ;; Funci\u00f3n an\u00f3nima que suma dos n\u00fameros ( fn [ x y ] ( + x y )) ;; Asignar la funci\u00f3n a una variable ( defn suma [ x y ] ( + x y )) ;; Pasar la funci\u00f3n como argumento a otra funci\u00f3n ( map ( fn [ x ] ( + x 1 )) [ 1 2 3 4 ]) ;; devuelve [2 3 4 5] Map \u00b6 ;; Aplicar una funci\u00f3n a cada elemento de una colecci\u00f3n ( map # ( * % 2 ) [ 1 2 3 4 ]) ;; devuelve [2 4 6 8] Filter \u00b6 ;; Filtrar una colecci\u00f3n seg\u00fan una condici\u00f3n ( filter even? [ 1 2 3 4 ]) ;; devuelve [2 4] Reduce \u00b6 ;; Combinar todos los elementos de una colecci\u00f3n en un \u00fanico valor ( reduce + [ 1 2 3 4 ]) ;; devuelve 10 Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Escribe una funci\u00f3n de orden superior que tome una colecci\u00f3n de n\u00fameros y devuelva una nueva colecci\u00f3n con el cuadrado de cada n\u00famero. Utiliza la funci\u00f3n filter para obtener solo los n\u00fameros pares de una colecci\u00f3n de n\u00fameros. Escribe una funci\u00f3n de orden superior que tome una colecci\u00f3n de cadenas y devuelva una nueva colecci\u00f3n con la primera letra de cada cadena en may\u00fascula. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza funciones an\u00f3nimas cuando necesites una funci\u00f3n r\u00e1pida y sencilla. Utiliza map, filter y reduce en lugar de bucles for o while cuando sea posible, ya que son m\u00e1s eficientes y expresivos. Utiliza nombres descriptivos para tus funciones de orden superior para hacer tu c\u00f3digo m\u00e1s legible y comprensible. <- Lecci\u00f3n anterior : Estructuras de datos avanzadas Siguiente lecci\u00f3n -> : Programaci\u00f3n funcional avanzada","title":"Funciones de orden superior en Clojure"},{"location":"clojure/mid/funciones_de_orden_superior/#funciones-de-orden-superior-en-clojure","text":"","title":"Funciones de orden superior en Clojure"},{"location":"clojure/mid/funciones_de_orden_superior/#explicacion-teorica","text":"Las funciones de orden superior son aquellas que reciben como argumento o devuelven como resultado otras funciones. Esto permite una mayor flexibilidad en la programaci\u00f3n y una forma m\u00e1s elegante y legible de escribir c\u00f3digo. En Clojure, las funciones son ciudadanos de primera clase, lo que significa que pueden ser tratadas como cualquier otro valor. Por lo tanto, las funciones de orden superior son una parte fundamental del lenguaje.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"clojure/mid/funciones_de_orden_superior/#palabras-clave-y-su-definicion","text":"Funci\u00f3n de orden superior: funci\u00f3n que recibe como argumento o devuelve como resultado otra funci\u00f3n. Funci\u00f3n an\u00f3nima: funci\u00f3n sin nombre que puede ser asignada a una variable o pasada como argumento a otra funci\u00f3n. Map: funci\u00f3n de orden superior que aplica una funci\u00f3n a cada elemento de una colecci\u00f3n y devuelve una nueva colecci\u00f3n con los resultados. Filter: funci\u00f3n de orden superior que filtra una colecci\u00f3n seg\u00fan una condici\u00f3n dada y devuelve una nueva colecci\u00f3n con los elementos que cumplen dicha condici\u00f3n. Reduce: funci\u00f3n de orden superior que combina todos los elementos de una colecci\u00f3n en un \u00fanico valor, utilizando una funci\u00f3n de combinaci\u00f3n.","title":"Palabras clave y su definici\u00f3n"},{"location":"clojure/mid/funciones_de_orden_superior/#preguntas-de-repaso","text":"\u00bfQu\u00e9 son las funciones de orden superior? \u00bfPor qu\u00e9 son importantes en Clojure? \u00bfQu\u00e9 es una funci\u00f3n an\u00f3nima? \u00bfCu\u00e1l es la diferencia entre map, filter y reduce? \u00bfC\u00f3mo se pueden utilizar las funciones de orden superior para escribir c\u00f3digo m\u00e1s legible y elegante?","title":"Preguntas de repaso"},{"location":"clojure/mid/funciones_de_orden_superior/#ejemplos-de-codigo-en-clojure","text":"","title":"Ejemplos de c\u00f3digo en Clojure"},{"location":"clojure/mid/funciones_de_orden_superior/#funcion-anonima","text":";; Funci\u00f3n an\u00f3nima que suma dos n\u00fameros ( fn [ x y ] ( + x y )) ;; Asignar la funci\u00f3n a una variable ( defn suma [ x y ] ( + x y )) ;; Pasar la funci\u00f3n como argumento a otra funci\u00f3n ( map ( fn [ x ] ( + x 1 )) [ 1 2 3 4 ]) ;; devuelve [2 3 4 5]","title":"Funci\u00f3n an\u00f3nima"},{"location":"clojure/mid/funciones_de_orden_superior/#map","text":";; Aplicar una funci\u00f3n a cada elemento de una colecci\u00f3n ( map # ( * % 2 ) [ 1 2 3 4 ]) ;; devuelve [2 4 6 8]","title":"Map"},{"location":"clojure/mid/funciones_de_orden_superior/#filter","text":";; Filtrar una colecci\u00f3n seg\u00fan una condici\u00f3n ( filter even? [ 1 2 3 4 ]) ;; devuelve [2 4]","title":"Filter"},{"location":"clojure/mid/funciones_de_orden_superior/#reduce","text":";; Combinar todos los elementos de una colecci\u00f3n en un \u00fanico valor ( reduce + [ 1 2 3 4 ]) ;; devuelve 10","title":"Reduce"},{"location":"clojure/mid/funciones_de_orden_superior/#ejercicios-practicos-con-instrucciones-claras","text":"Escribe una funci\u00f3n de orden superior que tome una colecci\u00f3n de n\u00fameros y devuelva una nueva colecci\u00f3n con el cuadrado de cada n\u00famero. Utiliza la funci\u00f3n filter para obtener solo los n\u00fameros pares de una colecci\u00f3n de n\u00fameros. Escribe una funci\u00f3n de orden superior que tome una colecci\u00f3n de cadenas y devuelva una nueva colecci\u00f3n con la primera letra de cada cadena en may\u00fascula.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"clojure/mid/funciones_de_orden_superior/#consejos-o-mejores-practicas","text":"Utiliza funciones an\u00f3nimas cuando necesites una funci\u00f3n r\u00e1pida y sencilla. Utiliza map, filter y reduce en lugar de bucles for o while cuando sea posible, ya que son m\u00e1s eficientes y expresivos. Utiliza nombres descriptivos para tus funciones de orden superior para hacer tu c\u00f3digo m\u00e1s legible y comprensible. <- Lecci\u00f3n anterior : Estructuras de datos avanzadas Siguiente lecci\u00f3n -> : Programaci\u00f3n funcional avanzada","title":"Consejos o mejores pr\u00e1cticas"},{"location":"clojure/mid/interoperabilidad_con_java/","text":"Interoperabilidad con Java \u00b6 La interoperabilidad con Java es una capacidad importante de Clojure que permite a los desarrolladores utilizar librer\u00edas y clases de Java en sus proyectos. Esto es posible gracias a que Clojure est\u00e1 construido sobre la plataforma Java Virtual Machine (JVM), lo que permite una integraci\u00f3n fluida entre ambos lenguajes. Palabras clave y definiciones \u00b6 Interoperabilidad: capacidad de distintos sistemas o programas para comunicarse y trabajar juntos de manera eficiente y efectiva. Librer\u00eda: conjunto de funciones y m\u00e9todos que se utilizan para realizar tareas espec\u00edficas. Clase: plantilla o modelo que define las caracter\u00edsticas y comportamientos de un objeto en la programaci\u00f3n orientada a objetos. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la interoperabilidad con Java y por qu\u00e9 es importante en Clojure? \u00bfQu\u00e9 es una librer\u00eda en el contexto de la programaci\u00f3n? \u00bfCu\u00e1l es la diferencia entre una clase y un objeto en la programaci\u00f3n orientada a objetos? Ejemplos de c\u00f3digo en Clojure \u00b6 Para utilizar una librer\u00eda o clase de Java en un proyecto de Clojure, primero es necesario importarla utilizando la funci\u00f3n import de Clojure. Por ejemplo, para utilizar la clase ArrayList de Java en nuestro c\u00f3digo de Clojure, podemos hacer lo siguiente: ( import 'java.util.ArrayList) Una vez que la clase ha sido importada, podemos utilizarla en nuestro c\u00f3digo de Clojure de la misma manera que lo har\u00edamos en Java. Por ejemplo, para crear una instancia de ArrayList , podemos hacer lo siguiente: (def my-list (ArrayList.)) En este ejemplo, utilizamos la sintaxis de Java para crear una instancia de la clase ArrayList , utilizando el operador . para llamar al constructor de la clase. Tambi\u00e9n podemos utilizar los m\u00e9todos de la clase de la siguiente manera: (.add my-list \"elemento\") Este c\u00f3digo llamar\u00e1 al m\u00e9todo add de la instancia my-list y agregar\u00e1 el elemento \"elemento\" a la lista. Ejercicios pr\u00e1cticos \u00b6 Importa la clase Scanner de Java y utiliza su m\u00e9todo nextLine para pedir al usuario que ingrese su nombre y luego imprimirlo en la consola. Crea una instancia de la clase Random de Java y utiliza su m\u00e9todo nextInt para generar un n\u00famero aleatorio entre 1 y 10. Crea una lista de n\u00fameros utilizando la clase ArrayList de Java y luego utiliza un ciclo for de Clojure para imprimir cada n\u00famero en la lista en la consola. Consejos y mejores pr\u00e1cticas \u00b6 Al utilizar la interoperabilidad con Java en un proyecto de Clojure, es importante seguir algunas mejores pr\u00e1cticas para evitar posibles errores o problemas de rendimiento: - Importa solo las librer\u00edas y clases que necesitas en lugar de importar todo un paquete. - Utiliza la sintaxis de Java solo cuando sea necesario y trata de utilizar funciones y estructuras de datos de Clojure siempre que sea posible. - Aseg\u00farate de entender las diferencias entre los tipos de datos y estructuras de datos en Java y Clojure para evitar errores al pasar datos entre ambos lenguajes. - Si es posible, utiliza librer\u00edas de Clojure que ya hayan encapsulado la interoperabilidad con Java para evitar tener que escribir c\u00f3digo adicional. <- Lecci\u00f3n anterior : Desarrollo guiado por pruebas Siguiente lecci\u00f3n -> : Persistencia de datos","title":"Interoperabilidad con Java"},{"location":"clojure/mid/interoperabilidad_con_java/#interoperabilidad-con-java","text":"La interoperabilidad con Java es una capacidad importante de Clojure que permite a los desarrolladores utilizar librer\u00edas y clases de Java en sus proyectos. Esto es posible gracias a que Clojure est\u00e1 construido sobre la plataforma Java Virtual Machine (JVM), lo que permite una integraci\u00f3n fluida entre ambos lenguajes.","title":"Interoperabilidad con Java"},{"location":"clojure/mid/interoperabilidad_con_java/#palabras-clave-y-definiciones","text":"Interoperabilidad: capacidad de distintos sistemas o programas para comunicarse y trabajar juntos de manera eficiente y efectiva. Librer\u00eda: conjunto de funciones y m\u00e9todos que se utilizan para realizar tareas espec\u00edficas. Clase: plantilla o modelo que define las caracter\u00edsticas y comportamientos de un objeto en la programaci\u00f3n orientada a objetos.","title":"Palabras clave y definiciones"},{"location":"clojure/mid/interoperabilidad_con_java/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la interoperabilidad con Java y por qu\u00e9 es importante en Clojure? \u00bfQu\u00e9 es una librer\u00eda en el contexto de la programaci\u00f3n? \u00bfCu\u00e1l es la diferencia entre una clase y un objeto en la programaci\u00f3n orientada a objetos?","title":"Preguntas de repaso"},{"location":"clojure/mid/interoperabilidad_con_java/#ejemplos-de-codigo-en-clojure","text":"Para utilizar una librer\u00eda o clase de Java en un proyecto de Clojure, primero es necesario importarla utilizando la funci\u00f3n import de Clojure. Por ejemplo, para utilizar la clase ArrayList de Java en nuestro c\u00f3digo de Clojure, podemos hacer lo siguiente: ( import 'java.util.ArrayList) Una vez que la clase ha sido importada, podemos utilizarla en nuestro c\u00f3digo de Clojure de la misma manera que lo har\u00edamos en Java. Por ejemplo, para crear una instancia de ArrayList , podemos hacer lo siguiente: (def my-list (ArrayList.)) En este ejemplo, utilizamos la sintaxis de Java para crear una instancia de la clase ArrayList , utilizando el operador . para llamar al constructor de la clase. Tambi\u00e9n podemos utilizar los m\u00e9todos de la clase de la siguiente manera: (.add my-list \"elemento\") Este c\u00f3digo llamar\u00e1 al m\u00e9todo add de la instancia my-list y agregar\u00e1 el elemento \"elemento\" a la lista.","title":"Ejemplos de c\u00f3digo en Clojure"},{"location":"clojure/mid/interoperabilidad_con_java/#ejercicios-practicos","text":"Importa la clase Scanner de Java y utiliza su m\u00e9todo nextLine para pedir al usuario que ingrese su nombre y luego imprimirlo en la consola. Crea una instancia de la clase Random de Java y utiliza su m\u00e9todo nextInt para generar un n\u00famero aleatorio entre 1 y 10. Crea una lista de n\u00fameros utilizando la clase ArrayList de Java y luego utiliza un ciclo for de Clojure para imprimir cada n\u00famero en la lista en la consola.","title":"Ejercicios pr\u00e1cticos"},{"location":"clojure/mid/interoperabilidad_con_java/#consejos-y-mejores-practicas","text":"Al utilizar la interoperabilidad con Java en un proyecto de Clojure, es importante seguir algunas mejores pr\u00e1cticas para evitar posibles errores o problemas de rendimiento: - Importa solo las librer\u00edas y clases que necesitas en lugar de importar todo un paquete. - Utiliza la sintaxis de Java solo cuando sea necesario y trata de utilizar funciones y estructuras de datos de Clojure siempre que sea posible. - Aseg\u00farate de entender las diferencias entre los tipos de datos y estructuras de datos en Java y Clojure para evitar errores al pasar datos entre ambos lenguajes. - Si es posible, utiliza librer\u00edas de Clojure que ya hayan encapsulado la interoperabilidad con Java para evitar tener que escribir c\u00f3digo adicional. <- Lecci\u00f3n anterior : Desarrollo guiado por pruebas Siguiente lecci\u00f3n -> : Persistencia de datos","title":"Consejos y mejores pr\u00e1cticas"},{"location":"clojure/mid/optimizacion_de_codigo/","text":"Optimizaci\u00f3n de c\u00f3digo en Clojure \u00b6 En Clojure, como en cualquier otro lenguaje de programaci\u00f3n, es importante tener en cuenta la eficiencia y la optimizaci\u00f3n de nuestro c\u00f3digo. Esto no solo nos ayuda a mejorar el rendimiento de nuestras aplicaciones, sino que tambi\u00e9n puede ahorrar recursos y tiempo de ejecuci\u00f3n. En este m\u00f3dulo, aprenderemos t\u00e9cnicas de optimizaci\u00f3n de c\u00f3digo en Clojure, como lazy evaluation y memoization, para mejorar la eficiencia de nuestras aplicaciones. Palabras clave y definiciones \u00b6 Lazy evaluation: t\u00e9cnica de evaluaci\u00f3n en la que los valores no se calculan hasta que son necesarios, lo que permite ahorrar recursos y mejorar el rendimiento. Memoization: t\u00e9cnica de almacenamiento en cach\u00e9 de resultados de funciones para evitar su c\u00e1lculo repetitivo y mejorar el rendimiento. Recursi\u00f3n de cola: t\u00e9cnica de recursi\u00f3n en la que la llamada recursiva es la \u00faltima operaci\u00f3n realizada, lo que permite ahorrar memoria y evitar errores de desbordamiento de pila. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es lazy evaluation y c\u00f3mo puede ayudar a optimizar el c\u00f3digo en Clojure? \u00bfEn qu\u00e9 consiste la t\u00e9cnica de memoization? \u00bfCu\u00e1l es la diferencia entre recursi\u00f3n de cola y recursi\u00f3n normal? \u00bfCu\u00e1les son algunos de los beneficios de la optimizaci\u00f3n de c\u00f3digo en Clojure? Ejemplos de c\u00f3digo en Clojure \u00b6 Lazy evaluation \u00b6 En este ejemplo, se utiliza la funci\u00f3n range para generar una lista de n\u00fameros del 1 al 10. Sin embargo, gracias a la lazy evaluation, la lista no se generar\u00e1 hasta que se acceda a ella a trav\u00e9s de la funci\u00f3n first . (first (range 1 11)) ; => 1 Memoization \u00b6 La funci\u00f3n memoize nos permite almacenar en cach\u00e9 los resultados de una funci\u00f3n para evitar su c\u00e1lculo repetitivo. En este ejemplo, la funci\u00f3n fib calcula los n\u00fameros de la secuencia de Fibonacci y la funci\u00f3n memoized-fib utiliza memoization para mejorar su rendimiento. ( defn fib [ n ] ( if ( or ( zero? n ) ( = n 1 )) n ( + ( fib ( - n 1 )) ( fib ( - n 2 ))))) ( def memoized-fib ( memoize fib )) ( memoized-fib 10 ) ; => 55 Recursi\u00f3n de cola \u00b6 En este ejemplo, la funci\u00f3n sum utiliza recursi\u00f3n de cola para sumar todos los n\u00fameros de una lista de forma eficiente, evitando errores de desbordamiento de pila. ( defn sum [ lst acc ] ( if ( empty? lst ) acc ( recur ( rest lst ) ( + acc ( first lst ))))) ( sum ( range 1 100000 ) 0 ) ; => 4999950000 Ejercicios pr\u00e1cticos \u00b6 Escribe una funci\u00f3n que genere una lista de n\u00fameros pares utilizando lazy evaluation. Crea una funci\u00f3n factorial que utilice memoization para mejorar su rendimiento. Implementa una funci\u00f3n que calcule el m\u00e1ximo com\u00fan divisor de dos n\u00fameros utilizando recursi\u00f3n de cola. Consejos y mejores pr\u00e1cticas \u00b6 Utiliza lazy evaluation y memoization en funciones que realicen c\u00e1lculos intensivos o que puedan ser llamadas varias veces con los mismos argumentos. Utiliza recursi\u00f3n de cola en lugar de recursi\u00f3n normal para evitar errores de desbordamiento de pila y mejorar el rendimiento. Realiza pruebas de rendimiento antes y despu\u00e9s de aplicar t\u00e9cnicas de optimizaci\u00f3n de c\u00f3digo para medir su impacto. No sacrifiques la legibilidad y la simplicidad del c\u00f3digo por optimizaci\u00f3n excesiva. Es importante encontrar un equilibrio entre eficiencia y claridad del c\u00f3digo. <- Lecci\u00f3n anterior : Persistencia de datos Siguiente lecci\u00f3n -> : Optimizaci\u00f3n de rendimiento","title":"Optimizaci\u00f3n de c\u00f3digo en Clojure"},{"location":"clojure/mid/optimizacion_de_codigo/#optimizacion-de-codigo-en-clojure","text":"En Clojure, como en cualquier otro lenguaje de programaci\u00f3n, es importante tener en cuenta la eficiencia y la optimizaci\u00f3n de nuestro c\u00f3digo. Esto no solo nos ayuda a mejorar el rendimiento de nuestras aplicaciones, sino que tambi\u00e9n puede ahorrar recursos y tiempo de ejecuci\u00f3n. En este m\u00f3dulo, aprenderemos t\u00e9cnicas de optimizaci\u00f3n de c\u00f3digo en Clojure, como lazy evaluation y memoization, para mejorar la eficiencia de nuestras aplicaciones.","title":"Optimizaci\u00f3n de c\u00f3digo en Clojure"},{"location":"clojure/mid/optimizacion_de_codigo/#palabras-clave-y-definiciones","text":"Lazy evaluation: t\u00e9cnica de evaluaci\u00f3n en la que los valores no se calculan hasta que son necesarios, lo que permite ahorrar recursos y mejorar el rendimiento. Memoization: t\u00e9cnica de almacenamiento en cach\u00e9 de resultados de funciones para evitar su c\u00e1lculo repetitivo y mejorar el rendimiento. Recursi\u00f3n de cola: t\u00e9cnica de recursi\u00f3n en la que la llamada recursiva es la \u00faltima operaci\u00f3n realizada, lo que permite ahorrar memoria y evitar errores de desbordamiento de pila.","title":"Palabras clave y definiciones"},{"location":"clojure/mid/optimizacion_de_codigo/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es lazy evaluation y c\u00f3mo puede ayudar a optimizar el c\u00f3digo en Clojure? \u00bfEn qu\u00e9 consiste la t\u00e9cnica de memoization? \u00bfCu\u00e1l es la diferencia entre recursi\u00f3n de cola y recursi\u00f3n normal? \u00bfCu\u00e1les son algunos de los beneficios de la optimizaci\u00f3n de c\u00f3digo en Clojure?","title":"Preguntas de repaso"},{"location":"clojure/mid/optimizacion_de_codigo/#ejemplos-de-codigo-en-clojure","text":"","title":"Ejemplos de c\u00f3digo en Clojure"},{"location":"clojure/mid/optimizacion_de_codigo/#lazy-evaluation","text":"En este ejemplo, se utiliza la funci\u00f3n range para generar una lista de n\u00fameros del 1 al 10. Sin embargo, gracias a la lazy evaluation, la lista no se generar\u00e1 hasta que se acceda a ella a trav\u00e9s de la funci\u00f3n first . (first (range 1 11)) ; => 1","title":"Lazy evaluation"},{"location":"clojure/mid/optimizacion_de_codigo/#memoization","text":"La funci\u00f3n memoize nos permite almacenar en cach\u00e9 los resultados de una funci\u00f3n para evitar su c\u00e1lculo repetitivo. En este ejemplo, la funci\u00f3n fib calcula los n\u00fameros de la secuencia de Fibonacci y la funci\u00f3n memoized-fib utiliza memoization para mejorar su rendimiento. ( defn fib [ n ] ( if ( or ( zero? n ) ( = n 1 )) n ( + ( fib ( - n 1 )) ( fib ( - n 2 ))))) ( def memoized-fib ( memoize fib )) ( memoized-fib 10 ) ; => 55","title":"Memoization"},{"location":"clojure/mid/optimizacion_de_codigo/#recursion-de-cola","text":"En este ejemplo, la funci\u00f3n sum utiliza recursi\u00f3n de cola para sumar todos los n\u00fameros de una lista de forma eficiente, evitando errores de desbordamiento de pila. ( defn sum [ lst acc ] ( if ( empty? lst ) acc ( recur ( rest lst ) ( + acc ( first lst ))))) ( sum ( range 1 100000 ) 0 ) ; => 4999950000","title":"Recursi\u00f3n de cola"},{"location":"clojure/mid/optimizacion_de_codigo/#ejercicios-practicos","text":"Escribe una funci\u00f3n que genere una lista de n\u00fameros pares utilizando lazy evaluation. Crea una funci\u00f3n factorial que utilice memoization para mejorar su rendimiento. Implementa una funci\u00f3n que calcule el m\u00e1ximo com\u00fan divisor de dos n\u00fameros utilizando recursi\u00f3n de cola.","title":"Ejercicios pr\u00e1cticos"},{"location":"clojure/mid/optimizacion_de_codigo/#consejos-y-mejores-practicas","text":"Utiliza lazy evaluation y memoization en funciones que realicen c\u00e1lculos intensivos o que puedan ser llamadas varias veces con los mismos argumentos. Utiliza recursi\u00f3n de cola en lugar de recursi\u00f3n normal para evitar errores de desbordamiento de pila y mejorar el rendimiento. Realiza pruebas de rendimiento antes y despu\u00e9s de aplicar t\u00e9cnicas de optimizaci\u00f3n de c\u00f3digo para medir su impacto. No sacrifiques la legibilidad y la simplicidad del c\u00f3digo por optimizaci\u00f3n excesiva. Es importante encontrar un equilibrio entre eficiencia y claridad del c\u00f3digo. <- Lecci\u00f3n anterior : Persistencia de datos Siguiente lecci\u00f3n -> : Optimizaci\u00f3n de rendimiento","title":"Consejos y mejores pr\u00e1cticas"},{"location":"clojure/mid/optimizacion_de_rendimiento/","text":"M\u00f3dulo: Optimizaci\u00f3n de rendimiento \u00b6 En este m\u00f3dulo, aprender\u00e1s c\u00f3mo mejorar el rendimiento y la eficiencia de tus programas escritos en Clojure. La optimizaci\u00f3n de rendimiento es un aspecto importante a considerar al desarrollar aplicaciones, ya que puede afectar directamente la experiencia del usuario y la escalabilidad del sistema. Explicaci\u00f3n te\u00f3rica \u00b6 La optimizaci\u00f3n de rendimiento se refiere a la mejora del tiempo de ejecuci\u00f3n y el uso de recursos de un programa. En Clojure, podemos mejorar el rendimiento de nuestro c\u00f3digo a trav\u00e9s de diferentes t\u00e9cnicas, como la elecci\u00f3n de estructuras de datos adecuadas, la reducci\u00f3n del uso de funciones recursivas y la implementaci\u00f3n de algoritmos eficientes. Una de las caracter\u00edsticas m\u00e1s importantes de Clojure es su enfoque en la inmutabilidad y la programaci\u00f3n funcional. Esta filosof\u00eda nos permite crear programas m\u00e1s eficientes, ya que los datos inmutables no requieren copias para ser modificados, lo que ahorra tiempo y memoria. Palabras clave y definiciones \u00b6 Optimizaci\u00f3n de rendimiento: Mejora del tiempo de ejecuci\u00f3n y el uso de recursos de un programa. Inmutabilidad: Caracter\u00edstica de Clojure que hace que los datos sean inmutables, es decir, no pueden ser modificados despu\u00e9s de su creaci\u00f3n. Programaci\u00f3n funcional: Paradigma de programaci\u00f3n que se enfoca en la evaluaci\u00f3n de funciones y la evitaci\u00f3n de estados mutables. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la optimizaci\u00f3n de rendimiento? \u00bfCu\u00e1l es una de las caracter\u00edsticas m\u00e1s importantes de Clojure en t\u00e9rminos de rendimiento? \u00bfQu\u00e9 es la inmutabilidad en Clojure? \u00bfQu\u00e9 es la programaci\u00f3n funcional? Ejemplos de c\u00f3digo en Clojure \u00b6 Uso adecuado de estructuras de datos: ;; Mal rendimiento ( def lista ( range 10000000 )) ( apply + lista ) ;; Buen rendimiento ( def vector ( vec ( range 10000000 ))) ( reduce + vector ) Evitar el uso de funciones recursivas en casos innecesarios: ;; Funci\u00f3n recursiva para calcular el factorial de un n\u00famero ( defn factorial [ n ] ( if ( <= n 1 ) 1 ( * n ( factorial ( - n 1 ))))) ;; Mejora del rendimiento utilizando una funci\u00f3n iterativa ( defn factorial [ n ] ( loop [ n n res 1 ] ( if ( <= n 1 ) res ( recur ( - n 1 ) ( * res n ))))) Ejercicios pr\u00e1cticos \u00b6 Crea una funci\u00f3n en Clojure que calcule el promedio de una lista de n\u00fameros. Implementa una funci\u00f3n que busque un elemento en una lista y devuelva su \u00edndice. Escribe una funci\u00f3n que filtre una lista de n\u00fameros y devuelva solo los n\u00fameros pares. Mejora el rendimiento de las funciones anteriores utilizando las t\u00e9cnicas aprendidas en este m\u00f3dulo. Consejos y mejores pr\u00e1cticas \u00b6 Utiliza estructuras de datos adecuadas para el problema que est\u00e1s resolviendo. Evita el uso innecesario de funciones recursivas. Utiliza funciones de la biblioteca est\u00e1ndar de Clojure en lugar de crear tus propias implementaciones, ya que suelen ser m\u00e1s eficientes. Utiliza t\u00e9cnicas de profiling para identificar las partes de tu c\u00f3digo que necesitan ser optimizadas. No sacrifiques la legibilidad del c\u00f3digo por optimizaciones prematuras. Es importante encontrar un equilibrio entre rendimiento y mantenibilidad del c\u00f3digo. <- Lecci\u00f3n anterior : Optimizaci\u00f3n de c\u00f3digo Siguiente lecci\u00f3n -> : Despliegue y gesti\u00f3n de aplicaciones","title":"M\u00f3dulo: Optimizaci\u00f3n de rendimiento"},{"location":"clojure/mid/optimizacion_de_rendimiento/#modulo-optimizacion-de-rendimiento","text":"En este m\u00f3dulo, aprender\u00e1s c\u00f3mo mejorar el rendimiento y la eficiencia de tus programas escritos en Clojure. La optimizaci\u00f3n de rendimiento es un aspecto importante a considerar al desarrollar aplicaciones, ya que puede afectar directamente la experiencia del usuario y la escalabilidad del sistema.","title":"M\u00f3dulo: Optimizaci\u00f3n de rendimiento"},{"location":"clojure/mid/optimizacion_de_rendimiento/#explicacion-teorica","text":"La optimizaci\u00f3n de rendimiento se refiere a la mejora del tiempo de ejecuci\u00f3n y el uso de recursos de un programa. En Clojure, podemos mejorar el rendimiento de nuestro c\u00f3digo a trav\u00e9s de diferentes t\u00e9cnicas, como la elecci\u00f3n de estructuras de datos adecuadas, la reducci\u00f3n del uso de funciones recursivas y la implementaci\u00f3n de algoritmos eficientes. Una de las caracter\u00edsticas m\u00e1s importantes de Clojure es su enfoque en la inmutabilidad y la programaci\u00f3n funcional. Esta filosof\u00eda nos permite crear programas m\u00e1s eficientes, ya que los datos inmutables no requieren copias para ser modificados, lo que ahorra tiempo y memoria.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"clojure/mid/optimizacion_de_rendimiento/#palabras-clave-y-definiciones","text":"Optimizaci\u00f3n de rendimiento: Mejora del tiempo de ejecuci\u00f3n y el uso de recursos de un programa. Inmutabilidad: Caracter\u00edstica de Clojure que hace que los datos sean inmutables, es decir, no pueden ser modificados despu\u00e9s de su creaci\u00f3n. Programaci\u00f3n funcional: Paradigma de programaci\u00f3n que se enfoca en la evaluaci\u00f3n de funciones y la evitaci\u00f3n de estados mutables.","title":"Palabras clave y definiciones"},{"location":"clojure/mid/optimizacion_de_rendimiento/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la optimizaci\u00f3n de rendimiento? \u00bfCu\u00e1l es una de las caracter\u00edsticas m\u00e1s importantes de Clojure en t\u00e9rminos de rendimiento? \u00bfQu\u00e9 es la inmutabilidad en Clojure? \u00bfQu\u00e9 es la programaci\u00f3n funcional?","title":"Preguntas de repaso"},{"location":"clojure/mid/optimizacion_de_rendimiento/#ejemplos-de-codigo-en-clojure","text":"Uso adecuado de estructuras de datos: ;; Mal rendimiento ( def lista ( range 10000000 )) ( apply + lista ) ;; Buen rendimiento ( def vector ( vec ( range 10000000 ))) ( reduce + vector ) Evitar el uso de funciones recursivas en casos innecesarios: ;; Funci\u00f3n recursiva para calcular el factorial de un n\u00famero ( defn factorial [ n ] ( if ( <= n 1 ) 1 ( * n ( factorial ( - n 1 ))))) ;; Mejora del rendimiento utilizando una funci\u00f3n iterativa ( defn factorial [ n ] ( loop [ n n res 1 ] ( if ( <= n 1 ) res ( recur ( - n 1 ) ( * res n )))))","title":"Ejemplos de c\u00f3digo en Clojure"},{"location":"clojure/mid/optimizacion_de_rendimiento/#ejercicios-practicos","text":"Crea una funci\u00f3n en Clojure que calcule el promedio de una lista de n\u00fameros. Implementa una funci\u00f3n que busque un elemento en una lista y devuelva su \u00edndice. Escribe una funci\u00f3n que filtre una lista de n\u00fameros y devuelva solo los n\u00fameros pares. Mejora el rendimiento de las funciones anteriores utilizando las t\u00e9cnicas aprendidas en este m\u00f3dulo.","title":"Ejercicios pr\u00e1cticos"},{"location":"clojure/mid/optimizacion_de_rendimiento/#consejos-y-mejores-practicas","text":"Utiliza estructuras de datos adecuadas para el problema que est\u00e1s resolviendo. Evita el uso innecesario de funciones recursivas. Utiliza funciones de la biblioteca est\u00e1ndar de Clojure en lugar de crear tus propias implementaciones, ya que suelen ser m\u00e1s eficientes. Utiliza t\u00e9cnicas de profiling para identificar las partes de tu c\u00f3digo que necesitan ser optimizadas. No sacrifiques la legibilidad del c\u00f3digo por optimizaciones prematuras. Es importante encontrar un equilibrio entre rendimiento y mantenibilidad del c\u00f3digo. <- Lecci\u00f3n anterior : Optimizaci\u00f3n de c\u00f3digo Siguiente lecci\u00f3n -> : Despliegue y gesti\u00f3n de aplicaciones","title":"Consejos y mejores pr\u00e1cticas"},{"location":"clojure/mid/persistencia_de_datos/","text":"Persistencia de datos en Clojure \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 La persistencia de datos se refiere a la capacidad de un programa para almacenar y recuperar datos de manera permanente. En el caso de Clojure, esto se logra mediante el uso de bases de datos relacionales o no relacionales, como PostgreSQL, MongoDB o Redis, entre otros. Clojure cuenta con una amplia variedad de librer\u00edas y herramientas para trabajar con bases de datos, lo que hace que sea una buena opci\u00f3n para desarrollar aplicaciones que requieran persistencia de datos. Palabras clave y su definici\u00f3n \u00b6 Bases de datos: Conjunto de datos estructurados y organizados de manera que sea f\u00e1cil acceder a ellos y gestionarlos. Almacenamiento: Proceso de guardar datos en un medio de almacenamiento para su posterior recuperaci\u00f3n. Persistencia: Capacidad de un programa para almacenar datos de manera permanente. Relacional: Tipo de base de datos que organiza los datos en tablas, con relaciones entre ellas. No relacionales: Tipo de base de datos que no utiliza tablas y no tiene relaciones entre los datos almacenados. Librer\u00edas: Conjunto de funciones y herramientas que facilitan el desarrollo de software. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la persistencia de datos? \u00bfQu\u00e9 tipos de bases de datos se pueden utilizar en Clojure? \u00bfQu\u00e9 es una librer\u00eda en el contexto de Clojure? \u00bfCu\u00e1l es la diferencia entre bases de datos relacionales y no relacionales? Ejemplos de c\u00f3digo en Clojure \u00b6 Conexi\u00f3n a una base de datos PostgreSQL \u00b6 ( require ' [ clojure.java.jdbc :as jdbc ]) ( def db { :classname \"org.postgresql.Driver\" :subprotocol \"postgresql\" :subname \"//localhost:5432/mydatabase\" :user \"username\" :password \"password\" }) ( jdbc/query db [ \"SELECT * FROM users\" ]) Creaci\u00f3n de una nueva entrada en MongoDB \u00b6 ( require ' [ monger.core :as mg ]) ( mg/insert! :users { :name \"John\" :age 25 }) Ejercicios pr\u00e1cticos \u00b6 Crear una base de datos en PostgreSQL y conectarla desde Clojure. Insertar un nuevo registro en una base de datos MongoDB utilizando Clojure. Realizar una consulta a una base de datos no relacional y mostrar los resultados en la consola. Consejos o mejores pr\u00e1cticas \u00b6 Utilizar librer\u00edas de terceros para trabajar con bases de datos, como clojure.java.jdbc o monger. Utilizar transacciones para asegurar la integridad de los datos en la base de datos. Implementar un sistema de gesti\u00f3n de errores y excepciones al trabajar con bases de datos. Realizar pruebas unitarias para asegurar el correcto funcionamiento de las consultas y operaciones en la base de datos. <- Lecci\u00f3n anterior : Interoperabilidad con Java Siguiente lecci\u00f3n -> : Optimizaci\u00f3n de c\u00f3digo","title":"Persistencia de datos en Clojure"},{"location":"clojure/mid/persistencia_de_datos/#persistencia-de-datos-en-clojure","text":"","title":"Persistencia de datos en Clojure"},{"location":"clojure/mid/persistencia_de_datos/#explicacion-teorica","text":"La persistencia de datos se refiere a la capacidad de un programa para almacenar y recuperar datos de manera permanente. En el caso de Clojure, esto se logra mediante el uso de bases de datos relacionales o no relacionales, como PostgreSQL, MongoDB o Redis, entre otros. Clojure cuenta con una amplia variedad de librer\u00edas y herramientas para trabajar con bases de datos, lo que hace que sea una buena opci\u00f3n para desarrollar aplicaciones que requieran persistencia de datos.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"clojure/mid/persistencia_de_datos/#palabras-clave-y-su-definicion","text":"Bases de datos: Conjunto de datos estructurados y organizados de manera que sea f\u00e1cil acceder a ellos y gestionarlos. Almacenamiento: Proceso de guardar datos en un medio de almacenamiento para su posterior recuperaci\u00f3n. Persistencia: Capacidad de un programa para almacenar datos de manera permanente. Relacional: Tipo de base de datos que organiza los datos en tablas, con relaciones entre ellas. No relacionales: Tipo de base de datos que no utiliza tablas y no tiene relaciones entre los datos almacenados. Librer\u00edas: Conjunto de funciones y herramientas que facilitan el desarrollo de software.","title":"Palabras clave y su definici\u00f3n"},{"location":"clojure/mid/persistencia_de_datos/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la persistencia de datos? \u00bfQu\u00e9 tipos de bases de datos se pueden utilizar en Clojure? \u00bfQu\u00e9 es una librer\u00eda en el contexto de Clojure? \u00bfCu\u00e1l es la diferencia entre bases de datos relacionales y no relacionales?","title":"Preguntas de repaso"},{"location":"clojure/mid/persistencia_de_datos/#ejemplos-de-codigo-en-clojure","text":"","title":"Ejemplos de c\u00f3digo en Clojure"},{"location":"clojure/mid/persistencia_de_datos/#conexion-a-una-base-de-datos-postgresql","text":"( require ' [ clojure.java.jdbc :as jdbc ]) ( def db { :classname \"org.postgresql.Driver\" :subprotocol \"postgresql\" :subname \"//localhost:5432/mydatabase\" :user \"username\" :password \"password\" }) ( jdbc/query db [ \"SELECT * FROM users\" ])","title":"Conexi\u00f3n a una base de datos PostgreSQL"},{"location":"clojure/mid/persistencia_de_datos/#creacion-de-una-nueva-entrada-en-mongodb","text":"( require ' [ monger.core :as mg ]) ( mg/insert! :users { :name \"John\" :age 25 })","title":"Creaci\u00f3n de una nueva entrada en MongoDB"},{"location":"clojure/mid/persistencia_de_datos/#ejercicios-practicos","text":"Crear una base de datos en PostgreSQL y conectarla desde Clojure. Insertar un nuevo registro en una base de datos MongoDB utilizando Clojure. Realizar una consulta a una base de datos no relacional y mostrar los resultados en la consola.","title":"Ejercicios pr\u00e1cticos"},{"location":"clojure/mid/persistencia_de_datos/#consejos-o-mejores-practicas","text":"Utilizar librer\u00edas de terceros para trabajar con bases de datos, como clojure.java.jdbc o monger. Utilizar transacciones para asegurar la integridad de los datos en la base de datos. Implementar un sistema de gesti\u00f3n de errores y excepciones al trabajar con bases de datos. Realizar pruebas unitarias para asegurar el correcto funcionamiento de las consultas y operaciones en la base de datos. <- Lecci\u00f3n anterior : Interoperabilidad con Java Siguiente lecci\u00f3n -> : Optimizaci\u00f3n de c\u00f3digo","title":"Consejos o mejores pr\u00e1cticas"},{"location":"clojure/mid/programacion_concurrente_y_paralela/","text":"Programaci\u00f3n concurrente y paralela \u00b6 La programaci\u00f3n concurrente y paralela son dos paradigmas de programaci\u00f3n que permiten ejecutar m\u00faltiples tareas al mismo tiempo. Aunque a menudo se utilizan de manera intercambiable, existen algunas diferencias clave entre ellos. Explicaci\u00f3n te\u00f3rica \u00b6 La programaci\u00f3n concurrente se refiere a la capacidad de un programa de ejecutar varias tareas de manera intercalada. Esto significa que el programa puede iniciar una tarea, luego pasar a otra y luego volver a la tarea original. En la programaci\u00f3n concurrente, las tareas se ejecutan de manera no determinista, lo que significa que su orden de ejecuci\u00f3n no se puede predecir. En Clojure, la programaci\u00f3n concurrente se logra mediante el uso de hilos. Los hilos son secuencias de instrucciones que se ejecutan de forma independiente dentro de un programa. Cada hilo tiene su propio estado y puede realizar operaciones de manera concurrente con otros hilos. Para lograr una programaci\u00f3n concurrente efectiva, es importante tener en cuenta el manejo de la concurrencia. Esto se refiere a c\u00f3mo se gestionan los recursos compartidos entre diferentes hilos. En Clojure, se utilizan estructuras de datos inmutables para evitar conflictos entre hilos y garantizar una ejecuci\u00f3n segura y sin errores. Por otro lado, la programaci\u00f3n paralela se refiere a la capacidad de ejecutar varias tareas al mismo tiempo en diferentes n\u00facleos de procesamiento o m\u00e1quinas. A diferencia de la programaci\u00f3n concurrente, en la programaci\u00f3n paralela las tareas se ejecutan de manera simult\u00e1nea y se pueden predecir su orden de ejecuci\u00f3n. En Clojure, ambos paradigmas se pueden implementar utilizando el modelo de concurrencia de Agent y el modelo de paralelismo de Pmap. Palabras clave y su definici\u00f3n \u00b6 Hilos: Secuencias de instrucciones que se ejecutan de forma independiente en un programa. Concurrencia: la capacidad de un programa para ejecutar varias tareas de manera intercalada. Paralelismo: la capacidad de un programa para ejecutar varias tareas de manera simult\u00e1nea. Atom: Estructura de datos en Clojure que permite la actualizaci\u00f3n de un valor de forma segura y sin conflictos entre hilos. Refs: Referencias a estructuras de datos que se pueden modificar de forma transaccional y concurrente. Agent: un modelo de concurrencia en Clojure que permite la ejecuci\u00f3n de tareas de manera as\u00edncrona y en paralelo. Pmap: un modelo de paralelismo en Clojure que permite aplicar una funci\u00f3n a una colecci\u00f3n de elementos de manera paralela. Promise: Objeto que representa un valor que ser\u00e1 entregado en alg\u00fan momento futuro. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la programaci\u00f3n concurrente y por qu\u00e9 es importante en Clojure? \u00bfC\u00f3mo se logra la programaci\u00f3n concurrente en Clojure? \u00bfCu\u00e1l es la diferencia entre programaci\u00f3n concurrente y paralela? \u00bfQu\u00e9 modelos de concurrencia y paralelismo existen en Clojure? \u00bfQu\u00e9 es un Agent en Clojure? \u00bfQu\u00e9 es Pmap en Clojure? Ejemplos de c\u00f3digo en Clojure \u00b6 Programaci\u00f3n concurrente \u00b6 ( defn tarea [ x ] ( println ( str \"Iniciando tarea \" x )) ( Thread/sleep 1000 ) ( println ( str \"Finalizando tarea \" x ))) ( dosync ( future ( tarea 1 )) ( future ( tarea 2 )) ( future ( tarea 3 ))) En este ejemplo, la funci\u00f3n tarea se ejecuta de manera as\u00edncrona utilizando el modelo de concurrencia de Agent. Las tareas se ejecutar\u00e1n de manera intercalada y su orden de ejecuci\u00f3n no se puede predecir. Uso de hilos \u00b6 ( defn funcion1 [] ( println \"Ejecutando funci\u00f3n 1\" ) ( Thread/sleep 1000 ) ( println \"Fin de funci\u00f3n 1\" )) ( defn funcion2 [] ( println \"Ejecutando funci\u00f3n 2\" ) ( Thread/sleep 2000 ) ( println \"Fin de funci\u00f3n 2\" )) ( def t1 ( Thread. funcion1 )) ( def t2 ( Thread. funcion2 )) ( .start t1 ) ( .start t2 ) ;; Resultado: ;; Ejecutando funci\u00f3n 1 ;; Ejecutando funci\u00f3n 2 ;; Fin de funci\u00f3n 1 ;; Fin de funci\u00f3n 2 Uso de atoms \u00b6 ( def saldo ( atom 100 )) ( defn depositar [ cantidad ] ( swap! saldo + cantidad )) ( defn retirar [ cantidad ] ( swap! saldo - cantidad )) ;; Ejecutar en hilos separados ( dotimes [ i 10 ] ( future ( depositar 10 )) ( future ( retirar 5 ))) @ saldo ;; Resultado: 150 Programaci\u00f3n paralela \u00b6 ( defn tarea [ x ] ( println ( str \"Iniciando tarea \" x )) ( Thread/sleep 1000 ) ( println ( str \"Finalizando tarea \" x ))) ( pmap tarea ( range 1 4 )) En este ejemplo, la funci\u00f3n pmap se encarga de aplicar la funci\u00f3n tarea de manera paralela a cada elemento de la colecci\u00f3n generada por range . Esto significa que las tareas se ejecutar\u00e1n en diferentes n\u00facleos de procesamiento o m\u00e1quinas de manera simult\u00e1nea. Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una funci\u00f3n que reciba un n\u00famero entero y devuelva su cuadrado utilizando el modelo de concurrencia de Agent. Crea una funci\u00f3n que reciba una lista de n\u00fameros y devuelva una lista con sus respectivos cuadrados utilizando el modelo de paralelismo de Pmap. Modifica la funci\u00f3n anterior para que solo devuelva los cuadrados de los n\u00fameros pares de la lista. Crea una funci\u00f3n en Clojure que calcule el \u00e1rea de un c\u00edrculo utilizando hilos y muestre el resultado por pantalla. Modifica la funci\u00f3n anterior para que utilice una estructura de datos inmutable y evite conflictos entre hilos. Crea una funci\u00f3n que realice una operaci\u00f3n matem\u00e1tica compleja en un agente y muestre el resultado por pantalla. Crea una promesa en Clojure que devuelva un n\u00famero aleatorio despu\u00e9s de 5 segundos y muestra el resultado por pantalla. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza la programaci\u00f3n concurrente cuando necesites ejecutar tareas en segundo plano y no te importe su orden de ejecuci\u00f3n. Utiliza la programaci\u00f3n paralela cuando necesites mejorar el rendimiento de tu aplicaci\u00f3n al ejecutar tareas en diferentes n\u00facleos de procesamiento o m\u00e1quinas. Ten en cuenta que la programaci\u00f3n paralela puede tener un costo adicional de comunicaci\u00f3n entre los diferentes procesos, por lo que es importante medir y evaluar su rendimiento antes de implementarla en tu aplicaci\u00f3n. Utiliza estructuras de datos inmutables para evitar conflictos entre hilos. Evita la modificaci\u00f3n directa de estructuras de datos compartidas entre hilos. Utiliza estructuras de datos espec\u00edficas para la programaci\u00f3n concurrente, como atoms, refs, agents y promises. Aseg\u00farate de entender y manejar adecuadamente el manejo de la concurrencia en tus aplicaciones. Utiliza herramientas como la funci\u00f3n \"future\" para ejecutar tareas de forma asincr\u00f3nica y no bloquear el flujo principal del programa. <- Lecci\u00f3n anterior : Programaci\u00f3n funcional avanzada Siguiente lecci\u00f3n -> : Testing y depuraci\u00f3n","title":"Programaci\u00f3n concurrente y paralela"},{"location":"clojure/mid/programacion_concurrente_y_paralela/#programacion-concurrente-y-paralela","text":"La programaci\u00f3n concurrente y paralela son dos paradigmas de programaci\u00f3n que permiten ejecutar m\u00faltiples tareas al mismo tiempo. Aunque a menudo se utilizan de manera intercambiable, existen algunas diferencias clave entre ellos.","title":"Programaci\u00f3n concurrente y paralela"},{"location":"clojure/mid/programacion_concurrente_y_paralela/#explicacion-teorica","text":"La programaci\u00f3n concurrente se refiere a la capacidad de un programa de ejecutar varias tareas de manera intercalada. Esto significa que el programa puede iniciar una tarea, luego pasar a otra y luego volver a la tarea original. En la programaci\u00f3n concurrente, las tareas se ejecutan de manera no determinista, lo que significa que su orden de ejecuci\u00f3n no se puede predecir. En Clojure, la programaci\u00f3n concurrente se logra mediante el uso de hilos. Los hilos son secuencias de instrucciones que se ejecutan de forma independiente dentro de un programa. Cada hilo tiene su propio estado y puede realizar operaciones de manera concurrente con otros hilos. Para lograr una programaci\u00f3n concurrente efectiva, es importante tener en cuenta el manejo de la concurrencia. Esto se refiere a c\u00f3mo se gestionan los recursos compartidos entre diferentes hilos. En Clojure, se utilizan estructuras de datos inmutables para evitar conflictos entre hilos y garantizar una ejecuci\u00f3n segura y sin errores. Por otro lado, la programaci\u00f3n paralela se refiere a la capacidad de ejecutar varias tareas al mismo tiempo en diferentes n\u00facleos de procesamiento o m\u00e1quinas. A diferencia de la programaci\u00f3n concurrente, en la programaci\u00f3n paralela las tareas se ejecutan de manera simult\u00e1nea y se pueden predecir su orden de ejecuci\u00f3n. En Clojure, ambos paradigmas se pueden implementar utilizando el modelo de concurrencia de Agent y el modelo de paralelismo de Pmap.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"clojure/mid/programacion_concurrente_y_paralela/#palabras-clave-y-su-definicion","text":"Hilos: Secuencias de instrucciones que se ejecutan de forma independiente en un programa. Concurrencia: la capacidad de un programa para ejecutar varias tareas de manera intercalada. Paralelismo: la capacidad de un programa para ejecutar varias tareas de manera simult\u00e1nea. Atom: Estructura de datos en Clojure que permite la actualizaci\u00f3n de un valor de forma segura y sin conflictos entre hilos. Refs: Referencias a estructuras de datos que se pueden modificar de forma transaccional y concurrente. Agent: un modelo de concurrencia en Clojure que permite la ejecuci\u00f3n de tareas de manera as\u00edncrona y en paralelo. Pmap: un modelo de paralelismo en Clojure que permite aplicar una funci\u00f3n a una colecci\u00f3n de elementos de manera paralela. Promise: Objeto que representa un valor que ser\u00e1 entregado en alg\u00fan momento futuro.","title":"Palabras clave y su definici\u00f3n"},{"location":"clojure/mid/programacion_concurrente_y_paralela/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la programaci\u00f3n concurrente y por qu\u00e9 es importante en Clojure? \u00bfC\u00f3mo se logra la programaci\u00f3n concurrente en Clojure? \u00bfCu\u00e1l es la diferencia entre programaci\u00f3n concurrente y paralela? \u00bfQu\u00e9 modelos de concurrencia y paralelismo existen en Clojure? \u00bfQu\u00e9 es un Agent en Clojure? \u00bfQu\u00e9 es Pmap en Clojure?","title":"Preguntas de repaso"},{"location":"clojure/mid/programacion_concurrente_y_paralela/#ejemplos-de-codigo-en-clojure","text":"","title":"Ejemplos de c\u00f3digo en Clojure"},{"location":"clojure/mid/programacion_concurrente_y_paralela/#programacion-concurrente","text":"( defn tarea [ x ] ( println ( str \"Iniciando tarea \" x )) ( Thread/sleep 1000 ) ( println ( str \"Finalizando tarea \" x ))) ( dosync ( future ( tarea 1 )) ( future ( tarea 2 )) ( future ( tarea 3 ))) En este ejemplo, la funci\u00f3n tarea se ejecuta de manera as\u00edncrona utilizando el modelo de concurrencia de Agent. Las tareas se ejecutar\u00e1n de manera intercalada y su orden de ejecuci\u00f3n no se puede predecir.","title":"Programaci\u00f3n concurrente"},{"location":"clojure/mid/programacion_concurrente_y_paralela/#uso-de-hilos","text":"( defn funcion1 [] ( println \"Ejecutando funci\u00f3n 1\" ) ( Thread/sleep 1000 ) ( println \"Fin de funci\u00f3n 1\" )) ( defn funcion2 [] ( println \"Ejecutando funci\u00f3n 2\" ) ( Thread/sleep 2000 ) ( println \"Fin de funci\u00f3n 2\" )) ( def t1 ( Thread. funcion1 )) ( def t2 ( Thread. funcion2 )) ( .start t1 ) ( .start t2 ) ;; Resultado: ;; Ejecutando funci\u00f3n 1 ;; Ejecutando funci\u00f3n 2 ;; Fin de funci\u00f3n 1 ;; Fin de funci\u00f3n 2","title":"Uso de hilos"},{"location":"clojure/mid/programacion_concurrente_y_paralela/#uso-de-atoms","text":"( def saldo ( atom 100 )) ( defn depositar [ cantidad ] ( swap! saldo + cantidad )) ( defn retirar [ cantidad ] ( swap! saldo - cantidad )) ;; Ejecutar en hilos separados ( dotimes [ i 10 ] ( future ( depositar 10 )) ( future ( retirar 5 ))) @ saldo ;; Resultado: 150","title":"Uso de atoms"},{"location":"clojure/mid/programacion_concurrente_y_paralela/#programacion-paralela","text":"( defn tarea [ x ] ( println ( str \"Iniciando tarea \" x )) ( Thread/sleep 1000 ) ( println ( str \"Finalizando tarea \" x ))) ( pmap tarea ( range 1 4 )) En este ejemplo, la funci\u00f3n pmap se encarga de aplicar la funci\u00f3n tarea de manera paralela a cada elemento de la colecci\u00f3n generada por range . Esto significa que las tareas se ejecutar\u00e1n en diferentes n\u00facleos de procesamiento o m\u00e1quinas de manera simult\u00e1nea.","title":"Programaci\u00f3n paralela"},{"location":"clojure/mid/programacion_concurrente_y_paralela/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una funci\u00f3n que reciba un n\u00famero entero y devuelva su cuadrado utilizando el modelo de concurrencia de Agent. Crea una funci\u00f3n que reciba una lista de n\u00fameros y devuelva una lista con sus respectivos cuadrados utilizando el modelo de paralelismo de Pmap. Modifica la funci\u00f3n anterior para que solo devuelva los cuadrados de los n\u00fameros pares de la lista. Crea una funci\u00f3n en Clojure que calcule el \u00e1rea de un c\u00edrculo utilizando hilos y muestre el resultado por pantalla. Modifica la funci\u00f3n anterior para que utilice una estructura de datos inmutable y evite conflictos entre hilos. Crea una funci\u00f3n que realice una operaci\u00f3n matem\u00e1tica compleja en un agente y muestre el resultado por pantalla. Crea una promesa en Clojure que devuelva un n\u00famero aleatorio despu\u00e9s de 5 segundos y muestra el resultado por pantalla.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"clojure/mid/programacion_concurrente_y_paralela/#consejos-o-mejores-practicas","text":"Utiliza la programaci\u00f3n concurrente cuando necesites ejecutar tareas en segundo plano y no te importe su orden de ejecuci\u00f3n. Utiliza la programaci\u00f3n paralela cuando necesites mejorar el rendimiento de tu aplicaci\u00f3n al ejecutar tareas en diferentes n\u00facleos de procesamiento o m\u00e1quinas. Ten en cuenta que la programaci\u00f3n paralela puede tener un costo adicional de comunicaci\u00f3n entre los diferentes procesos, por lo que es importante medir y evaluar su rendimiento antes de implementarla en tu aplicaci\u00f3n. Utiliza estructuras de datos inmutables para evitar conflictos entre hilos. Evita la modificaci\u00f3n directa de estructuras de datos compartidas entre hilos. Utiliza estructuras de datos espec\u00edficas para la programaci\u00f3n concurrente, como atoms, refs, agents y promises. Aseg\u00farate de entender y manejar adecuadamente el manejo de la concurrencia en tus aplicaciones. Utiliza herramientas como la funci\u00f3n \"future\" para ejecutar tareas de forma asincr\u00f3nica y no bloquear el flujo principal del programa. <- Lecci\u00f3n anterior : Programaci\u00f3n funcional avanzada Siguiente lecci\u00f3n -> : Testing y depuraci\u00f3n","title":"Consejos o mejores pr\u00e1cticas"},{"location":"clojure/mid/programacion_funcional_avanzada/","text":"Programaci\u00f3n funcional avanzada \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 La programaci\u00f3n funcional es un paradigma de programaci\u00f3n que se basa en el uso de funciones como elementos fundamentales del c\u00f3digo. En Clojure, un lenguaje de programaci\u00f3n funcional basado en lenguaje Lisp, se pueden utilizar funciones de orden superior, recursividad y composici\u00f3n de funciones para crear programas m\u00e1s eficientes y elegantes. Las funciones de orden superior son aquellas que pueden tomar otras funciones como argumentos y devolver funciones como resultado. Son una herramienta poderosa en la programaci\u00f3n funcional, ya que permiten crear funciones m\u00e1s gen\u00e9ricas y reutilizables. Algunos ejemplos de funciones de orden superior en Clojure son map , filter y reduce . La recursividad es una t\u00e9cnica en la que una funci\u00f3n se llama a s\u00ed misma hasta que se cumple una condici\u00f3n de salida. En Clojure, se puede utilizar la recursividad para resolver problemas de manera elegante y eficiente, especialmente aquellos que involucran estructuras de datos recursivas como listas y \u00e1rboles. La composici\u00f3n de funciones es otra t\u00e9cnica importante en la programaci\u00f3n funcional que consiste en combinar varias funciones para crear una nueva funci\u00f3n. Esto permite construir programas de manera modular y componer funciones m\u00e1s complejas a partir de funciones m\u00e1s simples. Palabras clave y su definici\u00f3n \u00b6 Programaci\u00f3n funcional: paradigma de programaci\u00f3n basado en el uso de funciones como elementos fundamentales del c\u00f3digo. Funciones de orden superior: funciones que pueden tomar otras funciones como argumentos y devolver funciones como resultado. Recursividad: t\u00e9cnica en la que una funci\u00f3n se llama a s\u00ed misma hasta que se cumple una condici\u00f3n de salida. Composici\u00f3n de funciones: t\u00e9cnica en la que se combinan varias funciones para crear una nueva funci\u00f3n. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la programaci\u00f3n funcional y cu\u00e1l es su principal caracter\u00edstica? \u00bfQu\u00e9 son las funciones de orden superior y por qu\u00e9 son \u00fatiles? \u00bfEn qu\u00e9 consiste la recursividad y en qu\u00e9 situaciones se puede utilizar? \u00bfQu\u00e9 es la composici\u00f3n de funciones y cu\u00e1l es su ventaja en la programaci\u00f3n funcional? Ejemplos de c\u00f3digo en Clojure \u00b6 ; Ejemplo de funci\u00f3n de orden superior ( defn sum [ a b ] ( + a b )) ( defn operate [ f a b ] ( f a b )) ( operate sum 5 3 ) ; devuelve 8 ; Ejemplo de recursividad ( defn factorial [ n ] ( if ( < n 2 ) 1 ( * n ( factorial ( - n 1 ))))) ( factorial 5 ) ; devuelve 120 ; Ejemplo de composici\u00f3n de funciones ( defn add [ x ] ( + x 1 )) ( defn multiply [ x ] ( * x 2 )) ( defn add-and-multiply [ x ] ( -> x add multiply )) ( add-and-multiply 5 ) ; devuelve 12 Ejercicios pr\u00e1cticos \u00b6 Crea una funci\u00f3n de orden superior que tome una lista de n\u00fameros y devuelva una lista con los n\u00fameros pares. Utiliza la recursividad para calcular la suma de los n\u00fameros de una lista. Crea una funci\u00f3n que combine dos listas en una sola utilizando composici\u00f3n de funciones. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza funciones de orden superior para crear funciones m\u00e1s gen\u00e9ricas y reutilizables. Ten cuidado con la recursividad infinita, aseg\u00farate siempre de tener una condici\u00f3n de salida. Utiliza la composici\u00f3n de funciones para crear programas modulares y f\u00e1ciles de mantener. <- Lecci\u00f3n anterior : Funciones de orden superior Siguiente lecci\u00f3n -> : Programaci\u00f3n concurrente y paralela","title":"Programaci\u00f3n funcional avanzada"},{"location":"clojure/mid/programacion_funcional_avanzada/#programacion-funcional-avanzada","text":"","title":"Programaci\u00f3n funcional avanzada"},{"location":"clojure/mid/programacion_funcional_avanzada/#explicacion-teorica","text":"La programaci\u00f3n funcional es un paradigma de programaci\u00f3n que se basa en el uso de funciones como elementos fundamentales del c\u00f3digo. En Clojure, un lenguaje de programaci\u00f3n funcional basado en lenguaje Lisp, se pueden utilizar funciones de orden superior, recursividad y composici\u00f3n de funciones para crear programas m\u00e1s eficientes y elegantes. Las funciones de orden superior son aquellas que pueden tomar otras funciones como argumentos y devolver funciones como resultado. Son una herramienta poderosa en la programaci\u00f3n funcional, ya que permiten crear funciones m\u00e1s gen\u00e9ricas y reutilizables. Algunos ejemplos de funciones de orden superior en Clojure son map , filter y reduce . La recursividad es una t\u00e9cnica en la que una funci\u00f3n se llama a s\u00ed misma hasta que se cumple una condici\u00f3n de salida. En Clojure, se puede utilizar la recursividad para resolver problemas de manera elegante y eficiente, especialmente aquellos que involucran estructuras de datos recursivas como listas y \u00e1rboles. La composici\u00f3n de funciones es otra t\u00e9cnica importante en la programaci\u00f3n funcional que consiste en combinar varias funciones para crear una nueva funci\u00f3n. Esto permite construir programas de manera modular y componer funciones m\u00e1s complejas a partir de funciones m\u00e1s simples.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"clojure/mid/programacion_funcional_avanzada/#palabras-clave-y-su-definicion","text":"Programaci\u00f3n funcional: paradigma de programaci\u00f3n basado en el uso de funciones como elementos fundamentales del c\u00f3digo. Funciones de orden superior: funciones que pueden tomar otras funciones como argumentos y devolver funciones como resultado. Recursividad: t\u00e9cnica en la que una funci\u00f3n se llama a s\u00ed misma hasta que se cumple una condici\u00f3n de salida. Composici\u00f3n de funciones: t\u00e9cnica en la que se combinan varias funciones para crear una nueva funci\u00f3n.","title":"Palabras clave y su definici\u00f3n"},{"location":"clojure/mid/programacion_funcional_avanzada/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la programaci\u00f3n funcional y cu\u00e1l es su principal caracter\u00edstica? \u00bfQu\u00e9 son las funciones de orden superior y por qu\u00e9 son \u00fatiles? \u00bfEn qu\u00e9 consiste la recursividad y en qu\u00e9 situaciones se puede utilizar? \u00bfQu\u00e9 es la composici\u00f3n de funciones y cu\u00e1l es su ventaja en la programaci\u00f3n funcional?","title":"Preguntas de repaso"},{"location":"clojure/mid/programacion_funcional_avanzada/#ejemplos-de-codigo-en-clojure","text":"; Ejemplo de funci\u00f3n de orden superior ( defn sum [ a b ] ( + a b )) ( defn operate [ f a b ] ( f a b )) ( operate sum 5 3 ) ; devuelve 8 ; Ejemplo de recursividad ( defn factorial [ n ] ( if ( < n 2 ) 1 ( * n ( factorial ( - n 1 ))))) ( factorial 5 ) ; devuelve 120 ; Ejemplo de composici\u00f3n de funciones ( defn add [ x ] ( + x 1 )) ( defn multiply [ x ] ( * x 2 )) ( defn add-and-multiply [ x ] ( -> x add multiply )) ( add-and-multiply 5 ) ; devuelve 12","title":"Ejemplos de c\u00f3digo en Clojure"},{"location":"clojure/mid/programacion_funcional_avanzada/#ejercicios-practicos","text":"Crea una funci\u00f3n de orden superior que tome una lista de n\u00fameros y devuelva una lista con los n\u00fameros pares. Utiliza la recursividad para calcular la suma de los n\u00fameros de una lista. Crea una funci\u00f3n que combine dos listas en una sola utilizando composici\u00f3n de funciones.","title":"Ejercicios pr\u00e1cticos"},{"location":"clojure/mid/programacion_funcional_avanzada/#consejos-o-mejores-practicas","text":"Utiliza funciones de orden superior para crear funciones m\u00e1s gen\u00e9ricas y reutilizables. Ten cuidado con la recursividad infinita, aseg\u00farate siempre de tener una condici\u00f3n de salida. Utiliza la composici\u00f3n de funciones para crear programas modulares y f\u00e1ciles de mantener. <- Lecci\u00f3n anterior : Funciones de orden superior Siguiente lecci\u00f3n -> : Programaci\u00f3n concurrente y paralela","title":"Consejos o mejores pr\u00e1cticas"},{"location":"clojure/mid/testing_y_depuracion/","text":"Testing y depuraci\u00f3n en Clojure \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 Clojure es un lenguaje de programaci\u00f3n funcional que se ejecuta en la m\u00e1quina virtual de Java (JVM). La programaci\u00f3n funcional se basa en funciones puras, que no tienen efectos secundarios y siempre producen el mismo resultado para los mismos valores de entrada. Esto hace que el c\u00f3digo en Clojure sea m\u00e1s f\u00e1cil de probar y depurar. El testing y la depuraci\u00f3n son procesos importantes en el desarrollo de software, ya que permiten detectar y corregir errores en el c\u00f3digo. En Clojure, existen varias t\u00e9cnicas y herramientas que facilitan estas tareas. Palabras clave y su definici\u00f3n \u00b6 Testing: proceso de verificar que el c\u00f3digo funcione correctamente y cumpla con los requisitos establecidos. Depuraci\u00f3n: proceso de identificar y corregir errores en el c\u00f3digo. Pruebas unitarias: pruebas que se realizan a nivel de funciones o peque\u00f1as secciones de c\u00f3digo. Pruebas de integraci\u00f3n: pruebas que se realizan a nivel de sistema, verificando la interacci\u00f3n entre diferentes partes del c\u00f3digo. REPL: Read-Evaluate-Print Loop, una herramienta que permite ejecutar c\u00f3digo y ver los resultados en tiempo real. TDD: Test Driven Development, una metodolog\u00eda de desarrollo en la que se escriben las pruebas antes de escribir el c\u00f3digo. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es el testing y por qu\u00e9 es importante? \u00bfQu\u00e9 es la depuraci\u00f3n y por qu\u00e9 es importante? \u00bfCu\u00e1l es la diferencia entre pruebas unitarias y pruebas de integraci\u00f3n? \u00bfQu\u00e9 es el REPL y para qu\u00e9 se utiliza? \u00bfQu\u00e9 es TDD y c\u00f3mo puede ayudar en el desarrollo de software? Ejemplos de c\u00f3digo en Clojure \u00b6 Pruebas unitarias \u00b6 ( defn sum [ a b ] ( + a b )) ( deftest test-sum ( is ( = ( sum 2 3 ) 5 )) ( is ( = ( sum -1 4 ) 3 ))) Pruebas de integraci\u00f3n \u00b6 ( defn get-user [ id ] ( db/get-user-by-id id )) ( deftest test-get-user ( is ( = ( get-user 1 ) { :name \"John\" , :age 30 })) ( is ( = ( get-user 2 ) { :name \"Jane\" , :age 25 }))) Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una funci\u00f3n en Clojure que calcule el \u00e1rea de un c\u00edrculo, dado su radio. Escribe pruebas unitarias para la funci\u00f3n anterior. Crea una funci\u00f3n en Clojure que reciba una lista de n\u00fameros y devuelva la suma de los n\u00fameros pares. Escribe pruebas de integraci\u00f3n para la funci\u00f3n anterior, utilizando una lista de n\u00fameros de prueba. Consejos o mejores pr\u00e1cticas \u00b6 Utilizar la herramienta REPL para probar y depurar c\u00f3digo en tiempo real. Escribir pruebas unitarias y de integraci\u00f3n para asegurar que el c\u00f3digo funcione correctamente. Utilizar TDD para escribir las pruebas antes de escribir el c\u00f3digo, esto ayuda a identificar posibles errores antes de que sean implementados. Utilizar herramientas como clojure.test para facilitar la escritura de pruebas. Utilizar assert y is para verificar que los resultados obtenidos sean los esperados. Escribir pruebas para casos de prueba extremos o l\u00edmites, para asegurar que el c\u00f3digo maneje correctamente estos casos. <- Lecci\u00f3n anterior : Programaci\u00f3n concurrente y paralela Siguiente lecci\u00f3n -> : Desarrollo guiado por pruebas","title":"Testing y depuraci\u00f3n en Clojure"},{"location":"clojure/mid/testing_y_depuracion/#testing-y-depuracion-en-clojure","text":"","title":"Testing y depuraci\u00f3n en Clojure"},{"location":"clojure/mid/testing_y_depuracion/#explicacion-teorica","text":"Clojure es un lenguaje de programaci\u00f3n funcional que se ejecuta en la m\u00e1quina virtual de Java (JVM). La programaci\u00f3n funcional se basa en funciones puras, que no tienen efectos secundarios y siempre producen el mismo resultado para los mismos valores de entrada. Esto hace que el c\u00f3digo en Clojure sea m\u00e1s f\u00e1cil de probar y depurar. El testing y la depuraci\u00f3n son procesos importantes en el desarrollo de software, ya que permiten detectar y corregir errores en el c\u00f3digo. En Clojure, existen varias t\u00e9cnicas y herramientas que facilitan estas tareas.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"clojure/mid/testing_y_depuracion/#palabras-clave-y-su-definicion","text":"Testing: proceso de verificar que el c\u00f3digo funcione correctamente y cumpla con los requisitos establecidos. Depuraci\u00f3n: proceso de identificar y corregir errores en el c\u00f3digo. Pruebas unitarias: pruebas que se realizan a nivel de funciones o peque\u00f1as secciones de c\u00f3digo. Pruebas de integraci\u00f3n: pruebas que se realizan a nivel de sistema, verificando la interacci\u00f3n entre diferentes partes del c\u00f3digo. REPL: Read-Evaluate-Print Loop, una herramienta que permite ejecutar c\u00f3digo y ver los resultados en tiempo real. TDD: Test Driven Development, una metodolog\u00eda de desarrollo en la que se escriben las pruebas antes de escribir el c\u00f3digo.","title":"Palabras clave y su definici\u00f3n"},{"location":"clojure/mid/testing_y_depuracion/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es el testing y por qu\u00e9 es importante? \u00bfQu\u00e9 es la depuraci\u00f3n y por qu\u00e9 es importante? \u00bfCu\u00e1l es la diferencia entre pruebas unitarias y pruebas de integraci\u00f3n? \u00bfQu\u00e9 es el REPL y para qu\u00e9 se utiliza? \u00bfQu\u00e9 es TDD y c\u00f3mo puede ayudar en el desarrollo de software?","title":"Preguntas de repaso"},{"location":"clojure/mid/testing_y_depuracion/#ejemplos-de-codigo-en-clojure","text":"","title":"Ejemplos de c\u00f3digo en Clojure"},{"location":"clojure/mid/testing_y_depuracion/#pruebas-unitarias","text":"( defn sum [ a b ] ( + a b )) ( deftest test-sum ( is ( = ( sum 2 3 ) 5 )) ( is ( = ( sum -1 4 ) 3 )))","title":"Pruebas unitarias"},{"location":"clojure/mid/testing_y_depuracion/#pruebas-de-integracion","text":"( defn get-user [ id ] ( db/get-user-by-id id )) ( deftest test-get-user ( is ( = ( get-user 1 ) { :name \"John\" , :age 30 })) ( is ( = ( get-user 2 ) { :name \"Jane\" , :age 25 })))","title":"Pruebas de integraci\u00f3n"},{"location":"clojure/mid/testing_y_depuracion/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una funci\u00f3n en Clojure que calcule el \u00e1rea de un c\u00edrculo, dado su radio. Escribe pruebas unitarias para la funci\u00f3n anterior. Crea una funci\u00f3n en Clojure que reciba una lista de n\u00fameros y devuelva la suma de los n\u00fameros pares. Escribe pruebas de integraci\u00f3n para la funci\u00f3n anterior, utilizando una lista de n\u00fameros de prueba.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"clojure/mid/testing_y_depuracion/#consejos-o-mejores-practicas","text":"Utilizar la herramienta REPL para probar y depurar c\u00f3digo en tiempo real. Escribir pruebas unitarias y de integraci\u00f3n para asegurar que el c\u00f3digo funcione correctamente. Utilizar TDD para escribir las pruebas antes de escribir el c\u00f3digo, esto ayuda a identificar posibles errores antes de que sean implementados. Utilizar herramientas como clojure.test para facilitar la escritura de pruebas. Utilizar assert y is para verificar que los resultados obtenidos sean los esperados. Escribir pruebas para casos de prueba extremos o l\u00edmites, para asegurar que el c\u00f3digo maneje correctamente estos casos. <- Lecci\u00f3n anterior : Programaci\u00f3n concurrente y paralela Siguiente lecci\u00f3n -> : Desarrollo guiado por pruebas","title":"Consejos o mejores pr\u00e1cticas"},{"location":"clojure/senior/","text":"Clojure - Nivel Senior \u00b6 \u00a1Bienvenido/a al nivel Senior del curso de Clojure! Ahora explorar\u00e1s temas avanzados y t\u00e9cnicas para proyectos complejos: Macros y metaprogramaci\u00f3n Transducers y reducers Protocolos y registros Programaci\u00f3n l\u00f3gica Arquitecturas y patrones de dise\u00f1o Integraci\u00f3n con otros lenguajes y plataformas Proyectos pr\u00e1cticos Desarrollo en equipo y buenas pr\u00e1cticas Investigaci\u00f3n y experimentaci\u00f3n","title":"Nivel Senior"},{"location":"clojure/senior/#clojure-nivel-senior","text":"\u00a1Bienvenido/a al nivel Senior del curso de Clojure! Ahora explorar\u00e1s temas avanzados y t\u00e9cnicas para proyectos complejos: Macros y metaprogramaci\u00f3n Transducers y reducers Protocolos y registros Programaci\u00f3n l\u00f3gica Arquitecturas y patrones de dise\u00f1o Integraci\u00f3n con otros lenguajes y plataformas Proyectos pr\u00e1cticos Desarrollo en equipo y buenas pr\u00e1cticas Investigaci\u00f3n y experimentaci\u00f3n","title":"Clojure - Nivel Senior"},{"location":"clojure/senior/arquitecturas_y_patrones_de_diseno/","text":"Arquitecturas y patrones de dise\u00f1o en Clojure \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 Clojure es un lenguaje de programaci\u00f3n funcional que se basa en la filosof\u00eda de \"programaci\u00f3n orientada a datos\". Esto significa que todas las operaciones se realizan sobre estructuras de datos inmutables, lo que lo hace ideal para construir aplicaciones altamente escalables y mantenibles. Sin embargo, para construir aplicaciones complejas, es importante tener una comprensi\u00f3n clara de la arquitectura y los patrones de dise\u00f1o en Clojure. Estos proporcionan una estructura y un enfoque para desarrollar aplicaciones que sean f\u00e1ciles de entender, extender y mantener. En Clojure, hay dos arquitecturas principales que se utilizan com\u00fanmente: Datomic y Component. Datomic \u00b6 Datomic es una base de datos distribuida y orientada a tiempo que se integra perfectamente con Clojure. Utiliza un modelo de datos inmutable y transaccional, lo que lo hace ideal para aplicaciones que requieren una alta consistencia y escalabilidad. Una de las principales ventajas de Datomic es que permite realizar consultas en el tiempo, lo que significa que se pueden realizar consultas sobre c\u00f3mo eran los datos en un momento espec\u00edfico en el pasado. Esto es especialmente \u00fatil en aplicaciones que manejan datos sensibles o cr\u00edticos en el tiempo. Component \u00b6 Component es un patr\u00f3n de dise\u00f1o que se utiliza para construir aplicaciones modulares y altamente extensibles en Clojure. Se basa en el principio de separar la l\u00f3gica de la aplicaci\u00f3n en componentes independientes y conectados. Cada componente es una entidad inmutable que encapsula un estado y una l\u00f3gica de negocio espec\u00edficos. Estos componentes se conectan entre s\u00ed mediante un sistema de dependencias, lo que permite una f\u00e1cil reutilizaci\u00f3n y extensi\u00f3n de la funcionalidad de la aplicaci\u00f3n. Palabras clave y su definici\u00f3n \u00b6 Inmutabilidad: significa que los datos no pueden modificarse una vez que se han creado. En Clojure, todos los datos son inmutables por defecto, lo que garantiza una mayor consistencia y evita errores comunes en el manejo de datos. Transaccional: se refiere a una operaci\u00f3n que se realiza de forma completa o no se realiza en absoluto. En Datomic, todas las transacciones se realizan de manera at\u00f3mica, lo que significa que se ejecutan completamente o no se ejecutan en absoluto. Modularidad: es un enfoque de programaci\u00f3n que consiste en dividir una aplicaci\u00f3n en componentes independientes y conectados. Esta t\u00e9cnica facilita la reutilizaci\u00f3n y extensi\u00f3n de la funcionalidad de la aplicaci\u00f3n. Dependencias: se refiere a la relaci\u00f3n entre diferentes componentes en una aplicaci\u00f3n. En Component, los componentes est\u00e1n conectados entre s\u00ed a trav\u00e9s de un sistema de dependencias, lo que permite una f\u00e1cil gesti\u00f3n y extensi\u00f3n de la aplicaci\u00f3n. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es Datomic y qu\u00e9 ventajas ofrece en el desarrollo de aplicaciones en Clojure? \u00bfEn qu\u00e9 se basa el patr\u00f3n de dise\u00f1o Component y qu\u00e9 beneficios ofrece en el desarrollo de aplicaciones en Clojure? \u00bfQu\u00e9 significa que los datos sean inmutables en Clojure? \u00bfCu\u00e1l es la diferencia entre una operaci\u00f3n transaccional y una no transaccional? \u00bfPor qu\u00e9 es importante tener una arquitectura clara y bien definida en una aplicaci\u00f3n en Clojure? Ejemplos de c\u00f3digo en Clojure \u00b6 Datomic \u00b6 ( require ' [ datomic.api :as d ]) ( def db-uri \"datomic:mem://my-db\" ) ( def schema [{ :db/ident :person/name :db/valueType :db.type/string :db/cardinality :db.cardinality/one :db/unique :db.unique/identity } { :db/ident :person/age :db/valueType :db.type/long :db/cardinality :db.cardinality/one } { :db/ident :person/gender :db/valueType :db.type/string :db/cardinality :db.cardinality/one } { :db/ident :person/country :db/valueType :db.type/string :db/cardinality :db.cardinality/one }]) ( d/create-database db-uri ) ( def conn ( d/connect db-uri )) ( d/transact conn schema ) ( def person1 { :db/id # db/id [ :db.part/user ] :person/name \"John\" :person/age 30 :person/gender \"Male\" :person/country \"USA\" }) ( def person2 { :db/id # db/id [ :db.part/user ] :person/name \"Jane\" :person/age 25 :person/gender \"Female\" :person/country \"Canada\" }) ( def tx ( d/transact conn [ person1 person2 ])) ( def all-persons ( d/q ' [ :find ?name ?age ?gender ?country :where [ ?person :person/name ?name ] [ ?person :person/age ?age ] [ ?person :person/gender ?gender ] [ ?person :person/country ?country ]] ( d/db conn ))) ( println all-persons ) ; Output: [[\"John\" 30 \"Male\" \"USA\"] [\"Jane\" 25 \"Female\" \"Canada\"]] Component \u00b6 ( defrecord DatabaseComponent [ host port ] component/Lifecycle ( start [ component ] ( println ( str \"Starting database on \" host \":\" port )) ( assoc component :status :started )) ( stop [ component ] ( println \"Stopping database\" ) ( assoc component :status :stopped ))) ( defrecord WebServerComponent [ port ] component/Lifecycle ( start [ component ] ( println ( str \"Starting web server on port \" port )) ( assoc component :status :started )) ( stop [ component ] ( println \"Stopping web server\" ) ( assoc component :status :stopped ))) ( defrecord ApplicationComponent [ database web-server ] component/Lifecycle ( start [ component ] ( let [ db ( component/start database ) web-server ( component/start web-server )] ( println \"Starting application\" ) ( assoc component :status :started ))) ( stop [ component ] ( println \"Stopping application\" ) ( assoc component :status :stopped ))) ( def database ( map->DatabaseComponent { :host \"localhost\" :port 3306 })) ( def web-server ( map->WebServerComponent { :port 8080 })) ( def application ( map->ApplicationComponent { :database database :web-server web-server })) ( component/start application ) ; Output: Starting web server on port 8080 ; Starting database on localhost:3306 ; Starting application ( component/stop application ) ; Output: Stopping application ; Stopping web server ; Stopping database Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea un nuevo proyecto de Clojure y agrega las dependencias de Datomic y Component. Define un schema para una base de datos de Datomic que tenga los atributos :book/title, :book/author y :book/price. Crea una funci\u00f3n que permita agregar un nuevo libro a la base de datos. La funci\u00f3n debe recibir los par\u00e1metros title, author y price y transaccionarlos en la base de datos. Crea una funci\u00f3n que permita consultar todos los libros de la base de datos y devolverlos en una lista. Define los componentes para una aplicaci\u00f3n que utilice la base de datos de Datomic y el servidor web Jetty. Implementa la l\u00f3gica para iniciar y detener la aplicaci\u00f3n de acuerdo con el patr\u00f3n de dise\u00f1o Component. Agrega un nuevo endpoint en el servidor web que permita agregar un libro utilizando la funci\u00f3n creada en el paso 3. Ejecuta y prueba tu aplicaci\u00f3n para asegurarte de que todo funcione correctamente. Consejos o mejores pr\u00e1cticas \u00b6 Al utilizar Datomic, es importante tener una comprensi\u00f3n clara de la estructura de datos y c\u00f3mo se relacionan entre s\u00ed. Esto facilitar\u00e1 la escritura de consultas efectivas y eficientes. Al utilizar Component, es importante definir componentes lo m\u00e1s peque\u00f1os y espec\u00edficos posible. Esto facilitar\u00e1 la reutilizaci\u00f3n y extensi\u00f3n de la funcionalidad de la aplicaci\u00f3n. Es importante seguir pr\u00e1cticas de programaci\u00f3n funcional al trabajar con Clojure. Esto incluye evitar el uso de variables mutables y utilizar funciones puras siempre que sea posible. <- Lecci\u00f3n anterior : Programaci\u00f3n l\u00f3gica Siguiente lecci\u00f3n -> : Integraci\u00f3n con otros lenguajes y plataformas","title":"Arquitecturas y patrones de dise\u00f1o en Clojure"},{"location":"clojure/senior/arquitecturas_y_patrones_de_diseno/#arquitecturas-y-patrones-de-diseno-en-clojure","text":"","title":"Arquitecturas y patrones de dise\u00f1o en Clojure"},{"location":"clojure/senior/arquitecturas_y_patrones_de_diseno/#explicacion-teorica","text":"Clojure es un lenguaje de programaci\u00f3n funcional que se basa en la filosof\u00eda de \"programaci\u00f3n orientada a datos\". Esto significa que todas las operaciones se realizan sobre estructuras de datos inmutables, lo que lo hace ideal para construir aplicaciones altamente escalables y mantenibles. Sin embargo, para construir aplicaciones complejas, es importante tener una comprensi\u00f3n clara de la arquitectura y los patrones de dise\u00f1o en Clojure. Estos proporcionan una estructura y un enfoque para desarrollar aplicaciones que sean f\u00e1ciles de entender, extender y mantener. En Clojure, hay dos arquitecturas principales que se utilizan com\u00fanmente: Datomic y Component.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"clojure/senior/arquitecturas_y_patrones_de_diseno/#datomic","text":"Datomic es una base de datos distribuida y orientada a tiempo que se integra perfectamente con Clojure. Utiliza un modelo de datos inmutable y transaccional, lo que lo hace ideal para aplicaciones que requieren una alta consistencia y escalabilidad. Una de las principales ventajas de Datomic es que permite realizar consultas en el tiempo, lo que significa que se pueden realizar consultas sobre c\u00f3mo eran los datos en un momento espec\u00edfico en el pasado. Esto es especialmente \u00fatil en aplicaciones que manejan datos sensibles o cr\u00edticos en el tiempo.","title":"Datomic"},{"location":"clojure/senior/arquitecturas_y_patrones_de_diseno/#component","text":"Component es un patr\u00f3n de dise\u00f1o que se utiliza para construir aplicaciones modulares y altamente extensibles en Clojure. Se basa en el principio de separar la l\u00f3gica de la aplicaci\u00f3n en componentes independientes y conectados. Cada componente es una entidad inmutable que encapsula un estado y una l\u00f3gica de negocio espec\u00edficos. Estos componentes se conectan entre s\u00ed mediante un sistema de dependencias, lo que permite una f\u00e1cil reutilizaci\u00f3n y extensi\u00f3n de la funcionalidad de la aplicaci\u00f3n.","title":"Component"},{"location":"clojure/senior/arquitecturas_y_patrones_de_diseno/#palabras-clave-y-su-definicion","text":"Inmutabilidad: significa que los datos no pueden modificarse una vez que se han creado. En Clojure, todos los datos son inmutables por defecto, lo que garantiza una mayor consistencia y evita errores comunes en el manejo de datos. Transaccional: se refiere a una operaci\u00f3n que se realiza de forma completa o no se realiza en absoluto. En Datomic, todas las transacciones se realizan de manera at\u00f3mica, lo que significa que se ejecutan completamente o no se ejecutan en absoluto. Modularidad: es un enfoque de programaci\u00f3n que consiste en dividir una aplicaci\u00f3n en componentes independientes y conectados. Esta t\u00e9cnica facilita la reutilizaci\u00f3n y extensi\u00f3n de la funcionalidad de la aplicaci\u00f3n. Dependencias: se refiere a la relaci\u00f3n entre diferentes componentes en una aplicaci\u00f3n. En Component, los componentes est\u00e1n conectados entre s\u00ed a trav\u00e9s de un sistema de dependencias, lo que permite una f\u00e1cil gesti\u00f3n y extensi\u00f3n de la aplicaci\u00f3n.","title":"Palabras clave y su definici\u00f3n"},{"location":"clojure/senior/arquitecturas_y_patrones_de_diseno/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Datomic y qu\u00e9 ventajas ofrece en el desarrollo de aplicaciones en Clojure? \u00bfEn qu\u00e9 se basa el patr\u00f3n de dise\u00f1o Component y qu\u00e9 beneficios ofrece en el desarrollo de aplicaciones en Clojure? \u00bfQu\u00e9 significa que los datos sean inmutables en Clojure? \u00bfCu\u00e1l es la diferencia entre una operaci\u00f3n transaccional y una no transaccional? \u00bfPor qu\u00e9 es importante tener una arquitectura clara y bien definida en una aplicaci\u00f3n en Clojure?","title":"Preguntas de repaso"},{"location":"clojure/senior/arquitecturas_y_patrones_de_diseno/#ejemplos-de-codigo-en-clojure","text":"","title":"Ejemplos de c\u00f3digo en Clojure"},{"location":"clojure/senior/arquitecturas_y_patrones_de_diseno/#datomic_1","text":"( require ' [ datomic.api :as d ]) ( def db-uri \"datomic:mem://my-db\" ) ( def schema [{ :db/ident :person/name :db/valueType :db.type/string :db/cardinality :db.cardinality/one :db/unique :db.unique/identity } { :db/ident :person/age :db/valueType :db.type/long :db/cardinality :db.cardinality/one } { :db/ident :person/gender :db/valueType :db.type/string :db/cardinality :db.cardinality/one } { :db/ident :person/country :db/valueType :db.type/string :db/cardinality :db.cardinality/one }]) ( d/create-database db-uri ) ( def conn ( d/connect db-uri )) ( d/transact conn schema ) ( def person1 { :db/id # db/id [ :db.part/user ] :person/name \"John\" :person/age 30 :person/gender \"Male\" :person/country \"USA\" }) ( def person2 { :db/id # db/id [ :db.part/user ] :person/name \"Jane\" :person/age 25 :person/gender \"Female\" :person/country \"Canada\" }) ( def tx ( d/transact conn [ person1 person2 ])) ( def all-persons ( d/q ' [ :find ?name ?age ?gender ?country :where [ ?person :person/name ?name ] [ ?person :person/age ?age ] [ ?person :person/gender ?gender ] [ ?person :person/country ?country ]] ( d/db conn ))) ( println all-persons ) ; Output: [[\"John\" 30 \"Male\" \"USA\"] [\"Jane\" 25 \"Female\" \"Canada\"]]","title":"Datomic"},{"location":"clojure/senior/arquitecturas_y_patrones_de_diseno/#component_1","text":"( defrecord DatabaseComponent [ host port ] component/Lifecycle ( start [ component ] ( println ( str \"Starting database on \" host \":\" port )) ( assoc component :status :started )) ( stop [ component ] ( println \"Stopping database\" ) ( assoc component :status :stopped ))) ( defrecord WebServerComponent [ port ] component/Lifecycle ( start [ component ] ( println ( str \"Starting web server on port \" port )) ( assoc component :status :started )) ( stop [ component ] ( println \"Stopping web server\" ) ( assoc component :status :stopped ))) ( defrecord ApplicationComponent [ database web-server ] component/Lifecycle ( start [ component ] ( let [ db ( component/start database ) web-server ( component/start web-server )] ( println \"Starting application\" ) ( assoc component :status :started ))) ( stop [ component ] ( println \"Stopping application\" ) ( assoc component :status :stopped ))) ( def database ( map->DatabaseComponent { :host \"localhost\" :port 3306 })) ( def web-server ( map->WebServerComponent { :port 8080 })) ( def application ( map->ApplicationComponent { :database database :web-server web-server })) ( component/start application ) ; Output: Starting web server on port 8080 ; Starting database on localhost:3306 ; Starting application ( component/stop application ) ; Output: Stopping application ; Stopping web server ; Stopping database","title":"Component"},{"location":"clojure/senior/arquitecturas_y_patrones_de_diseno/#ejercicios-practicos-con-instrucciones-claras","text":"Crea un nuevo proyecto de Clojure y agrega las dependencias de Datomic y Component. Define un schema para una base de datos de Datomic que tenga los atributos :book/title, :book/author y :book/price. Crea una funci\u00f3n que permita agregar un nuevo libro a la base de datos. La funci\u00f3n debe recibir los par\u00e1metros title, author y price y transaccionarlos en la base de datos. Crea una funci\u00f3n que permita consultar todos los libros de la base de datos y devolverlos en una lista. Define los componentes para una aplicaci\u00f3n que utilice la base de datos de Datomic y el servidor web Jetty. Implementa la l\u00f3gica para iniciar y detener la aplicaci\u00f3n de acuerdo con el patr\u00f3n de dise\u00f1o Component. Agrega un nuevo endpoint en el servidor web que permita agregar un libro utilizando la funci\u00f3n creada en el paso 3. Ejecuta y prueba tu aplicaci\u00f3n para asegurarte de que todo funcione correctamente.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"clojure/senior/arquitecturas_y_patrones_de_diseno/#consejos-o-mejores-practicas","text":"Al utilizar Datomic, es importante tener una comprensi\u00f3n clara de la estructura de datos y c\u00f3mo se relacionan entre s\u00ed. Esto facilitar\u00e1 la escritura de consultas efectivas y eficientes. Al utilizar Component, es importante definir componentes lo m\u00e1s peque\u00f1os y espec\u00edficos posible. Esto facilitar\u00e1 la reutilizaci\u00f3n y extensi\u00f3n de la funcionalidad de la aplicaci\u00f3n. Es importante seguir pr\u00e1cticas de programaci\u00f3n funcional al trabajar con Clojure. Esto incluye evitar el uso de variables mutables y utilizar funciones puras siempre que sea posible. <- Lecci\u00f3n anterior : Programaci\u00f3n l\u00f3gica Siguiente lecci\u00f3n -> : Integraci\u00f3n con otros lenguajes y plataformas","title":"Consejos o mejores pr\u00e1cticas"},{"location":"clojure/senior/desarrollo_en_equipo_y_buenas_practicas/","text":"Desarrollo en equipo y buenas pr\u00e1cticas \u00b6 En el mundo del desarrollo de software, trabajar en equipo es esencial para lograr proyectos exitosos y de alta calidad. Adem\u00e1s, es importante aplicar buenas pr\u00e1cticas para asegurar un proceso de desarrollo eficiente y un c\u00f3digo limpio y mantenible. En este m\u00f3dulo, aprenderemos c\u00f3mo trabajar en equipo y aplicar buenas pr\u00e1cticas en el desarrollo de aplicaciones en Clojure. Palabras clave \u00b6 Trabajo en equipo: colaboraci\u00f3n y comunicaci\u00f3n entre miembros del equipo en un proyecto de desarrollo. Buenas pr\u00e1cticas: m\u00e9todos y t\u00e9cnicas recomendados para lograr resultados \u00f3ptimos en un proceso de desarrollo. Control de versiones: sistema que permite gestionar cambios en el c\u00f3digo fuente de un proyecto. Revisi\u00f3n de c\u00f3digo: proceso de revisi\u00f3n por parte de otros miembros del equipo para identificar y corregir posibles errores en el c\u00f3digo. Preguntas de repaso \u00b6 \u00bfPor qu\u00e9 es importante trabajar en equipo en el desarrollo de aplicaciones en Clojure? \u00bfQu\u00e9 es el control de versiones y por qu\u00e9 es \u00fatil en el trabajo en equipo? \u00bfCu\u00e1l es el objetivo de la revisi\u00f3n de c\u00f3digo? Menciona una buena pr\u00e1ctica para mantener un c\u00f3digo limpio y mantenible en Clojure. Ejemplo de c\u00f3digo en Clojure \u00b6 ( defn suma [ a b ] ( + a b )) Ejercicios pr\u00e1cticos \u00b6 Trabaja en equipo para crear una funci\u00f3n en Clojure que calcule el promedio de una lista de n\u00fameros. Utiliza un sistema de control de versiones para gestionar los cambios en el c\u00f3digo de tu proyecto en Clojure. Haz una revisi\u00f3n de c\u00f3digo de una funci\u00f3n en Clojure y sugiere mejoras para hacerla m\u00e1s eficiente. Consejos y mejores pr\u00e1cticas \u00b6 Comunica de manera efectiva con tu equipo y establece roles y responsabilidades claras. Utiliza herramientas de control de versiones como Git para mantener un registro de los cambios en el c\u00f3digo. Realiza revisiones de c\u00f3digo de manera regular para detectar y corregir posibles errores. Sigue las convenciones de estilo de c\u00f3digo de Clojure para mantener un c\u00f3digo legible y consistente. Documenta tu c\u00f3digo y aseg\u00farate de que sea entendible para otros miembros del equipo. <- Lecci\u00f3n anterior : Proyectos pr\u00e1cticos Siguiente lecci\u00f3n -> : Investigaci\u00f3n y experimentaci\u00f3n","title":"Desarrollo en equipo y buenas pr\u00e1cticas"},{"location":"clojure/senior/desarrollo_en_equipo_y_buenas_practicas/#desarrollo-en-equipo-y-buenas-practicas","text":"En el mundo del desarrollo de software, trabajar en equipo es esencial para lograr proyectos exitosos y de alta calidad. Adem\u00e1s, es importante aplicar buenas pr\u00e1cticas para asegurar un proceso de desarrollo eficiente y un c\u00f3digo limpio y mantenible. En este m\u00f3dulo, aprenderemos c\u00f3mo trabajar en equipo y aplicar buenas pr\u00e1cticas en el desarrollo de aplicaciones en Clojure.","title":"Desarrollo en equipo y buenas pr\u00e1cticas"},{"location":"clojure/senior/desarrollo_en_equipo_y_buenas_practicas/#palabras-clave","text":"Trabajo en equipo: colaboraci\u00f3n y comunicaci\u00f3n entre miembros del equipo en un proyecto de desarrollo. Buenas pr\u00e1cticas: m\u00e9todos y t\u00e9cnicas recomendados para lograr resultados \u00f3ptimos en un proceso de desarrollo. Control de versiones: sistema que permite gestionar cambios en el c\u00f3digo fuente de un proyecto. Revisi\u00f3n de c\u00f3digo: proceso de revisi\u00f3n por parte de otros miembros del equipo para identificar y corregir posibles errores en el c\u00f3digo.","title":"Palabras clave"},{"location":"clojure/senior/desarrollo_en_equipo_y_buenas_practicas/#preguntas-de-repaso","text":"\u00bfPor qu\u00e9 es importante trabajar en equipo en el desarrollo de aplicaciones en Clojure? \u00bfQu\u00e9 es el control de versiones y por qu\u00e9 es \u00fatil en el trabajo en equipo? \u00bfCu\u00e1l es el objetivo de la revisi\u00f3n de c\u00f3digo? Menciona una buena pr\u00e1ctica para mantener un c\u00f3digo limpio y mantenible en Clojure.","title":"Preguntas de repaso"},{"location":"clojure/senior/desarrollo_en_equipo_y_buenas_practicas/#ejemplo-de-codigo-en-clojure","text":"( defn suma [ a b ] ( + a b ))","title":"Ejemplo de c\u00f3digo en Clojure"},{"location":"clojure/senior/desarrollo_en_equipo_y_buenas_practicas/#ejercicios-practicos","text":"Trabaja en equipo para crear una funci\u00f3n en Clojure que calcule el promedio de una lista de n\u00fameros. Utiliza un sistema de control de versiones para gestionar los cambios en el c\u00f3digo de tu proyecto en Clojure. Haz una revisi\u00f3n de c\u00f3digo de una funci\u00f3n en Clojure y sugiere mejoras para hacerla m\u00e1s eficiente.","title":"Ejercicios pr\u00e1cticos"},{"location":"clojure/senior/desarrollo_en_equipo_y_buenas_practicas/#consejos-y-mejores-practicas","text":"Comunica de manera efectiva con tu equipo y establece roles y responsabilidades claras. Utiliza herramientas de control de versiones como Git para mantener un registro de los cambios en el c\u00f3digo. Realiza revisiones de c\u00f3digo de manera regular para detectar y corregir posibles errores. Sigue las convenciones de estilo de c\u00f3digo de Clojure para mantener un c\u00f3digo legible y consistente. Documenta tu c\u00f3digo y aseg\u00farate de que sea entendible para otros miembros del equipo. <- Lecci\u00f3n anterior : Proyectos pr\u00e1cticos Siguiente lecci\u00f3n -> : Investigaci\u00f3n y experimentaci\u00f3n","title":"Consejos y mejores pr\u00e1cticas"},{"location":"clojure/senior/integracion_con_otros_lenguajes_y_plataformas/","text":"Integraci\u00f3n con otros lenguajes y plataformas \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 Clojure es un lenguaje de programaci\u00f3n funcional y din\u00e1mico que se ejecuta sobre la plataforma de Java Virtual Machine (JVM). Esto significa que Clojure se integra f\u00e1cilmente con el ecosistema de Java y puede interactuar con c\u00f3digo escrito en Java. Adem\u00e1s, Clojure tambi\u00e9n tiene la capacidad de integrarse con otros lenguajes y plataformas, como JavaScript y la nube, lo que lo convierte en una excelente opci\u00f3n para proyectos que requieren una integraci\u00f3n fluida entre diferentes tecnolog\u00edas. Palabras clave y su definici\u00f3n \u00b6 Integraci\u00f3n: proceso de conectar dos o m\u00e1s sistemas para que puedan comunicarse y trabajar juntos. Java Virtual Machine (JVM): entorno de ejecuci\u00f3n que permite a los programas escritos en Java y otros lenguajes basados en JVM, como Clojure, ejecutarse en diferentes plataformas sin la necesidad de ser recompilados. JavaScript: lenguaje de programaci\u00f3n interpretado utilizado principalmente en el desarrollo web. Nube: t\u00e9rmino que se refiere a la entrega de servicios de computaci\u00f3n, como almacenamiento, servidores y aplicaciones, a trav\u00e9s de Internet. Preguntas de repaso \u00b6 \u00bfEn qu\u00e9 plataforma se ejecuta Clojure? \u00bfQu\u00e9 es la JVM y por qu\u00e9 es importante para la integraci\u00f3n de Clojure con otros lenguajes? \u00bfQu\u00e9 es JavaScript y c\u00f3mo se relaciona con Clojure? \u00bfQu\u00e9 es la nube y c\u00f3mo se puede integrar con Clojure? Ejemplos de c\u00f3digo en Clojure \u00b6 Integraci\u00f3n con Java \u00b6 ;; Importar una clase de Java ( import java.util.Date ) ;; Crear una instancia de la clase Date ( def fecha ( Date. )) ;; Llamar al m\u00e9todo getTime() de la clase Date ( .getTime fecha ) Integraci\u00f3n con JavaScript \u00b6 ;; Importar la librer\u00eda js de ClojureScript ( ns example.core ( :require [ cljs.js :as js ])) ;; Crear un objeto de JavaScript ( def obj ( js/obj )) ;; Agregar una propiedad al objeto ( . obj -prop \"valor\" ) ;; Llamar a una funci\u00f3n de JavaScript ( . console log \"Mensaje de ejemplo\" ) Integraci\u00f3n con la nube \u00b6 ;; Importar la librer\u00eda aws-api de Clojure ( ns example.core ( :require [ aws-api.lambda :as lambda ])) ;; Definir una funci\u00f3n lambda ( defn saludo [ nombre ] ( println ( str \"Hola \" nombre ))) ;; Crear una funci\u00f3n lambda en AWS ( defn lambda-function [] ( lambda/create-function { :function-name \"saludo\" :handler \"example.core/saludo\" })) Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una funci\u00f3n que reciba como argumento un n\u00famero y devuelva su cuadrado utilizando la librer\u00eda Math de Java. Crea un objeto en Clojure que tenga una propiedad llamada \"nombre\" con tu nombre y otra propiedad llamada \"edad\" con tu edad actual. Crea una funci\u00f3n que reciba un mensaje y lo imprima utilizando la funci\u00f3n log de JavaScript. Crea una funci\u00f3n lambda en AWS que reciba un nombre y lo pase como argumento a la funci\u00f3n \"saludo\" definida en el ejemplo anterior. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza la documentaci\u00f3n oficial de Clojure para aprender m\u00e1s sobre la integraci\u00f3n con otros lenguajes y plataformas. Utiliza librer\u00edas y herramientas de terceros para facilitar la integraci\u00f3n con otras tecnolog\u00edas. Prueba y depura tu c\u00f3digo cuidadosamente para asegurarte de que la integraci\u00f3n funcione correctamente. <- Lecci\u00f3n anterior : Arquitecturas y patrones de dise\u00f1o Siguiente lecci\u00f3n -> : Proyectos pr\u00e1cticos","title":"Integraci\u00f3n con otros lenguajes y plataformas"},{"location":"clojure/senior/integracion_con_otros_lenguajes_y_plataformas/#integracion-con-otros-lenguajes-y-plataformas","text":"","title":"Integraci\u00f3n con otros lenguajes y plataformas"},{"location":"clojure/senior/integracion_con_otros_lenguajes_y_plataformas/#explicacion-teorica","text":"Clojure es un lenguaje de programaci\u00f3n funcional y din\u00e1mico que se ejecuta sobre la plataforma de Java Virtual Machine (JVM). Esto significa que Clojure se integra f\u00e1cilmente con el ecosistema de Java y puede interactuar con c\u00f3digo escrito en Java. Adem\u00e1s, Clojure tambi\u00e9n tiene la capacidad de integrarse con otros lenguajes y plataformas, como JavaScript y la nube, lo que lo convierte en una excelente opci\u00f3n para proyectos que requieren una integraci\u00f3n fluida entre diferentes tecnolog\u00edas.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"clojure/senior/integracion_con_otros_lenguajes_y_plataformas/#palabras-clave-y-su-definicion","text":"Integraci\u00f3n: proceso de conectar dos o m\u00e1s sistemas para que puedan comunicarse y trabajar juntos. Java Virtual Machine (JVM): entorno de ejecuci\u00f3n que permite a los programas escritos en Java y otros lenguajes basados en JVM, como Clojure, ejecutarse en diferentes plataformas sin la necesidad de ser recompilados. JavaScript: lenguaje de programaci\u00f3n interpretado utilizado principalmente en el desarrollo web. Nube: t\u00e9rmino que se refiere a la entrega de servicios de computaci\u00f3n, como almacenamiento, servidores y aplicaciones, a trav\u00e9s de Internet.","title":"Palabras clave y su definici\u00f3n"},{"location":"clojure/senior/integracion_con_otros_lenguajes_y_plataformas/#preguntas-de-repaso","text":"\u00bfEn qu\u00e9 plataforma se ejecuta Clojure? \u00bfQu\u00e9 es la JVM y por qu\u00e9 es importante para la integraci\u00f3n de Clojure con otros lenguajes? \u00bfQu\u00e9 es JavaScript y c\u00f3mo se relaciona con Clojure? \u00bfQu\u00e9 es la nube y c\u00f3mo se puede integrar con Clojure?","title":"Preguntas de repaso"},{"location":"clojure/senior/integracion_con_otros_lenguajes_y_plataformas/#ejemplos-de-codigo-en-clojure","text":"","title":"Ejemplos de c\u00f3digo en Clojure"},{"location":"clojure/senior/integracion_con_otros_lenguajes_y_plataformas/#integracion-con-java","text":";; Importar una clase de Java ( import java.util.Date ) ;; Crear una instancia de la clase Date ( def fecha ( Date. )) ;; Llamar al m\u00e9todo getTime() de la clase Date ( .getTime fecha )","title":"Integraci\u00f3n con Java"},{"location":"clojure/senior/integracion_con_otros_lenguajes_y_plataformas/#integracion-con-javascript","text":";; Importar la librer\u00eda js de ClojureScript ( ns example.core ( :require [ cljs.js :as js ])) ;; Crear un objeto de JavaScript ( def obj ( js/obj )) ;; Agregar una propiedad al objeto ( . obj -prop \"valor\" ) ;; Llamar a una funci\u00f3n de JavaScript ( . console log \"Mensaje de ejemplo\" )","title":"Integraci\u00f3n con JavaScript"},{"location":"clojure/senior/integracion_con_otros_lenguajes_y_plataformas/#integracion-con-la-nube","text":";; Importar la librer\u00eda aws-api de Clojure ( ns example.core ( :require [ aws-api.lambda :as lambda ])) ;; Definir una funci\u00f3n lambda ( defn saludo [ nombre ] ( println ( str \"Hola \" nombre ))) ;; Crear una funci\u00f3n lambda en AWS ( defn lambda-function [] ( lambda/create-function { :function-name \"saludo\" :handler \"example.core/saludo\" }))","title":"Integraci\u00f3n con la nube"},{"location":"clojure/senior/integracion_con_otros_lenguajes_y_plataformas/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una funci\u00f3n que reciba como argumento un n\u00famero y devuelva su cuadrado utilizando la librer\u00eda Math de Java. Crea un objeto en Clojure que tenga una propiedad llamada \"nombre\" con tu nombre y otra propiedad llamada \"edad\" con tu edad actual. Crea una funci\u00f3n que reciba un mensaje y lo imprima utilizando la funci\u00f3n log de JavaScript. Crea una funci\u00f3n lambda en AWS que reciba un nombre y lo pase como argumento a la funci\u00f3n \"saludo\" definida en el ejemplo anterior.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"clojure/senior/integracion_con_otros_lenguajes_y_plataformas/#consejos-o-mejores-practicas","text":"Utiliza la documentaci\u00f3n oficial de Clojure para aprender m\u00e1s sobre la integraci\u00f3n con otros lenguajes y plataformas. Utiliza librer\u00edas y herramientas de terceros para facilitar la integraci\u00f3n con otras tecnolog\u00edas. Prueba y depura tu c\u00f3digo cuidadosamente para asegurarte de que la integraci\u00f3n funcione correctamente. <- Lecci\u00f3n anterior : Arquitecturas y patrones de dise\u00f1o Siguiente lecci\u00f3n -> : Proyectos pr\u00e1cticos","title":"Consejos o mejores pr\u00e1cticas"},{"location":"clojure/senior/investigacion_y_experimentacion/","text":"Investigaci\u00f3n y experimentaci\u00f3n en Clojure \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 Clojure es un lenguaje de programaci\u00f3n funcional que se basa en el paradigma de la programaci\u00f3n orientada a objetos. Una de las caracter\u00edsticas m\u00e1s importantes de Clojure es su enfoque en la inmutabilidad de los datos. Esto significa que los datos no pueden ser modificados una vez que han sido creados, lo que ayuda a evitar errores y hace m\u00e1s seguro el c\u00f3digo. Adem\u00e1s, Clojure es un lenguaje din\u00e1mico, lo que permite una mayor flexibilidad y agilidad en el desarrollo de software. Para mantenerse al d\u00eda en el mundo del desarrollo de software, es importante estar al tanto de las nuevas funcionalidades y herramientas que se van incorporando a Clojure. Para ello, es necesario dedicar tiempo a la investigaci\u00f3n y experimentaci\u00f3n con estas nuevas tecnolog\u00edas. Esto nos permitir\u00e1 ampliar nuestros conocimientos y habilidades, y aplicarlos en nuestros proyectos de manera efectiva. Palabras clave y su definici\u00f3n \u00b6 Investigaci\u00f3n: Proceso de b\u00fasqueda y recopilaci\u00f3n de informaci\u00f3n para adquirir conocimientos sobre un tema en particular. Experimentaci\u00f3n: Acci\u00f3n de probar o poner en pr\u00e1ctica una teor\u00eda o hip\u00f3tesis para obtener resultados y obtener nuevos conocimientos. Funcionalidades: Caracter\u00edsticas o capacidades que posee un lenguaje de programaci\u00f3n o una herramienta. Herramientas: Programas o aplicaciones que facilitan la realizaci\u00f3n de una tarea o actividad. Inmutabilidad: Propiedad de los datos que indica que no pueden ser modificados despu\u00e9s de su creaci\u00f3n. Dinamismo: Caracter\u00edstica de los lenguajes de programaci\u00f3n que permite cambios en tiempo de ejecuci\u00f3n. Flexibilidad: Capacidad de adaptarse y responder a cambios o situaciones nuevas. Agilidad: Metodolog\u00eda de trabajo que promueve la colaboraci\u00f3n, la adaptabilidad y la entrega continua de software de alta calidad. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la inmutabilidad en Clojure? \u00bfPor qu\u00e9 es importante dedicar tiempo a la investigaci\u00f3n y experimentaci\u00f3n en Clojure? Menciona dos caracter\u00edsticas principales de Clojure. \u00bfQu\u00e9 son las funcionalidades y herramientas en un lenguaje de programaci\u00f3n? \u00bfCu\u00e1l es la diferencia entre un lenguaje de programaci\u00f3n est\u00e1tico y din\u00e1mico? Ejemplos de c\u00f3digo en Clojure \u00b6 Definici\u00f3n de una funci\u00f3n que suma dos n\u00fameros: ( defn sum [ x y ] ( + x y )) Uso de la funci\u00f3n map para aplicar una funci\u00f3n a cada elemento de una lista: ( defn double [ x ] ( * 2 x )) ( map double [ 1 2 3 4 5 ]) ; retorna (2 4 6 8 10) Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una funci\u00f3n en Clojure que reciba una lista de n\u00fameros y retorne el promedio de esos n\u00fameros. Utiliza la funci\u00f3n filter para obtener una lista con los n\u00fameros pares de una lista dada. Escribe una funci\u00f3n que reciba una lista de palabras y retorne una nueva lista con las palabras en may\u00fasculas. Utiliza la funci\u00f3n reduce para obtener la suma de los elementos de una lista de n\u00fameros. Crea una funci\u00f3n que reciba una lista de n\u00fameros y retorne una lista con los n\u00fameros elevados al cuadrado. Consejos o mejores pr\u00e1cticas \u00b6 Dedica tiempo regularmente a la investigaci\u00f3n y experimentaci\u00f3n en Clojure para mantenerte al d\u00eda en sus nuevas funcionalidades y herramientas. Utiliza recursos en l\u00ednea como blogs, tutoriales y videos para aprender sobre las \u00faltimas tendencias en Clojure. Participa en comunidades de desarrolladores de Clojure para compartir conocimientos y obtener retroalimentaci\u00f3n sobre tus experimentos. Realiza peque\u00f1os proyectos o ejercicios pr\u00e1cticos para aplicar lo que has aprendido y consolidar tus conocimientos. No tengas miedo de probar nuevas herramientas o t\u00e9cnicas en tus proyectos, esto te ayudar\u00e1 a expandir tus habilidades y mejorar tu flujo de trabajo. <- Lecci\u00f3n anterior : Desarrollo en equipo y buenas pr\u00e1cticas","title":"Investigaci\u00f3n y experimentaci\u00f3n en Clojure"},{"location":"clojure/senior/investigacion_y_experimentacion/#investigacion-y-experimentacion-en-clojure","text":"","title":"Investigaci\u00f3n y experimentaci\u00f3n en Clojure"},{"location":"clojure/senior/investigacion_y_experimentacion/#explicacion-teorica","text":"Clojure es un lenguaje de programaci\u00f3n funcional que se basa en el paradigma de la programaci\u00f3n orientada a objetos. Una de las caracter\u00edsticas m\u00e1s importantes de Clojure es su enfoque en la inmutabilidad de los datos. Esto significa que los datos no pueden ser modificados una vez que han sido creados, lo que ayuda a evitar errores y hace m\u00e1s seguro el c\u00f3digo. Adem\u00e1s, Clojure es un lenguaje din\u00e1mico, lo que permite una mayor flexibilidad y agilidad en el desarrollo de software. Para mantenerse al d\u00eda en el mundo del desarrollo de software, es importante estar al tanto de las nuevas funcionalidades y herramientas que se van incorporando a Clojure. Para ello, es necesario dedicar tiempo a la investigaci\u00f3n y experimentaci\u00f3n con estas nuevas tecnolog\u00edas. Esto nos permitir\u00e1 ampliar nuestros conocimientos y habilidades, y aplicarlos en nuestros proyectos de manera efectiva.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"clojure/senior/investigacion_y_experimentacion/#palabras-clave-y-su-definicion","text":"Investigaci\u00f3n: Proceso de b\u00fasqueda y recopilaci\u00f3n de informaci\u00f3n para adquirir conocimientos sobre un tema en particular. Experimentaci\u00f3n: Acci\u00f3n de probar o poner en pr\u00e1ctica una teor\u00eda o hip\u00f3tesis para obtener resultados y obtener nuevos conocimientos. Funcionalidades: Caracter\u00edsticas o capacidades que posee un lenguaje de programaci\u00f3n o una herramienta. Herramientas: Programas o aplicaciones que facilitan la realizaci\u00f3n de una tarea o actividad. Inmutabilidad: Propiedad de los datos que indica que no pueden ser modificados despu\u00e9s de su creaci\u00f3n. Dinamismo: Caracter\u00edstica de los lenguajes de programaci\u00f3n que permite cambios en tiempo de ejecuci\u00f3n. Flexibilidad: Capacidad de adaptarse y responder a cambios o situaciones nuevas. Agilidad: Metodolog\u00eda de trabajo que promueve la colaboraci\u00f3n, la adaptabilidad y la entrega continua de software de alta calidad.","title":"Palabras clave y su definici\u00f3n"},{"location":"clojure/senior/investigacion_y_experimentacion/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la inmutabilidad en Clojure? \u00bfPor qu\u00e9 es importante dedicar tiempo a la investigaci\u00f3n y experimentaci\u00f3n en Clojure? Menciona dos caracter\u00edsticas principales de Clojure. \u00bfQu\u00e9 son las funcionalidades y herramientas en un lenguaje de programaci\u00f3n? \u00bfCu\u00e1l es la diferencia entre un lenguaje de programaci\u00f3n est\u00e1tico y din\u00e1mico?","title":"Preguntas de repaso"},{"location":"clojure/senior/investigacion_y_experimentacion/#ejemplos-de-codigo-en-clojure","text":"Definici\u00f3n de una funci\u00f3n que suma dos n\u00fameros: ( defn sum [ x y ] ( + x y )) Uso de la funci\u00f3n map para aplicar una funci\u00f3n a cada elemento de una lista: ( defn double [ x ] ( * 2 x )) ( map double [ 1 2 3 4 5 ]) ; retorna (2 4 6 8 10)","title":"Ejemplos de c\u00f3digo en Clojure"},{"location":"clojure/senior/investigacion_y_experimentacion/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una funci\u00f3n en Clojure que reciba una lista de n\u00fameros y retorne el promedio de esos n\u00fameros. Utiliza la funci\u00f3n filter para obtener una lista con los n\u00fameros pares de una lista dada. Escribe una funci\u00f3n que reciba una lista de palabras y retorne una nueva lista con las palabras en may\u00fasculas. Utiliza la funci\u00f3n reduce para obtener la suma de los elementos de una lista de n\u00fameros. Crea una funci\u00f3n que reciba una lista de n\u00fameros y retorne una lista con los n\u00fameros elevados al cuadrado.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"clojure/senior/investigacion_y_experimentacion/#consejos-o-mejores-practicas","text":"Dedica tiempo regularmente a la investigaci\u00f3n y experimentaci\u00f3n en Clojure para mantenerte al d\u00eda en sus nuevas funcionalidades y herramientas. Utiliza recursos en l\u00ednea como blogs, tutoriales y videos para aprender sobre las \u00faltimas tendencias en Clojure. Participa en comunidades de desarrolladores de Clojure para compartir conocimientos y obtener retroalimentaci\u00f3n sobre tus experimentos. Realiza peque\u00f1os proyectos o ejercicios pr\u00e1cticos para aplicar lo que has aprendido y consolidar tus conocimientos. No tengas miedo de probar nuevas herramientas o t\u00e9cnicas en tus proyectos, esto te ayudar\u00e1 a expandir tus habilidades y mejorar tu flujo de trabajo. <- Lecci\u00f3n anterior : Desarrollo en equipo y buenas pr\u00e1cticas","title":"Consejos o mejores pr\u00e1cticas"},{"location":"clojure/senior/macros_y_metaprogramacion/","text":"Macros y metaprogramaci\u00f3n \u00b6 En Clojure, una macro es una funci\u00f3n especial que toma c\u00f3digo como entrada y devuelve c\u00f3digo como salida. A diferencia de una funci\u00f3n regular, una macro se ejecuta en tiempo de compilaci\u00f3n en lugar de tiempo de ejecuci\u00f3n, lo que permite generar c\u00f3digo personalizado y optimizado para una determinada situaci\u00f3n. Las macros son una herramienta poderosa en Clojure que permite a los desarrolladores crear abstracciones y automatizar tareas repetitivas. Adem\u00e1s, la metaprogramaci\u00f3n, que es el proceso de escribir c\u00f3digo que genera c\u00f3digo, se vuelve posible gracias a las macros. Palabras clave \u00b6 Macros: Funciones especiales que se ejecutan en tiempo de compilaci\u00f3n y devuelven c\u00f3digo como salida. Metaprogramaci\u00f3n: Proceso de escribir c\u00f3digo que genera c\u00f3digo. Abstracci\u00f3n: T\u00e9cnica de programaci\u00f3n que permite ocultar detalles complejos detr\u00e1s de una interfaz simple y f\u00e1cil de usar. Expansi\u00f3n: Proceso en el que una macro se ejecuta y devuelve c\u00f3digo que reemplaza la llamada a la macro en tiempo de compilaci\u00f3n. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es una macro y c\u00f3mo se diferencia de una funci\u00f3n regular? \u00bfQu\u00e9 es la metaprogramaci\u00f3n y c\u00f3mo se relaciona con las macros? \u00bfCu\u00e1l es la diferencia entre una macro y una abstracci\u00f3n? \u00bfEn qu\u00e9 momento se ejecuta una macro? \u00bfQu\u00e9 es la expansi\u00f3n de una macro y cu\u00e1ndo ocurre? Ejemplos de c\u00f3digo en Clojure \u00b6 Una macro en Clojure se define utilizando la palabra clave defmacro seguida del nombre de la macro y los par\u00e1metros que toma como entrada. Por ejemplo: ( defmacro suma [ a b ] ` ( + ~ a ~ b )) En este ejemplo, la macro suma toma dos par\u00e1metros a y b y devuelve una expresi\u00f3n que suma los dos valores. La expresi\u00f3n (+ ~a ~b) se llama una lista literal y se utiliza para construir una expresi\u00f3n que se evaluar\u00e1 en tiempo de compilaci\u00f3n. Para utilizar la macro, se llama a suma de la misma manera que una funci\u00f3n regular, pero en este caso, el c\u00f3digo devuelto por la macro se expandir\u00e1 en tiempo de compilaci\u00f3n. Por ejemplo: ( suma 2 3 ) ; devuelve 5 Ejercicios pr\u00e1cticos \u00b6 Ejercicio 1: Crear una macro para definir constantes \u00b6 En este ejercicio, se te pedir\u00e1 que crees una macro llamada defconst que tome dos par\u00e1metros: el nombre de la constante y su valor. La macro deber\u00e1 definir una constante con el nombre y valor proporcionados. Por ejemplo: ( defconst PI 3.14159 ) Pasos a seguir: Crea una macro llamada defconst que tome dos par\u00e1metros: nombre y valor . Utiliza la lista literal para construir una expresi\u00f3n que defina la constante utilizando el nombre y valor proporcionados. Expande la macro utilizando la funci\u00f3n def para definir la constante. Prueba tu macro utilizando diferentes valores y aseg\u00farate de que se defina correctamente la constante. Ejercicio 2: Crear una macro para generar funciones \u00b6 En este ejercicio, se te pedir\u00e1 que crees una macro llamada defn-super que genere una funci\u00f3n que siempre devuelve el n\u00famero 10. Esta funci\u00f3n se utilizar\u00e1 en situaciones en las que se requiere una funci\u00f3n de prueba r\u00e1pida o un valor de relleno. Por ejemplo: ( defn-super sumar [ a b ] ( + a b )) ; devuelve siempre 10 Pasos a seguir: Crea una macro llamada defn-super que tome como par\u00e1metros el nombre de la funci\u00f3n y los par\u00e1metros de entrada. Utiliza la lista literal para construir una expresi\u00f3n que defina la funci\u00f3n y siempre devuelva el n\u00famero 10. Expande la macro utilizando la funci\u00f3n defn para definir la funci\u00f3n. Prueba tu macro utilizando diferentes nombres de funci\u00f3n y aseg\u00farate de que siempre devuelva 10. Consejos y mejores pr\u00e1cticas \u00b6 Utiliza macros con moderaci\u00f3n. Aunque son una herramienta poderosa, su uso excesivo puede dificultar la comprensi\u00f3n y el mantenimiento del c\u00f3digo. Es importante documentar adecuadamente las macros para que otros desarrolladores puedan entender su funcionamiento y prop\u00f3sito. Al utilizar la metaprogramaci\u00f3n, aseg\u00farate de que el c\u00f3digo generado sea v\u00e1lido y seguro para su ejecuci\u00f3n. Siguiente lecci\u00f3n -> : Transducers y reducers","title":"Macros y metaprogramaci\u00f3n"},{"location":"clojure/senior/macros_y_metaprogramacion/#macros-y-metaprogramacion","text":"En Clojure, una macro es una funci\u00f3n especial que toma c\u00f3digo como entrada y devuelve c\u00f3digo como salida. A diferencia de una funci\u00f3n regular, una macro se ejecuta en tiempo de compilaci\u00f3n en lugar de tiempo de ejecuci\u00f3n, lo que permite generar c\u00f3digo personalizado y optimizado para una determinada situaci\u00f3n. Las macros son una herramienta poderosa en Clojure que permite a los desarrolladores crear abstracciones y automatizar tareas repetitivas. Adem\u00e1s, la metaprogramaci\u00f3n, que es el proceso de escribir c\u00f3digo que genera c\u00f3digo, se vuelve posible gracias a las macros.","title":"Macros y metaprogramaci\u00f3n"},{"location":"clojure/senior/macros_y_metaprogramacion/#palabras-clave","text":"Macros: Funciones especiales que se ejecutan en tiempo de compilaci\u00f3n y devuelven c\u00f3digo como salida. Metaprogramaci\u00f3n: Proceso de escribir c\u00f3digo que genera c\u00f3digo. Abstracci\u00f3n: T\u00e9cnica de programaci\u00f3n que permite ocultar detalles complejos detr\u00e1s de una interfaz simple y f\u00e1cil de usar. Expansi\u00f3n: Proceso en el que una macro se ejecuta y devuelve c\u00f3digo que reemplaza la llamada a la macro en tiempo de compilaci\u00f3n.","title":"Palabras clave"},{"location":"clojure/senior/macros_y_metaprogramacion/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es una macro y c\u00f3mo se diferencia de una funci\u00f3n regular? \u00bfQu\u00e9 es la metaprogramaci\u00f3n y c\u00f3mo se relaciona con las macros? \u00bfCu\u00e1l es la diferencia entre una macro y una abstracci\u00f3n? \u00bfEn qu\u00e9 momento se ejecuta una macro? \u00bfQu\u00e9 es la expansi\u00f3n de una macro y cu\u00e1ndo ocurre?","title":"Preguntas de repaso"},{"location":"clojure/senior/macros_y_metaprogramacion/#ejemplos-de-codigo-en-clojure","text":"Una macro en Clojure se define utilizando la palabra clave defmacro seguida del nombre de la macro y los par\u00e1metros que toma como entrada. Por ejemplo: ( defmacro suma [ a b ] ` ( + ~ a ~ b )) En este ejemplo, la macro suma toma dos par\u00e1metros a y b y devuelve una expresi\u00f3n que suma los dos valores. La expresi\u00f3n (+ ~a ~b) se llama una lista literal y se utiliza para construir una expresi\u00f3n que se evaluar\u00e1 en tiempo de compilaci\u00f3n. Para utilizar la macro, se llama a suma de la misma manera que una funci\u00f3n regular, pero en este caso, el c\u00f3digo devuelto por la macro se expandir\u00e1 en tiempo de compilaci\u00f3n. Por ejemplo: ( suma 2 3 ) ; devuelve 5","title":"Ejemplos de c\u00f3digo en Clojure"},{"location":"clojure/senior/macros_y_metaprogramacion/#ejercicios-practicos","text":"","title":"Ejercicios pr\u00e1cticos"},{"location":"clojure/senior/macros_y_metaprogramacion/#ejercicio-1-crear-una-macro-para-definir-constantes","text":"En este ejercicio, se te pedir\u00e1 que crees una macro llamada defconst que tome dos par\u00e1metros: el nombre de la constante y su valor. La macro deber\u00e1 definir una constante con el nombre y valor proporcionados. Por ejemplo: ( defconst PI 3.14159 ) Pasos a seguir: Crea una macro llamada defconst que tome dos par\u00e1metros: nombre y valor . Utiliza la lista literal para construir una expresi\u00f3n que defina la constante utilizando el nombre y valor proporcionados. Expande la macro utilizando la funci\u00f3n def para definir la constante. Prueba tu macro utilizando diferentes valores y aseg\u00farate de que se defina correctamente la constante.","title":"Ejercicio 1: Crear una macro para definir constantes"},{"location":"clojure/senior/macros_y_metaprogramacion/#ejercicio-2-crear-una-macro-para-generar-funciones","text":"En este ejercicio, se te pedir\u00e1 que crees una macro llamada defn-super que genere una funci\u00f3n que siempre devuelve el n\u00famero 10. Esta funci\u00f3n se utilizar\u00e1 en situaciones en las que se requiere una funci\u00f3n de prueba r\u00e1pida o un valor de relleno. Por ejemplo: ( defn-super sumar [ a b ] ( + a b )) ; devuelve siempre 10 Pasos a seguir: Crea una macro llamada defn-super que tome como par\u00e1metros el nombre de la funci\u00f3n y los par\u00e1metros de entrada. Utiliza la lista literal para construir una expresi\u00f3n que defina la funci\u00f3n y siempre devuelva el n\u00famero 10. Expande la macro utilizando la funci\u00f3n defn para definir la funci\u00f3n. Prueba tu macro utilizando diferentes nombres de funci\u00f3n y aseg\u00farate de que siempre devuelva 10.","title":"Ejercicio 2: Crear una macro para generar funciones"},{"location":"clojure/senior/macros_y_metaprogramacion/#consejos-y-mejores-practicas","text":"Utiliza macros con moderaci\u00f3n. Aunque son una herramienta poderosa, su uso excesivo puede dificultar la comprensi\u00f3n y el mantenimiento del c\u00f3digo. Es importante documentar adecuadamente las macros para que otros desarrolladores puedan entender su funcionamiento y prop\u00f3sito. Al utilizar la metaprogramaci\u00f3n, aseg\u00farate de que el c\u00f3digo generado sea v\u00e1lido y seguro para su ejecuci\u00f3n. Siguiente lecci\u00f3n -> : Transducers y reducers","title":"Consejos y mejores pr\u00e1cticas"},{"location":"clojure/senior/programacion_logica/","text":"Programaci\u00f3n l\u00f3gica \u00b6 La programaci\u00f3n l\u00f3gica es un paradigma de programaci\u00f3n que se basa en la l\u00f3gica matem\u00e1tica para resolver problemas. Se centra en la descripci\u00f3n de relaciones entre hechos y reglas l\u00f3gicas, en lugar de instrucciones secuenciales como en la programaci\u00f3n imperativa. En Clojure, este paradigma se implementa a trav\u00e9s del lenguaje de programaci\u00f3n l\u00f3gica miniKanren. Palabras clave y definiciones \u00b6 Paradigma de programaci\u00f3n: Un enfoque o modelo de programaci\u00f3n que define c\u00f3mo se estructura y se resuelven problemas en un lenguaje de programaci\u00f3n. L\u00f3gica matem\u00e1tica: Un sistema formal que utiliza s\u00edmbolos y reglas para representar y manipular proposiciones l\u00f3gicas. MiniKanren: Un lenguaje de programaci\u00f3n l\u00f3gica basado en el c\u00e1lculo de relaciones que se ejecuta sobre Clojure. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la programaci\u00f3n l\u00f3gica y en qu\u00e9 se diferencia de la programaci\u00f3n imperativa? \u00bfCu\u00e1les son las palabras clave y su definici\u00f3n en el contexto de la programaci\u00f3n l\u00f3gica? \u00bfQu\u00e9 es miniKanren y c\u00f3mo se relaciona con Clojure? Ejemplos de c\u00f3digo en Clojure \u00b6 Para ilustrar el uso de la programaci\u00f3n l\u00f3gica en Clojure, a continuaci\u00f3n se presenta un ejemplo simple de un programa miniKanren que encuentra todas las posibles soluciones para una ecuaci\u00f3n de la forma \"a + b = c\": ( require ' [ clojure.core.logic :as l ]) ( l/run* [ q ] ( l/== q [ a b c ]) ( l/== a 2 ) ( l/== b 3 ) ( l/== c ( + a b ))) En este c\u00f3digo, primero se importa la biblioteca clojure.core.logic que contiene las funciones necesarias para trabajar con miniKanren. Luego, se define una variable q que representa una lista de tres elementos, a , b y c . A continuaci\u00f3n, se establecen las restricciones para a , b y c , donde a tiene el valor de 2, b tiene el valor de 3 y c es igual a a + b . La funci\u00f3n l/run* se encarga de encontrar todas las posibles soluciones para q que cumplan con las restricciones establecidas. Ejercicios pr\u00e1cticos \u00b6 Escribe un programa miniKanren en Clojure que encuentre todas las posibles soluciones para la ecuaci\u00f3n \"a * b = 24\", donde a y b son n\u00fameros enteros. Utilizando el mismo programa, modifica las restricciones para que se encuentren todas las parejas de n\u00fameros enteros que sumen un n\u00famero dado por el usuario. Consejos y mejores pr\u00e1cticas \u00b6 Al trabajar con miniKanren en Clojure, es importante tener en cuenta que no se est\u00e1 escribiendo c\u00f3digo imperativo, sino que se est\u00e1n estableciendo relaciones entre los diferentes elementos. Es importante entender c\u00f3mo se resuelve el c\u00e1lculo de relaciones en miniKanren para poder escribir programas eficientes y sin errores. Una buena pr\u00e1ctica es empezar con problemas sencillos y progresivamente ir aumentando la complejidad. Esto ayudar\u00e1 a entender mejor el paradigma de la programaci\u00f3n l\u00f3gica y sus aplicaciones en Clojure. <- Lecci\u00f3n anterior : Protocolos y registros Siguiente lecci\u00f3n -> : Arquitecturas y patrones de dise\u00f1o","title":"Programacion logica"},{"location":"clojure/senior/programacion_logica/#programacion-logica","text":"La programaci\u00f3n l\u00f3gica es un paradigma de programaci\u00f3n que se basa en la l\u00f3gica matem\u00e1tica para resolver problemas. Se centra en la descripci\u00f3n de relaciones entre hechos y reglas l\u00f3gicas, en lugar de instrucciones secuenciales como en la programaci\u00f3n imperativa. En Clojure, este paradigma se implementa a trav\u00e9s del lenguaje de programaci\u00f3n l\u00f3gica miniKanren.","title":"Programaci\u00f3n l\u00f3gica"},{"location":"clojure/senior/programacion_logica/#palabras-clave-y-definiciones","text":"Paradigma de programaci\u00f3n: Un enfoque o modelo de programaci\u00f3n que define c\u00f3mo se estructura y se resuelven problemas en un lenguaje de programaci\u00f3n. L\u00f3gica matem\u00e1tica: Un sistema formal que utiliza s\u00edmbolos y reglas para representar y manipular proposiciones l\u00f3gicas. MiniKanren: Un lenguaje de programaci\u00f3n l\u00f3gica basado en el c\u00e1lculo de relaciones que se ejecuta sobre Clojure.","title":"Palabras clave y definiciones"},{"location":"clojure/senior/programacion_logica/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la programaci\u00f3n l\u00f3gica y en qu\u00e9 se diferencia de la programaci\u00f3n imperativa? \u00bfCu\u00e1les son las palabras clave y su definici\u00f3n en el contexto de la programaci\u00f3n l\u00f3gica? \u00bfQu\u00e9 es miniKanren y c\u00f3mo se relaciona con Clojure?","title":"Preguntas de repaso"},{"location":"clojure/senior/programacion_logica/#ejemplos-de-codigo-en-clojure","text":"Para ilustrar el uso de la programaci\u00f3n l\u00f3gica en Clojure, a continuaci\u00f3n se presenta un ejemplo simple de un programa miniKanren que encuentra todas las posibles soluciones para una ecuaci\u00f3n de la forma \"a + b = c\": ( require ' [ clojure.core.logic :as l ]) ( l/run* [ q ] ( l/== q [ a b c ]) ( l/== a 2 ) ( l/== b 3 ) ( l/== c ( + a b ))) En este c\u00f3digo, primero se importa la biblioteca clojure.core.logic que contiene las funciones necesarias para trabajar con miniKanren. Luego, se define una variable q que representa una lista de tres elementos, a , b y c . A continuaci\u00f3n, se establecen las restricciones para a , b y c , donde a tiene el valor de 2, b tiene el valor de 3 y c es igual a a + b . La funci\u00f3n l/run* se encarga de encontrar todas las posibles soluciones para q que cumplan con las restricciones establecidas.","title":"Ejemplos de c\u00f3digo en Clojure"},{"location":"clojure/senior/programacion_logica/#ejercicios-practicos","text":"Escribe un programa miniKanren en Clojure que encuentre todas las posibles soluciones para la ecuaci\u00f3n \"a * b = 24\", donde a y b son n\u00fameros enteros. Utilizando el mismo programa, modifica las restricciones para que se encuentren todas las parejas de n\u00fameros enteros que sumen un n\u00famero dado por el usuario.","title":"Ejercicios pr\u00e1cticos"},{"location":"clojure/senior/programacion_logica/#consejos-y-mejores-practicas","text":"Al trabajar con miniKanren en Clojure, es importante tener en cuenta que no se est\u00e1 escribiendo c\u00f3digo imperativo, sino que se est\u00e1n estableciendo relaciones entre los diferentes elementos. Es importante entender c\u00f3mo se resuelve el c\u00e1lculo de relaciones en miniKanren para poder escribir programas eficientes y sin errores. Una buena pr\u00e1ctica es empezar con problemas sencillos y progresivamente ir aumentando la complejidad. Esto ayudar\u00e1 a entender mejor el paradigma de la programaci\u00f3n l\u00f3gica y sus aplicaciones en Clojure. <- Lecci\u00f3n anterior : Protocolos y registros Siguiente lecci\u00f3n -> : Arquitecturas y patrones de dise\u00f1o","title":"Consejos y mejores pr\u00e1cticas"},{"location":"clojure/senior/protocolos_y_registros/","text":"Protocolos y registros en Clojure \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En este m\u00f3dulo, aprender\u00e1s sobre el uso de protocolos y registros en Clojure para estructurar y extender tipos de datos. Los protocolos y registros son herramientas fundamentales en Clojure para trabajar con estructuras de datos y permiten una mayor flexibilidad y extensibilidad en el c\u00f3digo. Explicaci\u00f3n te\u00f3rica \u00b6 \u00bfQu\u00e9 son los protocolos y registros? \u00b6 En t\u00e9rminos simples, los protocolos son un conjunto de funciones que se pueden aplicar a diferentes tipos de datos. Los registros, por otro lado, son una forma de definir estructuras de datos con campos espec\u00edficos y funciones asociadas. Los protocolos y registros se complementan entre s\u00ed, ya que los protocolos se utilizan para definir comportamientos comunes entre diferentes tipos de datos, mientras que los registros se utilizan para definir tipos de datos concretos con campos espec\u00edficos y comportamientos definidos por los protocolos. \u00bfPor qu\u00e9 usar protocolos y registros? \u00b6 La principal ventaja de utilizar protocolos y registros es que permiten una mayor extensibilidad y flexibilidad en el c\u00f3digo. Al definir comportamientos comunes a trav\u00e9s de protocolos, se puede aplicar a diferentes tipos de datos sin necesidad de cambiar el c\u00f3digo existente. Adem\u00e1s, los registros permiten definir tipos de datos personalizados con campos espec\u00edficos y comportamientos definidos por los protocolos, lo que facilita la creaci\u00f3n de estructuras de datos complejas. Otra ventaja de los protocolos y registros es que fomentan la programaci\u00f3n orientada a objetos (POO) en Clojure, lo que facilita la transici\u00f3n para aquellos que vienen de otros lenguajes de programaci\u00f3n orientados a objetos. Palabras clave y su definici\u00f3n \u00b6 Protocolo: Un conjunto de funciones que se pueden aplicar a diferentes tipos de datos. Registro: Una estructura de datos con campos espec\u00edficos y funciones asociadas. Extensibilidad: La capacidad de extender o agregar nuevas funcionalidades a un sistema existente. Flexibilidad: La capacidad de adaptarse y cambiar f\u00e1cilmente para cumplir diferentes requisitos. Programaci\u00f3n orientada a objetos (POO): Un paradigma de programaci\u00f3n que se centra en la definici\u00f3n de objetos y sus interacciones. Preguntas de repaso \u00b6 \u00bfQu\u00e9 son los protocolos y registros en Clojure? \u00bfCu\u00e1l es la relaci\u00f3n entre los protocolos y registros? \u00bfPara qu\u00e9 se utilizan los protocolos y registros? \u00bfCu\u00e1l es la ventaja de utilizar protocolos y registros en Clojure? \u00bfC\u00f3mo fomentan los protocolos y registros la programaci\u00f3n orientada a objetos en Clojure? Ejemplos de c\u00f3digo en Clojure \u00b6 Definir un protocolo \u00b6 Para definir un protocolo en Clojure, se utiliza la macro defprotocol . Por ejemplo: ( defprotocol Printable ( print [ data ])) Este protocolo se llama Printable y define una \u00fanica funci\u00f3n print que puede ser aplicada a diferentes tipos de datos. Implementar un protocolo en un registro \u00b6 Para implementar un protocolo en un registro, se utiliza la macro defrecord . Por ejemplo: ( defrecord Person [ name age ] Printable ( print [ data ] ( println ( str \"Name: \" ( :name data ) \" Age: \" ( :age data ))))) Este registro se llama Person y tiene dos campos: name y age . Adem\u00e1s, implementa el protocolo Printable y define la funci\u00f3n print para imprimir el nombre y la edad de la persona. Utilizar un registro y su funci\u00f3n implementada \u00b6 Una vez que se ha definido un registro que implementa un protocolo, se puede crear una instancia del registro y utilizar su funci\u00f3n implementada. Por ejemplo: ( def person ( ->Person \"John\" 30 )) ( print person ) Este c\u00f3digo crea una instancia de Person con el nombre \"John\" y edad 30, y luego llama a la funci\u00f3n print para imprimir su informaci\u00f3n. Ejercicios pr\u00e1cticos \u00b6 Define un protocolo llamado Calculable con las funciones sumar y restar . Implementa el protocolo Calculable en un registro llamado Operacion con dos campos num1 y num2 . Crea una funci\u00f3n calcular que tome un registro Operacion y devuelva el resultado de sumar num1 y num2 . Crea una instancia de Operacion con los n\u00fameros 10 y 5 y utiliza la funci\u00f3n calcular para obtener el resultado. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza protocolos y registros para estructurar y extender tipos de datos en lugar de utilizar estructuras de datos anidadas. Antes de crear un registro, piensa en qu\u00e9 protocolos podr\u00eda implementar y qu\u00e9 campos y funciones asociadas necesitar\u00e1. Utiliza nombres descriptivos para tus protocolos y registros para facilitar su comprensi\u00f3n y uso en el c\u00f3digo. <- Lecci\u00f3n anterior : Transducers y reducers Siguiente lecci\u00f3n -> : Programaci\u00f3n l\u00f3gica","title":"Protocolos y registros en Clojure"},{"location":"clojure/senior/protocolos_y_registros/#protocolos-y-registros-en-clojure","text":"","title":"Protocolos y registros en Clojure"},{"location":"clojure/senior/protocolos_y_registros/#descripcion-del-modulo","text":"En este m\u00f3dulo, aprender\u00e1s sobre el uso de protocolos y registros en Clojure para estructurar y extender tipos de datos. Los protocolos y registros son herramientas fundamentales en Clojure para trabajar con estructuras de datos y permiten una mayor flexibilidad y extensibilidad en el c\u00f3digo.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"clojure/senior/protocolos_y_registros/#explicacion-teorica","text":"","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"clojure/senior/protocolos_y_registros/#que-son-los-protocolos-y-registros","text":"En t\u00e9rminos simples, los protocolos son un conjunto de funciones que se pueden aplicar a diferentes tipos de datos. Los registros, por otro lado, son una forma de definir estructuras de datos con campos espec\u00edficos y funciones asociadas. Los protocolos y registros se complementan entre s\u00ed, ya que los protocolos se utilizan para definir comportamientos comunes entre diferentes tipos de datos, mientras que los registros se utilizan para definir tipos de datos concretos con campos espec\u00edficos y comportamientos definidos por los protocolos.","title":"\u00bfQu\u00e9 son los protocolos y registros?"},{"location":"clojure/senior/protocolos_y_registros/#por-que-usar-protocolos-y-registros","text":"La principal ventaja de utilizar protocolos y registros es que permiten una mayor extensibilidad y flexibilidad en el c\u00f3digo. Al definir comportamientos comunes a trav\u00e9s de protocolos, se puede aplicar a diferentes tipos de datos sin necesidad de cambiar el c\u00f3digo existente. Adem\u00e1s, los registros permiten definir tipos de datos personalizados con campos espec\u00edficos y comportamientos definidos por los protocolos, lo que facilita la creaci\u00f3n de estructuras de datos complejas. Otra ventaja de los protocolos y registros es que fomentan la programaci\u00f3n orientada a objetos (POO) en Clojure, lo que facilita la transici\u00f3n para aquellos que vienen de otros lenguajes de programaci\u00f3n orientados a objetos.","title":"\u00bfPor qu\u00e9 usar protocolos y registros?"},{"location":"clojure/senior/protocolos_y_registros/#palabras-clave-y-su-definicion","text":"Protocolo: Un conjunto de funciones que se pueden aplicar a diferentes tipos de datos. Registro: Una estructura de datos con campos espec\u00edficos y funciones asociadas. Extensibilidad: La capacidad de extender o agregar nuevas funcionalidades a un sistema existente. Flexibilidad: La capacidad de adaptarse y cambiar f\u00e1cilmente para cumplir diferentes requisitos. Programaci\u00f3n orientada a objetos (POO): Un paradigma de programaci\u00f3n que se centra en la definici\u00f3n de objetos y sus interacciones.","title":"Palabras clave y su definici\u00f3n"},{"location":"clojure/senior/protocolos_y_registros/#preguntas-de-repaso","text":"\u00bfQu\u00e9 son los protocolos y registros en Clojure? \u00bfCu\u00e1l es la relaci\u00f3n entre los protocolos y registros? \u00bfPara qu\u00e9 se utilizan los protocolos y registros? \u00bfCu\u00e1l es la ventaja de utilizar protocolos y registros en Clojure? \u00bfC\u00f3mo fomentan los protocolos y registros la programaci\u00f3n orientada a objetos en Clojure?","title":"Preguntas de repaso"},{"location":"clojure/senior/protocolos_y_registros/#ejemplos-de-codigo-en-clojure","text":"","title":"Ejemplos de c\u00f3digo en Clojure"},{"location":"clojure/senior/protocolos_y_registros/#definir-un-protocolo","text":"Para definir un protocolo en Clojure, se utiliza la macro defprotocol . Por ejemplo: ( defprotocol Printable ( print [ data ])) Este protocolo se llama Printable y define una \u00fanica funci\u00f3n print que puede ser aplicada a diferentes tipos de datos.","title":"Definir un protocolo"},{"location":"clojure/senior/protocolos_y_registros/#implementar-un-protocolo-en-un-registro","text":"Para implementar un protocolo en un registro, se utiliza la macro defrecord . Por ejemplo: ( defrecord Person [ name age ] Printable ( print [ data ] ( println ( str \"Name: \" ( :name data ) \" Age: \" ( :age data ))))) Este registro se llama Person y tiene dos campos: name y age . Adem\u00e1s, implementa el protocolo Printable y define la funci\u00f3n print para imprimir el nombre y la edad de la persona.","title":"Implementar un protocolo en un registro"},{"location":"clojure/senior/protocolos_y_registros/#utilizar-un-registro-y-su-funcion-implementada","text":"Una vez que se ha definido un registro que implementa un protocolo, se puede crear una instancia del registro y utilizar su funci\u00f3n implementada. Por ejemplo: ( def person ( ->Person \"John\" 30 )) ( print person ) Este c\u00f3digo crea una instancia de Person con el nombre \"John\" y edad 30, y luego llama a la funci\u00f3n print para imprimir su informaci\u00f3n.","title":"Utilizar un registro y su funci\u00f3n implementada"},{"location":"clojure/senior/protocolos_y_registros/#ejercicios-practicos","text":"Define un protocolo llamado Calculable con las funciones sumar y restar . Implementa el protocolo Calculable en un registro llamado Operacion con dos campos num1 y num2 . Crea una funci\u00f3n calcular que tome un registro Operacion y devuelva el resultado de sumar num1 y num2 . Crea una instancia de Operacion con los n\u00fameros 10 y 5 y utiliza la funci\u00f3n calcular para obtener el resultado.","title":"Ejercicios pr\u00e1cticos"},{"location":"clojure/senior/protocolos_y_registros/#consejos-o-mejores-practicas","text":"Utiliza protocolos y registros para estructurar y extender tipos de datos en lugar de utilizar estructuras de datos anidadas. Antes de crear un registro, piensa en qu\u00e9 protocolos podr\u00eda implementar y qu\u00e9 campos y funciones asociadas necesitar\u00e1. Utiliza nombres descriptivos para tus protocolos y registros para facilitar su comprensi\u00f3n y uso en el c\u00f3digo. <- Lecci\u00f3n anterior : Transducers y reducers Siguiente lecci\u00f3n -> : Programaci\u00f3n l\u00f3gica","title":"Consejos o mejores pr\u00e1cticas"},{"location":"clojure/senior/proyectos_practicos/","text":"Proyectos pr\u00e1cticos \u00b6 Este m\u00f3dulo se enfoca en la aplicaci\u00f3n pr\u00e1ctica de los conocimientos adquiridos en Clojure. A trav\u00e9s de la realizaci\u00f3n de proyectos, podr\u00e1s consolidar y mejorar tus habilidades en este lenguaje de programaci\u00f3n funcional. Explicaci\u00f3n te\u00f3rica \u00b6 Los proyectos pr\u00e1cticos son una forma efectiva de poner en pr\u00e1ctica los conceptos aprendidos en Clojure y mejorar tus habilidades de programaci\u00f3n. Al trabajar en proyectos, podr\u00e1s enfrentarte a problemas reales y encontrar soluciones utilizando las caracter\u00edsticas y herramientas de Clojure. Adem\u00e1s, los proyectos pr\u00e1cticos te ayudar\u00e1n a entender mejor la sintaxis y la estructura del lenguaje, as\u00ed como tambi\u00e9n a familiarizarte con las librer\u00edas y frameworks disponibles. Palabras clave y su definici\u00f3n \u00b6 Proyectos pr\u00e1cticos: Son actividades de programaci\u00f3n en las que se aplican los conocimientos adquiridos en Clojure para resolver problemas reales o crear aplicaciones \u00fatiles. Lenguaje de programaci\u00f3n funcional: Un paradigma de programaci\u00f3n en el que los programas se construyen a partir de funciones, evitando el uso de estados y mutabilidad. Sintaxis: Reglas y estructuras utilizadas para escribir c\u00f3digo en un lenguaje de programaci\u00f3n. Librer\u00edas: Conjunto de funciones y herramientas que se pueden utilizar para realizar tareas espec\u00edficas en un lenguaje de programaci\u00f3n. Frameworks: Conjunto de librer\u00edas y herramientas que proporcionan una base para desarrollar aplicaciones de manera m\u00e1s eficiente. Preguntas de repaso \u00b6 \u00bfPor qu\u00e9 es importante realizar proyectos pr\u00e1cticos en Clojure? \u00bfQu\u00e9 es un lenguaje de programaci\u00f3n funcional? \u00bfCu\u00e1l es la diferencia entre una librer\u00eda y un framework en Clojure? \u00bfQu\u00e9 son las librer\u00edas y frameworks m\u00e1s utilizadas en Clojure? \u00bfC\u00f3mo pueden los proyectos pr\u00e1cticos ayudarte a mejorar tus habilidades en este lenguaje? Ejemplos de c\u00f3digo en Clojure \u00b6 Ejemplo 1: Funci\u00f3n que calcula el factorial de un n\u00famero \u00b6 ( defn factorial [ n ] ( if ( <= n 1 ) 1 ( * n ( factorial ( - n 1 ))))) Ejemplo 2: Funci\u00f3n que ordena una lista de n\u00fameros de menor a mayor \u00b6 ( defn ordenar [ lst ] ( if ( empty? lst ) lst ( let [ pivot ( first lst ) smaller ( filter # ( < % pivot ) ( rest lst )) greater ( filter # ( > % pivot ) ( rest lst ))] ( concat ( ordenar smaller ) ( list pivot ) ( ordenar greater ))))) Ejercicios pr\u00e1cticos \u00b6 Crea una funci\u00f3n en Clojure que reciba una lista de n\u00fameros y devuelva la suma de todos ellos. Escribe una funci\u00f3n que reciba una lista de palabras y devuelva una nueva lista con las palabras en may\u00fasculas. Crea un programa en Clojure que permita al usuario ingresar un n\u00famero y luego imprima todos los n\u00fameros pares menores o iguales a ese n\u00famero. Utilizando la librer\u00eda clojure.string , desarrolla una funci\u00f3n que reciba una cadena de texto y devuelva la misma cadena pero con todas las vocales reemplazadas por asteriscos. Crea un peque\u00f1o juego en Clojure en el que el usuario deba adivinar un n\u00famero aleatorio generado por el programa. El juego debe indicar si el n\u00famero ingresado es mayor o menor al n\u00famero a adivinar, y terminar cuando el usuario adivine el n\u00famero correcto. Consejos o mejores pr\u00e1cticas \u00b6 Comienza con proyectos sencillos y ve aumentando la complejidad a medida que adquieras m\u00e1s habilidades en Clojure. Utiliza las librer\u00edas y frameworks disponibles para ahorrar tiempo y mejorar la eficiencia en tus proyectos. No tengas miedo de experimentar y probar nuevas formas de resolver problemas en Clojure. Busca proyectos de c\u00f3digo abierto en Clojure y contribuye con tu conocimiento y habilidades en la comunidad. Siempre revisa y refactoriza tu c\u00f3digo para hacerlo m\u00e1s legible y eficiente. <- Lecci\u00f3n anterior : Integraci\u00f3n con otros lenguajes y plataformas Siguiente lecci\u00f3n -> : Desarrollo en equipo y buenas pr\u00e1cticas","title":"Proyectos pr\u00e1cticos"},{"location":"clojure/senior/proyectos_practicos/#proyectos-practicos","text":"Este m\u00f3dulo se enfoca en la aplicaci\u00f3n pr\u00e1ctica de los conocimientos adquiridos en Clojure. A trav\u00e9s de la realizaci\u00f3n de proyectos, podr\u00e1s consolidar y mejorar tus habilidades en este lenguaje de programaci\u00f3n funcional.","title":"Proyectos pr\u00e1cticos"},{"location":"clojure/senior/proyectos_practicos/#explicacion-teorica","text":"Los proyectos pr\u00e1cticos son una forma efectiva de poner en pr\u00e1ctica los conceptos aprendidos en Clojure y mejorar tus habilidades de programaci\u00f3n. Al trabajar en proyectos, podr\u00e1s enfrentarte a problemas reales y encontrar soluciones utilizando las caracter\u00edsticas y herramientas de Clojure. Adem\u00e1s, los proyectos pr\u00e1cticos te ayudar\u00e1n a entender mejor la sintaxis y la estructura del lenguaje, as\u00ed como tambi\u00e9n a familiarizarte con las librer\u00edas y frameworks disponibles.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"clojure/senior/proyectos_practicos/#palabras-clave-y-su-definicion","text":"Proyectos pr\u00e1cticos: Son actividades de programaci\u00f3n en las que se aplican los conocimientos adquiridos en Clojure para resolver problemas reales o crear aplicaciones \u00fatiles. Lenguaje de programaci\u00f3n funcional: Un paradigma de programaci\u00f3n en el que los programas se construyen a partir de funciones, evitando el uso de estados y mutabilidad. Sintaxis: Reglas y estructuras utilizadas para escribir c\u00f3digo en un lenguaje de programaci\u00f3n. Librer\u00edas: Conjunto de funciones y herramientas que se pueden utilizar para realizar tareas espec\u00edficas en un lenguaje de programaci\u00f3n. Frameworks: Conjunto de librer\u00edas y herramientas que proporcionan una base para desarrollar aplicaciones de manera m\u00e1s eficiente.","title":"Palabras clave y su definici\u00f3n"},{"location":"clojure/senior/proyectos_practicos/#preguntas-de-repaso","text":"\u00bfPor qu\u00e9 es importante realizar proyectos pr\u00e1cticos en Clojure? \u00bfQu\u00e9 es un lenguaje de programaci\u00f3n funcional? \u00bfCu\u00e1l es la diferencia entre una librer\u00eda y un framework en Clojure? \u00bfQu\u00e9 son las librer\u00edas y frameworks m\u00e1s utilizadas en Clojure? \u00bfC\u00f3mo pueden los proyectos pr\u00e1cticos ayudarte a mejorar tus habilidades en este lenguaje?","title":"Preguntas de repaso"},{"location":"clojure/senior/proyectos_practicos/#ejemplos-de-codigo-en-clojure","text":"","title":"Ejemplos de c\u00f3digo en Clojure"},{"location":"clojure/senior/proyectos_practicos/#ejemplo-1-funcion-que-calcula-el-factorial-de-un-numero","text":"( defn factorial [ n ] ( if ( <= n 1 ) 1 ( * n ( factorial ( - n 1 )))))","title":"Ejemplo 1: Funci\u00f3n que calcula el factorial de un n\u00famero"},{"location":"clojure/senior/proyectos_practicos/#ejemplo-2-funcion-que-ordena-una-lista-de-numeros-de-menor-a-mayor","text":"( defn ordenar [ lst ] ( if ( empty? lst ) lst ( let [ pivot ( first lst ) smaller ( filter # ( < % pivot ) ( rest lst )) greater ( filter # ( > % pivot ) ( rest lst ))] ( concat ( ordenar smaller ) ( list pivot ) ( ordenar greater )))))","title":"Ejemplo 2: Funci\u00f3n que ordena una lista de n\u00fameros de menor a mayor"},{"location":"clojure/senior/proyectos_practicos/#ejercicios-practicos","text":"Crea una funci\u00f3n en Clojure que reciba una lista de n\u00fameros y devuelva la suma de todos ellos. Escribe una funci\u00f3n que reciba una lista de palabras y devuelva una nueva lista con las palabras en may\u00fasculas. Crea un programa en Clojure que permita al usuario ingresar un n\u00famero y luego imprima todos los n\u00fameros pares menores o iguales a ese n\u00famero. Utilizando la librer\u00eda clojure.string , desarrolla una funci\u00f3n que reciba una cadena de texto y devuelva la misma cadena pero con todas las vocales reemplazadas por asteriscos. Crea un peque\u00f1o juego en Clojure en el que el usuario deba adivinar un n\u00famero aleatorio generado por el programa. El juego debe indicar si el n\u00famero ingresado es mayor o menor al n\u00famero a adivinar, y terminar cuando el usuario adivine el n\u00famero correcto.","title":"Ejercicios pr\u00e1cticos"},{"location":"clojure/senior/proyectos_practicos/#consejos-o-mejores-practicas","text":"Comienza con proyectos sencillos y ve aumentando la complejidad a medida que adquieras m\u00e1s habilidades en Clojure. Utiliza las librer\u00edas y frameworks disponibles para ahorrar tiempo y mejorar la eficiencia en tus proyectos. No tengas miedo de experimentar y probar nuevas formas de resolver problemas en Clojure. Busca proyectos de c\u00f3digo abierto en Clojure y contribuye con tu conocimiento y habilidades en la comunidad. Siempre revisa y refactoriza tu c\u00f3digo para hacerlo m\u00e1s legible y eficiente. <- Lecci\u00f3n anterior : Integraci\u00f3n con otros lenguajes y plataformas Siguiente lecci\u00f3n -> : Desarrollo en equipo y buenas pr\u00e1cticas","title":"Consejos o mejores pr\u00e1cticas"},{"location":"clojure/senior/transducers_y_reducers/","text":"Transducers y Reducers \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 En Clojure, transducers y reducers son dos estructuras de datos que nos permiten trabajar con grandes conjuntos de datos de manera eficiente. Ambas se basan en la idea de transformar y reducir datos sin necesidad de iterar sobre cada elemento de la colecci\u00f3n, lo que reduce el tiempo de ejecuci\u00f3n y mejora el rendimiento. Los transducers son funciones que toman una funci\u00f3n de reducci\u00f3n y la transforman en otra funci\u00f3n de reducci\u00f3n. Esto significa que, en lugar de aplicar la funci\u00f3n de reducci\u00f3n a cada elemento de la colecci\u00f3n, el transducer la aplica a la colecci\u00f3n en su conjunto, lo que reduce el n\u00famero de operaciones necesarias. Adem\u00e1s, los transducers son componibles, lo que significa que podemos combinar varios transducers para aplicar m\u00faltiples transformaciones a la vez. Por otro lado, los reducers son estructuras de datos que nos permiten aplicar operaciones de reducci\u00f3n de manera eficiente. En lugar de iterar sobre cada elemento de la colecci\u00f3n, los reducers utilizan un proceso de reducci\u00f3n en dos fases: la primera fase divide la colecci\u00f3n en partes m\u00e1s peque\u00f1as y la segunda fase combina los resultados de cada parte para obtener el resultado final. Esto es especialmente \u00fatil en colecciones grandes, ya que el proceso de divisi\u00f3n en partes se puede realizar en paralelo, lo que mejora significativamente el rendimiento. Palabras clave y su definici\u00f3n \u00b6 Transducers: funciones que transforman una funci\u00f3n de reducci\u00f3n en otra funci\u00f3n de reducci\u00f3n, lo que permite aplicar transformaciones a una colecci\u00f3n de manera eficiente. Reducers: estructuras de datos que utilizan un proceso de reducci\u00f3n en dos fases para aplicar operaciones de reducci\u00f3n de manera eficiente en colecciones grandes. Componibilidad: capacidad de combinar varias funciones o estructuras de datos para lograr un resultado deseado. Eficiencia: capacidad de realizar una tarea en el menor tiempo posible y utilizando la menor cantidad de recursos. Preguntas de repaso \u00b6 \u00bfQu\u00e9 son los transducers en Clojure? \u00bfCu\u00e1l es la diferencia entre un transducer y un reducer? \u00bfPor qu\u00e9 es importante la componibilidad de los transducers? \u00bfEn qu\u00e9 tipo de colecciones son especialmente \u00fatiles los reducers? \u00bfCu\u00e1l es el proceso de reducci\u00f3n en dos fases utilizado por los reducers? Ejemplos de c\u00f3digo en Clojure \u00b6 Transducers \u00b6 ;; Crear un transducer que multiplique cada elemento por 2 ( def multiplicar-por-2 ( map # ( * % 2 ))) ;; Combinar el transducer con una funci\u00f3n de reducci\u00f3n ( defn sumar [ a b ] ( + a b )) ( def transducer-suma ( comp multiplicar-por-2 ( reduce sumar ))) ( transducer-suma [ 1 2 3 4 ]) ; retorna 20 Reducers \u00b6 ;; Crear un reducer que sume los elementos de una colecci\u00f3n ( defn sumar [ a b ] ( + a b )) ( def sumar-reducer ( reducer sumar )) ( sumar-reducer [ 1 2 3 4 ]) ; retorna 10 Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea un transducer que multiplique cada elemento de una colecci\u00f3n por 3 y luego sume todos los elementos resultantes. Utiliza un reducer para encontrar el n\u00famero m\u00e1s grande en una colecci\u00f3n de enteros. Combina dos transducers: uno que filtre los elementos pares y otro que los multiplique por 5. Aplica el transducer resultante a una colecci\u00f3n de n\u00fameros y comprueba el resultado. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza transducers y reducers en colecciones grandes para mejorar el rendimiento y la eficiencia. Experimenta con diferentes combinaciones de transducers para lograr el resultado deseado. Aseg\u00farate de entender bien c\u00f3mo funcionan los transducers y reducers antes de utilizarlos en tus proyectos. <- Lecci\u00f3n anterior : Macros y metaprogramaci\u00f3n Siguiente lecci\u00f3n -> : Protocolos y registros","title":"Transducers y Reducers"},{"location":"clojure/senior/transducers_y_reducers/#transducers-y-reducers","text":"","title":"Transducers y Reducers"},{"location":"clojure/senior/transducers_y_reducers/#explicacion-teorica","text":"En Clojure, transducers y reducers son dos estructuras de datos que nos permiten trabajar con grandes conjuntos de datos de manera eficiente. Ambas se basan en la idea de transformar y reducir datos sin necesidad de iterar sobre cada elemento de la colecci\u00f3n, lo que reduce el tiempo de ejecuci\u00f3n y mejora el rendimiento. Los transducers son funciones que toman una funci\u00f3n de reducci\u00f3n y la transforman en otra funci\u00f3n de reducci\u00f3n. Esto significa que, en lugar de aplicar la funci\u00f3n de reducci\u00f3n a cada elemento de la colecci\u00f3n, el transducer la aplica a la colecci\u00f3n en su conjunto, lo que reduce el n\u00famero de operaciones necesarias. Adem\u00e1s, los transducers son componibles, lo que significa que podemos combinar varios transducers para aplicar m\u00faltiples transformaciones a la vez. Por otro lado, los reducers son estructuras de datos que nos permiten aplicar operaciones de reducci\u00f3n de manera eficiente. En lugar de iterar sobre cada elemento de la colecci\u00f3n, los reducers utilizan un proceso de reducci\u00f3n en dos fases: la primera fase divide la colecci\u00f3n en partes m\u00e1s peque\u00f1as y la segunda fase combina los resultados de cada parte para obtener el resultado final. Esto es especialmente \u00fatil en colecciones grandes, ya que el proceso de divisi\u00f3n en partes se puede realizar en paralelo, lo que mejora significativamente el rendimiento.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"clojure/senior/transducers_y_reducers/#palabras-clave-y-su-definicion","text":"Transducers: funciones que transforman una funci\u00f3n de reducci\u00f3n en otra funci\u00f3n de reducci\u00f3n, lo que permite aplicar transformaciones a una colecci\u00f3n de manera eficiente. Reducers: estructuras de datos que utilizan un proceso de reducci\u00f3n en dos fases para aplicar operaciones de reducci\u00f3n de manera eficiente en colecciones grandes. Componibilidad: capacidad de combinar varias funciones o estructuras de datos para lograr un resultado deseado. Eficiencia: capacidad de realizar una tarea en el menor tiempo posible y utilizando la menor cantidad de recursos.","title":"Palabras clave y su definici\u00f3n"},{"location":"clojure/senior/transducers_y_reducers/#preguntas-de-repaso","text":"\u00bfQu\u00e9 son los transducers en Clojure? \u00bfCu\u00e1l es la diferencia entre un transducer y un reducer? \u00bfPor qu\u00e9 es importante la componibilidad de los transducers? \u00bfEn qu\u00e9 tipo de colecciones son especialmente \u00fatiles los reducers? \u00bfCu\u00e1l es el proceso de reducci\u00f3n en dos fases utilizado por los reducers?","title":"Preguntas de repaso"},{"location":"clojure/senior/transducers_y_reducers/#ejemplos-de-codigo-en-clojure","text":"","title":"Ejemplos de c\u00f3digo en Clojure"},{"location":"clojure/senior/transducers_y_reducers/#transducers","text":";; Crear un transducer que multiplique cada elemento por 2 ( def multiplicar-por-2 ( map # ( * % 2 ))) ;; Combinar el transducer con una funci\u00f3n de reducci\u00f3n ( defn sumar [ a b ] ( + a b )) ( def transducer-suma ( comp multiplicar-por-2 ( reduce sumar ))) ( transducer-suma [ 1 2 3 4 ]) ; retorna 20","title":"Transducers"},{"location":"clojure/senior/transducers_y_reducers/#reducers","text":";; Crear un reducer que sume los elementos de una colecci\u00f3n ( defn sumar [ a b ] ( + a b )) ( def sumar-reducer ( reducer sumar )) ( sumar-reducer [ 1 2 3 4 ]) ; retorna 10","title":"Reducers"},{"location":"clojure/senior/transducers_y_reducers/#ejercicios-practicos-con-instrucciones-claras","text":"Crea un transducer que multiplique cada elemento de una colecci\u00f3n por 3 y luego sume todos los elementos resultantes. Utiliza un reducer para encontrar el n\u00famero m\u00e1s grande en una colecci\u00f3n de enteros. Combina dos transducers: uno que filtre los elementos pares y otro que los multiplique por 5. Aplica el transducer resultante a una colecci\u00f3n de n\u00fameros y comprueba el resultado.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"clojure/senior/transducers_y_reducers/#consejos-o-mejores-practicas","text":"Utiliza transducers y reducers en colecciones grandes para mejorar el rendimiento y la eficiencia. Experimenta con diferentes combinaciones de transducers para lograr el resultado deseado. Aseg\u00farate de entender bien c\u00f3mo funcionan los transducers y reducers antes de utilizarlos en tus proyectos. <- Lecci\u00f3n anterior : Macros y metaprogramaci\u00f3n Siguiente lecci\u00f3n -> : Protocolos y registros","title":"Consejos o mejores pr\u00e1cticas"},{"location":"elixir/","text":"Curso de Elixir \u00b6 \u00a1Bienvenido(a) al curso de Elixir ! Este curso est\u00e1 dividido en distintos niveles de complejidad, para que puedas avanzar seg\u00fan tu experiencia previa: Junior Mid Senior Encontrar\u00e1s temas como sintaxis de Elixir, procesos, concurrencia, desarrollo web, rendimiento, seguridad, y otros t\u00f3picos avanzados.","title":"Introducci\u00f3n"},{"location":"elixir/#curso-de-elixir","text":"\u00a1Bienvenido(a) al curso de Elixir ! Este curso est\u00e1 dividido en distintos niveles de complejidad, para que puedas avanzar seg\u00fan tu experiencia previa: Junior Mid Senior Encontrar\u00e1s temas como sintaxis de Elixir, procesos, concurrencia, desarrollo web, rendimiento, seguridad, y otros t\u00f3picos avanzados.","title":"Curso de Elixir"},{"location":"elixir/jr/","text":"Elixir - Nivel Junior \u00b6 \u00a1Bienvenido/a al nivel Junior del curso de Elixir! Aqu\u00ed encontrar\u00e1s los fundamentos de Elixir, ideales para quienes inician: Introducci\u00f3n a Elixir Sintaxis b\u00e1sica Listas y tuplas Patrones y coincidencias Procesos Concurrencia Recursividad M\u00f3dulos M\u00f3dulos de la librer\u00eda est\u00e1ndar de Elixir Desarrollo de aplicaciones web con Elixir Pruebas y depuraci\u00f3n Despliegue de aplicaciones Elixir Supervisi\u00f3n de procesos","title":"Nivel Junior"},{"location":"elixir/jr/#elixir-nivel-junior","text":"\u00a1Bienvenido/a al nivel Junior del curso de Elixir! Aqu\u00ed encontrar\u00e1s los fundamentos de Elixir, ideales para quienes inician: Introducci\u00f3n a Elixir Sintaxis b\u00e1sica Listas y tuplas Patrones y coincidencias Procesos Concurrencia Recursividad M\u00f3dulos M\u00f3dulos de la librer\u00eda est\u00e1ndar de Elixir Desarrollo de aplicaciones web con Elixir Pruebas y depuraci\u00f3n Despliegue de aplicaciones Elixir Supervisi\u00f3n de procesos","title":"Elixir - Nivel Junior"},{"location":"elixir/jr/concurrencia/","text":"Concurrencia en Elixir \u00b6 La concurrencia en Elixir se refiere a la capacidad de manejar m\u00faltiples procesos de forma eficiente. Esto significa que varios procesos pueden ejecutarse simult\u00e1neamente y compartir recursos de manera segura y controlada. Esto es posible gracias al modelo de concurrencia basado en el actor que utiliza Elixir, donde cada proceso se comporta como un actor independiente que se comunica con otros procesos a trav\u00e9s de mensajes. Explicaci\u00f3n te\u00f3rica \u00b6 La concurrencia en Elixir se basa en el concepto de procesos livianos, tambi\u00e9n conocidos como procesos de Erlang (el lenguaje en el que se basa Elixir). Estos procesos son diferentes a los procesos del sistema operativo, ya que son creados y administrados por la m\u00e1quina virtual de Elixir y pueden tener un tama\u00f1o de memoria mucho m\u00e1s peque\u00f1o. Esto permite a Elixir crear y manejar miles de procesos en una sola m\u00e1quina virtual, lo que lo hace ideal para aplicaciones que requieren una alta concurrencia. Los procesos en Elixir se comunican entre s\u00ed enviando mensajes, que son en realidad datos inmutables. Esto significa que no se pueden modificar, por lo que no hay problemas de concurrencia al compartir datos entre procesos. Adem\u00e1s, Elixir utiliza un mecanismo de paso de mensajes as\u00edncrono, lo que significa que un proceso puede enviar un mensaje a otro proceso y seguir ejecutando su propio c\u00f3digo sin tener que esperar una respuesta. Esto permite una comunicaci\u00f3n eficiente entre procesos sin bloquear la ejecuci\u00f3n. Otra caracter\u00edstica importante de la concurrencia en Elixir es la capacidad de manejar errores de forma controlada. Cada proceso tiene su propio manejo de errores, lo que significa que un proceso puede fallar sin afectar a otros procesos en ejecuci\u00f3n. Adem\u00e1s, Elixir proporciona mecanismos para supervisar y reiniciar procesos en caso de errores, lo que aumenta la tolerancia a fallos de las aplicaciones. Palabras clave y su definici\u00f3n \u00b6 Concurrency: El manejo de m\u00faltiples procesos que se ejecutan simult\u00e1neamente y comparten recursos de forma controlada. Process: Un proceso en Elixir es una unidad de ejecuci\u00f3n liviana que se comunica con otros procesos a trav\u00e9s de mensajes. Actor model: Un modelo de concurrencia donde cada proceso se comporta como un actor independiente que se comunica a trav\u00e9s de mensajes. Message passing: El mecanismo utilizado por Elixir para que los procesos se comuniquen entre s\u00ed enviando mensajes. Immutable data: Datos que no pueden ser modificados despu\u00e9s de su creaci\u00f3n, lo que garantiza una comunicaci\u00f3n segura entre procesos. Asynchronous: Un tipo de comunicaci\u00f3n en la que un proceso puede enviar un mensaje y continuar ejecutando su propio c\u00f3digo sin tener que esperar una respuesta. Error handling: El manejo de errores en los procesos, que se hace de forma individual para cada proceso en Elixir. Supervision: Un mecanismo en Elixir para monitorear y reiniciar procesos en caso de errores. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la concurrencia en Elixir? \u00bfEn qu\u00e9 se diferencia un proceso en Elixir de un proceso del sistema operativo? \u00bfC\u00f3mo se comunican los procesos en Elixir? \u00bfQu\u00e9 es el modelo de actores? \u00bfQu\u00e9 es el mecanismo de paso de mensajes as\u00edncrono? \u00bfC\u00f3mo maneja Elixir los errores en los procesos? \u00bfQu\u00e9 es la supervisi\u00f3n en Elixir? \u00bfPor qu\u00e9 es importante que los datos sean inmutables en un entorno de concurrencia? Ejemplos de c\u00f3digo en Elixir \u00b6 Crear un proceso en Elixir \u00b6 pid = spawn ( fn -> \"Hola, soy un proceso!\" end) Este c\u00f3digo crear\u00e1 un nuevo proceso que imprimir\u00e1 \"Hola, soy un proceso!\" cuando se le env\u00ede un mensaje. Enviar y recibir mensajes entre procesos \u00b6 pid = spawn ( fn -> receive do mensaje -> IO . puts ( \"He recibido un mensaje: #{mensaje}\" ) end end) send ( pid , \"Hola desde el proceso padre!\" ) Este c\u00f3digo crear\u00e1 un proceso que espera recibir un mensaje y luego imprimir\u00e1 ese mensaje. Luego, el proceso padre enviar\u00e1 un mensaje al proceso reci\u00e9n creado. Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una funci\u00f3n en Elixir que genere un n\u00famero aleatorio y lo env\u00ede como mensaje a otro proceso. El otro proceso debe imprimir el n\u00famero recibido. Crea dos procesos en Elixir y haz que se comuniquen entre s\u00ed enviando mensajes. El primer proceso debe imprimir \"Hola\" y el segundo proceso debe responder con \"Hola de vuelta\". Crea una funci\u00f3n en Elixir que calcule el factorial de un n\u00famero y lo env\u00ede como mensaje a otro proceso. El otro proceso debe imprimir el resultado recibido. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza procesos en lugar de hilos para lograr una concurrencia m\u00e1s eficiente y segura en Elixir. Utiliza el modelo de actores para manejar los procesos de forma independiente y asegurar una comunicaci\u00f3n segura entre ellos. Utiliza el mecanismo de supervisi\u00f3n para manejar errores en los procesos y aumentar la tolerancia a fallos de las aplicaciones. Utiliza datos inmutables en la comunicaci\u00f3n entre procesos para evitar problemas de concurrencia. Evita bloquear la ejecuci\u00f3n de procesos con llamadas s\u00edncronas, utiliza el paso de mensajes as\u00edncrono siempre que sea posible. Navegaci\u00f3n de lecciones \u00b6 <- Lecci\u00f3n anterior : Procesos Siguiente lecci\u00f3n -> : Recursividad","title":"Concurrencia en Elixir"},{"location":"elixir/jr/concurrencia/#concurrencia-en-elixir","text":"La concurrencia en Elixir se refiere a la capacidad de manejar m\u00faltiples procesos de forma eficiente. Esto significa que varios procesos pueden ejecutarse simult\u00e1neamente y compartir recursos de manera segura y controlada. Esto es posible gracias al modelo de concurrencia basado en el actor que utiliza Elixir, donde cada proceso se comporta como un actor independiente que se comunica con otros procesos a trav\u00e9s de mensajes.","title":"Concurrencia en Elixir"},{"location":"elixir/jr/concurrencia/#explicacion-teorica","text":"La concurrencia en Elixir se basa en el concepto de procesos livianos, tambi\u00e9n conocidos como procesos de Erlang (el lenguaje en el que se basa Elixir). Estos procesos son diferentes a los procesos del sistema operativo, ya que son creados y administrados por la m\u00e1quina virtual de Elixir y pueden tener un tama\u00f1o de memoria mucho m\u00e1s peque\u00f1o. Esto permite a Elixir crear y manejar miles de procesos en una sola m\u00e1quina virtual, lo que lo hace ideal para aplicaciones que requieren una alta concurrencia. Los procesos en Elixir se comunican entre s\u00ed enviando mensajes, que son en realidad datos inmutables. Esto significa que no se pueden modificar, por lo que no hay problemas de concurrencia al compartir datos entre procesos. Adem\u00e1s, Elixir utiliza un mecanismo de paso de mensajes as\u00edncrono, lo que significa que un proceso puede enviar un mensaje a otro proceso y seguir ejecutando su propio c\u00f3digo sin tener que esperar una respuesta. Esto permite una comunicaci\u00f3n eficiente entre procesos sin bloquear la ejecuci\u00f3n. Otra caracter\u00edstica importante de la concurrencia en Elixir es la capacidad de manejar errores de forma controlada. Cada proceso tiene su propio manejo de errores, lo que significa que un proceso puede fallar sin afectar a otros procesos en ejecuci\u00f3n. Adem\u00e1s, Elixir proporciona mecanismos para supervisar y reiniciar procesos en caso de errores, lo que aumenta la tolerancia a fallos de las aplicaciones.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"elixir/jr/concurrencia/#palabras-clave-y-su-definicion","text":"Concurrency: El manejo de m\u00faltiples procesos que se ejecutan simult\u00e1neamente y comparten recursos de forma controlada. Process: Un proceso en Elixir es una unidad de ejecuci\u00f3n liviana que se comunica con otros procesos a trav\u00e9s de mensajes. Actor model: Un modelo de concurrencia donde cada proceso se comporta como un actor independiente que se comunica a trav\u00e9s de mensajes. Message passing: El mecanismo utilizado por Elixir para que los procesos se comuniquen entre s\u00ed enviando mensajes. Immutable data: Datos que no pueden ser modificados despu\u00e9s de su creaci\u00f3n, lo que garantiza una comunicaci\u00f3n segura entre procesos. Asynchronous: Un tipo de comunicaci\u00f3n en la que un proceso puede enviar un mensaje y continuar ejecutando su propio c\u00f3digo sin tener que esperar una respuesta. Error handling: El manejo de errores en los procesos, que se hace de forma individual para cada proceso en Elixir. Supervision: Un mecanismo en Elixir para monitorear y reiniciar procesos en caso de errores.","title":"Palabras clave y su definici\u00f3n"},{"location":"elixir/jr/concurrencia/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la concurrencia en Elixir? \u00bfEn qu\u00e9 se diferencia un proceso en Elixir de un proceso del sistema operativo? \u00bfC\u00f3mo se comunican los procesos en Elixir? \u00bfQu\u00e9 es el modelo de actores? \u00bfQu\u00e9 es el mecanismo de paso de mensajes as\u00edncrono? \u00bfC\u00f3mo maneja Elixir los errores en los procesos? \u00bfQu\u00e9 es la supervisi\u00f3n en Elixir? \u00bfPor qu\u00e9 es importante que los datos sean inmutables en un entorno de concurrencia?","title":"Preguntas de repaso"},{"location":"elixir/jr/concurrencia/#ejemplos-de-codigo-en-elixir","text":"","title":"Ejemplos de c\u00f3digo en Elixir"},{"location":"elixir/jr/concurrencia/#crear-un-proceso-en-elixir","text":"pid = spawn ( fn -> \"Hola, soy un proceso!\" end) Este c\u00f3digo crear\u00e1 un nuevo proceso que imprimir\u00e1 \"Hola, soy un proceso!\" cuando se le env\u00ede un mensaje.","title":"Crear un proceso en Elixir"},{"location":"elixir/jr/concurrencia/#enviar-y-recibir-mensajes-entre-procesos","text":"pid = spawn ( fn -> receive do mensaje -> IO . puts ( \"He recibido un mensaje: #{mensaje}\" ) end end) send ( pid , \"Hola desde el proceso padre!\" ) Este c\u00f3digo crear\u00e1 un proceso que espera recibir un mensaje y luego imprimir\u00e1 ese mensaje. Luego, el proceso padre enviar\u00e1 un mensaje al proceso reci\u00e9n creado.","title":"Enviar y recibir mensajes entre procesos"},{"location":"elixir/jr/concurrencia/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una funci\u00f3n en Elixir que genere un n\u00famero aleatorio y lo env\u00ede como mensaje a otro proceso. El otro proceso debe imprimir el n\u00famero recibido. Crea dos procesos en Elixir y haz que se comuniquen entre s\u00ed enviando mensajes. El primer proceso debe imprimir \"Hola\" y el segundo proceso debe responder con \"Hola de vuelta\". Crea una funci\u00f3n en Elixir que calcule el factorial de un n\u00famero y lo env\u00ede como mensaje a otro proceso. El otro proceso debe imprimir el resultado recibido.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"elixir/jr/concurrencia/#consejos-o-mejores-practicas","text":"Utiliza procesos en lugar de hilos para lograr una concurrencia m\u00e1s eficiente y segura en Elixir. Utiliza el modelo de actores para manejar los procesos de forma independiente y asegurar una comunicaci\u00f3n segura entre ellos. Utiliza el mecanismo de supervisi\u00f3n para manejar errores en los procesos y aumentar la tolerancia a fallos de las aplicaciones. Utiliza datos inmutables en la comunicaci\u00f3n entre procesos para evitar problemas de concurrencia. Evita bloquear la ejecuci\u00f3n de procesos con llamadas s\u00edncronas, utiliza el paso de mensajes as\u00edncrono siempre que sea posible.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"elixir/jr/concurrencia/#navegacion-de-lecciones","text":"<- Lecci\u00f3n anterior : Procesos Siguiente lecci\u00f3n -> : Recursividad","title":"Navegaci\u00f3n de lecciones"},{"location":"elixir/jr/desarrollo_de_aplicaciones_web_con_elixir/","text":"Desarrollo de aplicaciones web con Elixir \u00b6 Introducci\u00f3n \u00b6 Elixir es un lenguaje de programaci\u00f3n funcional y din\u00e1mico que se ejecuta en la m\u00e1quina virtual de Erlang (BEAM). Fue creado por Jos\u00e9 Valim en 2011 y se ha vuelto cada vez m\u00e1s popular en los \u00faltimos a\u00f1os debido a su eficiencia, escalabilidad y capacidad para manejar una gran cantidad de conexiones simult\u00e1neas. Una de las principales fortalezas de Elixir es su framework web, Phoenix, que permite a los desarrolladores crear aplicaciones web altamente escalables y de alto rendimiento. Palabras clave \u00b6 Elixir: Lenguaje de programaci\u00f3n funcional y din\u00e1mico. Phoenix: Framework web para Elixir. Erlang: M\u00e1quina virtual en la que se ejecuta Elixir. Escalabilidad: Capacidad de una aplicaci\u00f3n para manejar un aumento en la cantidad de usuarios o tr\u00e1fico sin afectar su rendimiento. Rendimiento: Velocidad y eficiencia de una aplicaci\u00f3n. Concurrente: Capacidad de realizar m\u00faltiples tareas al mismo tiempo. Teor\u00eda \u00b6 Framework Phoenix \u00b6 Phoenix es un framework web para Elixir que est\u00e1 basado en el patr\u00f3n de arquitectura Modelo-Vista-Controlador (MVC). Utiliza el lenguaje de plantillas EEx para generar el contenido HTML y utiliza el protocolo HTTP para comunicarse con el navegador. Phoenix tambi\u00e9n incluye una capa de enrutamiento, que permite mapear las URL a las acciones correspondientes en el controlador. Procesos y concurrencia \u00b6 Una de las caracter\u00edsticas m\u00e1s importantes de Elixir es su capacidad para manejar m\u00faltiples procesos concurrentes. En Elixir, los procesos son ligeros y tienen un costo muy bajo, lo que permite tener miles de ellos ejecut\u00e1ndose simult\u00e1neamente sin afectar el rendimiento de la aplicaci\u00f3n. Esto es especialmente \u00fatil para aplicaciones web que deben manejar muchas solicitudes simult\u00e1neas. Ecto \u00b6 Ecto es un m\u00f3dulo de Elixir que proporciona un lenguaje de consulta para interactuar con bases de datos. Utiliza el patr\u00f3n de dise\u00f1o de repositorio para abstraer la l\u00f3gica de acceso a la base de datos y facilitar la manipulaci\u00f3n de datos en la aplicaci\u00f3n. Canales \u00b6 Los canales son una caracter\u00edstica de Phoenix que permite la comunicaci\u00f3n bidireccional en tiempo real entre el servidor y el cliente. Esto es \u00fatil para crear aplicaciones en tiempo real, como chats o juegos multijugador. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es Elixir y por qu\u00e9 se ha vuelto tan popular en los \u00faltimos a\u00f1os? \u00bfCu\u00e1l es la principal fortaleza de Elixir en el desarrollo de aplicaciones web? \u00bfQu\u00e9 es Phoenix y en qu\u00e9 se basa su arquitectura? \u00bfC\u00f3mo maneja Elixir la concurrencia y por qu\u00e9 es importante en el desarrollo de aplicaciones web? \u00bfQu\u00e9 es Ecto y c\u00f3mo ayuda en la interacci\u00f3n con bases de datos? \u00bfQu\u00e9 son los canales en Phoenix y para qu\u00e9 se utilizan? Ejemplos de c\u00f3digo en Elixir \u00b6 # Definici\u00f3n de un m\u00f3dulo en Elixir defmodule Saludo do # Funci\u00f3n que imprime un saludo def decir_hola(nombre) do IO.puts(\"\u00a1Hola #{nombre}!\") end end # Llamada a la funci\u00f3n decir_hola Saludo.decir_hola(\"Juan\") # Output: \u00a1Hola Juan! # Creaci\u00f3n de un canal en Phoenix defmodule ChatWeb.RoomChannel do use Phoenix.Channel # Funci\u00f3n que se ejecuta al unirse al canal def join(\"room:\" <> room_id, _params, socket) do {:ok, socket} end # Funci\u00f3n que se ejecuta al recibir un mensaje del cliente def handle_in(\"new_msg\", %{\"body\" => body}, socket) do broadcast(socket, \"new_msg\", %{body: body}) {:noreply, socket} end end Ejercicios pr\u00e1cticos \u00b6 Crea un nuevo proyecto de Phoenix utilizando el comando mix phx.new . Agrega una funci\u00f3n en el controlador que reciba una solicitud GET y devuelva un mensaje de saludo. Crea una base de datos utilizando Ecto y realiza una consulta para obtener todos los registros de una tabla. Crea un canal en Phoenix para permitir la comunicaci\u00f3n en tiempo real entre el servidor y el cliente. Agrega una funci\u00f3n en el canal que env\u00ede un mensaje a todos los clientes conectados cada vez que un nuevo mensaje es recibido. Consejos y mejores pr\u00e1cticas \u00b6 Utiliza el patr\u00f3n de dise\u00f1o de repositorio para abstraer la l\u00f3gica de acceso a la base de datos y mantener el c\u00f3digo m\u00e1s organizado y f\u00e1cil de mantener. Aprovecha la concurrencia en Elixir para crear aplicaciones altamente escalables y de alto rendimiento. Utiliza los canales en Phoenix para crear aplicaciones en tiempo real y mejorar la experiencia del usuario. Sigue las convenciones de nomenclatura y buenas pr\u00e1cticas de Elixir para mantener el c\u00f3digo legible y consistente. Navegaci\u00f3n de lecciones \u00b6 <- Lecci\u00f3n anterior : M\u00f3dulos de la librer\u00eda est\u00e1ndar de Elixir Siguiente lecci\u00f3n -> : Pruebas y depuraci\u00f3n","title":"Desarrollo de aplicaciones web con Elixir"},{"location":"elixir/jr/desarrollo_de_aplicaciones_web_con_elixir/#desarrollo-de-aplicaciones-web-con-elixir","text":"","title":"Desarrollo de aplicaciones web con Elixir"},{"location":"elixir/jr/desarrollo_de_aplicaciones_web_con_elixir/#introduccion","text":"Elixir es un lenguaje de programaci\u00f3n funcional y din\u00e1mico que se ejecuta en la m\u00e1quina virtual de Erlang (BEAM). Fue creado por Jos\u00e9 Valim en 2011 y se ha vuelto cada vez m\u00e1s popular en los \u00faltimos a\u00f1os debido a su eficiencia, escalabilidad y capacidad para manejar una gran cantidad de conexiones simult\u00e1neas. Una de las principales fortalezas de Elixir es su framework web, Phoenix, que permite a los desarrolladores crear aplicaciones web altamente escalables y de alto rendimiento.","title":"Introducci\u00f3n"},{"location":"elixir/jr/desarrollo_de_aplicaciones_web_con_elixir/#palabras-clave","text":"Elixir: Lenguaje de programaci\u00f3n funcional y din\u00e1mico. Phoenix: Framework web para Elixir. Erlang: M\u00e1quina virtual en la que se ejecuta Elixir. Escalabilidad: Capacidad de una aplicaci\u00f3n para manejar un aumento en la cantidad de usuarios o tr\u00e1fico sin afectar su rendimiento. Rendimiento: Velocidad y eficiencia de una aplicaci\u00f3n. Concurrente: Capacidad de realizar m\u00faltiples tareas al mismo tiempo.","title":"Palabras clave"},{"location":"elixir/jr/desarrollo_de_aplicaciones_web_con_elixir/#teoria","text":"","title":"Teor\u00eda"},{"location":"elixir/jr/desarrollo_de_aplicaciones_web_con_elixir/#framework-phoenix","text":"Phoenix es un framework web para Elixir que est\u00e1 basado en el patr\u00f3n de arquitectura Modelo-Vista-Controlador (MVC). Utiliza el lenguaje de plantillas EEx para generar el contenido HTML y utiliza el protocolo HTTP para comunicarse con el navegador. Phoenix tambi\u00e9n incluye una capa de enrutamiento, que permite mapear las URL a las acciones correspondientes en el controlador.","title":"Framework Phoenix"},{"location":"elixir/jr/desarrollo_de_aplicaciones_web_con_elixir/#procesos-y-concurrencia","text":"Una de las caracter\u00edsticas m\u00e1s importantes de Elixir es su capacidad para manejar m\u00faltiples procesos concurrentes. En Elixir, los procesos son ligeros y tienen un costo muy bajo, lo que permite tener miles de ellos ejecut\u00e1ndose simult\u00e1neamente sin afectar el rendimiento de la aplicaci\u00f3n. Esto es especialmente \u00fatil para aplicaciones web que deben manejar muchas solicitudes simult\u00e1neas.","title":"Procesos y concurrencia"},{"location":"elixir/jr/desarrollo_de_aplicaciones_web_con_elixir/#ecto","text":"Ecto es un m\u00f3dulo de Elixir que proporciona un lenguaje de consulta para interactuar con bases de datos. Utiliza el patr\u00f3n de dise\u00f1o de repositorio para abstraer la l\u00f3gica de acceso a la base de datos y facilitar la manipulaci\u00f3n de datos en la aplicaci\u00f3n.","title":"Ecto"},{"location":"elixir/jr/desarrollo_de_aplicaciones_web_con_elixir/#canales","text":"Los canales son una caracter\u00edstica de Phoenix que permite la comunicaci\u00f3n bidireccional en tiempo real entre el servidor y el cliente. Esto es \u00fatil para crear aplicaciones en tiempo real, como chats o juegos multijugador.","title":"Canales"},{"location":"elixir/jr/desarrollo_de_aplicaciones_web_con_elixir/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Elixir y por qu\u00e9 se ha vuelto tan popular en los \u00faltimos a\u00f1os? \u00bfCu\u00e1l es la principal fortaleza de Elixir en el desarrollo de aplicaciones web? \u00bfQu\u00e9 es Phoenix y en qu\u00e9 se basa su arquitectura? \u00bfC\u00f3mo maneja Elixir la concurrencia y por qu\u00e9 es importante en el desarrollo de aplicaciones web? \u00bfQu\u00e9 es Ecto y c\u00f3mo ayuda en la interacci\u00f3n con bases de datos? \u00bfQu\u00e9 son los canales en Phoenix y para qu\u00e9 se utilizan?","title":"Preguntas de repaso"},{"location":"elixir/jr/desarrollo_de_aplicaciones_web_con_elixir/#ejemplos-de-codigo-en-elixir","text":"# Definici\u00f3n de un m\u00f3dulo en Elixir defmodule Saludo do # Funci\u00f3n que imprime un saludo def decir_hola(nombre) do IO.puts(\"\u00a1Hola #{nombre}!\") end end # Llamada a la funci\u00f3n decir_hola Saludo.decir_hola(\"Juan\") # Output: \u00a1Hola Juan! # Creaci\u00f3n de un canal en Phoenix defmodule ChatWeb.RoomChannel do use Phoenix.Channel # Funci\u00f3n que se ejecuta al unirse al canal def join(\"room:\" <> room_id, _params, socket) do {:ok, socket} end # Funci\u00f3n que se ejecuta al recibir un mensaje del cliente def handle_in(\"new_msg\", %{\"body\" => body}, socket) do broadcast(socket, \"new_msg\", %{body: body}) {:noreply, socket} end end","title":"Ejemplos de c\u00f3digo en Elixir"},{"location":"elixir/jr/desarrollo_de_aplicaciones_web_con_elixir/#ejercicios-practicos","text":"Crea un nuevo proyecto de Phoenix utilizando el comando mix phx.new . Agrega una funci\u00f3n en el controlador que reciba una solicitud GET y devuelva un mensaje de saludo. Crea una base de datos utilizando Ecto y realiza una consulta para obtener todos los registros de una tabla. Crea un canal en Phoenix para permitir la comunicaci\u00f3n en tiempo real entre el servidor y el cliente. Agrega una funci\u00f3n en el canal que env\u00ede un mensaje a todos los clientes conectados cada vez que un nuevo mensaje es recibido.","title":"Ejercicios pr\u00e1cticos"},{"location":"elixir/jr/desarrollo_de_aplicaciones_web_con_elixir/#consejos-y-mejores-practicas","text":"Utiliza el patr\u00f3n de dise\u00f1o de repositorio para abstraer la l\u00f3gica de acceso a la base de datos y mantener el c\u00f3digo m\u00e1s organizado y f\u00e1cil de mantener. Aprovecha la concurrencia en Elixir para crear aplicaciones altamente escalables y de alto rendimiento. Utiliza los canales en Phoenix para crear aplicaciones en tiempo real y mejorar la experiencia del usuario. Sigue las convenciones de nomenclatura y buenas pr\u00e1cticas de Elixir para mantener el c\u00f3digo legible y consistente.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"elixir/jr/desarrollo_de_aplicaciones_web_con_elixir/#navegacion-de-lecciones","text":"<- Lecci\u00f3n anterior : M\u00f3dulos de la librer\u00eda est\u00e1ndar de Elixir Siguiente lecci\u00f3n -> : Pruebas y depuraci\u00f3n","title":"Navegaci\u00f3n de lecciones"},{"location":"elixir/jr/despliegue_de_aplicaciones_elixir/","text":"Despliegue de aplicaciones Elixir \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 El despliegue de aplicaciones Elixir se refiere al proceso de llevar una aplicaci\u00f3n desarrollada en este lenguaje a un entorno de producci\u00f3n, donde los usuarios pueden acceder y utilizarla. Este proceso es crucial para cualquier proyecto en Elixir, ya que permite que la aplicaci\u00f3n sea utilizada de manera eficiente y confiable. Existen diferentes opciones para desplegar aplicaciones Elixir en producci\u00f3n, y la elecci\u00f3n depender\u00e1 de las necesidades y requerimientos del proyecto en particular. Algunas de las opciones m\u00e1s comunes son el uso de contenedores y servicios de hosting. Los contenedores son una forma de empaquetar una aplicaci\u00f3n junto con todas sus dependencias en un entorno aislado y port\u00e1til. Esto permite que la aplicaci\u00f3n se ejecute de manera consistente en diferentes sistemas operativos y plataformas. Algunas herramientas populares para el despliegue de aplicaciones Elixir en contenedores son Docker y Kubernetes. Por otro lado, los servicios de hosting son plataformas que ofrecen entornos de producci\u00f3n listos para ejecutar aplicaciones Elixir. Estos servicios se encargan de la configuraci\u00f3n y mantenimiento de los servidores, permitiendo que los desarrolladores se enfoquen en la creaci\u00f3n y mejora de la aplicaci\u00f3n. Algunos ejemplos de servicios de hosting para aplicaciones Elixir son Heroku, Gigalixir y Fly.io. En ambos casos, es importante tener en cuenta aspectos como la escalabilidad, el rendimiento y la seguridad al elegir una opci\u00f3n de despliegue para una aplicaci\u00f3n Elixir. Palabras clave y su definici\u00f3n \u00b6 Despliegue: proceso de llevar una aplicaci\u00f3n a un entorno de producci\u00f3n. Contenedor: tecnolog\u00eda de virtualizaci\u00f3n que permite empaquetar una aplicaci\u00f3n junto con sus dependencias en un entorno aislado y port\u00e1til. Servicio de hosting: plataforma que ofrece entornos de producci\u00f3n listos para ejecutar aplicaciones. Escalabilidad: capacidad de una aplicaci\u00f3n para manejar un aumento en la cantidad de usuarios o tr\u00e1fico. Rendimiento: medida de la eficiencia y velocidad de una aplicaci\u00f3n. Seguridad: conjunto de medidas tomadas para proteger una aplicaci\u00f3n contra posibles ataques o vulnerabilidades. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es el despliegue de aplicaciones Elixir? \u00bfCu\u00e1les son algunas opciones comunes para desplegar aplicaciones Elixir en producci\u00f3n? \u00bfQu\u00e9 es un contenedor y c\u00f3mo ayuda en el despliegue de aplicaciones Elixir? \u00bfQu\u00e9 son los servicios de hosting y cu\u00e1l es su ventaja en el despliegue de aplicaciones Elixir? \u00bfQu\u00e9 aspectos se deben tener en cuenta al elegir una opci\u00f3n de despliegue para una aplicaci\u00f3n Elixir? Ejemplos de c\u00f3digo en Elixir \u00b6 Crear una aplicaci\u00f3n Elixir \u00b6 mix new my_app Configurar una aplicaci\u00f3n para ser desplegada en Heroku \u00b6 Agregar las dependencias necesarias en el archivo mix.exs: defp deps do [ {: plug_cowboy , \"~> 2.0\" }, {: phoenix , \"~> 1.5.0\" }, {: phoenix_ecto , \"~> 4.1\" }, {: ecto_sql , \"~> 3.0\" }, {: postgrex , \">= 0.0.0\" }, {: distillery , \"~> 2.0\" }, {: phoenix_live_reload , \"~> 1.2\" , only : : dev } ] end Crear un archivo Procfile para especificar c\u00f3mo se debe iniciar la aplicaci\u00f3n: web : MIX_ENV = prod mix release -- no - tar -- no - silent Crear un archivo config/prod.exs para configurar la base de datos y otras variables de entorno: config : my_app , MyApp . Repo , adapter : Ecto . Adapters . Postgres , username : System . get_env ( \"DB_USERNAME\" ), password : System . get_env ( \"DB_PASSWORD\" ), database : System . get_env ( \"DB_NAME\" ), hostname : System . get_env ( \"DB_HOSTNAME\" ), pool_size : 10 Generar una migraci\u00f3n para crear la base de datos: mix ecto.gen.migration create_table Configurar la aplicaci\u00f3n para utilizar Distillery en el archivo config/config.exs: config : my_app , MyApp . Release , migration_commands : &[ \"ecto.migrate\" ], start_commands : &[ \"ecto.migrate\" , \"phx.server\" ] Generar un release de la aplicaci\u00f3n: MIX_ENV=prod mix release Crear una aplicaci\u00f3n en Heroku y configurar las variables de entorno necesarias (DB_USERNAME, DB_PASSWORD, DB_NAME, DB_HOSTNAME). Subir la aplicaci\u00f3n a Heroku: heroku create git push heroku master Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una aplicaci\u00f3n Elixir utilizando el comando mix new . Configura la aplicaci\u00f3n para ser desplegada en Heroku siguiendo los pasos mencionados en el ejemplo de c\u00f3digo. Genera un release de la aplicaci\u00f3n y sube la aplicaci\u00f3n a Heroku. Crea un contenedor para la aplicaci\u00f3n utilizando Docker. Configura un servicio de hosting y sube la aplicaci\u00f3n a este servicio. Consejos o mejores pr\u00e1cticas \u00b6 Utilizar contenedores o servicios de hosting en lugar de configurar manualmente un servidor para desplegar una aplicaci\u00f3n Elixir. Realizar pruebas de rendimiento y seguridad antes de elegir una opci\u00f3n de despliegue en producci\u00f3n. Utilizar herramientas como Distillery para generar releases de la aplicaci\u00f3n y facilitar el proceso de despliegue. Configurar correctamente las variables de entorno en el entorno de producci\u00f3n para mantener la seguridad de la aplicaci\u00f3n. Revisar y actualizar regularmente las dependencias de la aplicaci\u00f3n para mantenerla segura y eficiente. Navegaci\u00f3n de lecciones \u00b6 <- Lecci\u00f3n anterior : Pruebas y depuraci\u00f3n Siguiente lecci\u00f3n -> : Supervisi\u00f3n de procesos","title":"Despliegue de aplicaciones Elixir"},{"location":"elixir/jr/despliegue_de_aplicaciones_elixir/#despliegue-de-aplicaciones-elixir","text":"","title":"Despliegue de aplicaciones Elixir"},{"location":"elixir/jr/despliegue_de_aplicaciones_elixir/#explicacion-teorica","text":"El despliegue de aplicaciones Elixir se refiere al proceso de llevar una aplicaci\u00f3n desarrollada en este lenguaje a un entorno de producci\u00f3n, donde los usuarios pueden acceder y utilizarla. Este proceso es crucial para cualquier proyecto en Elixir, ya que permite que la aplicaci\u00f3n sea utilizada de manera eficiente y confiable. Existen diferentes opciones para desplegar aplicaciones Elixir en producci\u00f3n, y la elecci\u00f3n depender\u00e1 de las necesidades y requerimientos del proyecto en particular. Algunas de las opciones m\u00e1s comunes son el uso de contenedores y servicios de hosting. Los contenedores son una forma de empaquetar una aplicaci\u00f3n junto con todas sus dependencias en un entorno aislado y port\u00e1til. Esto permite que la aplicaci\u00f3n se ejecute de manera consistente en diferentes sistemas operativos y plataformas. Algunas herramientas populares para el despliegue de aplicaciones Elixir en contenedores son Docker y Kubernetes. Por otro lado, los servicios de hosting son plataformas que ofrecen entornos de producci\u00f3n listos para ejecutar aplicaciones Elixir. Estos servicios se encargan de la configuraci\u00f3n y mantenimiento de los servidores, permitiendo que los desarrolladores se enfoquen en la creaci\u00f3n y mejora de la aplicaci\u00f3n. Algunos ejemplos de servicios de hosting para aplicaciones Elixir son Heroku, Gigalixir y Fly.io. En ambos casos, es importante tener en cuenta aspectos como la escalabilidad, el rendimiento y la seguridad al elegir una opci\u00f3n de despliegue para una aplicaci\u00f3n Elixir.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"elixir/jr/despliegue_de_aplicaciones_elixir/#palabras-clave-y-su-definicion","text":"Despliegue: proceso de llevar una aplicaci\u00f3n a un entorno de producci\u00f3n. Contenedor: tecnolog\u00eda de virtualizaci\u00f3n que permite empaquetar una aplicaci\u00f3n junto con sus dependencias en un entorno aislado y port\u00e1til. Servicio de hosting: plataforma que ofrece entornos de producci\u00f3n listos para ejecutar aplicaciones. Escalabilidad: capacidad de una aplicaci\u00f3n para manejar un aumento en la cantidad de usuarios o tr\u00e1fico. Rendimiento: medida de la eficiencia y velocidad de una aplicaci\u00f3n. Seguridad: conjunto de medidas tomadas para proteger una aplicaci\u00f3n contra posibles ataques o vulnerabilidades.","title":"Palabras clave y su definici\u00f3n"},{"location":"elixir/jr/despliegue_de_aplicaciones_elixir/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es el despliegue de aplicaciones Elixir? \u00bfCu\u00e1les son algunas opciones comunes para desplegar aplicaciones Elixir en producci\u00f3n? \u00bfQu\u00e9 es un contenedor y c\u00f3mo ayuda en el despliegue de aplicaciones Elixir? \u00bfQu\u00e9 son los servicios de hosting y cu\u00e1l es su ventaja en el despliegue de aplicaciones Elixir? \u00bfQu\u00e9 aspectos se deben tener en cuenta al elegir una opci\u00f3n de despliegue para una aplicaci\u00f3n Elixir?","title":"Preguntas de repaso"},{"location":"elixir/jr/despliegue_de_aplicaciones_elixir/#ejemplos-de-codigo-en-elixir","text":"","title":"Ejemplos de c\u00f3digo en Elixir"},{"location":"elixir/jr/despliegue_de_aplicaciones_elixir/#crear-una-aplicacion-elixir","text":"mix new my_app","title":"Crear una aplicaci\u00f3n Elixir"},{"location":"elixir/jr/despliegue_de_aplicaciones_elixir/#configurar-una-aplicacion-para-ser-desplegada-en-heroku","text":"Agregar las dependencias necesarias en el archivo mix.exs: defp deps do [ {: plug_cowboy , \"~> 2.0\" }, {: phoenix , \"~> 1.5.0\" }, {: phoenix_ecto , \"~> 4.1\" }, {: ecto_sql , \"~> 3.0\" }, {: postgrex , \">= 0.0.0\" }, {: distillery , \"~> 2.0\" }, {: phoenix_live_reload , \"~> 1.2\" , only : : dev } ] end Crear un archivo Procfile para especificar c\u00f3mo se debe iniciar la aplicaci\u00f3n: web : MIX_ENV = prod mix release -- no - tar -- no - silent Crear un archivo config/prod.exs para configurar la base de datos y otras variables de entorno: config : my_app , MyApp . Repo , adapter : Ecto . Adapters . Postgres , username : System . get_env ( \"DB_USERNAME\" ), password : System . get_env ( \"DB_PASSWORD\" ), database : System . get_env ( \"DB_NAME\" ), hostname : System . get_env ( \"DB_HOSTNAME\" ), pool_size : 10 Generar una migraci\u00f3n para crear la base de datos: mix ecto.gen.migration create_table Configurar la aplicaci\u00f3n para utilizar Distillery en el archivo config/config.exs: config : my_app , MyApp . Release , migration_commands : &[ \"ecto.migrate\" ], start_commands : &[ \"ecto.migrate\" , \"phx.server\" ] Generar un release de la aplicaci\u00f3n: MIX_ENV=prod mix release Crear una aplicaci\u00f3n en Heroku y configurar las variables de entorno necesarias (DB_USERNAME, DB_PASSWORD, DB_NAME, DB_HOSTNAME). Subir la aplicaci\u00f3n a Heroku: heroku create git push heroku master","title":"Configurar una aplicaci\u00f3n para ser desplegada en Heroku"},{"location":"elixir/jr/despliegue_de_aplicaciones_elixir/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una aplicaci\u00f3n Elixir utilizando el comando mix new . Configura la aplicaci\u00f3n para ser desplegada en Heroku siguiendo los pasos mencionados en el ejemplo de c\u00f3digo. Genera un release de la aplicaci\u00f3n y sube la aplicaci\u00f3n a Heroku. Crea un contenedor para la aplicaci\u00f3n utilizando Docker. Configura un servicio de hosting y sube la aplicaci\u00f3n a este servicio.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"elixir/jr/despliegue_de_aplicaciones_elixir/#consejos-o-mejores-practicas","text":"Utilizar contenedores o servicios de hosting en lugar de configurar manualmente un servidor para desplegar una aplicaci\u00f3n Elixir. Realizar pruebas de rendimiento y seguridad antes de elegir una opci\u00f3n de despliegue en producci\u00f3n. Utilizar herramientas como Distillery para generar releases de la aplicaci\u00f3n y facilitar el proceso de despliegue. Configurar correctamente las variables de entorno en el entorno de producci\u00f3n para mantener la seguridad de la aplicaci\u00f3n. Revisar y actualizar regularmente las dependencias de la aplicaci\u00f3n para mantenerla segura y eficiente.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"elixir/jr/despliegue_de_aplicaciones_elixir/#navegacion-de-lecciones","text":"<- Lecci\u00f3n anterior : Pruebas y depuraci\u00f3n Siguiente lecci\u00f3n -> : Supervisi\u00f3n de procesos","title":"Navegaci\u00f3n de lecciones"},{"location":"elixir/jr/funciones/","text":"Funciones Las funciones son uno de los conceptos fundamentales en Elixir, ya que permiten encapsular l\u00f3gica y reutilizarla en diferentes partes de un programa. Una funci\u00f3n es un bloque de c\u00f3digo que recibe argumentos y devuelve un resultado. En Elixir, se definen utilizando la palabra clave \"def\" seguida del nombre de la funci\u00f3n y sus argumentos entre par\u00e9ntesis. Luego, se utiliza la palabra clave \"do\" para indicar el inicio del cuerpo de la funci\u00f3n, y el resultado se obtiene con la palabra clave \"end\". Palabras clave y su definici\u00f3n: def: palabra clave utilizada para definir una funci\u00f3n en Elixir. do: palabra clave utilizada para indicar el inicio del cuerpo de una funci\u00f3n. end: palabra clave utilizada para indicar el fin del cuerpo de una funci\u00f3n. funci\u00f3n: bloque de c\u00f3digo que recibe argumentos y devuelve un resultado. argumentos: valores que se pasan a una funci\u00f3n para ser procesados. resultado: valor devuelto por una funci\u00f3n despu\u00e9s de procesar los argumentos. Preguntas de repaso: \u00bfQu\u00e9 es una funci\u00f3n en Elixir? \u00bfC\u00f3mo se define una funci\u00f3n en Elixir? \u00bfQu\u00e9 son los argumentos de una funci\u00f3n? \u00bfQu\u00e9 es el resultado de una funci\u00f3n? \u00bfCu\u00e1les son las palabras clave utilizadas para definir una funci\u00f3n en Elixir? Ejemplos de c\u00f3digo en Elixir: Definir una funci\u00f3n que sume dos n\u00fameros: def sumar ( a , b ) do a + b end Definir una funci\u00f3n que multiplique un n\u00famero por s\u00ed mismo: def cuadrado(x) do x * x end Ejercicios pr\u00e1cticos: Escribir una funci\u00f3n que calcule el \u00e1rea de un c\u00edrculo, utilizando la f\u00f3rmula A = \u03c0r\u00b2. La funci\u00f3n debe recibir el radio como argumento y devolver el \u00e1rea como resultado. def area_circulo(r) do 3.14 * r * r end Escribir una funci\u00f3n que convierta grados Celsius a Fahrenheit, utilizando la f\u00f3rmula F = (C * 9/5) + 32. La funci\u00f3n debe recibir la temperatura en grados Celsius como argumento y devolver la temperatura en grados Fahrenheit como resultado. def celsius_a_fahrenheit(c) do (c * 9/5) + 32 end Consejos o mejores pr\u00e1cticas: Utilizar nombres descriptivos para las funciones, que indiquen claramente su prop\u00f3sito. Evitar funciones con un n\u00famero excesivo de argumentos, ya que dificultan la comprensi\u00f3n y el mantenimiento del c\u00f3digo. Utilizar patrones en los argumentos de las funciones para manejar diferentes casos y mejorar la legibilidad. Utilizar comentarios para explicar el prop\u00f3sito y funcionamiento de una funci\u00f3n. Probar y depurar las funciones individualmente antes de integrarlas en el resto del programa.","title":"Funciones"},{"location":"elixir/jr/introduccion_a_elixir/","text":"Introducci\u00f3n a Elixir \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En este m\u00f3dulo aprender\u00e1s los fundamentos de Elixir, un lenguaje de programaci\u00f3n funcional y concurrente dise\u00f1ado para construir aplicaciones escalables y fiables. Conocer\u00e1s su historia, caracter\u00edsticas y ventajas, y aprender\u00e1s a escribir c\u00f3digo en Elixir utilizando ejemplos y ejercicios pr\u00e1cticos. Explicaci\u00f3n te\u00f3rica \u00b6 Elixir fue creado en 2011 por Jos\u00e9 Valim, un desarrollador brasile\u00f1o, con el objetivo de mejorar la productividad y la escalabilidad de las aplicaciones web. Est\u00e1 basado en Erlang, un lenguaje de programaci\u00f3n de sistemas utilizado en aplicaciones de telecomunicaciones, y se ejecuta en la m\u00e1quina virtual de Erlang (BEAM). Elixir se ha vuelto cada vez m\u00e1s popular en los \u00faltimos a\u00f1os gracias a su capacidad para gestionar grandes vol\u00famenes de datos y procesos concurrentes, y su comunidad activa y colaborativa. Palabras clave y su definici\u00f3n \u00b6 Lenguaje de programaci\u00f3n: un conjunto de reglas y s\u00edmbolos utilizados para escribir instrucciones que una computadora puede entender y ejecutar. Funcional: un paradigma de programaci\u00f3n en el que los programas se construyen a partir de funciones, que son unidades de c\u00f3digo que reciben una entrada y producen una salida. Concurrente: la capacidad de un programa para realizar varias tareas al mismo tiempo. Escalabilidad: la capacidad de un sistema para manejar un aumento en la carga de trabajo sin disminuir su rendimiento. M\u00e1quina virtual: un entorno de ejecuci\u00f3n que permite que un programa se ejecute en diferentes sistemas operativos y hardware sin cambios en el c\u00f3digo fuente. Preguntas de repaso \u00b6 \u00bfQui\u00e9n cre\u00f3 Elixir y en qu\u00e9 a\u00f1o? \u00bfEn qu\u00e9 est\u00e1 basado Elixir? \u00bfQu\u00e9 es la escalabilidad y por qu\u00e9 es importante en las aplicaciones web? \u00bfQu\u00e9 es una m\u00e1quina virtual y por qu\u00e9 es \u00fatil en el contexto de Elixir? Instalaci\u00f3n de Elixir \u00b6 A continuaci\u00f3n, se muestra un breve resumen de c\u00f3mo instalar Elixir en distintos sistemas operativos. Para m\u00e1s detalles, puedes consultar la documentaci\u00f3n oficial . En Windows \u00b6 Descarga el instalador de Elixir desde la p\u00e1gina oficial o utiliza un administrador de paquetes como Chocolatey : choco install elixir Una vez instalado, abre una terminal (PowerShell o CMD) y verifica la instalaci\u00f3n: elixir -v En macOS \u00b6 Si tienes Homebrew instalado: brew update brew install elixir Verifica la instalaci\u00f3n: elixir -v En Linux \u00b6 Ubuntu/Debian : sudo apt-get update sudo apt-get install elixir Fedora/RHEL : sudo dnf install elixir O utiliza la herramienta de versiones asdf para instalar y administrar m\u00faltiples versiones de Elixir y Erlang. Tras la instalaci\u00f3n, confirma la versi\u00f3n con: elixir -v Uso de la consola interactiva (IEx) \u00b6 Elixir incluye una consola interactiva llamada IEx , ideal para realizar pruebas r\u00e1pidas de c\u00f3digo y experimentar con Elixir. Para abrirla, simplemente escribe en tu terminal: iex Dentro de IEx, podr\u00e1s ejecutar expresiones Elixir, ver resultados de forma inmediata y cargar m\u00f3dulos o archivos con facilidad. Ejemplo : iex > IO . puts ( \"\u00a1Hola, Elixir!\" ) \u00a1 Hola , Elixir ! :ok Para salir de IEx, presiona Ctrl + C dos veces. Ejecutar scripts de Elixir \u00b6 Si tienes un archivo .exs (script de Elixir), puedes ejecutarlo directamente desde la terminal con: elixir nombre_del_script.exs Por ejemplo, si tu archivo se llama hola.exs y contiene: IO . puts ( \"\u00a1Hola desde un script de Elixir!\" ) Entonces, al correr: elixir hola.exs ver\u00e1s en la salida de tu terminal: \u00a1Hola desde un script de Elixir! Con estos pasos, ya podr\u00e1s instalar Elixir en tu sistema, probar c\u00f3digo de manera interactiva en IEx y ejecutar scripts en tu entorno local. Ejemplos de c\u00f3digo en Elixir \u00b6 Hola mundo \u00b6 IO.puts \"\u00a1Hola mundo!\" Funciones \u00b6 defmodule Calculadora do def sumar ( a , b ) do a + b end def restar ( a , b ) do a - b end end Concurrente \u00b6 defmodule Proceso do def imprimir_mensaje ( mensaje ) do IO . puts mensaje end end spawn ( fn -> Proceso . imprimir_mensaje ( \"\u00a1Hola!\" ) end) spawn ( fn -> Proceso . imprimir_mensaje ( \"\u00a1Mundo!\" ) end) Ejercicios pr\u00e1cticos \u00b6 Crea una funci\u00f3n en Elixir que multiplique dos n\u00fameros. Escribe un programa concurrente en Elixir que imprima \"\u00a1Hola!\" y \"\u00a1Mundo!\" al mismo tiempo. Utiliza Elixir para calcular el \u00e1rea de un c\u00edrculo con un radio dado. Consejos o mejores pr\u00e1cticas \u00b6 Aprende los conceptos b\u00e1sicos de Erlang antes de sumergirte en Elixir. Utiliza la documentaci\u00f3n oficial y la comunidad para resolver problemas y aprender nuevas t\u00e9cnicas. Practica la concurrencia y la programaci\u00f3n funcional para aprovechar al m\u00e1ximo las capacidades de Elixir. Navegaci\u00f3n de lecciones \u00b6 Siguiente lecci\u00f3n -> : Sintaxis b\u00e1sica","title":"Introducci\u00f3n a Elixir"},{"location":"elixir/jr/introduccion_a_elixir/#introduccion-a-elixir","text":"","title":"Introducci\u00f3n a Elixir"},{"location":"elixir/jr/introduccion_a_elixir/#descripcion-del-modulo","text":"En este m\u00f3dulo aprender\u00e1s los fundamentos de Elixir, un lenguaje de programaci\u00f3n funcional y concurrente dise\u00f1ado para construir aplicaciones escalables y fiables. Conocer\u00e1s su historia, caracter\u00edsticas y ventajas, y aprender\u00e1s a escribir c\u00f3digo en Elixir utilizando ejemplos y ejercicios pr\u00e1cticos.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"elixir/jr/introduccion_a_elixir/#explicacion-teorica","text":"Elixir fue creado en 2011 por Jos\u00e9 Valim, un desarrollador brasile\u00f1o, con el objetivo de mejorar la productividad y la escalabilidad de las aplicaciones web. Est\u00e1 basado en Erlang, un lenguaje de programaci\u00f3n de sistemas utilizado en aplicaciones de telecomunicaciones, y se ejecuta en la m\u00e1quina virtual de Erlang (BEAM). Elixir se ha vuelto cada vez m\u00e1s popular en los \u00faltimos a\u00f1os gracias a su capacidad para gestionar grandes vol\u00famenes de datos y procesos concurrentes, y su comunidad activa y colaborativa.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"elixir/jr/introduccion_a_elixir/#palabras-clave-y-su-definicion","text":"Lenguaje de programaci\u00f3n: un conjunto de reglas y s\u00edmbolos utilizados para escribir instrucciones que una computadora puede entender y ejecutar. Funcional: un paradigma de programaci\u00f3n en el que los programas se construyen a partir de funciones, que son unidades de c\u00f3digo que reciben una entrada y producen una salida. Concurrente: la capacidad de un programa para realizar varias tareas al mismo tiempo. Escalabilidad: la capacidad de un sistema para manejar un aumento en la carga de trabajo sin disminuir su rendimiento. M\u00e1quina virtual: un entorno de ejecuci\u00f3n que permite que un programa se ejecute en diferentes sistemas operativos y hardware sin cambios en el c\u00f3digo fuente.","title":"Palabras clave y su definici\u00f3n"},{"location":"elixir/jr/introduccion_a_elixir/#preguntas-de-repaso","text":"\u00bfQui\u00e9n cre\u00f3 Elixir y en qu\u00e9 a\u00f1o? \u00bfEn qu\u00e9 est\u00e1 basado Elixir? \u00bfQu\u00e9 es la escalabilidad y por qu\u00e9 es importante en las aplicaciones web? \u00bfQu\u00e9 es una m\u00e1quina virtual y por qu\u00e9 es \u00fatil en el contexto de Elixir?","title":"Preguntas de repaso"},{"location":"elixir/jr/introduccion_a_elixir/#instalacion-de-elixir","text":"A continuaci\u00f3n, se muestra un breve resumen de c\u00f3mo instalar Elixir en distintos sistemas operativos. Para m\u00e1s detalles, puedes consultar la documentaci\u00f3n oficial .","title":"Instalaci\u00f3n de Elixir"},{"location":"elixir/jr/introduccion_a_elixir/#en-windows","text":"Descarga el instalador de Elixir desde la p\u00e1gina oficial o utiliza un administrador de paquetes como Chocolatey : choco install elixir Una vez instalado, abre una terminal (PowerShell o CMD) y verifica la instalaci\u00f3n: elixir -v","title":"En Windows"},{"location":"elixir/jr/introduccion_a_elixir/#en-macos","text":"Si tienes Homebrew instalado: brew update brew install elixir Verifica la instalaci\u00f3n: elixir -v","title":"En macOS"},{"location":"elixir/jr/introduccion_a_elixir/#en-linux","text":"Ubuntu/Debian : sudo apt-get update sudo apt-get install elixir Fedora/RHEL : sudo dnf install elixir O utiliza la herramienta de versiones asdf para instalar y administrar m\u00faltiples versiones de Elixir y Erlang. Tras la instalaci\u00f3n, confirma la versi\u00f3n con: elixir -v","title":"En Linux"},{"location":"elixir/jr/introduccion_a_elixir/#uso-de-la-consola-interactiva-iex","text":"Elixir incluye una consola interactiva llamada IEx , ideal para realizar pruebas r\u00e1pidas de c\u00f3digo y experimentar con Elixir. Para abrirla, simplemente escribe en tu terminal: iex Dentro de IEx, podr\u00e1s ejecutar expresiones Elixir, ver resultados de forma inmediata y cargar m\u00f3dulos o archivos con facilidad. Ejemplo : iex > IO . puts ( \"\u00a1Hola, Elixir!\" ) \u00a1 Hola , Elixir ! :ok Para salir de IEx, presiona Ctrl + C dos veces.","title":"Uso de la consola interactiva (IEx)"},{"location":"elixir/jr/introduccion_a_elixir/#ejecutar-scripts-de-elixir","text":"Si tienes un archivo .exs (script de Elixir), puedes ejecutarlo directamente desde la terminal con: elixir nombre_del_script.exs Por ejemplo, si tu archivo se llama hola.exs y contiene: IO . puts ( \"\u00a1Hola desde un script de Elixir!\" ) Entonces, al correr: elixir hola.exs ver\u00e1s en la salida de tu terminal: \u00a1Hola desde un script de Elixir! Con estos pasos, ya podr\u00e1s instalar Elixir en tu sistema, probar c\u00f3digo de manera interactiva en IEx y ejecutar scripts en tu entorno local.","title":"Ejecutar scripts de Elixir"},{"location":"elixir/jr/introduccion_a_elixir/#ejemplos-de-codigo-en-elixir","text":"","title":"Ejemplos de c\u00f3digo en Elixir"},{"location":"elixir/jr/introduccion_a_elixir/#hola-mundo","text":"IO.puts \"\u00a1Hola mundo!\"","title":"Hola mundo"},{"location":"elixir/jr/introduccion_a_elixir/#funciones","text":"defmodule Calculadora do def sumar ( a , b ) do a + b end def restar ( a , b ) do a - b end end","title":"Funciones"},{"location":"elixir/jr/introduccion_a_elixir/#concurrente","text":"defmodule Proceso do def imprimir_mensaje ( mensaje ) do IO . puts mensaje end end spawn ( fn -> Proceso . imprimir_mensaje ( \"\u00a1Hola!\" ) end) spawn ( fn -> Proceso . imprimir_mensaje ( \"\u00a1Mundo!\" ) end)","title":"Concurrente"},{"location":"elixir/jr/introduccion_a_elixir/#ejercicios-practicos","text":"Crea una funci\u00f3n en Elixir que multiplique dos n\u00fameros. Escribe un programa concurrente en Elixir que imprima \"\u00a1Hola!\" y \"\u00a1Mundo!\" al mismo tiempo. Utiliza Elixir para calcular el \u00e1rea de un c\u00edrculo con un radio dado.","title":"Ejercicios pr\u00e1cticos"},{"location":"elixir/jr/introduccion_a_elixir/#consejos-o-mejores-practicas","text":"Aprende los conceptos b\u00e1sicos de Erlang antes de sumergirte en Elixir. Utiliza la documentaci\u00f3n oficial y la comunidad para resolver problemas y aprender nuevas t\u00e9cnicas. Practica la concurrencia y la programaci\u00f3n funcional para aprovechar al m\u00e1ximo las capacidades de Elixir.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"elixir/jr/introduccion_a_elixir/#navegacion-de-lecciones","text":"Siguiente lecci\u00f3n -> : Sintaxis b\u00e1sica","title":"Navegaci\u00f3n de lecciones"},{"location":"elixir/jr/listas_y_tuplas/","text":"Listas y tuplas en Elixir \u00b6 Introducci\u00f3n \u00b6 En Elixir, las listas y tuplas son dos de las estructuras de datos m\u00e1s utilizadas. Aunque pueden parecer similares, tienen diferentes caracter\u00edsticas y se utilizan para diferentes prop\u00f3sitos. En esta lecci\u00f3n, exploraremos en profundidad las listas y tuplas en Elixir, c\u00f3mo se crean, modifican y utilizan en la programaci\u00f3n. Listas \u00b6 Las listas en Elixir son una colecci\u00f3n ordenada de elementos del mismo tipo o de diferentes tipos. Se crean utilizando corchetes y separando los elementos con comas. list = [ 1 , 2 , 3 , 4 ] Las listas son estructuras de datos din\u00e1micas, lo que significa que se pueden modificar agregando o eliminando elementos. Para agregar un elemento al final de la lista, se utiliza el operador ++ : list ++ [ 5 ] Esto devolver\u00e1 una nueva lista con el elemento agregado al final. Para eliminar un elemento de la lista, se utiliza el operador -- : list -- [ 3 ] Esto devolver\u00e1 una nueva lista sin el elemento especificado. Tambi\u00e9n se pueden agregar o eliminar m\u00faltiples elementos a la vez utilizando el mismo operador. Otra caracter\u00edstica importante de las listas en Elixir es que se pueden acceder a sus elementos mediante su \u00edndice, comenzando desde 0. Esto se hace utilizando el operador de acceso [] seguido del \u00edndice del elemento deseado: list = [ \"a\" , \"b\" , \"c\" , \"d\" ] list [ 2 ] # Devuelve \"c\" Tuplas \u00b6 Las tuplas en Elixir son una colecci\u00f3n ordenada de elementos del mismo tipo o de diferentes tipos, al igual que las listas. Sin embargo, a diferencia de las listas, las tuplas son estructuras de datos inmutables, lo que significa que no se pueden modificar una vez creadas. Se crean utilizando llaves y separando los elementos con comas. tuple = { :ok , \"Hola\" , 1 } Aunque las tuplas no se pueden modificar, se pueden acceder a sus elementos de la misma manera que en las listas, utilizando el operador de acceso [] seguido del \u00edndice del elemento deseado: tuple = { :ok , \"Hola\" , 1 } tuple [ 1 ] # Devuelve \"Hola\" Palabras clave \u00b6 Listas: colecciones ordenadas de elementos en Elixir que se pueden modificar. Tuplas: colecciones ordenadas de elementos en Elixir que no se pueden modificar. Din\u00e1mico: en el contexto de las estructuras de datos, se refiere a la capacidad de ser modificadas. Inmutable: en el contexto de las estructuras de datos, se refiere a la incapacidad de ser modificadas. Preguntas de repaso \u00b6 \u00bfCu\u00e1l es la diferencia principal entre las listas y tuplas en Elixir? \u00bfC\u00f3mo se crean las listas y tuplas en Elixir? \u00bfC\u00f3mo se pueden modificar las listas en Elixir? \u00bfC\u00f3mo se accede a los elementos de una tupla en Elixir? \u00bfCu\u00e1l es la principal ventaja de utilizar una tupla en lugar de una lista? Ejemplos de c\u00f3digo \u00b6 Creaci\u00f3n de listas y tuplas \u00b6 list = [ 1 , 2 , 3 , 4 ] tuple = { :ok , \"Hola\" , 1 } Modificaci\u00f3n de listas \u00b6 list ++ [ 5 ] # Devuelve [1, 2, 3, 4, 5] list -- [ 3 ] # Devuelve [1, 2, 4] Acceso a elementos de una tupla \u00b6 tuple = { :ok , \"Hola\" , 1 } tuple [ 1 ] # Devuelve \"Hola\" Ejercicios pr\u00e1cticos \u00b6 Crea una lista con los n\u00fameros del 1 al 10 y agrega el n\u00famero 11 al final. Crea una tupla con tres elementos y modifica el segundo elemento para que sea \"adi\u00f3s\" en lugar de \"Hola\". Dado el siguiente c\u00f3digo, \u00bfcu\u00e1l es el resultado de tuple[3] ? tuple = { :ok , \"Hola\" , [ 1 , 2 , 3 ], true } Consejos y mejores pr\u00e1cticas \u00b6 Utiliza listas cuando necesites una estructura de datos que pueda ser modificada. Utiliza tuplas cuando necesites una estructura de datos inmutable para almacenar valores que no cambiar\u00e1n. Si necesitas una estructura de datos que pueda ser modificada pero tambi\u00e9n necesitas acceder a sus elementos por \u00edndice, considera utilizar una lista y convertirla a una tupla cuando sea necesario acceder a sus elementos por \u00edndice. Navegaci\u00f3n de lecciones \u00b6 <- Lecci\u00f3n anterior : Sintaxis b\u00e1sica Siguiente lecci\u00f3n -> : Patrones y coincidencias","title":"Listas y tuplas en Elixir"},{"location":"elixir/jr/listas_y_tuplas/#listas-y-tuplas-en-elixir","text":"","title":"Listas y tuplas en Elixir"},{"location":"elixir/jr/listas_y_tuplas/#introduccion","text":"En Elixir, las listas y tuplas son dos de las estructuras de datos m\u00e1s utilizadas. Aunque pueden parecer similares, tienen diferentes caracter\u00edsticas y se utilizan para diferentes prop\u00f3sitos. En esta lecci\u00f3n, exploraremos en profundidad las listas y tuplas en Elixir, c\u00f3mo se crean, modifican y utilizan en la programaci\u00f3n.","title":"Introducci\u00f3n"},{"location":"elixir/jr/listas_y_tuplas/#listas","text":"Las listas en Elixir son una colecci\u00f3n ordenada de elementos del mismo tipo o de diferentes tipos. Se crean utilizando corchetes y separando los elementos con comas. list = [ 1 , 2 , 3 , 4 ] Las listas son estructuras de datos din\u00e1micas, lo que significa que se pueden modificar agregando o eliminando elementos. Para agregar un elemento al final de la lista, se utiliza el operador ++ : list ++ [ 5 ] Esto devolver\u00e1 una nueva lista con el elemento agregado al final. Para eliminar un elemento de la lista, se utiliza el operador -- : list -- [ 3 ] Esto devolver\u00e1 una nueva lista sin el elemento especificado. Tambi\u00e9n se pueden agregar o eliminar m\u00faltiples elementos a la vez utilizando el mismo operador. Otra caracter\u00edstica importante de las listas en Elixir es que se pueden acceder a sus elementos mediante su \u00edndice, comenzando desde 0. Esto se hace utilizando el operador de acceso [] seguido del \u00edndice del elemento deseado: list = [ \"a\" , \"b\" , \"c\" , \"d\" ] list [ 2 ] # Devuelve \"c\"","title":"Listas"},{"location":"elixir/jr/listas_y_tuplas/#tuplas","text":"Las tuplas en Elixir son una colecci\u00f3n ordenada de elementos del mismo tipo o de diferentes tipos, al igual que las listas. Sin embargo, a diferencia de las listas, las tuplas son estructuras de datos inmutables, lo que significa que no se pueden modificar una vez creadas. Se crean utilizando llaves y separando los elementos con comas. tuple = { :ok , \"Hola\" , 1 } Aunque las tuplas no se pueden modificar, se pueden acceder a sus elementos de la misma manera que en las listas, utilizando el operador de acceso [] seguido del \u00edndice del elemento deseado: tuple = { :ok , \"Hola\" , 1 } tuple [ 1 ] # Devuelve \"Hola\"","title":"Tuplas"},{"location":"elixir/jr/listas_y_tuplas/#palabras-clave","text":"Listas: colecciones ordenadas de elementos en Elixir que se pueden modificar. Tuplas: colecciones ordenadas de elementos en Elixir que no se pueden modificar. Din\u00e1mico: en el contexto de las estructuras de datos, se refiere a la capacidad de ser modificadas. Inmutable: en el contexto de las estructuras de datos, se refiere a la incapacidad de ser modificadas.","title":"Palabras clave"},{"location":"elixir/jr/listas_y_tuplas/#preguntas-de-repaso","text":"\u00bfCu\u00e1l es la diferencia principal entre las listas y tuplas en Elixir? \u00bfC\u00f3mo se crean las listas y tuplas en Elixir? \u00bfC\u00f3mo se pueden modificar las listas en Elixir? \u00bfC\u00f3mo se accede a los elementos de una tupla en Elixir? \u00bfCu\u00e1l es la principal ventaja de utilizar una tupla en lugar de una lista?","title":"Preguntas de repaso"},{"location":"elixir/jr/listas_y_tuplas/#ejemplos-de-codigo","text":"","title":"Ejemplos de c\u00f3digo"},{"location":"elixir/jr/listas_y_tuplas/#creacion-de-listas-y-tuplas","text":"list = [ 1 , 2 , 3 , 4 ] tuple = { :ok , \"Hola\" , 1 }","title":"Creaci\u00f3n de listas y tuplas"},{"location":"elixir/jr/listas_y_tuplas/#modificacion-de-listas","text":"list ++ [ 5 ] # Devuelve [1, 2, 3, 4, 5] list -- [ 3 ] # Devuelve [1, 2, 4]","title":"Modificaci\u00f3n de listas"},{"location":"elixir/jr/listas_y_tuplas/#acceso-a-elementos-de-una-tupla","text":"tuple = { :ok , \"Hola\" , 1 } tuple [ 1 ] # Devuelve \"Hola\"","title":"Acceso a elementos de una tupla"},{"location":"elixir/jr/listas_y_tuplas/#ejercicios-practicos","text":"Crea una lista con los n\u00fameros del 1 al 10 y agrega el n\u00famero 11 al final. Crea una tupla con tres elementos y modifica el segundo elemento para que sea \"adi\u00f3s\" en lugar de \"Hola\". Dado el siguiente c\u00f3digo, \u00bfcu\u00e1l es el resultado de tuple[3] ? tuple = { :ok , \"Hola\" , [ 1 , 2 , 3 ], true }","title":"Ejercicios pr\u00e1cticos"},{"location":"elixir/jr/listas_y_tuplas/#consejos-y-mejores-practicas","text":"Utiliza listas cuando necesites una estructura de datos que pueda ser modificada. Utiliza tuplas cuando necesites una estructura de datos inmutable para almacenar valores que no cambiar\u00e1n. Si necesitas una estructura de datos que pueda ser modificada pero tambi\u00e9n necesitas acceder a sus elementos por \u00edndice, considera utilizar una lista y convertirla a una tupla cuando sea necesario acceder a sus elementos por \u00edndice.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"elixir/jr/listas_y_tuplas/#navegacion-de-lecciones","text":"<- Lecci\u00f3n anterior : Sintaxis b\u00e1sica Siguiente lecci\u00f3n -> : Patrones y coincidencias","title":"Navegaci\u00f3n de lecciones"},{"location":"elixir/jr/modulos/","text":"M\u00f3dulos \u00b6 En Elixir, un m\u00f3dulo es una unidad de c\u00f3digo que agrupa una serie de funciones relacionadas. Los m\u00f3dulos son una forma de organizar y estructurar el c\u00f3digo en Elixir, lo que permite una mejor modularidad, reutilizaci\u00f3n y mantenibilidad del mismo. Palabras clave y su definici\u00f3n \u00b6 defmodule : se utiliza para definir un nuevo m\u00f3dulo en Elixir. do : indica el inicio del cuerpo del m\u00f3dulo. end : indica el final del cuerpo del m\u00f3dulo. def : se utiliza para definir una funci\u00f3n dentro de un m\u00f3dulo. defp : similar a def , pero define una funci\u00f3n privada que solo puede ser utilizada dentro del m\u00f3dulo. import : importa funciones de otros m\u00f3dulos para ser utilizadas en el m\u00f3dulo actual. use : se utiliza para importar y ejecutar c\u00f3digo de otros m\u00f3dulos. alias : permite crear un alias para un m\u00f3dulo, lo que facilita su uso en el c\u00f3digo. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es un m\u00f3dulo en Elixir? \u00bfCu\u00e1l es la palabra clave utilizada para definir un nuevo m\u00f3dulo? \u00bfQu\u00e9 funci\u00f3n se utiliza para definir una funci\u00f3n dentro de un m\u00f3dulo? \u00bfCu\u00e1l es la diferencia entre def y defp ? \u00bfC\u00f3mo se pueden importar funciones de otros m\u00f3dulos en Elixir? Ejemplos de c\u00f3digo en Elixir \u00b6 Definici\u00f3n de un m\u00f3dulo con una funci\u00f3n p\u00fablica y una privada: defmodule Calculadora do def suma ( a , b ) do a + b end defp resta ( a , b ) do a - b end end Importaci\u00f3n de un m\u00f3dulo en otro: defmodule Ejemplo do import Calculadora def promedio ( a , b ) do suma ( a , b ) / 2 end end Alias de un m\u00f3dulo: defmodule Ejemplo do alias Calculadora , as : Calc def promedio ( a , b ) do Calc . suma ( a , b ) / 2 end end Ejercicios pr\u00e1cticos \u00b6 Crea un m\u00f3dulo llamado Conversion que contenga dos funciones: fahrenheit_to_celsius y celsius_to_fahrenheit , que conviertan entre estas dos unidades de temperatura. Importa el m\u00f3dulo Conversion en otro m\u00f3dulo y utiliza sus funciones para imprimir la conversi\u00f3n de 32\u00b0F a \u00b0C y de 100\u00b0C a \u00b0F. Consejos o mejores pr\u00e1cticas \u00b6 Utilizar los m\u00f3dulos para agrupar funciones relacionadas y mantener un c\u00f3digo m\u00e1s organizado y legible. Utilizar nombres descriptivos para los m\u00f3dulos y sus funciones. Evitar la definici\u00f3n de funciones con el mismo nombre en diferentes m\u00f3dulos, ya que puede causar conflictos. Utilizar la funci\u00f3n defp para definir funciones que solo ser\u00e1n utilizadas dentro del m\u00f3dulo. Utilizar la importaci\u00f3n selectiva de funciones con la palabra clave only para evitar importar todas las funciones de un m\u00f3dulo. Utilizar la funci\u00f3n use para importar y ejecutar c\u00f3digo de otros m\u00f3dulos, por ejemplo, para definir comportamientos y macros. Utilizar un alias para un m\u00f3dulo largo o de uso frecuente para un c\u00f3digo m\u00e1s conciso y legible. Navegaci\u00f3n de lecciones \u00b6 <- Lecci\u00f3n anterior : Recursividad Siguiente lecci\u00f3n -> : M\u00f3dulos de la librer\u00eda est\u00e1ndar de Elixir","title":"M\u00f3dulos"},{"location":"elixir/jr/modulos/#modulos","text":"En Elixir, un m\u00f3dulo es una unidad de c\u00f3digo que agrupa una serie de funciones relacionadas. Los m\u00f3dulos son una forma de organizar y estructurar el c\u00f3digo en Elixir, lo que permite una mejor modularidad, reutilizaci\u00f3n y mantenibilidad del mismo.","title":"M\u00f3dulos"},{"location":"elixir/jr/modulos/#palabras-clave-y-su-definicion","text":"defmodule : se utiliza para definir un nuevo m\u00f3dulo en Elixir. do : indica el inicio del cuerpo del m\u00f3dulo. end : indica el final del cuerpo del m\u00f3dulo. def : se utiliza para definir una funci\u00f3n dentro de un m\u00f3dulo. defp : similar a def , pero define una funci\u00f3n privada que solo puede ser utilizada dentro del m\u00f3dulo. import : importa funciones de otros m\u00f3dulos para ser utilizadas en el m\u00f3dulo actual. use : se utiliza para importar y ejecutar c\u00f3digo de otros m\u00f3dulos. alias : permite crear un alias para un m\u00f3dulo, lo que facilita su uso en el c\u00f3digo.","title":"Palabras clave y su definici\u00f3n"},{"location":"elixir/jr/modulos/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es un m\u00f3dulo en Elixir? \u00bfCu\u00e1l es la palabra clave utilizada para definir un nuevo m\u00f3dulo? \u00bfQu\u00e9 funci\u00f3n se utiliza para definir una funci\u00f3n dentro de un m\u00f3dulo? \u00bfCu\u00e1l es la diferencia entre def y defp ? \u00bfC\u00f3mo se pueden importar funciones de otros m\u00f3dulos en Elixir?","title":"Preguntas de repaso"},{"location":"elixir/jr/modulos/#ejemplos-de-codigo-en-elixir","text":"Definici\u00f3n de un m\u00f3dulo con una funci\u00f3n p\u00fablica y una privada: defmodule Calculadora do def suma ( a , b ) do a + b end defp resta ( a , b ) do a - b end end Importaci\u00f3n de un m\u00f3dulo en otro: defmodule Ejemplo do import Calculadora def promedio ( a , b ) do suma ( a , b ) / 2 end end Alias de un m\u00f3dulo: defmodule Ejemplo do alias Calculadora , as : Calc def promedio ( a , b ) do Calc . suma ( a , b ) / 2 end end","title":"Ejemplos de c\u00f3digo en Elixir"},{"location":"elixir/jr/modulos/#ejercicios-practicos","text":"Crea un m\u00f3dulo llamado Conversion que contenga dos funciones: fahrenheit_to_celsius y celsius_to_fahrenheit , que conviertan entre estas dos unidades de temperatura. Importa el m\u00f3dulo Conversion en otro m\u00f3dulo y utiliza sus funciones para imprimir la conversi\u00f3n de 32\u00b0F a \u00b0C y de 100\u00b0C a \u00b0F.","title":"Ejercicios pr\u00e1cticos"},{"location":"elixir/jr/modulos/#consejos-o-mejores-practicas","text":"Utilizar los m\u00f3dulos para agrupar funciones relacionadas y mantener un c\u00f3digo m\u00e1s organizado y legible. Utilizar nombres descriptivos para los m\u00f3dulos y sus funciones. Evitar la definici\u00f3n de funciones con el mismo nombre en diferentes m\u00f3dulos, ya que puede causar conflictos. Utilizar la funci\u00f3n defp para definir funciones que solo ser\u00e1n utilizadas dentro del m\u00f3dulo. Utilizar la importaci\u00f3n selectiva de funciones con la palabra clave only para evitar importar todas las funciones de un m\u00f3dulo. Utilizar la funci\u00f3n use para importar y ejecutar c\u00f3digo de otros m\u00f3dulos, por ejemplo, para definir comportamientos y macros. Utilizar un alias para un m\u00f3dulo largo o de uso frecuente para un c\u00f3digo m\u00e1s conciso y legible.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"elixir/jr/modulos/#navegacion-de-lecciones","text":"<- Lecci\u00f3n anterior : Recursividad Siguiente lecci\u00f3n -> : M\u00f3dulos de la librer\u00eda est\u00e1ndar de Elixir","title":"Navegaci\u00f3n de lecciones"},{"location":"elixir/jr/modulos_de_la_libreria_estandar_de_elixir/","text":"M\u00f3dulos de la librer\u00eda est\u00e1ndar de Elixir \u00b6 Los m\u00f3dulos de la librer\u00eda est\u00e1ndar de Elixir son un conjunto de funciones y estructuras de datos predefinidas que nos permiten realizar tareas comunes de manera eficiente y sencilla. Estos m\u00f3dulos forman parte del n\u00facleo de Elixir y se encuentran disponibles sin necesidad de instalar ning\u00fan paquete adicional. Palabras clave y definiciones \u00b6 String : tipo de dato que representa una secuencia de caracteres. Los m\u00f3dulos de la librer\u00eda est\u00e1ndar de Elixir permiten la manipulaci\u00f3n y transformaci\u00f3n de cadenas de manera eficiente. Date : tipo de dato que representa una fecha, incluyendo informaci\u00f3n sobre el a\u00f1o, mes y d\u00eda. Los m\u00f3dulos de la librer\u00eda est\u00e1ndar de Elixir ofrecen funciones para manipular y comparar fechas. File : tipo de dato que representa un archivo en el sistema. Los m\u00f3dulos de la librer\u00eda est\u00e1ndar de Elixir proporcionan funciones para crear, leer, escribir y manipular archivos. Preguntas de repaso \u00b6 \u00bfQu\u00e9 son los m\u00f3dulos de la librer\u00eda est\u00e1ndar de Elixir? \u00bfQu\u00e9 tipo de datos se pueden manipular con los m\u00f3dulos de cadenas? \u00bfC\u00f3mo se representan las fechas en Elixir? \u00bfQu\u00e9 funciones ofrecen los m\u00f3dulos de la librer\u00eda est\u00e1ndar para manipular archivos? \u00bfEs necesario instalar alg\u00fan paquete adicional para utilizar los m\u00f3dulos de la librer\u00eda est\u00e1ndar de Elixir? Ejemplos de c\u00f3digo en Elixir \u00b6 Manipulaci\u00f3n de cadenas \u00b6 # Obtener la longitud de una cadena String . length ( \"Hola Mundo\" ) # => 10 # Convertir una cadena a may\u00fasculas String . upcase ( \"hola mundo\" ) # => \"HOLA MUNDO\" # Reemplazar una subcadena por otra String . replace ( \"Elixir es genial\" , \"genial\" , \"incre\u00edble\" ) # => \"Elixir es incre\u00edble\" Manipulaci\u00f3n de fechas \u00b6 # Obtener la fecha actual Date . utc_today () # => ~D[2021-12-03] # Sumar un d\u00eda a una fecha Date . add ( ~D[2021-01-01] , 1 ) # => ~D[2021-01-02] # Comparar dos fechas Date . compare ( ~D[2021-01-01] , ~D[2020-12-31] ) # => :gt Manipulaci\u00f3n de archivos \u00b6 # Crear un nuevo archivo File . write ( \"nuevo.txt\" , \"Este es un nuevo archivo\" ) # => :ok # Leer el contenido de un archivo File . read ( \"nuevo.txt\" ) # => {:ok, \"Este es un nuevo archivo\"} # Mover un archivo a otro directorio File . rename ( \"nuevo.txt\" , \"otro/nuevo.txt\" ) # => :ok Ejercicios pr\u00e1cticos \u00b6 Crea una funci\u00f3n que reciba una cadena y devuelva la misma cadena en may\u00fasculas. Crea una funci\u00f3n que reciba dos fechas y determine cu\u00e1l de ellas es m\u00e1s reciente. Crea una funci\u00f3n que reciba una lista de nombres y los escriba en un archivo de texto, cada uno en una l\u00ednea diferente. Consejos y mejores pr\u00e1cticas \u00b6 Antes de utilizar cualquier m\u00f3dulo de la librer\u00eda est\u00e1ndar, es importante leer la documentaci\u00f3n oficial para entender c\u00f3mo funciona y qu\u00e9 par\u00e1metros recibe cada funci\u00f3n. Al manipular cadenas, es recomendable utilizar el m\u00f3dulo String para aprovechar sus funciones optimizadas en lugar de realizar operaciones directamente sobre la cadena. Al trabajar con fechas, es importante tener en cuenta la zona horaria para evitar resultados inesperados. Antes de manipular archivos, es necesario asegurarse de tener los permisos adecuados para realizar las operaciones deseadas. Navegaci\u00f3n de lecciones \u00b6 <- Lecci\u00f3n anterior : M\u00f3dulos Siguiente lecci\u00f3n -> : Desarrollo de aplicaciones web con Elixir","title":"M\u00f3dulos de la librer\u00eda est\u00e1ndar de Elixir"},{"location":"elixir/jr/modulos_de_la_libreria_estandar_de_elixir/#modulos-de-la-libreria-estandar-de-elixir","text":"Los m\u00f3dulos de la librer\u00eda est\u00e1ndar de Elixir son un conjunto de funciones y estructuras de datos predefinidas que nos permiten realizar tareas comunes de manera eficiente y sencilla. Estos m\u00f3dulos forman parte del n\u00facleo de Elixir y se encuentran disponibles sin necesidad de instalar ning\u00fan paquete adicional.","title":"M\u00f3dulos de la librer\u00eda est\u00e1ndar de Elixir"},{"location":"elixir/jr/modulos_de_la_libreria_estandar_de_elixir/#palabras-clave-y-definiciones","text":"String : tipo de dato que representa una secuencia de caracteres. Los m\u00f3dulos de la librer\u00eda est\u00e1ndar de Elixir permiten la manipulaci\u00f3n y transformaci\u00f3n de cadenas de manera eficiente. Date : tipo de dato que representa una fecha, incluyendo informaci\u00f3n sobre el a\u00f1o, mes y d\u00eda. Los m\u00f3dulos de la librer\u00eda est\u00e1ndar de Elixir ofrecen funciones para manipular y comparar fechas. File : tipo de dato que representa un archivo en el sistema. Los m\u00f3dulos de la librer\u00eda est\u00e1ndar de Elixir proporcionan funciones para crear, leer, escribir y manipular archivos.","title":"Palabras clave y definiciones"},{"location":"elixir/jr/modulos_de_la_libreria_estandar_de_elixir/#preguntas-de-repaso","text":"\u00bfQu\u00e9 son los m\u00f3dulos de la librer\u00eda est\u00e1ndar de Elixir? \u00bfQu\u00e9 tipo de datos se pueden manipular con los m\u00f3dulos de cadenas? \u00bfC\u00f3mo se representan las fechas en Elixir? \u00bfQu\u00e9 funciones ofrecen los m\u00f3dulos de la librer\u00eda est\u00e1ndar para manipular archivos? \u00bfEs necesario instalar alg\u00fan paquete adicional para utilizar los m\u00f3dulos de la librer\u00eda est\u00e1ndar de Elixir?","title":"Preguntas de repaso"},{"location":"elixir/jr/modulos_de_la_libreria_estandar_de_elixir/#ejemplos-de-codigo-en-elixir","text":"","title":"Ejemplos de c\u00f3digo en Elixir"},{"location":"elixir/jr/modulos_de_la_libreria_estandar_de_elixir/#manipulacion-de-cadenas","text":"# Obtener la longitud de una cadena String . length ( \"Hola Mundo\" ) # => 10 # Convertir una cadena a may\u00fasculas String . upcase ( \"hola mundo\" ) # => \"HOLA MUNDO\" # Reemplazar una subcadena por otra String . replace ( \"Elixir es genial\" , \"genial\" , \"incre\u00edble\" ) # => \"Elixir es incre\u00edble\"","title":"Manipulaci\u00f3n de cadenas"},{"location":"elixir/jr/modulos_de_la_libreria_estandar_de_elixir/#manipulacion-de-fechas","text":"# Obtener la fecha actual Date . utc_today () # => ~D[2021-12-03] # Sumar un d\u00eda a una fecha Date . add ( ~D[2021-01-01] , 1 ) # => ~D[2021-01-02] # Comparar dos fechas Date . compare ( ~D[2021-01-01] , ~D[2020-12-31] ) # => :gt","title":"Manipulaci\u00f3n de fechas"},{"location":"elixir/jr/modulos_de_la_libreria_estandar_de_elixir/#manipulacion-de-archivos","text":"# Crear un nuevo archivo File . write ( \"nuevo.txt\" , \"Este es un nuevo archivo\" ) # => :ok # Leer el contenido de un archivo File . read ( \"nuevo.txt\" ) # => {:ok, \"Este es un nuevo archivo\"} # Mover un archivo a otro directorio File . rename ( \"nuevo.txt\" , \"otro/nuevo.txt\" ) # => :ok","title":"Manipulaci\u00f3n de archivos"},{"location":"elixir/jr/modulos_de_la_libreria_estandar_de_elixir/#ejercicios-practicos","text":"Crea una funci\u00f3n que reciba una cadena y devuelva la misma cadena en may\u00fasculas. Crea una funci\u00f3n que reciba dos fechas y determine cu\u00e1l de ellas es m\u00e1s reciente. Crea una funci\u00f3n que reciba una lista de nombres y los escriba en un archivo de texto, cada uno en una l\u00ednea diferente.","title":"Ejercicios pr\u00e1cticos"},{"location":"elixir/jr/modulos_de_la_libreria_estandar_de_elixir/#consejos-y-mejores-practicas","text":"Antes de utilizar cualquier m\u00f3dulo de la librer\u00eda est\u00e1ndar, es importante leer la documentaci\u00f3n oficial para entender c\u00f3mo funciona y qu\u00e9 par\u00e1metros recibe cada funci\u00f3n. Al manipular cadenas, es recomendable utilizar el m\u00f3dulo String para aprovechar sus funciones optimizadas en lugar de realizar operaciones directamente sobre la cadena. Al trabajar con fechas, es importante tener en cuenta la zona horaria para evitar resultados inesperados. Antes de manipular archivos, es necesario asegurarse de tener los permisos adecuados para realizar las operaciones deseadas.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"elixir/jr/modulos_de_la_libreria_estandar_de_elixir/#navegacion-de-lecciones","text":"<- Lecci\u00f3n anterior : M\u00f3dulos Siguiente lecci\u00f3n -> : Desarrollo de aplicaciones web con Elixir","title":"Navegaci\u00f3n de lecciones"},{"location":"elixir/jr/patrones_y_coincidencias/","text":"Patrones y coincidencias \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En este m\u00f3dulo, aprender\u00e1s sobre los patrones y coincidencias en Elixir, y c\u00f3mo se utilizan en la programaci\u00f3n funcional. Los patrones y coincidencias son una parte fundamental de la sintaxis de Elixir y te permiten escribir c\u00f3digo limpio y conciso, adem\u00e1s de facilitar el manejo de datos y estructuras complejas. Explicaci\u00f3n te\u00f3rica \u00b6 En Elixir, los patrones y coincidencias se utilizan para comparar valores y estructuras de datos, y ejecutar cierto c\u00f3digo en funci\u00f3n de si se cumple o no la coincidencia. Se basa en la idea de la descomposici\u00f3n de datos, donde una estructura de datos se puede descomponer en partes m\u00e1s peque\u00f1as y se pueden realizar operaciones en cada una de ellas. El patr\u00f3n de coincidencia se escribe como una expresi\u00f3n regular y se utiliza en conjunto con la palabra clave match . Para que la coincidencia sea exitosa, los valores deben coincidir en cada parte del patr\u00f3n. Palabras clave y su definici\u00f3n \u00b6 Patr\u00f3n: una expresi\u00f3n regular utilizada para comparar valores y estructuras de datos. Coincidencia: la acci\u00f3n de comparar un valor con un patr\u00f3n y determinar si hay una correspondencia. Descomposici\u00f3n de datos: el proceso de dividir una estructura de datos en partes m\u00e1s peque\u00f1as. match : palabra clave utilizada para realizar una coincidencia entre un patr\u00f3n y un valor. Preguntas de repaso \u00b6 \u00bfQu\u00e9 son los patrones y coincidencias en Elixir? \u00bfPara qu\u00e9 se utilizan los patrones y coincidencias? \u00bfQu\u00e9 es la descomposici\u00f3n de datos? \u00bfCu\u00e1l es la palabra clave utilizada para realizar una coincidencia en Elixir? Ejemplos de c\u00f3digo en Elixir \u00b6 Ejemplo 1: Comparando valores simples \u00b6 value = 5 match value do 5 -> \"Cinco\" _ -> \"No es cinco\" end # Output: \"Cinco\" En este ejemplo, se asigna el valor 5 a la variable value y se realiza una coincidencia con el patr\u00f3n 5 . Como el valor coincide con el patr\u00f3n, se ejecuta el c\u00f3digo correspondiente y se devuelve \"Cinco\". Si el valor fuera diferente de 5 , se ejecutar\u00eda el c\u00f3digo en el _ (comod\u00edn) y devolver\u00eda \"No es cinco\". Ejemplo 2: Descomposici\u00f3n de tuplas \u00b6 tuple = { :ok , \"\u00a1\u00c9xito!\" } match tuple do { :ok , message } -> \"Mensaje de \u00e9xito: #{ message } \" { :error , _ } -> \"Ha ocurrido un error\" end # Output: \"Mensaje de \u00e9xito: \u00a1\u00c9xito!\" En este ejemplo, se tiene una tupla con dos elementos y se realiza una coincidencia con dos patrones diferentes. Si el primer elemento de la tupla es :ok , se asigna el segundo elemento a la variable message y se devuelve un mensaje de \u00e9xito. Si el primer elemento es :error , se ejecuta el c\u00f3digo en el segundo patr\u00f3n y se devuelve un mensaje de error. Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Escribe un c\u00f3digo que compare un n\u00famero con los siguientes patrones: Si el n\u00famero es mayor que 10, devolver \"Mayor que 10\" Si el n\u00famero es menor que 5, devolver \"Menor que 5\" Si el n\u00famero es igual a 7, devolver \"N\u00famero m\u00e1gico\" Si no se cumple ninguna de las condiciones anteriores, devolver \"N\u00famero desconocido\" Escribe un c\u00f3digo que compare una lista con los siguientes patrones: Si la lista tiene 3 elementos, devolver la palabra \"Tres\" Si la lista tiene 5 elementos, devolver la palabra \"Cinco\" Si la lista tiene 8 elementos, devolver la palabra \"Ocho\" Si no se cumple ninguna de las condiciones anteriores, devolver \"N\u00famero de elementos desconocido\" Consejos o mejores pr\u00e1cticas \u00b6 Utiliza patrones y coincidencias en lugar de declaraciones if/else cuando sea posible, ya que es una forma m\u00e1s concisa y legible de escribir c\u00f3digo. Practica la descomposici\u00f3n de datos y utiliza patrones m\u00e1s complejos para manejar estructuras de datos m\u00e1s grandes. Utiliza el comod\u00edn _ cuando no necesites asignar un valor a una variable en un patr\u00f3n de coincidencia. Aprovecha la capacidad de Elixir para realizar coincidencias en diferentes tipos de datos, como listas, mapas y tuplas. Navegaci\u00f3n de lecciones \u00b6 <- Lecci\u00f3n anterior : Listas y tuplas Siguiente lecci\u00f3n -> : Procesos","title":"Patrones y coincidencias"},{"location":"elixir/jr/patrones_y_coincidencias/#patrones-y-coincidencias","text":"","title":"Patrones y coincidencias"},{"location":"elixir/jr/patrones_y_coincidencias/#descripcion-del-modulo","text":"En este m\u00f3dulo, aprender\u00e1s sobre los patrones y coincidencias en Elixir, y c\u00f3mo se utilizan en la programaci\u00f3n funcional. Los patrones y coincidencias son una parte fundamental de la sintaxis de Elixir y te permiten escribir c\u00f3digo limpio y conciso, adem\u00e1s de facilitar el manejo de datos y estructuras complejas.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"elixir/jr/patrones_y_coincidencias/#explicacion-teorica","text":"En Elixir, los patrones y coincidencias se utilizan para comparar valores y estructuras de datos, y ejecutar cierto c\u00f3digo en funci\u00f3n de si se cumple o no la coincidencia. Se basa en la idea de la descomposici\u00f3n de datos, donde una estructura de datos se puede descomponer en partes m\u00e1s peque\u00f1as y se pueden realizar operaciones en cada una de ellas. El patr\u00f3n de coincidencia se escribe como una expresi\u00f3n regular y se utiliza en conjunto con la palabra clave match . Para que la coincidencia sea exitosa, los valores deben coincidir en cada parte del patr\u00f3n.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"elixir/jr/patrones_y_coincidencias/#palabras-clave-y-su-definicion","text":"Patr\u00f3n: una expresi\u00f3n regular utilizada para comparar valores y estructuras de datos. Coincidencia: la acci\u00f3n de comparar un valor con un patr\u00f3n y determinar si hay una correspondencia. Descomposici\u00f3n de datos: el proceso de dividir una estructura de datos en partes m\u00e1s peque\u00f1as. match : palabra clave utilizada para realizar una coincidencia entre un patr\u00f3n y un valor.","title":"Palabras clave y su definici\u00f3n"},{"location":"elixir/jr/patrones_y_coincidencias/#preguntas-de-repaso","text":"\u00bfQu\u00e9 son los patrones y coincidencias en Elixir? \u00bfPara qu\u00e9 se utilizan los patrones y coincidencias? \u00bfQu\u00e9 es la descomposici\u00f3n de datos? \u00bfCu\u00e1l es la palabra clave utilizada para realizar una coincidencia en Elixir?","title":"Preguntas de repaso"},{"location":"elixir/jr/patrones_y_coincidencias/#ejemplos-de-codigo-en-elixir","text":"","title":"Ejemplos de c\u00f3digo en Elixir"},{"location":"elixir/jr/patrones_y_coincidencias/#ejemplo-1-comparando-valores-simples","text":"value = 5 match value do 5 -> \"Cinco\" _ -> \"No es cinco\" end # Output: \"Cinco\" En este ejemplo, se asigna el valor 5 a la variable value y se realiza una coincidencia con el patr\u00f3n 5 . Como el valor coincide con el patr\u00f3n, se ejecuta el c\u00f3digo correspondiente y se devuelve \"Cinco\". Si el valor fuera diferente de 5 , se ejecutar\u00eda el c\u00f3digo en el _ (comod\u00edn) y devolver\u00eda \"No es cinco\".","title":"Ejemplo 1: Comparando valores simples"},{"location":"elixir/jr/patrones_y_coincidencias/#ejemplo-2-descomposicion-de-tuplas","text":"tuple = { :ok , \"\u00a1\u00c9xito!\" } match tuple do { :ok , message } -> \"Mensaje de \u00e9xito: #{ message } \" { :error , _ } -> \"Ha ocurrido un error\" end # Output: \"Mensaje de \u00e9xito: \u00a1\u00c9xito!\" En este ejemplo, se tiene una tupla con dos elementos y se realiza una coincidencia con dos patrones diferentes. Si el primer elemento de la tupla es :ok , se asigna el segundo elemento a la variable message y se devuelve un mensaje de \u00e9xito. Si el primer elemento es :error , se ejecuta el c\u00f3digo en el segundo patr\u00f3n y se devuelve un mensaje de error.","title":"Ejemplo 2: Descomposici\u00f3n de tuplas"},{"location":"elixir/jr/patrones_y_coincidencias/#ejercicios-practicos-con-instrucciones-claras","text":"Escribe un c\u00f3digo que compare un n\u00famero con los siguientes patrones: Si el n\u00famero es mayor que 10, devolver \"Mayor que 10\" Si el n\u00famero es menor que 5, devolver \"Menor que 5\" Si el n\u00famero es igual a 7, devolver \"N\u00famero m\u00e1gico\" Si no se cumple ninguna de las condiciones anteriores, devolver \"N\u00famero desconocido\" Escribe un c\u00f3digo que compare una lista con los siguientes patrones: Si la lista tiene 3 elementos, devolver la palabra \"Tres\" Si la lista tiene 5 elementos, devolver la palabra \"Cinco\" Si la lista tiene 8 elementos, devolver la palabra \"Ocho\" Si no se cumple ninguna de las condiciones anteriores, devolver \"N\u00famero de elementos desconocido\"","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"elixir/jr/patrones_y_coincidencias/#consejos-o-mejores-practicas","text":"Utiliza patrones y coincidencias en lugar de declaraciones if/else cuando sea posible, ya que es una forma m\u00e1s concisa y legible de escribir c\u00f3digo. Practica la descomposici\u00f3n de datos y utiliza patrones m\u00e1s complejos para manejar estructuras de datos m\u00e1s grandes. Utiliza el comod\u00edn _ cuando no necesites asignar un valor a una variable en un patr\u00f3n de coincidencia. Aprovecha la capacidad de Elixir para realizar coincidencias en diferentes tipos de datos, como listas, mapas y tuplas.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"elixir/jr/patrones_y_coincidencias/#navegacion-de-lecciones","text":"<- Lecci\u00f3n anterior : Listas y tuplas Siguiente lecci\u00f3n -> : Procesos","title":"Navegaci\u00f3n de lecciones"},{"location":"elixir/jr/procesos/","text":"Procesos \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 Los procesos en Elixir son la unidad b\u00e1sica de concurrencia en el lenguaje. Se trata de un mecanismo ligero y eficiente para ejecutar c\u00f3digo de manera paralela y as\u00ed aprovechar al m\u00e1ximo los recursos del sistema. Cada proceso tiene su propio espacio de memoria y se comunican entre s\u00ed a trav\u00e9s de mensajes, lo que permite una comunicaci\u00f3n asincr\u00f3nica y segura. Para crear un proceso en Elixir, se utiliza la funci\u00f3n spawn/1 que recibe como argumento una funci\u00f3n an\u00f3nima o un m\u00f3dulo y una funci\u00f3n. Esto crea un nuevo proceso que ejecuta el c\u00f3digo especificado y devuelve un identificador \u00fanico, llamado pid, que se utiliza para comunicarse con dicho proceso. Los procesos en Elixir son supervisados por un supervisor, lo que significa que en caso de que un proceso falle, el supervisor puede reiniciar el proceso o tomar otra acci\u00f3n definida por el desarrollador. Palabras clave y su definici\u00f3n \u00b6 Proceso: Unidad b\u00e1sica de concurrencia en Elixir, que ejecuta c\u00f3digo de manera paralela y se comunica con otros procesos a trav\u00e9s de mensajes. Spawn: Funci\u00f3n que crea un proceso y devuelve un identificador \u00fanico. Pid: Identificador \u00fanico de un proceso que se utiliza para comunicarse con \u00e9l. Supervisi\u00f3n: Mecanismo que permite controlar y gestionar los procesos, reinici\u00e1ndolos en caso de fallos. Mensajes: Medio de comunicaci\u00f3n asincr\u00f3nico y seguro entre procesos en Elixir. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es un proceso en Elixir? \u00bfC\u00f3mo se crea un proceso en Elixir? \u00bfQu\u00e9 es un pid y para qu\u00e9 se utiliza? \u00bfQu\u00e9 es la supervisi\u00f3n en Elixir? \u00bfC\u00f3mo se comunican los procesos en Elixir? Ejemplos de c\u00f3digo en Elixir \u00b6 Crear un proceso que imprime un mensaje \u00b6 pid = spawn ( fn -> IO . puts ( \"Hola, soy un proceso\" ) end ) # Output: Hola, soy un proceso Comunicaci\u00f3n entre dos procesos \u00b6 receive do msg -> IO . puts ( \"Mensaje recibido: #{ msg } \" ) end pid = spawn ( fn -> send ( self (), \"Hola desde el proceso hijo\" ) end ) # Output: Mensaje recibido: Hola desde el proceso hijo Supervisi\u00f3n de procesos \u00b6 defmodule MiSupervisor do use Supervisor def start_link do Supervisor . start_link ( __MODULE__ , :ok ) end def init ( :ok ) do children = [ worker ( MyProcess , []), worker ( AnotherProcess , []) ] supervise ( children , strategy : :one_for_one ) end end Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea un proceso que calcule la suma de dos n\u00fameros ingresados por el usuario y devuelva el resultado. Crea dos procesos que se comuniquen entre s\u00ed para imprimir un mensaje en may\u00fasculas y otro en min\u00fasculas. Implementa un supervisor que gestione tres procesos y en caso de fallo de uno de ellos, lo reinicie autom\u00e1ticamente. Consejos o mejores pr\u00e1cticas \u00b6 Utilizar procesos para tareas que se puedan ejecutar de manera independiente y que no requieran un alto nivel de sincronizaci\u00f3n. Usar la comunicaci\u00f3n por mensajes para garantizar la seguridad y evitar los problemas de concurrencia. Utilizar supervisores para gestionar y controlar los procesos y asegurar la robustez del sistema. Evitar compartir datos mutables entre procesos para evitar problemas de concurrencia y asegurar la consistencia de los datos. En su lugar, utilizar estructuras de datos inmutables y la comunicaci\u00f3n por mensajes. Navegaci\u00f3n de lecciones \u00b6 <- Lecci\u00f3n anterior : Patrones y coincidencias Siguiente lecci\u00f3n -> : Concurrencia","title":"Procesos"},{"location":"elixir/jr/procesos/#procesos","text":"","title":"Procesos"},{"location":"elixir/jr/procesos/#explicacion-teorica","text":"Los procesos en Elixir son la unidad b\u00e1sica de concurrencia en el lenguaje. Se trata de un mecanismo ligero y eficiente para ejecutar c\u00f3digo de manera paralela y as\u00ed aprovechar al m\u00e1ximo los recursos del sistema. Cada proceso tiene su propio espacio de memoria y se comunican entre s\u00ed a trav\u00e9s de mensajes, lo que permite una comunicaci\u00f3n asincr\u00f3nica y segura. Para crear un proceso en Elixir, se utiliza la funci\u00f3n spawn/1 que recibe como argumento una funci\u00f3n an\u00f3nima o un m\u00f3dulo y una funci\u00f3n. Esto crea un nuevo proceso que ejecuta el c\u00f3digo especificado y devuelve un identificador \u00fanico, llamado pid, que se utiliza para comunicarse con dicho proceso. Los procesos en Elixir son supervisados por un supervisor, lo que significa que en caso de que un proceso falle, el supervisor puede reiniciar el proceso o tomar otra acci\u00f3n definida por el desarrollador.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"elixir/jr/procesos/#palabras-clave-y-su-definicion","text":"Proceso: Unidad b\u00e1sica de concurrencia en Elixir, que ejecuta c\u00f3digo de manera paralela y se comunica con otros procesos a trav\u00e9s de mensajes. Spawn: Funci\u00f3n que crea un proceso y devuelve un identificador \u00fanico. Pid: Identificador \u00fanico de un proceso que se utiliza para comunicarse con \u00e9l. Supervisi\u00f3n: Mecanismo que permite controlar y gestionar los procesos, reinici\u00e1ndolos en caso de fallos. Mensajes: Medio de comunicaci\u00f3n asincr\u00f3nico y seguro entre procesos en Elixir.","title":"Palabras clave y su definici\u00f3n"},{"location":"elixir/jr/procesos/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es un proceso en Elixir? \u00bfC\u00f3mo se crea un proceso en Elixir? \u00bfQu\u00e9 es un pid y para qu\u00e9 se utiliza? \u00bfQu\u00e9 es la supervisi\u00f3n en Elixir? \u00bfC\u00f3mo se comunican los procesos en Elixir?","title":"Preguntas de repaso"},{"location":"elixir/jr/procesos/#ejemplos-de-codigo-en-elixir","text":"","title":"Ejemplos de c\u00f3digo en Elixir"},{"location":"elixir/jr/procesos/#crear-un-proceso-que-imprime-un-mensaje","text":"pid = spawn ( fn -> IO . puts ( \"Hola, soy un proceso\" ) end ) # Output: Hola, soy un proceso","title":"Crear un proceso que imprime un mensaje"},{"location":"elixir/jr/procesos/#comunicacion-entre-dos-procesos","text":"receive do msg -> IO . puts ( \"Mensaje recibido: #{ msg } \" ) end pid = spawn ( fn -> send ( self (), \"Hola desde el proceso hijo\" ) end ) # Output: Mensaje recibido: Hola desde el proceso hijo","title":"Comunicaci\u00f3n entre dos procesos"},{"location":"elixir/jr/procesos/#supervision-de-procesos","text":"defmodule MiSupervisor do use Supervisor def start_link do Supervisor . start_link ( __MODULE__ , :ok ) end def init ( :ok ) do children = [ worker ( MyProcess , []), worker ( AnotherProcess , []) ] supervise ( children , strategy : :one_for_one ) end end","title":"Supervisi\u00f3n de procesos"},{"location":"elixir/jr/procesos/#ejercicios-practicos-con-instrucciones-claras","text":"Crea un proceso que calcule la suma de dos n\u00fameros ingresados por el usuario y devuelva el resultado. Crea dos procesos que se comuniquen entre s\u00ed para imprimir un mensaje en may\u00fasculas y otro en min\u00fasculas. Implementa un supervisor que gestione tres procesos y en caso de fallo de uno de ellos, lo reinicie autom\u00e1ticamente.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"elixir/jr/procesos/#consejos-o-mejores-practicas","text":"Utilizar procesos para tareas que se puedan ejecutar de manera independiente y que no requieran un alto nivel de sincronizaci\u00f3n. Usar la comunicaci\u00f3n por mensajes para garantizar la seguridad y evitar los problemas de concurrencia. Utilizar supervisores para gestionar y controlar los procesos y asegurar la robustez del sistema. Evitar compartir datos mutables entre procesos para evitar problemas de concurrencia y asegurar la consistencia de los datos. En su lugar, utilizar estructuras de datos inmutables y la comunicaci\u00f3n por mensajes.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"elixir/jr/procesos/#navegacion-de-lecciones","text":"<- Lecci\u00f3n anterior : Patrones y coincidencias Siguiente lecci\u00f3n -> : Concurrencia","title":"Navegaci\u00f3n de lecciones"},{"location":"elixir/jr/pruebas_y_depuracion/","text":"Pruebas y depuraci\u00f3n \u00b6 Introducci\u00f3n \u00b6 En el desarrollo de software, es importante asegurarse de que el c\u00f3digo escrito funciona correctamente y de manera confiable. Para lograr esto, es necesario realizar pruebas y depuraci\u00f3n de c\u00f3digo. En este m\u00f3dulo, aprenderemos sobre la importancia de las pruebas y la depuraci\u00f3n en Elixir y c\u00f3mo aplicarlas en nuestro c\u00f3digo. Teor\u00eda \u00b6 Pruebas \u00b6 Las pruebas son un conjunto de acciones que se realizan en el c\u00f3digo para verificar si funciona como se espera. Hay diferentes tipos de pruebas, como las pruebas unitarias, las pruebas de integraci\u00f3n y las pruebas funcionales. En este m\u00f3dulo, nos enfocaremos en las pruebas unitarias, que son pruebas que se realizan en peque\u00f1as partes del c\u00f3digo, como funciones y m\u00f3dulos. Las pruebas unitarias son importantes porque nos permiten detectar errores en el c\u00f3digo y asegurarnos de que nuestro c\u00f3digo cumpla con los requisitos y funcione correctamente. Tambi\u00e9n nos ayudan a detectar posibles problemas en el futuro y facilitan el mantenimiento del c\u00f3digo. Depuraci\u00f3n \u00b6 La depuraci\u00f3n es el proceso de identificar y corregir errores en el c\u00f3digo. Es una parte esencial del desarrollo de software, ya que incluso con pruebas rigurosas, es posible que se encuentren errores en el c\u00f3digo. La depuraci\u00f3n tambi\u00e9n nos permite comprender mejor el funcionamiento del c\u00f3digo y c\u00f3mo solucionar problemas en el futuro. Palabras clave \u00b6 Pruebas unitarias: pruebas que se realizan en peque\u00f1as partes del c\u00f3digo para verificar su correcto funcionamiento. Depuraci\u00f3n: proceso de identificar y corregir errores en el c\u00f3digo. Pruebas de integraci\u00f3n: pruebas que se realizan en diferentes partes del c\u00f3digo para verificar su correcta integraci\u00f3n. Pruebas funcionales: pruebas que se realizan en el sistema completo para verificar su correcto funcionamiento. Preguntas de repaso \u00b6 \u00bfQu\u00e9 son las pruebas unitarias y por qu\u00e9 son importantes? \u00bfCu\u00e1l es la diferencia entre las pruebas de integraci\u00f3n y las pruebas funcionales? \u00bfPor qu\u00e9 es importante realizar la depuraci\u00f3n en el c\u00f3digo? Ejemplos de c\u00f3digo \u00b6 A continuaci\u00f3n, se muestra un ejemplo de una funci\u00f3n en Elixir y c\u00f3mo se podr\u00eda escribir una prueba unitaria para ella. # Funci\u00f3n que devuelve el cuadrado de un n\u00famero def square ( num ) do num * num end Para escribir una prueba unitaria para esta funci\u00f3n, se puede utilizar el m\u00f3dulo ExUnit de Elixir de la siguiente manera: # Test para la funci\u00f3n square defmodule SquareTest do use ExUnit.Case # Definir el contexto de la prueba test \"square of 2 should be 4\" do assert Square . square ( 2 ) == 4 end end Ejercicios pr\u00e1cticos \u00b6 Escribe una funci\u00f3n en Elixir que devuelva la suma de dos n\u00fameros y escribe una prueba unitaria para ella. Escribe una funci\u00f3n en Elixir que determine si un n\u00famero es par o impar y escribe una prueba unitaria para ella. Consejos y mejores pr\u00e1cticas \u00b6 Es importante escribir pruebas unitarias para todas las funciones y m\u00f3dulos en nuestro c\u00f3digo. Utilizar nombres descriptivos para las pruebas y asegurarse de cubrir todos los casos posibles. Utilizar herramientas de depuraci\u00f3n, como el m\u00f3dulo IEx , para identificar y corregir errores en el c\u00f3digo. Navegaci\u00f3n de lecciones \u00b6 <- Lecci\u00f3n anterior : Desarrollo de aplicaciones web con Elixir Siguiente lecci\u00f3n -> : Despliegue de aplicaciones Elixir","title":"Pruebas y depuraci\u00f3n"},{"location":"elixir/jr/pruebas_y_depuracion/#pruebas-y-depuracion","text":"","title":"Pruebas y depuraci\u00f3n"},{"location":"elixir/jr/pruebas_y_depuracion/#introduccion","text":"En el desarrollo de software, es importante asegurarse de que el c\u00f3digo escrito funciona correctamente y de manera confiable. Para lograr esto, es necesario realizar pruebas y depuraci\u00f3n de c\u00f3digo. En este m\u00f3dulo, aprenderemos sobre la importancia de las pruebas y la depuraci\u00f3n en Elixir y c\u00f3mo aplicarlas en nuestro c\u00f3digo.","title":"Introducci\u00f3n"},{"location":"elixir/jr/pruebas_y_depuracion/#teoria","text":"","title":"Teor\u00eda"},{"location":"elixir/jr/pruebas_y_depuracion/#pruebas","text":"Las pruebas son un conjunto de acciones que se realizan en el c\u00f3digo para verificar si funciona como se espera. Hay diferentes tipos de pruebas, como las pruebas unitarias, las pruebas de integraci\u00f3n y las pruebas funcionales. En este m\u00f3dulo, nos enfocaremos en las pruebas unitarias, que son pruebas que se realizan en peque\u00f1as partes del c\u00f3digo, como funciones y m\u00f3dulos. Las pruebas unitarias son importantes porque nos permiten detectar errores en el c\u00f3digo y asegurarnos de que nuestro c\u00f3digo cumpla con los requisitos y funcione correctamente. Tambi\u00e9n nos ayudan a detectar posibles problemas en el futuro y facilitan el mantenimiento del c\u00f3digo.","title":"Pruebas"},{"location":"elixir/jr/pruebas_y_depuracion/#depuracion","text":"La depuraci\u00f3n es el proceso de identificar y corregir errores en el c\u00f3digo. Es una parte esencial del desarrollo de software, ya que incluso con pruebas rigurosas, es posible que se encuentren errores en el c\u00f3digo. La depuraci\u00f3n tambi\u00e9n nos permite comprender mejor el funcionamiento del c\u00f3digo y c\u00f3mo solucionar problemas en el futuro.","title":"Depuraci\u00f3n"},{"location":"elixir/jr/pruebas_y_depuracion/#palabras-clave","text":"Pruebas unitarias: pruebas que se realizan en peque\u00f1as partes del c\u00f3digo para verificar su correcto funcionamiento. Depuraci\u00f3n: proceso de identificar y corregir errores en el c\u00f3digo. Pruebas de integraci\u00f3n: pruebas que se realizan en diferentes partes del c\u00f3digo para verificar su correcta integraci\u00f3n. Pruebas funcionales: pruebas que se realizan en el sistema completo para verificar su correcto funcionamiento.","title":"Palabras clave"},{"location":"elixir/jr/pruebas_y_depuracion/#preguntas-de-repaso","text":"\u00bfQu\u00e9 son las pruebas unitarias y por qu\u00e9 son importantes? \u00bfCu\u00e1l es la diferencia entre las pruebas de integraci\u00f3n y las pruebas funcionales? \u00bfPor qu\u00e9 es importante realizar la depuraci\u00f3n en el c\u00f3digo?","title":"Preguntas de repaso"},{"location":"elixir/jr/pruebas_y_depuracion/#ejemplos-de-codigo","text":"A continuaci\u00f3n, se muestra un ejemplo de una funci\u00f3n en Elixir y c\u00f3mo se podr\u00eda escribir una prueba unitaria para ella. # Funci\u00f3n que devuelve el cuadrado de un n\u00famero def square ( num ) do num * num end Para escribir una prueba unitaria para esta funci\u00f3n, se puede utilizar el m\u00f3dulo ExUnit de Elixir de la siguiente manera: # Test para la funci\u00f3n square defmodule SquareTest do use ExUnit.Case # Definir el contexto de la prueba test \"square of 2 should be 4\" do assert Square . square ( 2 ) == 4 end end","title":"Ejemplos de c\u00f3digo"},{"location":"elixir/jr/pruebas_y_depuracion/#ejercicios-practicos","text":"Escribe una funci\u00f3n en Elixir que devuelva la suma de dos n\u00fameros y escribe una prueba unitaria para ella. Escribe una funci\u00f3n en Elixir que determine si un n\u00famero es par o impar y escribe una prueba unitaria para ella.","title":"Ejercicios pr\u00e1cticos"},{"location":"elixir/jr/pruebas_y_depuracion/#consejos-y-mejores-practicas","text":"Es importante escribir pruebas unitarias para todas las funciones y m\u00f3dulos en nuestro c\u00f3digo. Utilizar nombres descriptivos para las pruebas y asegurarse de cubrir todos los casos posibles. Utilizar herramientas de depuraci\u00f3n, como el m\u00f3dulo IEx , para identificar y corregir errores en el c\u00f3digo.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"elixir/jr/pruebas_y_depuracion/#navegacion-de-lecciones","text":"<- Lecci\u00f3n anterior : Desarrollo de aplicaciones web con Elixir Siguiente lecci\u00f3n -> : Despliegue de aplicaciones Elixir","title":"Navegaci\u00f3n de lecciones"},{"location":"elixir/jr/recursividad/","text":"Recursividad \u00b6 Descripci\u00f3n del m\u00f3dulo: \u00b6 La recursividad es un concepto fundamental en la programaci\u00f3n funcional y es especialmente importante en Elixir, ya que este lenguaje se basa en el paradigma funcional. En este m\u00f3dulo, aprenderemos qu\u00e9 es la recursividad, c\u00f3mo funciona y c\u00f3mo se implementa en Elixir. Tambi\u00e9n veremos algunos ejemplos de c\u00f3digo y ejercicios pr\u00e1cticos para afianzar los conocimientos adquiridos. Explicaci\u00f3n te\u00f3rica: \u00b6 La recursividad es una t\u00e9cnica de programaci\u00f3n en la que una funci\u00f3n se llama a s\u00ed misma para resolver un problema. Esto permite resolver problemas m\u00e1s complejos dividi\u00e9ndolos en problemas m\u00e1s peque\u00f1os y m\u00e1s simples. La recursividad es similar a un bucle, pero en lugar de repetir el mismo c\u00f3digo una y otra vez, se llama a la funci\u00f3n recursiva hasta que se alcanza un caso base que detiene la recursividad. La recursividad tiene dos componentes importantes: el caso base y el caso recursivo. El caso base es la condici\u00f3n que detiene la recursividad, mientras que el caso recursivo es la llamada a la funci\u00f3n recursiva para resolver el problema en t\u00e9rminos m\u00e1s peque\u00f1os. Palabras clave y su definici\u00f3n: \u00b6 Recursividad: t\u00e9cnica de programaci\u00f3n en la que una funci\u00f3n se llama a s\u00ed misma para resolver un problema. Caso base: condici\u00f3n que detiene la recursividad. Caso recursivo: llamada a la funci\u00f3n recursiva para resolver el problema en t\u00e9rminos m\u00e1s peque\u00f1os. Preguntas de repaso: \u00b6 \u00bfQu\u00e9 es la recursividad? \u00bfCu\u00e1les son los dos componentes importantes de la recursividad? \u00bfQu\u00e9 es el caso base? \u00bfQu\u00e9 es el caso recursivo? Ejemplos de c\u00f3digo en Elixir: \u00b6 Ejemplo 1: Factorial \u00b6 El factorial de un n\u00famero n se define como n! = n * (n-1) * (n-2) * ... * 1. Veamos c\u00f3mo se puede implementar esta funci\u00f3n de forma recursiva en Elixir: def factorial ( n ) do if n == 1 do 1 else n * factorial ( n - 1 ) end end Ejemplo 2: Fibonacci \u00b6 La secuencia de Fibonacci es una serie de n\u00fameros en la que cada n\u00famero es la suma de los dos anteriores. Por ejemplo, los primeros 10 n\u00fameros de la secuencia son: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34. Veamos c\u00f3mo se puede implementar esta funci\u00f3n de forma recursiva en Elixir: def fibonacci ( n ) do if n == 0 or n == 1 do n else fibonacci ( n - 1 ) + fibonacci ( n - 2 ) end end Ejercicios pr\u00e1cticos con instrucciones claras: \u00b6 Escribe una funci\u00f3n recursiva para calcular la suma de los primeros n n\u00fameros naturales. Escribe una funci\u00f3n recursiva para calcular el m\u00e1ximo com\u00fan divisor (MCD) de dos n\u00fameros. Escribe una funci\u00f3n recursiva para invertir una lista. Consejos o mejores pr\u00e1cticas: \u00b6 Aseg\u00farate de tener un caso base para detener la recursividad, de lo contrario, la funci\u00f3n se llamar\u00e1 infinitamente. Utiliza la recursividad cuando sea la soluci\u00f3n m\u00e1s simple y elegante para un problema. Evita la recursividad en casos en los que la iteraci\u00f3n sea m\u00e1s eficiente, ya que la recursividad puede ser m\u00e1s costosa en t\u00e9rminos de tiempo y memoria. Navegaci\u00f3n de lecciones \u00b6 <- Lecci\u00f3n anterior : Concurrencia Siguiente lecci\u00f3n -> : M\u00f3dulos","title":"Recursividad"},{"location":"elixir/jr/recursividad/#recursividad","text":"","title":"Recursividad"},{"location":"elixir/jr/recursividad/#descripcion-del-modulo","text":"La recursividad es un concepto fundamental en la programaci\u00f3n funcional y es especialmente importante en Elixir, ya que este lenguaje se basa en el paradigma funcional. En este m\u00f3dulo, aprenderemos qu\u00e9 es la recursividad, c\u00f3mo funciona y c\u00f3mo se implementa en Elixir. Tambi\u00e9n veremos algunos ejemplos de c\u00f3digo y ejercicios pr\u00e1cticos para afianzar los conocimientos adquiridos.","title":"Descripci\u00f3n del m\u00f3dulo:"},{"location":"elixir/jr/recursividad/#explicacion-teorica","text":"La recursividad es una t\u00e9cnica de programaci\u00f3n en la que una funci\u00f3n se llama a s\u00ed misma para resolver un problema. Esto permite resolver problemas m\u00e1s complejos dividi\u00e9ndolos en problemas m\u00e1s peque\u00f1os y m\u00e1s simples. La recursividad es similar a un bucle, pero en lugar de repetir el mismo c\u00f3digo una y otra vez, se llama a la funci\u00f3n recursiva hasta que se alcanza un caso base que detiene la recursividad. La recursividad tiene dos componentes importantes: el caso base y el caso recursivo. El caso base es la condici\u00f3n que detiene la recursividad, mientras que el caso recursivo es la llamada a la funci\u00f3n recursiva para resolver el problema en t\u00e9rminos m\u00e1s peque\u00f1os.","title":"Explicaci\u00f3n te\u00f3rica:"},{"location":"elixir/jr/recursividad/#palabras-clave-y-su-definicion","text":"Recursividad: t\u00e9cnica de programaci\u00f3n en la que una funci\u00f3n se llama a s\u00ed misma para resolver un problema. Caso base: condici\u00f3n que detiene la recursividad. Caso recursivo: llamada a la funci\u00f3n recursiva para resolver el problema en t\u00e9rminos m\u00e1s peque\u00f1os.","title":"Palabras clave y su definici\u00f3n:"},{"location":"elixir/jr/recursividad/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la recursividad? \u00bfCu\u00e1les son los dos componentes importantes de la recursividad? \u00bfQu\u00e9 es el caso base? \u00bfQu\u00e9 es el caso recursivo?","title":"Preguntas de repaso:"},{"location":"elixir/jr/recursividad/#ejemplos-de-codigo-en-elixir","text":"","title":"Ejemplos de c\u00f3digo en Elixir:"},{"location":"elixir/jr/recursividad/#ejemplo-1-factorial","text":"El factorial de un n\u00famero n se define como n! = n * (n-1) * (n-2) * ... * 1. Veamos c\u00f3mo se puede implementar esta funci\u00f3n de forma recursiva en Elixir: def factorial ( n ) do if n == 1 do 1 else n * factorial ( n - 1 ) end end","title":"Ejemplo 1: Factorial"},{"location":"elixir/jr/recursividad/#ejemplo-2-fibonacci","text":"La secuencia de Fibonacci es una serie de n\u00fameros en la que cada n\u00famero es la suma de los dos anteriores. Por ejemplo, los primeros 10 n\u00fameros de la secuencia son: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34. Veamos c\u00f3mo se puede implementar esta funci\u00f3n de forma recursiva en Elixir: def fibonacci ( n ) do if n == 0 or n == 1 do n else fibonacci ( n - 1 ) + fibonacci ( n - 2 ) end end","title":"Ejemplo 2: Fibonacci"},{"location":"elixir/jr/recursividad/#ejercicios-practicos-con-instrucciones-claras","text":"Escribe una funci\u00f3n recursiva para calcular la suma de los primeros n n\u00fameros naturales. Escribe una funci\u00f3n recursiva para calcular el m\u00e1ximo com\u00fan divisor (MCD) de dos n\u00fameros. Escribe una funci\u00f3n recursiva para invertir una lista.","title":"Ejercicios pr\u00e1cticos con instrucciones claras:"},{"location":"elixir/jr/recursividad/#consejos-o-mejores-practicas","text":"Aseg\u00farate de tener un caso base para detener la recursividad, de lo contrario, la funci\u00f3n se llamar\u00e1 infinitamente. Utiliza la recursividad cuando sea la soluci\u00f3n m\u00e1s simple y elegante para un problema. Evita la recursividad en casos en los que la iteraci\u00f3n sea m\u00e1s eficiente, ya que la recursividad puede ser m\u00e1s costosa en t\u00e9rminos de tiempo y memoria.","title":"Consejos o mejores pr\u00e1cticas:"},{"location":"elixir/jr/recursividad/#navegacion-de-lecciones","text":"<- Lecci\u00f3n anterior : Concurrencia Siguiente lecci\u00f3n -> : M\u00f3dulos","title":"Navegaci\u00f3n de lecciones"},{"location":"elixir/jr/sintaxis_basica/","text":"Sintaxis b\u00e1sica \u00b6 En esta lecci\u00f3n, aprenderemos la sintaxis b\u00e1sica de Elixir, un lenguaje de programaci\u00f3n funcional y concurrente que se ejecuta en la m\u00e1quina virtual de Erlang. Elixir es conocido por su sintaxis clara y concisa, lo que lo hace f\u00e1cil de aprender y leer. Tipos de datos \u00b6 En Elixir, existen varios tipos de datos b\u00e1sicos, incluyendo enteros, decimales, booleanos, \u00e1tomos, cadenas de texto y listas. Los enteros pueden ser positivos o negativos y no tienen un l\u00edmite de tama\u00f1o. Los decimales se representan con un punto decimal y pueden ser de doble precisi\u00f3n. Los booleanos pueden tener dos valores: true o false . Los \u00e1tomos son constantes que representan un valor \u00fanico, como un identificador o una etiqueta. Las cadenas de texto se representan entre comillas dobles y pueden contener cualquier car\u00e1cter. Las listas son colecciones ordenadas de elementos, que pueden ser de cualquier tipo de datos. Operadores \u00b6 Elixir tiene los operadores b\u00e1sicos de suma + , resta - , multiplicaci\u00f3n * , divisi\u00f3n / y m\u00f3dulo % . Tambi\u00e9n cuenta con los operadores de comparaci\u00f3n == , != , < , > , <= y >= para comparar valores. Adem\u00e1s, existen operadores l\u00f3gicos como and , or y not para evaluar expresiones booleanas. Estructuras de control \u00b6 Las estructuras de control en Elixir incluyen condicionales, bucles y funciones. Los condicionales se utilizan para ejecutar un bloque de c\u00f3digo si se cumple una determinada condici\u00f3n, y se pueden anidar utilizando la palabra clave else . Los bucles se utilizan para repetir un bloque de c\u00f3digo hasta que se cumpla una condici\u00f3n, y pueden ser de tipo while o for . Las funciones son bloques de c\u00f3digo que se pueden llamar en cualquier momento y pueden tener par\u00e1metros y valores de retorno. Palabras clave \u00b6 def : define una funci\u00f3n. do : indica el inicio de un bloque de c\u00f3digo. end : indica el final de un bloque de c\u00f3digo. if : inicia una estructura condicional. else : indica un bloque de c\u00f3digo alternativo en una estructura condicional. while : inicia un bucle que se repetir\u00e1 mientras se cumpla una condici\u00f3n. for : inicia un bucle que se repetir\u00e1 por cada elemento de una lista. and : operador l\u00f3gico que eval\u00faa si ambas expresiones son verdaderas. or : operador l\u00f3gico que eval\u00faa si al menos una de las expresiones es verdadera. not : operador l\u00f3gico que niega una expresi\u00f3n. Preguntas de repaso \u00b6 \u00bfCu\u00e1les son los tipos de datos b\u00e1sicos en Elixir? \u00bfC\u00f3mo se representan los decimales en Elixir? \u00bfQu\u00e9 palabra clave se utiliza para definir una funci\u00f3n? \u00bfQu\u00e9 operador se utiliza para comparar valores? \u00bfQu\u00e9 estructura de control se utiliza para repetir un bloque de c\u00f3digo mientras se cumpla una condici\u00f3n? Ejemplos de c\u00f3digo \u00b6 # Definici\u00f3n de una funci\u00f3n que suma dos n\u00fameros def sum ( a , b ) do a + b end # Uso de la funci\u00f3n result = sum ( 5 , 3 ) IO.puts ( \"El resultado es #{result}\" ) # Salida: El resultado es 8 # Estructura condicional if age >= 18 do IO.puts ( \"Eres mayor de edad\" ) else IO.puts ( \"Eres menor de edad\" ) end # Bucle while i = 1 while i <= 5 do IO.puts ( \"Contador: #{i}\" ) i = i + 1 end # Salida: # Contador: 1 # Contador: 2 # Contador: 3 # Contador: 4 # Contador: 5 # Bucle for for num <- [ 1 , 2 , 3 ] do IO.puts ( \"N\u00famero: #{num}\" ) end # Salida: # N\u00famero: 1 # N\u00famero: 2 # N\u00famero: 3 Ejercicios pr\u00e1cticos \u00b6 Escribe una funci\u00f3n que calcule el \u00e1rea de un tri\u00e1ngulo (base x altura / 2). Utiliza un bucle for para imprimir los n\u00fameros del 1 al 10. Escribe una funci\u00f3n que verifique si un n\u00famero es par o impar. Consejos \u00b6 Utiliza nombres de variables y funciones descriptivos para que sea m\u00e1s f\u00e1cil entender tu c\u00f3digo. Aprovecha la concisi\u00f3n de la sintaxis de Elixir para escribir c\u00f3digo m\u00e1s legible y mantenible. Practica la resoluci\u00f3n de problemas utilizando estructuras de control y funciones en Elixir para familiarizarte con su uso. Navegaci\u00f3n de lecciones \u00b6 <- Lecci\u00f3n anterior : Introducci\u00f3n a Elixir Siguiente lecci\u00f3n -> : Listas y tuplas","title":"Sintaxis basica"},{"location":"elixir/jr/sintaxis_basica/#sintaxis-basica","text":"En esta lecci\u00f3n, aprenderemos la sintaxis b\u00e1sica de Elixir, un lenguaje de programaci\u00f3n funcional y concurrente que se ejecuta en la m\u00e1quina virtual de Erlang. Elixir es conocido por su sintaxis clara y concisa, lo que lo hace f\u00e1cil de aprender y leer.","title":"Sintaxis b\u00e1sica"},{"location":"elixir/jr/sintaxis_basica/#tipos-de-datos","text":"En Elixir, existen varios tipos de datos b\u00e1sicos, incluyendo enteros, decimales, booleanos, \u00e1tomos, cadenas de texto y listas. Los enteros pueden ser positivos o negativos y no tienen un l\u00edmite de tama\u00f1o. Los decimales se representan con un punto decimal y pueden ser de doble precisi\u00f3n. Los booleanos pueden tener dos valores: true o false . Los \u00e1tomos son constantes que representan un valor \u00fanico, como un identificador o una etiqueta. Las cadenas de texto se representan entre comillas dobles y pueden contener cualquier car\u00e1cter. Las listas son colecciones ordenadas de elementos, que pueden ser de cualquier tipo de datos.","title":"Tipos de datos"},{"location":"elixir/jr/sintaxis_basica/#operadores","text":"Elixir tiene los operadores b\u00e1sicos de suma + , resta - , multiplicaci\u00f3n * , divisi\u00f3n / y m\u00f3dulo % . Tambi\u00e9n cuenta con los operadores de comparaci\u00f3n == , != , < , > , <= y >= para comparar valores. Adem\u00e1s, existen operadores l\u00f3gicos como and , or y not para evaluar expresiones booleanas.","title":"Operadores"},{"location":"elixir/jr/sintaxis_basica/#estructuras-de-control","text":"Las estructuras de control en Elixir incluyen condicionales, bucles y funciones. Los condicionales se utilizan para ejecutar un bloque de c\u00f3digo si se cumple una determinada condici\u00f3n, y se pueden anidar utilizando la palabra clave else . Los bucles se utilizan para repetir un bloque de c\u00f3digo hasta que se cumpla una condici\u00f3n, y pueden ser de tipo while o for . Las funciones son bloques de c\u00f3digo que se pueden llamar en cualquier momento y pueden tener par\u00e1metros y valores de retorno.","title":"Estructuras de control"},{"location":"elixir/jr/sintaxis_basica/#palabras-clave","text":"def : define una funci\u00f3n. do : indica el inicio de un bloque de c\u00f3digo. end : indica el final de un bloque de c\u00f3digo. if : inicia una estructura condicional. else : indica un bloque de c\u00f3digo alternativo en una estructura condicional. while : inicia un bucle que se repetir\u00e1 mientras se cumpla una condici\u00f3n. for : inicia un bucle que se repetir\u00e1 por cada elemento de una lista. and : operador l\u00f3gico que eval\u00faa si ambas expresiones son verdaderas. or : operador l\u00f3gico que eval\u00faa si al menos una de las expresiones es verdadera. not : operador l\u00f3gico que niega una expresi\u00f3n.","title":"Palabras clave"},{"location":"elixir/jr/sintaxis_basica/#preguntas-de-repaso","text":"\u00bfCu\u00e1les son los tipos de datos b\u00e1sicos en Elixir? \u00bfC\u00f3mo se representan los decimales en Elixir? \u00bfQu\u00e9 palabra clave se utiliza para definir una funci\u00f3n? \u00bfQu\u00e9 operador se utiliza para comparar valores? \u00bfQu\u00e9 estructura de control se utiliza para repetir un bloque de c\u00f3digo mientras se cumpla una condici\u00f3n?","title":"Preguntas de repaso"},{"location":"elixir/jr/sintaxis_basica/#ejemplos-de-codigo","text":"# Definici\u00f3n de una funci\u00f3n que suma dos n\u00fameros def sum ( a , b ) do a + b end # Uso de la funci\u00f3n result = sum ( 5 , 3 ) IO.puts ( \"El resultado es #{result}\" ) # Salida: El resultado es 8 # Estructura condicional if age >= 18 do IO.puts ( \"Eres mayor de edad\" ) else IO.puts ( \"Eres menor de edad\" ) end # Bucle while i = 1 while i <= 5 do IO.puts ( \"Contador: #{i}\" ) i = i + 1 end # Salida: # Contador: 1 # Contador: 2 # Contador: 3 # Contador: 4 # Contador: 5 # Bucle for for num <- [ 1 , 2 , 3 ] do IO.puts ( \"N\u00famero: #{num}\" ) end # Salida: # N\u00famero: 1 # N\u00famero: 2 # N\u00famero: 3","title":"Ejemplos de c\u00f3digo"},{"location":"elixir/jr/sintaxis_basica/#ejercicios-practicos","text":"Escribe una funci\u00f3n que calcule el \u00e1rea de un tri\u00e1ngulo (base x altura / 2). Utiliza un bucle for para imprimir los n\u00fameros del 1 al 10. Escribe una funci\u00f3n que verifique si un n\u00famero es par o impar.","title":"Ejercicios pr\u00e1cticos"},{"location":"elixir/jr/sintaxis_basica/#consejos","text":"Utiliza nombres de variables y funciones descriptivos para que sea m\u00e1s f\u00e1cil entender tu c\u00f3digo. Aprovecha la concisi\u00f3n de la sintaxis de Elixir para escribir c\u00f3digo m\u00e1s legible y mantenible. Practica la resoluci\u00f3n de problemas utilizando estructuras de control y funciones en Elixir para familiarizarte con su uso.","title":"Consejos"},{"location":"elixir/jr/sintaxis_basica/#navegacion-de-lecciones","text":"<- Lecci\u00f3n anterior : Introducci\u00f3n a Elixir Siguiente lecci\u00f3n -> : Listas y tuplas","title":"Navegaci\u00f3n de lecciones"},{"location":"elixir/jr/supervision_de_procesos/","text":"Supervisi\u00f3n de procesos \u00b6 Teor\u00eda \u00b6 En Elixir, cada proceso es independiente y puede comunicarse con otros procesos mediante el env\u00edo de mensajes. Sin embargo, los procesos pueden fallar debido a errores en el c\u00f3digo o en el sistema. Para mantener la estabilidad del sistema, Elixir cuenta con un sistema de supervisi\u00f3n de procesos que permite manejar los errores de forma eficiente. La supervisi\u00f3n de procesos se basa en el principio de \"let it crash\", lo que significa que un proceso debe fallar de forma controlada y ser reiniciado por su supervisor en lugar de intentar atrapar todos los errores y seguir ejecutando. Esto permite que el sistema se recupere de forma m\u00e1s r\u00e1pida y evita que los errores se propaguen a otros procesos. Cada proceso en Elixir es supervisado por un supervisor, que es un proceso especial que se encarga de iniciar, reiniciar y detener otros procesos. Los supervisores se organizan en una jerarqu\u00eda, donde un supervisor puede tener a su cargo otros supervisores y procesos. Esto permite una mayor granularidad en el manejo de errores y una mejor escalabilidad del sistema. En caso de que un proceso falle, su supervisor puede tomar diferentes acciones dependiendo del tipo de error y su gravedad. Por ejemplo, puede reiniciar el proceso, detenerlo completamente o incluso reiniciar todo el \u00e1rbol de procesos que est\u00e1 supervisando. Palabras clave y definiciones \u00b6 Proceso: Es una unidad de ejecuci\u00f3n independiente en Elixir, que puede comunicarse con otros procesos mediante el env\u00edo de mensajes. Supervisi\u00f3n: Es el proceso de monitorear y manejar los errores en un sistema de procesos. Supervisor: Es un proceso especial encargado de iniciar, reiniciar y detener otros procesos. Jerarqu\u00eda de supervisi\u00f3n: Es la estructura en la que los supervisores se organizan, permitiendo una mejor escalabilidad y manejo de errores. Let it crash: Es el principio en el que se basa la supervisi\u00f3n de procesos en Elixir, que consiste en dejar que un proceso falle de forma controlada y ser reiniciado por su supervisor. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la supervisi\u00f3n de procesos en Elixir? \u00bfPor qu\u00e9 se utiliza el principio de \"let it crash\" en la supervisi\u00f3n de procesos? \u00bfC\u00f3mo se organizan los supervisores en Elixir? \u00bfQu\u00e9 acciones puede tomar un supervisor en caso de que un proceso falle? \u00bfCu\u00e1l es la funci\u00f3n de un supervisor en el sistema de supervisi\u00f3n de procesos? Ejemplos de c\u00f3digo \u00b6 Definici\u00f3n de un supervisor \u00b6 defmodule MiApp . Supervisor do use Supervisor def start_link do Supervisor . start_link ( __MODULE__ , []) end def init ( _ ) do children = [ worker ( MiApp . Worker , []) # Se agrega un proceso \"worker\" al supervisor ] supervise ( children , strategy: : one_for_one ) # Se define la estrategia de supervisi\u00f3n end end Definici\u00f3n de un proceso supervisado \u00b6 defmodule MiApp.Worker do use GenServer def start_link do GenServer.start_link(__MODULE__, [], name: __MODULE__) end def init(_) do # C\u00f3digo de inicializaci\u00f3n del proceso {:ok, []} end def handle_cast(:error, state) do # C\u00f3digo para manejar un error en el proceso {:noreply, state} end end Ejercicios pr\u00e1cticos \u00b6 Crea un supervisor que supervise un proceso y un supervisor secundario. Define una estrategia de supervisi\u00f3n adecuada para esta estructura. Crea un proceso que reciba un mensaje y lo imprima por pantalla. Luego, utiliza el supervisor creado en el ejercicio anterior para manejar un posible error en el proceso. Modifica el c\u00f3digo del supervisor para que, en caso de que el proceso falle, se reinicie autom\u00e1ticamente. Consejos y mejores pr\u00e1cticas \u00b6 Utiliza una jerarqu\u00eda de supervisi\u00f3n bien definida y evita tener un supervisor para todos los procesos de la aplicaci\u00f3n. Define una estrategia de supervisi\u00f3n adecuada para cada supervisor, teniendo en cuenta la gravedad de los posibles errores. Utiliza el m\u00f3dulo Supervisor de Elixir para crear y manejar supervisores de forma sencilla. No intentes atrapar todos los errores en cada proceso, deja que el sistema de supervisi\u00f3n se encargue de manejarlos de forma eficiente. Navegaci\u00f3n de lecciones \u00b6 <- Lecci\u00f3n anterior : Despliegue de aplicaciones Elixir","title":"Supervisi\u00f3n de procesos"},{"location":"elixir/jr/supervision_de_procesos/#supervision-de-procesos","text":"","title":"Supervisi\u00f3n de procesos"},{"location":"elixir/jr/supervision_de_procesos/#teoria","text":"En Elixir, cada proceso es independiente y puede comunicarse con otros procesos mediante el env\u00edo de mensajes. Sin embargo, los procesos pueden fallar debido a errores en el c\u00f3digo o en el sistema. Para mantener la estabilidad del sistema, Elixir cuenta con un sistema de supervisi\u00f3n de procesos que permite manejar los errores de forma eficiente. La supervisi\u00f3n de procesos se basa en el principio de \"let it crash\", lo que significa que un proceso debe fallar de forma controlada y ser reiniciado por su supervisor en lugar de intentar atrapar todos los errores y seguir ejecutando. Esto permite que el sistema se recupere de forma m\u00e1s r\u00e1pida y evita que los errores se propaguen a otros procesos. Cada proceso en Elixir es supervisado por un supervisor, que es un proceso especial que se encarga de iniciar, reiniciar y detener otros procesos. Los supervisores se organizan en una jerarqu\u00eda, donde un supervisor puede tener a su cargo otros supervisores y procesos. Esto permite una mayor granularidad en el manejo de errores y una mejor escalabilidad del sistema. En caso de que un proceso falle, su supervisor puede tomar diferentes acciones dependiendo del tipo de error y su gravedad. Por ejemplo, puede reiniciar el proceso, detenerlo completamente o incluso reiniciar todo el \u00e1rbol de procesos que est\u00e1 supervisando.","title":"Teor\u00eda"},{"location":"elixir/jr/supervision_de_procesos/#palabras-clave-y-definiciones","text":"Proceso: Es una unidad de ejecuci\u00f3n independiente en Elixir, que puede comunicarse con otros procesos mediante el env\u00edo de mensajes. Supervisi\u00f3n: Es el proceso de monitorear y manejar los errores en un sistema de procesos. Supervisor: Es un proceso especial encargado de iniciar, reiniciar y detener otros procesos. Jerarqu\u00eda de supervisi\u00f3n: Es la estructura en la que los supervisores se organizan, permitiendo una mejor escalabilidad y manejo de errores. Let it crash: Es el principio en el que se basa la supervisi\u00f3n de procesos en Elixir, que consiste en dejar que un proceso falle de forma controlada y ser reiniciado por su supervisor.","title":"Palabras clave y definiciones"},{"location":"elixir/jr/supervision_de_procesos/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la supervisi\u00f3n de procesos en Elixir? \u00bfPor qu\u00e9 se utiliza el principio de \"let it crash\" en la supervisi\u00f3n de procesos? \u00bfC\u00f3mo se organizan los supervisores en Elixir? \u00bfQu\u00e9 acciones puede tomar un supervisor en caso de que un proceso falle? \u00bfCu\u00e1l es la funci\u00f3n de un supervisor en el sistema de supervisi\u00f3n de procesos?","title":"Preguntas de repaso"},{"location":"elixir/jr/supervision_de_procesos/#ejemplos-de-codigo","text":"","title":"Ejemplos de c\u00f3digo"},{"location":"elixir/jr/supervision_de_procesos/#definicion-de-un-supervisor","text":"defmodule MiApp . Supervisor do use Supervisor def start_link do Supervisor . start_link ( __MODULE__ , []) end def init ( _ ) do children = [ worker ( MiApp . Worker , []) # Se agrega un proceso \"worker\" al supervisor ] supervise ( children , strategy: : one_for_one ) # Se define la estrategia de supervisi\u00f3n end end","title":"Definici\u00f3n de un supervisor"},{"location":"elixir/jr/supervision_de_procesos/#definicion-de-un-proceso-supervisado","text":"defmodule MiApp.Worker do use GenServer def start_link do GenServer.start_link(__MODULE__, [], name: __MODULE__) end def init(_) do # C\u00f3digo de inicializaci\u00f3n del proceso {:ok, []} end def handle_cast(:error, state) do # C\u00f3digo para manejar un error en el proceso {:noreply, state} end end","title":"Definici\u00f3n de un proceso supervisado"},{"location":"elixir/jr/supervision_de_procesos/#ejercicios-practicos","text":"Crea un supervisor que supervise un proceso y un supervisor secundario. Define una estrategia de supervisi\u00f3n adecuada para esta estructura. Crea un proceso que reciba un mensaje y lo imprima por pantalla. Luego, utiliza el supervisor creado en el ejercicio anterior para manejar un posible error en el proceso. Modifica el c\u00f3digo del supervisor para que, en caso de que el proceso falle, se reinicie autom\u00e1ticamente.","title":"Ejercicios pr\u00e1cticos"},{"location":"elixir/jr/supervision_de_procesos/#consejos-y-mejores-practicas","text":"Utiliza una jerarqu\u00eda de supervisi\u00f3n bien definida y evita tener un supervisor para todos los procesos de la aplicaci\u00f3n. Define una estrategia de supervisi\u00f3n adecuada para cada supervisor, teniendo en cuenta la gravedad de los posibles errores. Utiliza el m\u00f3dulo Supervisor de Elixir para crear y manejar supervisores de forma sencilla. No intentes atrapar todos los errores en cada proceso, deja que el sistema de supervisi\u00f3n se encargue de manejarlos de forma eficiente.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"elixir/jr/supervision_de_procesos/#navegacion-de-lecciones","text":"<- Lecci\u00f3n anterior : Despliegue de aplicaciones Elixir","title":"Navegaci\u00f3n de lecciones"},{"location":"elixir/mid/","text":"Elixir - Nivel Mid \u00b6 \u00a1Bienvenido/a al nivel Mid del curso de Elixir! En este nivel exploras t\u00e9cnicas intermedias y desarrollo avanzado: Programaci\u00f3n funcional avanzada Composici\u00f3n de procesos Desarrollo de aplicaciones concurrentes Desarrollo de aplicaciones de tiempo real Dise\u00f1o de APIs en Elixir Integraci\u00f3n con bases de datos Optimizaci\u00f3n de rendimiento Implementaci\u00f3n de tolerancia a fallos Seguridad en aplicaciones Elixir Supervisi\u00f3n avanzada de procesos Desarrollo de sistemas distribuidos","title":"Nivel Middle"},{"location":"elixir/mid/#elixir-nivel-mid","text":"\u00a1Bienvenido/a al nivel Mid del curso de Elixir! En este nivel exploras t\u00e9cnicas intermedias y desarrollo avanzado: Programaci\u00f3n funcional avanzada Composici\u00f3n de procesos Desarrollo de aplicaciones concurrentes Desarrollo de aplicaciones de tiempo real Dise\u00f1o de APIs en Elixir Integraci\u00f3n con bases de datos Optimizaci\u00f3n de rendimiento Implementaci\u00f3n de tolerancia a fallos Seguridad en aplicaciones Elixir Supervisi\u00f3n avanzada de procesos Desarrollo de sistemas distribuidos","title":"Elixir - Nivel Mid"},{"location":"elixir/mid/composicion_de_procesos/","text":"Composici\u00f3n de procesos \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 En Elixir, los procesos son unidades de ejecuci\u00f3n concurrentes y ligeros que se comunican entre s\u00ed a trav\u00e9s de mensajes. La composici\u00f3n de procesos se refiere a la habilidad de crear sistemas escalables y distribuidos al combinar m\u00faltiples procesos para trabajar juntos de manera eficiente. La composici\u00f3n de procesos se basa en el modelo de \"supervisi\u00f3n\" de Elixir, donde un proceso principal supervisa a otros procesos secundarios y se encarga de reiniciarlos en caso de fallos. Este modelo permite que los sistemas sean resistentes a fallos y puedan recuperarse de manera autom\u00e1tica sin afectar la funcionalidad general. Adem\u00e1s, al tener m\u00faltiples procesos trabajando juntos, se pueden aprovechar mejor los recursos del sistema y balancear la carga de trabajo. Palabras clave y su definici\u00f3n \u00b6 Procesos: unidades de ejecuci\u00f3n concurrentes y ligeros en Elixir. Supervisi\u00f3n: modelo en el que un proceso principal supervisa a otros procesos y se encarga de reiniciarlos en caso de fallos. Composici\u00f3n: combinaci\u00f3n de m\u00faltiples procesos para crear sistemas escalables y distribuidos. Mensajes: medio de comunicaci\u00f3n entre procesos en Elixir. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la composici\u00f3n de procesos en Elixir? \u00bfEn qu\u00e9 se basa el modelo de supervisi\u00f3n de Elixir? \u00bfQu\u00e9 beneficios ofrece la composici\u00f3n de procesos en t\u00e9rminos de escalabilidad y distribuci\u00f3n? \u00bfQu\u00e9 es un mensaje en Elixir y c\u00f3mo se utiliza para la comunicaci\u00f3n entre procesos? Ejemplos de c\u00f3digo en Elixir \u00b6 # Definir un m\u00f3dulo que tenga un proceso principal y dos procesos secundarios defmodule Ejemplo do # Proceso principal defp proceso_principal do # Iniciar los procesos secundarios spawn_link ( fn -> proceso_secundario1 () end) spawn_link ( fn -> proceso_secundario2 () end) end # Proceso secundario 1 defp proceso_secundario1 do # Realizar una tarea espec\u00edfica IO . puts \"Proceso secundario 1 en ejecuci\u00f3n\" end # Proceso secundario 2 defp proceso_secundario2 do # Realizar otra tarea espec\u00edfica IO . puts \"Proceso secundario 2 en ejecuci\u00f3n\" end end # Iniciar el proceso principal spawn_link ( fn -> Ejemplo . proceso_principal () end) Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea un m\u00f3dulo que tenga un proceso principal y tres procesos secundarios. El proceso principal debe iniciar los procesos secundarios y enviarles un mensaje para que realicen una tarea espec\u00edfica. Luego, el proceso principal debe esperar a que los procesos secundarios le env\u00eden una respuesta y mostrarla por pantalla. Modifica el m\u00f3dulo anterior para que los procesos secundarios se comuniquen entre s\u00ed enviando mensajes. El proceso principal debe iniciar los procesos secundarios y esperar a que se comuniquen entre s\u00ed antes de mostrar la respuesta final. Crea un m\u00f3dulo que tenga un proceso principal que se encargue de supervisar a otros procesos secundarios. Los procesos secundarios deben ejecutar tareas diferentes y enviar un mensaje al proceso principal en caso de fallo. El proceso principal debe reiniciar autom\u00e1ticamente los procesos secundarios en caso de fallos y mostrar un mensaje de error si ocurren demasiados fallos en un per\u00edodo de tiempo. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza la composici\u00f3n de procesos para crear sistemas escalables y distribuidos en lugar de tener un \u00fanico proceso que realice todas las tareas. Utiliza el modelo de supervisi\u00f3n para garantizar que los procesos se reinicien en caso de fallos y para tener sistemas resistentes a fallas. Utiliza mensajes para la comunicaci\u00f3n entre procesos y aseg\u00farate de que los procesos est\u00e9n dise\u00f1ados para manejar diferentes tipos de mensajes. Utiliza la funci\u00f3n spawn_link para iniciar procesos secundarios y mantenerlos vinculados al proceso principal. Utiliza el m\u00f3dulo GenServer para crear procesos que act\u00faen como servidores y manejen peticiones de manera eficiente. <- Lecci\u00f3n anterior : Programaci\u00f3n funcional avanzada Siguiente lecci\u00f3n -> : Desarrollo de aplicaciones concurrentes","title":"Composici\u00f3n de procesos"},{"location":"elixir/mid/composicion_de_procesos/#composicion-de-procesos","text":"","title":"Composici\u00f3n de procesos"},{"location":"elixir/mid/composicion_de_procesos/#explicacion-teorica","text":"En Elixir, los procesos son unidades de ejecuci\u00f3n concurrentes y ligeros que se comunican entre s\u00ed a trav\u00e9s de mensajes. La composici\u00f3n de procesos se refiere a la habilidad de crear sistemas escalables y distribuidos al combinar m\u00faltiples procesos para trabajar juntos de manera eficiente. La composici\u00f3n de procesos se basa en el modelo de \"supervisi\u00f3n\" de Elixir, donde un proceso principal supervisa a otros procesos secundarios y se encarga de reiniciarlos en caso de fallos. Este modelo permite que los sistemas sean resistentes a fallos y puedan recuperarse de manera autom\u00e1tica sin afectar la funcionalidad general. Adem\u00e1s, al tener m\u00faltiples procesos trabajando juntos, se pueden aprovechar mejor los recursos del sistema y balancear la carga de trabajo.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"elixir/mid/composicion_de_procesos/#palabras-clave-y-su-definicion","text":"Procesos: unidades de ejecuci\u00f3n concurrentes y ligeros en Elixir. Supervisi\u00f3n: modelo en el que un proceso principal supervisa a otros procesos y se encarga de reiniciarlos en caso de fallos. Composici\u00f3n: combinaci\u00f3n de m\u00faltiples procesos para crear sistemas escalables y distribuidos. Mensajes: medio de comunicaci\u00f3n entre procesos en Elixir.","title":"Palabras clave y su definici\u00f3n"},{"location":"elixir/mid/composicion_de_procesos/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la composici\u00f3n de procesos en Elixir? \u00bfEn qu\u00e9 se basa el modelo de supervisi\u00f3n de Elixir? \u00bfQu\u00e9 beneficios ofrece la composici\u00f3n de procesos en t\u00e9rminos de escalabilidad y distribuci\u00f3n? \u00bfQu\u00e9 es un mensaje en Elixir y c\u00f3mo se utiliza para la comunicaci\u00f3n entre procesos?","title":"Preguntas de repaso"},{"location":"elixir/mid/composicion_de_procesos/#ejemplos-de-codigo-en-elixir","text":"# Definir un m\u00f3dulo que tenga un proceso principal y dos procesos secundarios defmodule Ejemplo do # Proceso principal defp proceso_principal do # Iniciar los procesos secundarios spawn_link ( fn -> proceso_secundario1 () end) spawn_link ( fn -> proceso_secundario2 () end) end # Proceso secundario 1 defp proceso_secundario1 do # Realizar una tarea espec\u00edfica IO . puts \"Proceso secundario 1 en ejecuci\u00f3n\" end # Proceso secundario 2 defp proceso_secundario2 do # Realizar otra tarea espec\u00edfica IO . puts \"Proceso secundario 2 en ejecuci\u00f3n\" end end # Iniciar el proceso principal spawn_link ( fn -> Ejemplo . proceso_principal () end)","title":"Ejemplos de c\u00f3digo en Elixir"},{"location":"elixir/mid/composicion_de_procesos/#ejercicios-practicos-con-instrucciones-claras","text":"Crea un m\u00f3dulo que tenga un proceso principal y tres procesos secundarios. El proceso principal debe iniciar los procesos secundarios y enviarles un mensaje para que realicen una tarea espec\u00edfica. Luego, el proceso principal debe esperar a que los procesos secundarios le env\u00eden una respuesta y mostrarla por pantalla. Modifica el m\u00f3dulo anterior para que los procesos secundarios se comuniquen entre s\u00ed enviando mensajes. El proceso principal debe iniciar los procesos secundarios y esperar a que se comuniquen entre s\u00ed antes de mostrar la respuesta final. Crea un m\u00f3dulo que tenga un proceso principal que se encargue de supervisar a otros procesos secundarios. Los procesos secundarios deben ejecutar tareas diferentes y enviar un mensaje al proceso principal en caso de fallo. El proceso principal debe reiniciar autom\u00e1ticamente los procesos secundarios en caso de fallos y mostrar un mensaje de error si ocurren demasiados fallos en un per\u00edodo de tiempo.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"elixir/mid/composicion_de_procesos/#consejos-o-mejores-practicas","text":"Utiliza la composici\u00f3n de procesos para crear sistemas escalables y distribuidos en lugar de tener un \u00fanico proceso que realice todas las tareas. Utiliza el modelo de supervisi\u00f3n para garantizar que los procesos se reinicien en caso de fallos y para tener sistemas resistentes a fallas. Utiliza mensajes para la comunicaci\u00f3n entre procesos y aseg\u00farate de que los procesos est\u00e9n dise\u00f1ados para manejar diferentes tipos de mensajes. Utiliza la funci\u00f3n spawn_link para iniciar procesos secundarios y mantenerlos vinculados al proceso principal. Utiliza el m\u00f3dulo GenServer para crear procesos que act\u00faen como servidores y manejen peticiones de manera eficiente. <- Lecci\u00f3n anterior : Programaci\u00f3n funcional avanzada Siguiente lecci\u00f3n -> : Desarrollo de aplicaciones concurrentes","title":"Consejos o mejores pr\u00e1cticas"},{"location":"elixir/mid/desarrollo_de_aplicaciones_concurrentes/","text":"Desarrollo de aplicaciones concurrentes \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 En Elixir, la concurrencia se refiere a la capacidad de ejecutar m\u00faltiples procesos al mismo tiempo. Esto es posible gracias al modelo de concurrencia de Elixir, basado en el modelo de actores. En este modelo, los procesos se comunican entre s\u00ed enviando y recibiendo mensajes, lo que permite una comunicaci\u00f3n eficiente y segura entre procesos. La concurrencia es esencial en el desarrollo de aplicaciones escalables y distribuidas, ya que permite aprovechar al m\u00e1ximo los recursos del sistema y mejorar el rendimiento de la aplicaci\u00f3n. Adem\u00e1s, en Elixir la concurrencia se logra de forma natural, ya que los procesos son ligeros y se crean y destruyen de manera eficiente. Para desarrollar aplicaciones concurrentes en Elixir, es importante entender los diferentes patrones y t\u00e9cnicas que ofrece el lenguaje. Algunos de los m\u00e1s comunes son: Supervisor: se encarga de iniciar, supervisar y reiniciar procesos en caso de que falle. GenServer: se utiliza para crear procesos que mantienen un estado y pueden recibir y enviar mensajes. Task: permite ejecutar tareas en segundo plano de forma as\u00edncrona. Agent: se utiliza para gestionar el estado de una sola entidad de forma concurrente. Palabras clave y su definici\u00f3n \u00b6 Concurrencia: capacidad de ejecutar m\u00faltiples procesos al mismo tiempo. Modelo de actores: modelo de concurrencia basado en el env\u00edo y recepci\u00f3n de mensajes entre procesos. Proceso: unidad de ejecuci\u00f3n en Elixir. Mensaje: forma de comunicaci\u00f3n entre procesos en el modelo de actores. Escalabilidad: capacidad de una aplicaci\u00f3n de crecer y adaptarse a un aumento en la demanda de recursos. Distribuci\u00f3n: capacidad de una aplicaci\u00f3n de ejecutarse en m\u00faltiples nodos o m\u00e1quinas. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la concurrencia y por qu\u00e9 es importante en el desarrollo de aplicaciones? \u00bfC\u00f3mo se logra la concurrencia en Elixir? \u00bfCu\u00e1les son algunos de los patrones y t\u00e9cnicas que se utilizan en Elixir para desarrollar aplicaciones concurrentes? \u00bfQu\u00e9 es el modelo de actores y c\u00f3mo se relaciona con la concurrencia en Elixir? \u00bfCu\u00e1l es la diferencia entre escalabilidad y distribuci\u00f3n en el contexto de aplicaciones concurrentes? Ejemplos de c\u00f3digo en Elixir \u00b6 Ejemplo de creaci\u00f3n de un proceso con Supervisor: defmodule MiProceso do use GenServer # funciones de GenServer end defmodule MiSupervisor do use Supervisor def start_link do Supervisor . start_link ( __MODULE__ , []) end def init ( _ ) do children = [ worker ( MiProceso , []) ] supervise ( children , strategy : :one_for_one ) end end Ejemplo de uso de GenServer para crear un proceso que mantiene un contador: defmodule Contador do use GenServer def start_link do GenServer . start_link ( __MODULE__ , 0 ) end def inc do GenServer . cast ( __MODULE__ , :inc ) end def handle_cast ( :inc , count ) do { :noreply , count + 1 } end end Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea un supervisor que supervise un proceso que mantenga una lista de nombres. El proceso debe tener las funciones add/1 para agregar un nombre a la lista, remove/1 para eliminar un nombre de la lista y get_all/0 para obtener la lista completa. Crea un GenServer que mantenga un contador y tenga las funciones increment/0 para aumentar el contador en 1 y get_count/0 para obtener el valor actual del contador. Utiliza el m\u00f3dulo Task para ejecutar una funci\u00f3n en segundo plano y obtener su resultado. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza el modelo de actores de forma adecuada, enviando mensajes y evitando el uso de variables compartidas. Utiliza supervisores para gestionar la creaci\u00f3n y reinicio de procesos en caso de fallos. Utiliza patrones como GenServer y Agent para gestionar el estado de forma concurrente. Evita bloquear procesos con operaciones costosas, como llamadas a la base de datos, y utiliza tareas en segundo plano si es necesario. <- Lecci\u00f3n anterior : Composici\u00f3n de procesos Siguiente lecci\u00f3n -> : Desarrollo de aplicaciones de tiempo real","title":"Desarrollo de aplicaciones concurrentes"},{"location":"elixir/mid/desarrollo_de_aplicaciones_concurrentes/#desarrollo-de-aplicaciones-concurrentes","text":"","title":"Desarrollo de aplicaciones concurrentes"},{"location":"elixir/mid/desarrollo_de_aplicaciones_concurrentes/#explicacion-teorica","text":"En Elixir, la concurrencia se refiere a la capacidad de ejecutar m\u00faltiples procesos al mismo tiempo. Esto es posible gracias al modelo de concurrencia de Elixir, basado en el modelo de actores. En este modelo, los procesos se comunican entre s\u00ed enviando y recibiendo mensajes, lo que permite una comunicaci\u00f3n eficiente y segura entre procesos. La concurrencia es esencial en el desarrollo de aplicaciones escalables y distribuidas, ya que permite aprovechar al m\u00e1ximo los recursos del sistema y mejorar el rendimiento de la aplicaci\u00f3n. Adem\u00e1s, en Elixir la concurrencia se logra de forma natural, ya que los procesos son ligeros y se crean y destruyen de manera eficiente. Para desarrollar aplicaciones concurrentes en Elixir, es importante entender los diferentes patrones y t\u00e9cnicas que ofrece el lenguaje. Algunos de los m\u00e1s comunes son: Supervisor: se encarga de iniciar, supervisar y reiniciar procesos en caso de que falle. GenServer: se utiliza para crear procesos que mantienen un estado y pueden recibir y enviar mensajes. Task: permite ejecutar tareas en segundo plano de forma as\u00edncrona. Agent: se utiliza para gestionar el estado de una sola entidad de forma concurrente.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"elixir/mid/desarrollo_de_aplicaciones_concurrentes/#palabras-clave-y-su-definicion","text":"Concurrencia: capacidad de ejecutar m\u00faltiples procesos al mismo tiempo. Modelo de actores: modelo de concurrencia basado en el env\u00edo y recepci\u00f3n de mensajes entre procesos. Proceso: unidad de ejecuci\u00f3n en Elixir. Mensaje: forma de comunicaci\u00f3n entre procesos en el modelo de actores. Escalabilidad: capacidad de una aplicaci\u00f3n de crecer y adaptarse a un aumento en la demanda de recursos. Distribuci\u00f3n: capacidad de una aplicaci\u00f3n de ejecutarse en m\u00faltiples nodos o m\u00e1quinas.","title":"Palabras clave y su definici\u00f3n"},{"location":"elixir/mid/desarrollo_de_aplicaciones_concurrentes/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la concurrencia y por qu\u00e9 es importante en el desarrollo de aplicaciones? \u00bfC\u00f3mo se logra la concurrencia en Elixir? \u00bfCu\u00e1les son algunos de los patrones y t\u00e9cnicas que se utilizan en Elixir para desarrollar aplicaciones concurrentes? \u00bfQu\u00e9 es el modelo de actores y c\u00f3mo se relaciona con la concurrencia en Elixir? \u00bfCu\u00e1l es la diferencia entre escalabilidad y distribuci\u00f3n en el contexto de aplicaciones concurrentes?","title":"Preguntas de repaso"},{"location":"elixir/mid/desarrollo_de_aplicaciones_concurrentes/#ejemplos-de-codigo-en-elixir","text":"Ejemplo de creaci\u00f3n de un proceso con Supervisor: defmodule MiProceso do use GenServer # funciones de GenServer end defmodule MiSupervisor do use Supervisor def start_link do Supervisor . start_link ( __MODULE__ , []) end def init ( _ ) do children = [ worker ( MiProceso , []) ] supervise ( children , strategy : :one_for_one ) end end Ejemplo de uso de GenServer para crear un proceso que mantiene un contador: defmodule Contador do use GenServer def start_link do GenServer . start_link ( __MODULE__ , 0 ) end def inc do GenServer . cast ( __MODULE__ , :inc ) end def handle_cast ( :inc , count ) do { :noreply , count + 1 } end end","title":"Ejemplos de c\u00f3digo en Elixir"},{"location":"elixir/mid/desarrollo_de_aplicaciones_concurrentes/#ejercicios-practicos-con-instrucciones-claras","text":"Crea un supervisor que supervise un proceso que mantenga una lista de nombres. El proceso debe tener las funciones add/1 para agregar un nombre a la lista, remove/1 para eliminar un nombre de la lista y get_all/0 para obtener la lista completa. Crea un GenServer que mantenga un contador y tenga las funciones increment/0 para aumentar el contador en 1 y get_count/0 para obtener el valor actual del contador. Utiliza el m\u00f3dulo Task para ejecutar una funci\u00f3n en segundo plano y obtener su resultado.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"elixir/mid/desarrollo_de_aplicaciones_concurrentes/#consejos-o-mejores-practicas","text":"Utiliza el modelo de actores de forma adecuada, enviando mensajes y evitando el uso de variables compartidas. Utiliza supervisores para gestionar la creaci\u00f3n y reinicio de procesos en caso de fallos. Utiliza patrones como GenServer y Agent para gestionar el estado de forma concurrente. Evita bloquear procesos con operaciones costosas, como llamadas a la base de datos, y utiliza tareas en segundo plano si es necesario. <- Lecci\u00f3n anterior : Composici\u00f3n de procesos Siguiente lecci\u00f3n -> : Desarrollo de aplicaciones de tiempo real","title":"Consejos o mejores pr\u00e1cticas"},{"location":"elixir/mid/desarrollo_de_aplicaciones_de_tiempo_real/","text":"Desarrollo de aplicaciones de tiempo real \u00b6 En este m\u00f3dulo, exploraremos c\u00f3mo utilizar Elixir para desarrollar aplicaciones de tiempo real, es decir, aquellas que deben procesar y actualizar informaci\u00f3n en tiempo real. Para ello, nos enfocaremos en dos herramientas fundamentales de Elixir: el framework Phoenix y el m\u00f3dulo GenStage. Explicaci\u00f3n te\u00f3rica \u00b6 Las aplicaciones de tiempo real son aquellas en las que se debe procesar y actualizar informaci\u00f3n de forma continua y en tiempo real, es decir, sin retrasos perceptibles por el usuario final. Ejemplos de este tipo de aplicaciones incluyen sistemas de mensajer\u00eda instant\u00e1nea, sistemas de seguimiento en tiempo real, juegos en l\u00ednea, entre otros. En el desarrollo de aplicaciones de tiempo real, es importante tener en cuenta dos aspectos fundamentales: la escalabilidad y la tolerancia a fallos. La escalabilidad se refiere a la capacidad de la aplicaci\u00f3n de manejar un gran volumen de datos y usuarios sin afectar su rendimiento, mientras que la tolerancia a fallos se refiere a la capacidad de la aplicaci\u00f3n de seguir funcionando correctamente incluso en caso de errores o fallos en el sistema. Elixir es un lenguaje de programaci\u00f3n funcional que se ejecuta en la m\u00e1quina virtual de Erlang (BEAM), lo que le brinda una gran capacidad para manejar aplicaciones de tiempo real. Adem\u00e1s, cuenta con el framework Phoenix, que est\u00e1 construido sobre el servidor web Cowboy y utiliza el lenguaje de programaci\u00f3n funcional Erlang para manejar una gran cantidad de conexiones de forma eficiente. Tambi\u00e9n cuenta con el m\u00f3dulo GenStage, que permite construir pipelines de procesamiento de datos en tiempo real. Palabras clave y su definici\u00f3n \u00b6 Aplicaciones de tiempo real: Son aquellas que deben procesar y actualizar informaci\u00f3n en tiempo real, sin retrasos perceptibles por el usuario final. Escalabilidad: Capacidad de una aplicaci\u00f3n de manejar un gran volumen de datos y usuarios sin afectar su rendimiento. Tolerancia a fallos: Capacidad de una aplicaci\u00f3n de seguir funcionando correctamente incluso en caso de errores o fallos en el sistema. Elixir: Lenguaje de programaci\u00f3n funcional que se ejecuta en la m\u00e1quina virtual de Erlang (BEAM). Phoenix: Framework construido sobre el servidor web Cowboy que utiliza el lenguaje de programaci\u00f3n funcional Erlang para manejar una gran cantidad de conexiones de forma eficiente. GenStage: M\u00f3dulo de Elixir que permite construir pipelines de procesamiento de datos en tiempo real. Preguntas de repaso \u00b6 \u00bfQu\u00e9 caracter\u00edsticas son importantes en el desarrollo de aplicaciones de tiempo real? \u00bfQu\u00e9 es Elixir y en qu\u00e9 m\u00e1quina virtual se ejecuta? \u00bfCu\u00e1l es el framework de Elixir utilizado para manejar aplicaciones de tiempo real? \u00bfQu\u00e9 es GenStage y cu\u00e1l es su funci\u00f3n en el desarrollo de aplicaciones de tiempo real? Ejemplos de c\u00f3digo en Elixir \u00b6 # Ejemplo de uso de Phoenix para definir una ruta y una funci\u00f3n de controlador defmodule MyAppWeb.Router do use Phoenix.Router get \"/\" , PageController , :index scope \"/users\" , MyAppWeb do resources \"/new\" , UserController , only : [ :create ] end end defmodule MyAppWeb.PageController do use MyAppWeb , :controller def index ( conn , _params ) do render ( conn , \"index.html\" ) end end # Ejemplo de uso de GenStage para construir un pipeline de procesamiento de datos defmodule MyApp.Processor do use GenStage def start_link do GenStage . start_link ( __MODULE__ , :ok , name : __MODULE__ ) end def init ( :ok ) do { :consumer , :state } end def handle_events ( events , _from , state ) do new_state = process_data ( events , state ) { :noreply , [], new_state } end def handle_info ( msg , state ) do { :noreply , [], state } end def process_data ( data , state ) do # L\u00f3gica para procesar los datos recibidos data |> Enum . map ( & process_event / 1 ) |> Enum . to_list () end def process_event ( event ) do # L\u00f3gica para procesar un evento espec\u00edfico event end end Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una aplicaci\u00f3n de chat en tiempo real utilizando Elixir y Phoenix. La aplicaci\u00f3n debe permitir a los usuarios enviar y recibir mensajes en tiempo real. Utiliza GenStage para construir un pipeline de procesamiento de datos que reciba informaci\u00f3n de un sensor y la env\u00ede a una base de datos en tiempo real. Crea una aplicaci\u00f3n de seguimiento en tiempo real que permita a los usuarios ver la ubicaci\u00f3n de sus amigos en un mapa utilizando Elixir y Phoenix. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza la concurrencia y la escalabilidad de Elixir para manejar grandes vol\u00famenes de datos y usuarios en tiempo real. Aprovecha las funcionalidades de Erlang para garantizar la tolerancia a fallos en tu aplicaci\u00f3n. Utiliza Phoenix para manejar las conexiones de forma eficiente y construir una aplicaci\u00f3n web en tiempo real. Utiliza GenStage para construir pipelines de procesamiento de datos en tiempo real de forma modular y escalable. Realiza pruebas de rendimiento en tu aplicaci\u00f3n para identificar posibles cuellos de botella y optimizar su rendimiento en tiempo real. <- Lecci\u00f3n anterior : Desarrollo de aplicaciones concurrentes Siguiente lecci\u00f3n -> : Dise\u00f1o de APIs en Elixir","title":"Desarrollo de aplicaciones de tiempo real"},{"location":"elixir/mid/desarrollo_de_aplicaciones_de_tiempo_real/#desarrollo-de-aplicaciones-de-tiempo-real","text":"En este m\u00f3dulo, exploraremos c\u00f3mo utilizar Elixir para desarrollar aplicaciones de tiempo real, es decir, aquellas que deben procesar y actualizar informaci\u00f3n en tiempo real. Para ello, nos enfocaremos en dos herramientas fundamentales de Elixir: el framework Phoenix y el m\u00f3dulo GenStage.","title":"Desarrollo de aplicaciones de tiempo real"},{"location":"elixir/mid/desarrollo_de_aplicaciones_de_tiempo_real/#explicacion-teorica","text":"Las aplicaciones de tiempo real son aquellas en las que se debe procesar y actualizar informaci\u00f3n de forma continua y en tiempo real, es decir, sin retrasos perceptibles por el usuario final. Ejemplos de este tipo de aplicaciones incluyen sistemas de mensajer\u00eda instant\u00e1nea, sistemas de seguimiento en tiempo real, juegos en l\u00ednea, entre otros. En el desarrollo de aplicaciones de tiempo real, es importante tener en cuenta dos aspectos fundamentales: la escalabilidad y la tolerancia a fallos. La escalabilidad se refiere a la capacidad de la aplicaci\u00f3n de manejar un gran volumen de datos y usuarios sin afectar su rendimiento, mientras que la tolerancia a fallos se refiere a la capacidad de la aplicaci\u00f3n de seguir funcionando correctamente incluso en caso de errores o fallos en el sistema. Elixir es un lenguaje de programaci\u00f3n funcional que se ejecuta en la m\u00e1quina virtual de Erlang (BEAM), lo que le brinda una gran capacidad para manejar aplicaciones de tiempo real. Adem\u00e1s, cuenta con el framework Phoenix, que est\u00e1 construido sobre el servidor web Cowboy y utiliza el lenguaje de programaci\u00f3n funcional Erlang para manejar una gran cantidad de conexiones de forma eficiente. Tambi\u00e9n cuenta con el m\u00f3dulo GenStage, que permite construir pipelines de procesamiento de datos en tiempo real.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"elixir/mid/desarrollo_de_aplicaciones_de_tiempo_real/#palabras-clave-y-su-definicion","text":"Aplicaciones de tiempo real: Son aquellas que deben procesar y actualizar informaci\u00f3n en tiempo real, sin retrasos perceptibles por el usuario final. Escalabilidad: Capacidad de una aplicaci\u00f3n de manejar un gran volumen de datos y usuarios sin afectar su rendimiento. Tolerancia a fallos: Capacidad de una aplicaci\u00f3n de seguir funcionando correctamente incluso en caso de errores o fallos en el sistema. Elixir: Lenguaje de programaci\u00f3n funcional que se ejecuta en la m\u00e1quina virtual de Erlang (BEAM). Phoenix: Framework construido sobre el servidor web Cowboy que utiliza el lenguaje de programaci\u00f3n funcional Erlang para manejar una gran cantidad de conexiones de forma eficiente. GenStage: M\u00f3dulo de Elixir que permite construir pipelines de procesamiento de datos en tiempo real.","title":"Palabras clave y su definici\u00f3n"},{"location":"elixir/mid/desarrollo_de_aplicaciones_de_tiempo_real/#preguntas-de-repaso","text":"\u00bfQu\u00e9 caracter\u00edsticas son importantes en el desarrollo de aplicaciones de tiempo real? \u00bfQu\u00e9 es Elixir y en qu\u00e9 m\u00e1quina virtual se ejecuta? \u00bfCu\u00e1l es el framework de Elixir utilizado para manejar aplicaciones de tiempo real? \u00bfQu\u00e9 es GenStage y cu\u00e1l es su funci\u00f3n en el desarrollo de aplicaciones de tiempo real?","title":"Preguntas de repaso"},{"location":"elixir/mid/desarrollo_de_aplicaciones_de_tiempo_real/#ejemplos-de-codigo-en-elixir","text":"# Ejemplo de uso de Phoenix para definir una ruta y una funci\u00f3n de controlador defmodule MyAppWeb.Router do use Phoenix.Router get \"/\" , PageController , :index scope \"/users\" , MyAppWeb do resources \"/new\" , UserController , only : [ :create ] end end defmodule MyAppWeb.PageController do use MyAppWeb , :controller def index ( conn , _params ) do render ( conn , \"index.html\" ) end end # Ejemplo de uso de GenStage para construir un pipeline de procesamiento de datos defmodule MyApp.Processor do use GenStage def start_link do GenStage . start_link ( __MODULE__ , :ok , name : __MODULE__ ) end def init ( :ok ) do { :consumer , :state } end def handle_events ( events , _from , state ) do new_state = process_data ( events , state ) { :noreply , [], new_state } end def handle_info ( msg , state ) do { :noreply , [], state } end def process_data ( data , state ) do # L\u00f3gica para procesar los datos recibidos data |> Enum . map ( & process_event / 1 ) |> Enum . to_list () end def process_event ( event ) do # L\u00f3gica para procesar un evento espec\u00edfico event end end","title":"Ejemplos de c\u00f3digo en Elixir"},{"location":"elixir/mid/desarrollo_de_aplicaciones_de_tiempo_real/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una aplicaci\u00f3n de chat en tiempo real utilizando Elixir y Phoenix. La aplicaci\u00f3n debe permitir a los usuarios enviar y recibir mensajes en tiempo real. Utiliza GenStage para construir un pipeline de procesamiento de datos que reciba informaci\u00f3n de un sensor y la env\u00ede a una base de datos en tiempo real. Crea una aplicaci\u00f3n de seguimiento en tiempo real que permita a los usuarios ver la ubicaci\u00f3n de sus amigos en un mapa utilizando Elixir y Phoenix.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"elixir/mid/desarrollo_de_aplicaciones_de_tiempo_real/#consejos-o-mejores-practicas","text":"Utiliza la concurrencia y la escalabilidad de Elixir para manejar grandes vol\u00famenes de datos y usuarios en tiempo real. Aprovecha las funcionalidades de Erlang para garantizar la tolerancia a fallos en tu aplicaci\u00f3n. Utiliza Phoenix para manejar las conexiones de forma eficiente y construir una aplicaci\u00f3n web en tiempo real. Utiliza GenStage para construir pipelines de procesamiento de datos en tiempo real de forma modular y escalable. Realiza pruebas de rendimiento en tu aplicaci\u00f3n para identificar posibles cuellos de botella y optimizar su rendimiento en tiempo real. <- Lecci\u00f3n anterior : Desarrollo de aplicaciones concurrentes Siguiente lecci\u00f3n -> : Dise\u00f1o de APIs en Elixir","title":"Consejos o mejores pr\u00e1cticas"},{"location":"elixir/mid/desarrollo_de_aplicaciones_en_tiempo_real/","text":"Desarrollo de aplicaciones en tiempo real \u00b6 En la actualidad, el desarrollo de aplicaciones en tiempo real se ha vuelto cada vez m\u00e1s importante debido a la necesidad de interacci\u00f3n constante entre los usuarios y las aplicaciones. Esto se ve reflejado en aplicaciones como redes sociales, aplicaciones de mensajer\u00eda instant\u00e1nea y juegos en l\u00ednea, entre otros. Es por ello que es crucial para un desarrollador de software dominar esta habilidad. Teor\u00eda \u00b6 El tiempo real en el desarrollo de aplicaciones se refiere a la capacidad de procesar y mostrar informaci\u00f3n en tiempo real, es decir, en el momento en que se produce. Esto implica una comunicaci\u00f3n constante y bidireccional entre el servidor y el cliente, lo que permite una experiencia de usuario m\u00e1s fluida y en tiempo real. Una de las principales ventajas de las aplicaciones en tiempo real es su capacidad para manejar grandes cantidades de datos y usuarios al mismo tiempo. Adem\u00e1s, estas aplicaciones pueden ser utilizadas en una variedad de industrias, como el comercio electr\u00f3nico, la banca en l\u00ednea y la atenci\u00f3n m\u00e9dica. Palabras clave \u00b6 Elixir: un lenguaje de programaci\u00f3n funcional y concurrente basado en Erlang. Phoenix: un framework de Elixir para el desarrollo de aplicaciones web en tiempo real. WebSockets: un protocolo de comunicaci\u00f3n bidireccional que permite una conexi\u00f3n persistente entre el cliente y el servidor. Preguntas de repaso \u00b6 \u00bfQu\u00e9 significa el t\u00e9rmino \"tiempo real\" en el desarrollo de aplicaciones? \u00bfPor qu\u00e9 es importante desarrollar aplicaciones en tiempo real? \u00bfCu\u00e1l es la ventaja de utilizar WebSockets en aplicaciones en tiempo real? Ejemplos de c\u00f3digo en Elixir \u00b6 Para ilustrar c\u00f3mo se desarrollan aplicaciones en tiempo real en Elixir, a continuaci\u00f3n se presenta un ejemplo sencillo de un chat en tiempo real utilizando Phoenix y WebSockets. En el servidor, se crea un canal en el archivo \"chat_channel.ex\": defmodule ChatChannel do use Phoenix.Channel def join ( \"chat_room\" , _payload , socket ) do { :ok , socket } end def handle_in ( \"new_message\" , %{ \"message\" => message }, socket ) do broadcast! socket , \"new_message\" , %{ message : message } { :noreply , socket } end end En el cliente, se establece la conexi\u00f3n con el servidor y se env\u00eda un mensaje al canal \"chat_room\": let socket = new Socket ( \"/socket\" , { params : { token : window . userToken }}) socket . connect () let channel = socket . channel ( \"chat_room\" ) channel . join () . receive ( \"ok\" , resp => { console . log ( \"Conexi\u00f3n establecida\" ) }) . receive ( \"error\" , resp => { console . log ( \"Error al conectarse\" ) }) channel . on ( \"new_message\" , payload => { console . log ( \"Nuevo mensaje: \" + payload . message ) }) channel . push ( \"new_message\" , { message : \"Hola, \u00bfc\u00f3mo est\u00e1s?\" }) Ejercicios pr\u00e1cticos \u00b6 Crea una aplicaci\u00f3n en tiempo real utilizando Phoenix y WebSockets que permita a los usuarios jugar al piedra, papel o tijera contra el ordenador. Implementa una funci\u00f3n en el servidor que env\u00ede notificaciones en tiempo real a un canal espec\u00edfico. Agrega una funci\u00f3n en el cliente que permita a los usuarios enviar y recibir mensajes en un chat en tiempo real. Consejos y mejores pr\u00e1cticas \u00b6 Utiliza un framework como Phoenix para facilitar el desarrollo de aplicaciones en tiempo real. Aprovecha las ventajas de la programaci\u00f3n funcional y concurrente en Elixir para desarrollar aplicaciones eficientes en tiempo real. Utiliza WebSockets en lugar de HTTP para una comunicaci\u00f3n m\u00e1s r\u00e1pida y eficiente entre el servidor y el cliente. Realiza pruebas exhaustivas para garantizar un funcionamiento correcto en situaciones de alta carga y tr\u00e1fico de usuarios. Mant\u00e9n un c\u00f3digo limpio y bien estructurado para facilitar el mantenimiento y la escalabilidad de la aplicaci\u00f3n.","title":"Desarrollo de aplicaciones en tiempo real"},{"location":"elixir/mid/desarrollo_de_aplicaciones_en_tiempo_real/#desarrollo-de-aplicaciones-en-tiempo-real","text":"En la actualidad, el desarrollo de aplicaciones en tiempo real se ha vuelto cada vez m\u00e1s importante debido a la necesidad de interacci\u00f3n constante entre los usuarios y las aplicaciones. Esto se ve reflejado en aplicaciones como redes sociales, aplicaciones de mensajer\u00eda instant\u00e1nea y juegos en l\u00ednea, entre otros. Es por ello que es crucial para un desarrollador de software dominar esta habilidad.","title":"Desarrollo de aplicaciones en tiempo real"},{"location":"elixir/mid/desarrollo_de_aplicaciones_en_tiempo_real/#teoria","text":"El tiempo real en el desarrollo de aplicaciones se refiere a la capacidad de procesar y mostrar informaci\u00f3n en tiempo real, es decir, en el momento en que se produce. Esto implica una comunicaci\u00f3n constante y bidireccional entre el servidor y el cliente, lo que permite una experiencia de usuario m\u00e1s fluida y en tiempo real. Una de las principales ventajas de las aplicaciones en tiempo real es su capacidad para manejar grandes cantidades de datos y usuarios al mismo tiempo. Adem\u00e1s, estas aplicaciones pueden ser utilizadas en una variedad de industrias, como el comercio electr\u00f3nico, la banca en l\u00ednea y la atenci\u00f3n m\u00e9dica.","title":"Teor\u00eda"},{"location":"elixir/mid/desarrollo_de_aplicaciones_en_tiempo_real/#palabras-clave","text":"Elixir: un lenguaje de programaci\u00f3n funcional y concurrente basado en Erlang. Phoenix: un framework de Elixir para el desarrollo de aplicaciones web en tiempo real. WebSockets: un protocolo de comunicaci\u00f3n bidireccional que permite una conexi\u00f3n persistente entre el cliente y el servidor.","title":"Palabras clave"},{"location":"elixir/mid/desarrollo_de_aplicaciones_en_tiempo_real/#preguntas-de-repaso","text":"\u00bfQu\u00e9 significa el t\u00e9rmino \"tiempo real\" en el desarrollo de aplicaciones? \u00bfPor qu\u00e9 es importante desarrollar aplicaciones en tiempo real? \u00bfCu\u00e1l es la ventaja de utilizar WebSockets en aplicaciones en tiempo real?","title":"Preguntas de repaso"},{"location":"elixir/mid/desarrollo_de_aplicaciones_en_tiempo_real/#ejemplos-de-codigo-en-elixir","text":"Para ilustrar c\u00f3mo se desarrollan aplicaciones en tiempo real en Elixir, a continuaci\u00f3n se presenta un ejemplo sencillo de un chat en tiempo real utilizando Phoenix y WebSockets. En el servidor, se crea un canal en el archivo \"chat_channel.ex\": defmodule ChatChannel do use Phoenix.Channel def join ( \"chat_room\" , _payload , socket ) do { :ok , socket } end def handle_in ( \"new_message\" , %{ \"message\" => message }, socket ) do broadcast! socket , \"new_message\" , %{ message : message } { :noreply , socket } end end En el cliente, se establece la conexi\u00f3n con el servidor y se env\u00eda un mensaje al canal \"chat_room\": let socket = new Socket ( \"/socket\" , { params : { token : window . userToken }}) socket . connect () let channel = socket . channel ( \"chat_room\" ) channel . join () . receive ( \"ok\" , resp => { console . log ( \"Conexi\u00f3n establecida\" ) }) . receive ( \"error\" , resp => { console . log ( \"Error al conectarse\" ) }) channel . on ( \"new_message\" , payload => { console . log ( \"Nuevo mensaje: \" + payload . message ) }) channel . push ( \"new_message\" , { message : \"Hola, \u00bfc\u00f3mo est\u00e1s?\" })","title":"Ejemplos de c\u00f3digo en Elixir"},{"location":"elixir/mid/desarrollo_de_aplicaciones_en_tiempo_real/#ejercicios-practicos","text":"Crea una aplicaci\u00f3n en tiempo real utilizando Phoenix y WebSockets que permita a los usuarios jugar al piedra, papel o tijera contra el ordenador. Implementa una funci\u00f3n en el servidor que env\u00ede notificaciones en tiempo real a un canal espec\u00edfico. Agrega una funci\u00f3n en el cliente que permita a los usuarios enviar y recibir mensajes en un chat en tiempo real.","title":"Ejercicios pr\u00e1cticos"},{"location":"elixir/mid/desarrollo_de_aplicaciones_en_tiempo_real/#consejos-y-mejores-practicas","text":"Utiliza un framework como Phoenix para facilitar el desarrollo de aplicaciones en tiempo real. Aprovecha las ventajas de la programaci\u00f3n funcional y concurrente en Elixir para desarrollar aplicaciones eficientes en tiempo real. Utiliza WebSockets en lugar de HTTP para una comunicaci\u00f3n m\u00e1s r\u00e1pida y eficiente entre el servidor y el cliente. Realiza pruebas exhaustivas para garantizar un funcionamiento correcto en situaciones de alta carga y tr\u00e1fico de usuarios. Mant\u00e9n un c\u00f3digo limpio y bien estructurado para facilitar el mantenimiento y la escalabilidad de la aplicaci\u00f3n.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"elixir/mid/desarrollo_de_sistemas_distribuidos/","text":"Desarrollo de sistemas distribuidos \u00b6 En esta lecci\u00f3n, exploraremos el desarrollo de sistemas distribuidos utilizando Elixir. Un sistema distribuido es aquel en el que un conjunto de computadoras independientes se comunican entre s\u00ed para lograr un objetivo com\u00fan. Elixir, un lenguaje de programaci\u00f3n funcional basado en Erlang, es ideal para el desarrollo de sistemas distribuidos debido a sus caracter\u00edsticas como la concurrencia, tolerancia a fallos y manejo de procesos. Teor\u00eda \u00b6 Un sistema distribuido se compone de m\u00faltiples nodos conectados a trav\u00e9s de una red de comunicaci\u00f3n. Estos nodos pueden ser servidores, computadoras personales, dispositivos m\u00f3viles, entre otros. Los sistemas distribuidos permiten el procesamiento paralelo y la escalabilidad, lo que los hace ideales para aplicaciones de alta demanda. En Elixir, los nodos se comunican a trav\u00e9s de Erlang Distribution, un protocolo de comunicaci\u00f3n que permite la comunicaci\u00f3n entre nodos en diferentes m\u00e1quinas. Al utilizar este protocolo, los nodos pueden enviar mensajes entre s\u00ed y compartir recursos como procesos y datos. Otra herramienta importante en el desarrollo de sistemas distribuidos en Elixir es RabbitMQ, un sistema de mensajer\u00eda y colas que permite la comunicaci\u00f3n as\u00edncrona entre nodos. Esto es \u00fatil para el manejo de tareas en segundo plano y la coordinaci\u00f3n de tareas entre diferentes nodos. Palabras clave \u00b6 Sistemas distribuidos: conjunto de computadoras independientes conectadas a trav\u00e9s de una red para lograr un objetivo com\u00fan. Elixir: lenguaje de programaci\u00f3n funcional basado en Erlang. Erlang Distribution: protocolo de comunicaci\u00f3n utilizado por Elixir para la comunicaci\u00f3n entre nodos en diferentes m\u00e1quinas. RabbitMQ: sistema de mensajer\u00eda y colas utilizado para la comunicaci\u00f3n as\u00edncrona entre nodos. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es un sistema distribuido? \u00bfPor qu\u00e9 Elixir es adecuado para el desarrollo de sistemas distribuidos? \u00bfQu\u00e9 es Erlang Distribution y c\u00f3mo se utiliza en Elixir? \u00bfCu\u00e1l es la funci\u00f3n de RabbitMQ en el desarrollo de sistemas distribuidos? \u00bfCu\u00e1les son las ventajas de utilizar sistemas distribuidos en aplicaciones de alta demanda? Ejemplos de c\u00f3digo \u00b6 Comunicaci\u00f3n entre nodos en Elixir \u00b6 Para que dos nodos se comuniquen entre s\u00ed, primero deben conocerse y estar conectados a trav\u00e9s de Erlang Distribution. # Nodo A iex --sname node_a # Nodo B iex --sname node_b # En el nodo A Node . connect ( : \"node_b@your_computer_name\" ) # En el nodo B Node . connect ( : \"node_a@your_computer_name\" ) Una vez que los nodos est\u00e1n conectados, pueden enviar mensajes entre s\u00ed utilizando el m\u00f3dulo Node . # En el nodo A Node . send ( : \"node_b@your_computer_name\" , \"Hola desde el nodo A\" ) # En el nodo B Node . recv ( : \"node_a@your_computer_name\" ) Comunicaci\u00f3n as\u00edncrona con RabbitMQ \u00b6 Para utilizar RabbitMQ en un proyecto de Elixir, primero se debe agregar la dependencia a mix.exs . defp deps do [ {: amqp , \"~> 1.0\" } ] end Luego, se debe iniciar un proceso de conexi\u00f3n a RabbitMQ y crear una cola para recibir mensajes. # Proceso de conexi\u00f3n {:ok, connection} = AMQP.Connection.open # Creaci\u00f3n de una cola {:ok, channel} = AMQP.Channel.open(connection) {:ok, queue} = AMQP.Queue.declare(channel, \"nombre_de_la_cola\") Para enviar un mensaje a trav\u00e9s de RabbitMQ, se debe publicar en la cola previamente creada. AMQP.Basic.publish(channel, \"\", \"nombre_de_la_cola\", \"Mensaje de prueba\") Para recibir mensajes, se debe suscribir a la cola y especificar una funci\u00f3n de manejo de mensajes. AMQP . Basic . consume ( channel , \"nombre_de_la_cola\" , fn ( msg ) -> IO . puts ( msg . body ) end) Ejercicios pr\u00e1cticos \u00b6 Configura dos nodos en tu m\u00e1quina y realiza una comunicaci\u00f3n entre ellos utilizando Erlang Distribution. Crea un proyecto en Elixir que utilice RabbitMQ para la comunicaci\u00f3n as\u00edncrona entre dos nodos. Implementa un sistema distribuido en Elixir que realice una tarea en paralelo utilizando m\u00faltiples nodos. Consejos y mejores pr\u00e1cticas \u00b6 Al trabajar con sistemas distribuidos, es importante tener en cuenta la tolerancia a fallos y el manejo de errores. Utiliza patrones como el modelo de actores y la supervisi\u00f3n de procesos para construir sistemas distribuidos robustos. Siempre documenta y prueba tu c\u00f3digo para asegurarte de que los nodos se comuniquen correctamente y manejen los errores de manera adecuada. Considera el uso de librer\u00edas y herramientas como Phoenix y GenStage para simplificar y mejorar el desarrollo de sistemas distribuidos en Elixir. <- Lecci\u00f3n anterior : Supervisi\u00f3n avanzada de procesos","title":"Desarrollo de sistemas distribuidos"},{"location":"elixir/mid/desarrollo_de_sistemas_distribuidos/#desarrollo-de-sistemas-distribuidos","text":"En esta lecci\u00f3n, exploraremos el desarrollo de sistemas distribuidos utilizando Elixir. Un sistema distribuido es aquel en el que un conjunto de computadoras independientes se comunican entre s\u00ed para lograr un objetivo com\u00fan. Elixir, un lenguaje de programaci\u00f3n funcional basado en Erlang, es ideal para el desarrollo de sistemas distribuidos debido a sus caracter\u00edsticas como la concurrencia, tolerancia a fallos y manejo de procesos.","title":"Desarrollo de sistemas distribuidos"},{"location":"elixir/mid/desarrollo_de_sistemas_distribuidos/#teoria","text":"Un sistema distribuido se compone de m\u00faltiples nodos conectados a trav\u00e9s de una red de comunicaci\u00f3n. Estos nodos pueden ser servidores, computadoras personales, dispositivos m\u00f3viles, entre otros. Los sistemas distribuidos permiten el procesamiento paralelo y la escalabilidad, lo que los hace ideales para aplicaciones de alta demanda. En Elixir, los nodos se comunican a trav\u00e9s de Erlang Distribution, un protocolo de comunicaci\u00f3n que permite la comunicaci\u00f3n entre nodos en diferentes m\u00e1quinas. Al utilizar este protocolo, los nodos pueden enviar mensajes entre s\u00ed y compartir recursos como procesos y datos. Otra herramienta importante en el desarrollo de sistemas distribuidos en Elixir es RabbitMQ, un sistema de mensajer\u00eda y colas que permite la comunicaci\u00f3n as\u00edncrona entre nodos. Esto es \u00fatil para el manejo de tareas en segundo plano y la coordinaci\u00f3n de tareas entre diferentes nodos.","title":"Teor\u00eda"},{"location":"elixir/mid/desarrollo_de_sistemas_distribuidos/#palabras-clave","text":"Sistemas distribuidos: conjunto de computadoras independientes conectadas a trav\u00e9s de una red para lograr un objetivo com\u00fan. Elixir: lenguaje de programaci\u00f3n funcional basado en Erlang. Erlang Distribution: protocolo de comunicaci\u00f3n utilizado por Elixir para la comunicaci\u00f3n entre nodos en diferentes m\u00e1quinas. RabbitMQ: sistema de mensajer\u00eda y colas utilizado para la comunicaci\u00f3n as\u00edncrona entre nodos.","title":"Palabras clave"},{"location":"elixir/mid/desarrollo_de_sistemas_distribuidos/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es un sistema distribuido? \u00bfPor qu\u00e9 Elixir es adecuado para el desarrollo de sistemas distribuidos? \u00bfQu\u00e9 es Erlang Distribution y c\u00f3mo se utiliza en Elixir? \u00bfCu\u00e1l es la funci\u00f3n de RabbitMQ en el desarrollo de sistemas distribuidos? \u00bfCu\u00e1les son las ventajas de utilizar sistemas distribuidos en aplicaciones de alta demanda?","title":"Preguntas de repaso"},{"location":"elixir/mid/desarrollo_de_sistemas_distribuidos/#ejemplos-de-codigo","text":"","title":"Ejemplos de c\u00f3digo"},{"location":"elixir/mid/desarrollo_de_sistemas_distribuidos/#comunicacion-entre-nodos-en-elixir","text":"Para que dos nodos se comuniquen entre s\u00ed, primero deben conocerse y estar conectados a trav\u00e9s de Erlang Distribution. # Nodo A iex --sname node_a # Nodo B iex --sname node_b # En el nodo A Node . connect ( : \"node_b@your_computer_name\" ) # En el nodo B Node . connect ( : \"node_a@your_computer_name\" ) Una vez que los nodos est\u00e1n conectados, pueden enviar mensajes entre s\u00ed utilizando el m\u00f3dulo Node . # En el nodo A Node . send ( : \"node_b@your_computer_name\" , \"Hola desde el nodo A\" ) # En el nodo B Node . recv ( : \"node_a@your_computer_name\" )","title":"Comunicaci\u00f3n entre nodos en Elixir"},{"location":"elixir/mid/desarrollo_de_sistemas_distribuidos/#comunicacion-asincrona-con-rabbitmq","text":"Para utilizar RabbitMQ en un proyecto de Elixir, primero se debe agregar la dependencia a mix.exs . defp deps do [ {: amqp , \"~> 1.0\" } ] end Luego, se debe iniciar un proceso de conexi\u00f3n a RabbitMQ y crear una cola para recibir mensajes. # Proceso de conexi\u00f3n {:ok, connection} = AMQP.Connection.open # Creaci\u00f3n de una cola {:ok, channel} = AMQP.Channel.open(connection) {:ok, queue} = AMQP.Queue.declare(channel, \"nombre_de_la_cola\") Para enviar un mensaje a trav\u00e9s de RabbitMQ, se debe publicar en la cola previamente creada. AMQP.Basic.publish(channel, \"\", \"nombre_de_la_cola\", \"Mensaje de prueba\") Para recibir mensajes, se debe suscribir a la cola y especificar una funci\u00f3n de manejo de mensajes. AMQP . Basic . consume ( channel , \"nombre_de_la_cola\" , fn ( msg ) -> IO . puts ( msg . body ) end)","title":"Comunicaci\u00f3n as\u00edncrona con RabbitMQ"},{"location":"elixir/mid/desarrollo_de_sistemas_distribuidos/#ejercicios-practicos","text":"Configura dos nodos en tu m\u00e1quina y realiza una comunicaci\u00f3n entre ellos utilizando Erlang Distribution. Crea un proyecto en Elixir que utilice RabbitMQ para la comunicaci\u00f3n as\u00edncrona entre dos nodos. Implementa un sistema distribuido en Elixir que realice una tarea en paralelo utilizando m\u00faltiples nodos.","title":"Ejercicios pr\u00e1cticos"},{"location":"elixir/mid/desarrollo_de_sistemas_distribuidos/#consejos-y-mejores-practicas","text":"Al trabajar con sistemas distribuidos, es importante tener en cuenta la tolerancia a fallos y el manejo de errores. Utiliza patrones como el modelo de actores y la supervisi\u00f3n de procesos para construir sistemas distribuidos robustos. Siempre documenta y prueba tu c\u00f3digo para asegurarte de que los nodos se comuniquen correctamente y manejen los errores de manera adecuada. Considera el uso de librer\u00edas y herramientas como Phoenix y GenStage para simplificar y mejorar el desarrollo de sistemas distribuidos en Elixir. <- Lecci\u00f3n anterior : Supervisi\u00f3n avanzada de procesos","title":"Consejos y mejores pr\u00e1cticas"},{"location":"elixir/mid/diseno_de_apis_en_elixir/","text":"Dise\u00f1o de APIs en Elixir \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 Una API (Application Programming Interface) es una interfaz de programaci\u00f3n que permite la comunicaci\u00f3n entre diferentes aplicaciones o sistemas. En el contexto de Elixir, una API se refiere a una interfaz que permite la comunicaci\u00f3n entre el c\u00f3digo escrito en Elixir y otras aplicaciones o servicios. El dise\u00f1o de APIs en Elixir se basa en el uso del framework Phoenix, que es una herramienta poderosa para construir aplicaciones web y APIs RESTful. Las APIs RESTful (Representational State Transfer) son un estilo de arquitectura de software que se basa en los principios fundamentales de HTTP, como el uso de los verbos GET, POST, PUT y DELETE para manipular recursos. El enfoque de dise\u00f1o de APIs en Elixir se basa en la simplicidad, escalabilidad y robustez. Elixir es un lenguaje funcional que se ejecuta en la m\u00e1quina virtual de Erlang, lo que le brinda una gran capacidad de concurrencia y tolerancia a fallos. Esto lo convierte en una excelente opci\u00f3n para construir APIs que deben manejar grandes cantidades de solicitudes y ser resilientes a errores y ca\u00eddas del sistema. Palabras clave y su definici\u00f3n \u00b6 API: Interfaz de programaci\u00f3n que permite la comunicaci\u00f3n entre diferentes aplicaciones o sistemas. Elixir: Lenguaje de programaci\u00f3n funcional que se ejecuta en la m\u00e1quina virtual de Erlang. Phoenix: Framework de Elixir para construir aplicaciones web y APIs RESTful. REST: Estilo de arquitectura de software basado en los principios de HTTP. HTTP: Protocolo de transferencia de hipertexto, utilizado para la comunicaci\u00f3n entre servidores y clientes en la web. Verbos HTTP: GET, POST, PUT y DELETE, utilizados para indicar la acci\u00f3n que se desea realizar sobre un recurso. Recursos: Elementos que se pueden manipular mediante una API RESTful, como por ejemplo usuarios, productos o publicaciones. Concurrencia: Capacidad de un sistema para ejecutar m\u00faltiples tareas al mismo tiempo. Tolerancia a fallos: Capacidad de un sistema para continuar funcionando a pesar de errores o ca\u00eddas en el sistema. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es una API y para qu\u00e9 se utiliza? \u00bfCu\u00e1les son los principios fundamentales de HTTP? \u00bfQu\u00e9 es Phoenix y por qu\u00e9 se utiliza en el dise\u00f1o de APIs en Elixir? \u00bfEn qu\u00e9 se basa el enfoque de dise\u00f1o de APIs en Elixir? \u00bfQu\u00e9 es la concurrencia y por qu\u00e9 es importante en el dise\u00f1o de APIs? \u00bfQu\u00e9 es la tolerancia a fallos y por qu\u00e9 es importante en el dise\u00f1o de APIs? Ejemplos de c\u00f3digo en Elixir \u00b6 A continuaci\u00f3n, se muestra un ejemplo de c\u00f3digo en Elixir para crear una API RESTful utilizando Phoenix: defmodule MyApp.UserController do use Phoenix.Controller # Acci\u00f3n para obtener todos los usuarios def index ( conn , _params ) do users = MyApp.Repo . all ( MyApp.User ) render ( conn , \"index.json\" , users : users ) end # Acci\u00f3n para crear un nuevo usuario def create ( conn , %{ \"user\" => user_params }) do changeset = MyApp.User . changeset (% MyApp.User {}, user_params ) case MyApp.Repo . insert ( changeset ) do { :ok , user } -> conn |> put_status ( :created ) |> put_resp_header ( \"location\" , Routes . user_path ( conn , :show , user )) |> render ( \"show.json\" , user : user ) { :error , changeset } -> conn |> put_status ( :unprocessable_entity ) |> render ( \"error.json\" , changeset : changeset ) end end # Acci\u00f3n para obtener un usuario espec\u00edfico def show ( conn , %{ \"id\" => id }) do user = MyApp.Repo . get! ( MyApp.User , id ) render ( conn , \"show.json\" , user : user ) end # Acci\u00f3n para actualizar un usuario def update ( conn , %{ \"id\" => id , \"user\" => user_params }) do user = MyApp.Repo . get! ( MyApp.User , id ) changeset = MyApp.User . changeset ( user , user_params ) case MyApp.Repo . update ( changeset ) do { :ok , user } -> render ( conn , \"show.json\" , user : user ) { :error , changeset } -> conn |> put_status ( :unprocessable_entity ) |> render ( \"error.json\" , changeset : changeset ) end end # Acci\u00f3n para eliminar un usuario def delete ( conn , %{ \"id\" => id }) do user = MyApp.Repo . get! ( MyApp.User , id ) MyApp.Repo . delete ( user ) send_resp ( conn , :no_content , \"\" ) end end Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea un nuevo proyecto en Phoenix utilizando el comando mix phx.new my_api . Agrega un modelo Product con los campos name , price y description . Crea las migraciones para crear la tabla products en la base de datos. Genera un controlador ProductController con las acciones index , create , show , update y delete . Implementa la l\u00f3gica en cada acci\u00f3n para manipular los recursos de la tabla products . Realiza pruebas utilizando herramientas como Postman para asegurarte de que la API funciona correctamente. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza el principio de responsabilidad \u00fanica para mantener tus controladores y modelos simples y f\u00e1ciles de entender. Utiliza los verbos HTTP adecuados para cada acci\u00f3n, siguiendo las convenciones de las APIs RESTful. Utiliza el patr\u00f3n de repositorio para encapsular la l\u00f3gica de acceso a la base de datos en una capa separada. Utiliza el enrutamiento basado en recursos para definir las rutas de tu API de forma clara y coherente. Utiliza las pruebas automatizadas para garantizar que tu API funcione correctamente y maneje errores de manera adecuada. Utiliza los m\u00f3dulos de autenticaci\u00f3n y autorizaci\u00f3n de Phoenix para proteger tu API de accesos no autorizados. Utiliza herramientas como Swagger para documentar tu API de forma clara y concisa. <- Lecci\u00f3n anterior : Desarrollo de aplicaciones de tiempo real Siguiente lecci\u00f3n -> : Integraci\u00f3n con bases de datos","title":"Dise\u00f1o de APIs en Elixir"},{"location":"elixir/mid/diseno_de_apis_en_elixir/#diseno-de-apis-en-elixir","text":"","title":"Dise\u00f1o de APIs en Elixir"},{"location":"elixir/mid/diseno_de_apis_en_elixir/#explicacion-teorica","text":"Una API (Application Programming Interface) es una interfaz de programaci\u00f3n que permite la comunicaci\u00f3n entre diferentes aplicaciones o sistemas. En el contexto de Elixir, una API se refiere a una interfaz que permite la comunicaci\u00f3n entre el c\u00f3digo escrito en Elixir y otras aplicaciones o servicios. El dise\u00f1o de APIs en Elixir se basa en el uso del framework Phoenix, que es una herramienta poderosa para construir aplicaciones web y APIs RESTful. Las APIs RESTful (Representational State Transfer) son un estilo de arquitectura de software que se basa en los principios fundamentales de HTTP, como el uso de los verbos GET, POST, PUT y DELETE para manipular recursos. El enfoque de dise\u00f1o de APIs en Elixir se basa en la simplicidad, escalabilidad y robustez. Elixir es un lenguaje funcional que se ejecuta en la m\u00e1quina virtual de Erlang, lo que le brinda una gran capacidad de concurrencia y tolerancia a fallos. Esto lo convierte en una excelente opci\u00f3n para construir APIs que deben manejar grandes cantidades de solicitudes y ser resilientes a errores y ca\u00eddas del sistema.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"elixir/mid/diseno_de_apis_en_elixir/#palabras-clave-y-su-definicion","text":"API: Interfaz de programaci\u00f3n que permite la comunicaci\u00f3n entre diferentes aplicaciones o sistemas. Elixir: Lenguaje de programaci\u00f3n funcional que se ejecuta en la m\u00e1quina virtual de Erlang. Phoenix: Framework de Elixir para construir aplicaciones web y APIs RESTful. REST: Estilo de arquitectura de software basado en los principios de HTTP. HTTP: Protocolo de transferencia de hipertexto, utilizado para la comunicaci\u00f3n entre servidores y clientes en la web. Verbos HTTP: GET, POST, PUT y DELETE, utilizados para indicar la acci\u00f3n que se desea realizar sobre un recurso. Recursos: Elementos que se pueden manipular mediante una API RESTful, como por ejemplo usuarios, productos o publicaciones. Concurrencia: Capacidad de un sistema para ejecutar m\u00faltiples tareas al mismo tiempo. Tolerancia a fallos: Capacidad de un sistema para continuar funcionando a pesar de errores o ca\u00eddas en el sistema.","title":"Palabras clave y su definici\u00f3n"},{"location":"elixir/mid/diseno_de_apis_en_elixir/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es una API y para qu\u00e9 se utiliza? \u00bfCu\u00e1les son los principios fundamentales de HTTP? \u00bfQu\u00e9 es Phoenix y por qu\u00e9 se utiliza en el dise\u00f1o de APIs en Elixir? \u00bfEn qu\u00e9 se basa el enfoque de dise\u00f1o de APIs en Elixir? \u00bfQu\u00e9 es la concurrencia y por qu\u00e9 es importante en el dise\u00f1o de APIs? \u00bfQu\u00e9 es la tolerancia a fallos y por qu\u00e9 es importante en el dise\u00f1o de APIs?","title":"Preguntas de repaso"},{"location":"elixir/mid/diseno_de_apis_en_elixir/#ejemplos-de-codigo-en-elixir","text":"A continuaci\u00f3n, se muestra un ejemplo de c\u00f3digo en Elixir para crear una API RESTful utilizando Phoenix: defmodule MyApp.UserController do use Phoenix.Controller # Acci\u00f3n para obtener todos los usuarios def index ( conn , _params ) do users = MyApp.Repo . all ( MyApp.User ) render ( conn , \"index.json\" , users : users ) end # Acci\u00f3n para crear un nuevo usuario def create ( conn , %{ \"user\" => user_params }) do changeset = MyApp.User . changeset (% MyApp.User {}, user_params ) case MyApp.Repo . insert ( changeset ) do { :ok , user } -> conn |> put_status ( :created ) |> put_resp_header ( \"location\" , Routes . user_path ( conn , :show , user )) |> render ( \"show.json\" , user : user ) { :error , changeset } -> conn |> put_status ( :unprocessable_entity ) |> render ( \"error.json\" , changeset : changeset ) end end # Acci\u00f3n para obtener un usuario espec\u00edfico def show ( conn , %{ \"id\" => id }) do user = MyApp.Repo . get! ( MyApp.User , id ) render ( conn , \"show.json\" , user : user ) end # Acci\u00f3n para actualizar un usuario def update ( conn , %{ \"id\" => id , \"user\" => user_params }) do user = MyApp.Repo . get! ( MyApp.User , id ) changeset = MyApp.User . changeset ( user , user_params ) case MyApp.Repo . update ( changeset ) do { :ok , user } -> render ( conn , \"show.json\" , user : user ) { :error , changeset } -> conn |> put_status ( :unprocessable_entity ) |> render ( \"error.json\" , changeset : changeset ) end end # Acci\u00f3n para eliminar un usuario def delete ( conn , %{ \"id\" => id }) do user = MyApp.Repo . get! ( MyApp.User , id ) MyApp.Repo . delete ( user ) send_resp ( conn , :no_content , \"\" ) end end","title":"Ejemplos de c\u00f3digo en Elixir"},{"location":"elixir/mid/diseno_de_apis_en_elixir/#ejercicios-practicos-con-instrucciones-claras","text":"Crea un nuevo proyecto en Phoenix utilizando el comando mix phx.new my_api . Agrega un modelo Product con los campos name , price y description . Crea las migraciones para crear la tabla products en la base de datos. Genera un controlador ProductController con las acciones index , create , show , update y delete . Implementa la l\u00f3gica en cada acci\u00f3n para manipular los recursos de la tabla products . Realiza pruebas utilizando herramientas como Postman para asegurarte de que la API funciona correctamente.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"elixir/mid/diseno_de_apis_en_elixir/#consejos-o-mejores-practicas","text":"Utiliza el principio de responsabilidad \u00fanica para mantener tus controladores y modelos simples y f\u00e1ciles de entender. Utiliza los verbos HTTP adecuados para cada acci\u00f3n, siguiendo las convenciones de las APIs RESTful. Utiliza el patr\u00f3n de repositorio para encapsular la l\u00f3gica de acceso a la base de datos en una capa separada. Utiliza el enrutamiento basado en recursos para definir las rutas de tu API de forma clara y coherente. Utiliza las pruebas automatizadas para garantizar que tu API funcione correctamente y maneje errores de manera adecuada. Utiliza los m\u00f3dulos de autenticaci\u00f3n y autorizaci\u00f3n de Phoenix para proteger tu API de accesos no autorizados. Utiliza herramientas como Swagger para documentar tu API de forma clara y concisa. <- Lecci\u00f3n anterior : Desarrollo de aplicaciones de tiempo real Siguiente lecci\u00f3n -> : Integraci\u00f3n con bases de datos","title":"Consejos o mejores pr\u00e1cticas"},{"location":"elixir/mid/estructuras_de_datos_avanzadas/","text":"Estructuras de datos avanzadas en Elixir \u00b6 En Elixir, las estructuras de datos avanzadas son una parte esencial de la programaci\u00f3n funcional. Estas estructuras nos permiten almacenar, organizar y manipular datos de manera eficiente y efectiva. Algunas de las estructuras de datos avanzadas m\u00e1s utilizadas en Elixir son los mapas, diccionarios y estructuras de \u00e1rbol. Palabras clave y su definici\u00f3n \u00b6 Mapas: Una estructura de datos que almacena pares de clave-valor, donde cada clave es \u00fanica y los valores pueden ser de cualquier tipo de datos. Diccionarios: Tambi\u00e9n conocidos como \"hashes\" o \"tablas de dispersi\u00f3n\", son estructuras de datos que almacenan pares de clave-valor, pero a diferencia de los mapas, los diccionarios no garantizan el orden de los elementos. Estructuras de \u00e1rbol: Una estructura de datos jer\u00e1rquica en la que cada elemento tiene un padre y cero o m\u00e1s hijos. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es un mapa en Elixir y c\u00f3mo se diferencia de un diccionario? \u00bfQu\u00e9 es una estructura de \u00e1rbol y c\u00f3mo se puede utilizar en Elixir? \u00bfCu\u00e1l es la diferencia entre una lista y un mapa en Elixir? \u00bfC\u00f3mo se pueden agregar elementos a un mapa existente en Elixir? \u00bfPor qu\u00e9 las estructuras de datos avanzadas son importantes en la programaci\u00f3n funcional? Ejemplos de c\u00f3digo en Elixir \u00b6 Mapas \u00b6 # Crear un mapa con pares de clave-valor mapa = %{ nombre : \"Ana\" , edad : 30 , ciudad : \"Barcelona\" } # Acceder a un valor en el mapa mapa [ :nombre ] # \"Ana\" # Agregar un nuevo par de clave-valor al mapa Map . put ( mapa , :telefono , \"123456789\" ) # Actualizar un valor existente en el mapa Map . put ( mapa , :edad , 31 ) # Eliminar un par de clave-valor del mapa Map . delete ( mapa , :ciudad ) Diccionarios \u00b6 # Crear un diccionario con pares de clave-valor diccionario = %{ nombre : \"Juan\" , edad : 25 , ciudad : \"Madrid\" } # Acceder a un valor en el diccionario diccionario [ :ciudad ] # \"Madrid\" # Agregar un nuevo par de clave-valor al diccionario Map . put ( diccionario , :telefono , \"987654321\" ) # Actualizar un valor existente en el diccionario Map . put ( diccionario , :edad , 26 ) # Eliminar un par de clave-valor del diccionario Map . delete ( diccionario , :nombre ) Estructuras de \u00e1rbol \u00b6 # Crear una estructura de \u00e1rbol con un nodo ra\u00edz arbol = %{ valor : 5 , hijos : [%{ valor : 3 , hijos : [%{ valor : 1 , hijos : []}, %{ valor : 4 , hijos : []}]}, %{ valor : 8 , hijos : [%{ valor : 6 , hijos : []}, %{ valor : 9 , hijos : []}]}]} # Acceder a un valor en el \u00e1rbol arbol [ :hijos ][ 0 ][ :valor ] # 3 # Agregar un nuevo nodo al \u00e1rbol Map . put ( arbol [ :hijos ][ 0 ][ :hijos ][ 1 ], :hijos , [%{ valor : 2 , hijos : []}]) # Eliminar un nodo del \u00e1rbol Map . delete ( arbol [ :hijos ][ 1 ][ :hijos ][ 1 ], :valor ) Ejercicios pr\u00e1cticos \u00b6 Crea un mapa con los datos de una persona (nombre, edad, ciudad) y agrega su n\u00famero de tel\u00e9fono. Crea un diccionario con las calificaciones de un estudiante en diferentes materias y actualiza su nota en una de ellas. Crea una estructura de \u00e1rbol con los nombres de diferentes pa\u00edses y agrega un nuevo pa\u00eds como hijo de uno existente. Crea una funci\u00f3n que reciba un mapa y una clave, y devuelva el valor correspondiente o \"No existe\" si la clave no est\u00e1 presente. Crea una funci\u00f3n que reciba una lista de n\u00fameros y devuelva la suma de todos los elementos utilizando una estructura de \u00e1rbol. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza mapas cuando necesites almacenar pares de clave-valor y mantener el orden de los elementos. Utiliza diccionarios cuando necesites una estructura de datos m\u00e1s r\u00e1pida para buscar y actualizar valores. Utiliza estructuras de \u00e1rbol cuando necesites almacenar datos de manera jer\u00e1rquica y realizar operaciones de b\u00fasqueda y modificaci\u00f3n de manera eficiente. Aseg\u00farate de entender c\u00f3mo se comportan las estructuras de datos en Elixir para elegir la m\u00e1s adecuada para cada situaci\u00f3n. No tengas miedo de utilizar patrones de recursividad para trabajar con estructuras de datos avanzadas en Elixir.","title":"Estructuras de datos avanzadas en Elixir"},{"location":"elixir/mid/estructuras_de_datos_avanzadas/#estructuras-de-datos-avanzadas-en-elixir","text":"En Elixir, las estructuras de datos avanzadas son una parte esencial de la programaci\u00f3n funcional. Estas estructuras nos permiten almacenar, organizar y manipular datos de manera eficiente y efectiva. Algunas de las estructuras de datos avanzadas m\u00e1s utilizadas en Elixir son los mapas, diccionarios y estructuras de \u00e1rbol.","title":"Estructuras de datos avanzadas en Elixir"},{"location":"elixir/mid/estructuras_de_datos_avanzadas/#palabras-clave-y-su-definicion","text":"Mapas: Una estructura de datos que almacena pares de clave-valor, donde cada clave es \u00fanica y los valores pueden ser de cualquier tipo de datos. Diccionarios: Tambi\u00e9n conocidos como \"hashes\" o \"tablas de dispersi\u00f3n\", son estructuras de datos que almacenan pares de clave-valor, pero a diferencia de los mapas, los diccionarios no garantizan el orden de los elementos. Estructuras de \u00e1rbol: Una estructura de datos jer\u00e1rquica en la que cada elemento tiene un padre y cero o m\u00e1s hijos.","title":"Palabras clave y su definici\u00f3n"},{"location":"elixir/mid/estructuras_de_datos_avanzadas/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es un mapa en Elixir y c\u00f3mo se diferencia de un diccionario? \u00bfQu\u00e9 es una estructura de \u00e1rbol y c\u00f3mo se puede utilizar en Elixir? \u00bfCu\u00e1l es la diferencia entre una lista y un mapa en Elixir? \u00bfC\u00f3mo se pueden agregar elementos a un mapa existente en Elixir? \u00bfPor qu\u00e9 las estructuras de datos avanzadas son importantes en la programaci\u00f3n funcional?","title":"Preguntas de repaso"},{"location":"elixir/mid/estructuras_de_datos_avanzadas/#ejemplos-de-codigo-en-elixir","text":"","title":"Ejemplos de c\u00f3digo en Elixir"},{"location":"elixir/mid/estructuras_de_datos_avanzadas/#mapas","text":"# Crear un mapa con pares de clave-valor mapa = %{ nombre : \"Ana\" , edad : 30 , ciudad : \"Barcelona\" } # Acceder a un valor en el mapa mapa [ :nombre ] # \"Ana\" # Agregar un nuevo par de clave-valor al mapa Map . put ( mapa , :telefono , \"123456789\" ) # Actualizar un valor existente en el mapa Map . put ( mapa , :edad , 31 ) # Eliminar un par de clave-valor del mapa Map . delete ( mapa , :ciudad )","title":"Mapas"},{"location":"elixir/mid/estructuras_de_datos_avanzadas/#diccionarios","text":"# Crear un diccionario con pares de clave-valor diccionario = %{ nombre : \"Juan\" , edad : 25 , ciudad : \"Madrid\" } # Acceder a un valor en el diccionario diccionario [ :ciudad ] # \"Madrid\" # Agregar un nuevo par de clave-valor al diccionario Map . put ( diccionario , :telefono , \"987654321\" ) # Actualizar un valor existente en el diccionario Map . put ( diccionario , :edad , 26 ) # Eliminar un par de clave-valor del diccionario Map . delete ( diccionario , :nombre )","title":"Diccionarios"},{"location":"elixir/mid/estructuras_de_datos_avanzadas/#estructuras-de-arbol","text":"# Crear una estructura de \u00e1rbol con un nodo ra\u00edz arbol = %{ valor : 5 , hijos : [%{ valor : 3 , hijos : [%{ valor : 1 , hijos : []}, %{ valor : 4 , hijos : []}]}, %{ valor : 8 , hijos : [%{ valor : 6 , hijos : []}, %{ valor : 9 , hijos : []}]}]} # Acceder a un valor en el \u00e1rbol arbol [ :hijos ][ 0 ][ :valor ] # 3 # Agregar un nuevo nodo al \u00e1rbol Map . put ( arbol [ :hijos ][ 0 ][ :hijos ][ 1 ], :hijos , [%{ valor : 2 , hijos : []}]) # Eliminar un nodo del \u00e1rbol Map . delete ( arbol [ :hijos ][ 1 ][ :hijos ][ 1 ], :valor )","title":"Estructuras de \u00e1rbol"},{"location":"elixir/mid/estructuras_de_datos_avanzadas/#ejercicios-practicos","text":"Crea un mapa con los datos de una persona (nombre, edad, ciudad) y agrega su n\u00famero de tel\u00e9fono. Crea un diccionario con las calificaciones de un estudiante en diferentes materias y actualiza su nota en una de ellas. Crea una estructura de \u00e1rbol con los nombres de diferentes pa\u00edses y agrega un nuevo pa\u00eds como hijo de uno existente. Crea una funci\u00f3n que reciba un mapa y una clave, y devuelva el valor correspondiente o \"No existe\" si la clave no est\u00e1 presente. Crea una funci\u00f3n que reciba una lista de n\u00fameros y devuelva la suma de todos los elementos utilizando una estructura de \u00e1rbol.","title":"Ejercicios pr\u00e1cticos"},{"location":"elixir/mid/estructuras_de_datos_avanzadas/#consejos-o-mejores-practicas","text":"Utiliza mapas cuando necesites almacenar pares de clave-valor y mantener el orden de los elementos. Utiliza diccionarios cuando necesites una estructura de datos m\u00e1s r\u00e1pida para buscar y actualizar valores. Utiliza estructuras de \u00e1rbol cuando necesites almacenar datos de manera jer\u00e1rquica y realizar operaciones de b\u00fasqueda y modificaci\u00f3n de manera eficiente. Aseg\u00farate de entender c\u00f3mo se comportan las estructuras de datos en Elixir para elegir la m\u00e1s adecuada para cada situaci\u00f3n. No tengas miedo de utilizar patrones de recursividad para trabajar con estructuras de datos avanzadas en Elixir.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"elixir/mid/implementacion_de_tolerancia_a_fallos/","text":"Implementaci\u00f3n de tolerancia a fallos \u00b6 En aplicaciones Elixir, es importante tener en cuenta la posibilidad de fallos y c\u00f3mo manejarlos adecuadamente para garantizar la fiabilidad y disponibilidad del sistema. La tolerancia a fallos se refiere a la capacidad de una aplicaci\u00f3n para continuar funcionando correctamente a pesar de que se produzcan errores o fallos en alguna parte del sistema. En esta lecci\u00f3n, exploraremos t\u00e9cnicas para implementar tolerancia a fallos en aplicaciones Elixir. Palabras clave y su definici\u00f3n \u00b6 Tolerancia a fallos: la capacidad de una aplicaci\u00f3n para continuar funcionando correctamente a pesar de fallos o errores en alguna parte del sistema. Circuit Breaker: una biblioteca en Elixir que se encarga de supervisar y controlar el flujo de llamadas a un servicio externo, evitando que se produzcan fallos en cascada. Supervisor: una biblioteca en Elixir que se encarga de supervisar y reiniciar procesos en caso de fallos. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la tolerancia a fallos en aplicaciones Elixir? \u00bfCu\u00e1l es la funci\u00f3n de la biblioteca Circuit Breaker? \u00bfCu\u00e1l es la funci\u00f3n de la biblioteca Supervisor? Ejemplos de c\u00f3digo en Elixir \u00b6 Implementaci\u00f3n de Circuit Breaker \u00b6 El siguiente c\u00f3digo muestra c\u00f3mo utilizar la biblioteca Circuit Breaker en una aplicaci\u00f3n Elixir: # Definir una funci\u00f3n que llame al servicio externo defp call_external_service () do # L\u00f3gica para llamar al servicio externo # En este ejemplo, se asume que la funci\u00f3n retorna un resultado o un error end # Utilizar Circuit Breaker para llamar al servicio externo result = CircuitBreaker . call ( call_external_service ()) # Verificar el resultado case result do { :ok , data } -> # L\u00f3gica para manejar el resultado exitoso { :error , reason } -> # L\u00f3gica para manejar el error o fallo end Implementaci\u00f3n de Supervisor \u00b6 El siguiente c\u00f3digo muestra c\u00f3mo utilizar la biblioteca Supervisor en una aplicaci\u00f3n Elixir: # Definir un m\u00f3dulo de proceso defmodule MyProcess do use GenServer # Definir el comportamiento del proceso def start_link () do GenServer . start_link ( __MODULE__ , nil , name : __MODULE__ ) end # Definir la l\u00f3gica del proceso def init ( _ ) do # L\u00f3gica de inicializaci\u00f3n { :ok , nil } end def handle_info ( :error , state ) do # L\u00f3gica para manejar un error o fallo { :noreply , state } end end # Utilizar Supervisor para iniciar y supervisar el proceso children = [ worker ( MyProcess , []) ] Supervisor . start_link ( children , strategy : :one_for_one ) Ejercicios pr\u00e1cticos \u00b6 Utiliza la biblioteca Circuit Breaker para manejar llamadas a un servicio externo en tu propia aplicaci\u00f3n. Crea un proceso utilizando la biblioteca Supervisor y maneja un posible error o fallo en el proceso. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza Circuit Breaker para controlar el flujo de llamadas a servicios externos y evitar fallos en cascada. Utiliza Supervisor para supervisar y reiniciar procesos en caso de fallos. Utiliza un enfoque de \"fail fast\" en tu aplicaci\u00f3n, es decir, detectar y manejar los errores r\u00e1pidamente para evitar impactos mayores en el sistema. <- Lecci\u00f3n anterior : Optimizaci\u00f3n de rendimiento Siguiente lecci\u00f3n -> : Seguridad en aplicaciones Elixir","title":"Implementacion de tolerancia a fallos"},{"location":"elixir/mid/implementacion_de_tolerancia_a_fallos/#implementacion-de-tolerancia-a-fallos","text":"En aplicaciones Elixir, es importante tener en cuenta la posibilidad de fallos y c\u00f3mo manejarlos adecuadamente para garantizar la fiabilidad y disponibilidad del sistema. La tolerancia a fallos se refiere a la capacidad de una aplicaci\u00f3n para continuar funcionando correctamente a pesar de que se produzcan errores o fallos en alguna parte del sistema. En esta lecci\u00f3n, exploraremos t\u00e9cnicas para implementar tolerancia a fallos en aplicaciones Elixir.","title":"Implementaci\u00f3n de tolerancia a fallos"},{"location":"elixir/mid/implementacion_de_tolerancia_a_fallos/#palabras-clave-y-su-definicion","text":"Tolerancia a fallos: la capacidad de una aplicaci\u00f3n para continuar funcionando correctamente a pesar de fallos o errores en alguna parte del sistema. Circuit Breaker: una biblioteca en Elixir que se encarga de supervisar y controlar el flujo de llamadas a un servicio externo, evitando que se produzcan fallos en cascada. Supervisor: una biblioteca en Elixir que se encarga de supervisar y reiniciar procesos en caso de fallos.","title":"Palabras clave y su definici\u00f3n"},{"location":"elixir/mid/implementacion_de_tolerancia_a_fallos/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la tolerancia a fallos en aplicaciones Elixir? \u00bfCu\u00e1l es la funci\u00f3n de la biblioteca Circuit Breaker? \u00bfCu\u00e1l es la funci\u00f3n de la biblioteca Supervisor?","title":"Preguntas de repaso"},{"location":"elixir/mid/implementacion_de_tolerancia_a_fallos/#ejemplos-de-codigo-en-elixir","text":"","title":"Ejemplos de c\u00f3digo en Elixir"},{"location":"elixir/mid/implementacion_de_tolerancia_a_fallos/#implementacion-de-circuit-breaker","text":"El siguiente c\u00f3digo muestra c\u00f3mo utilizar la biblioteca Circuit Breaker en una aplicaci\u00f3n Elixir: # Definir una funci\u00f3n que llame al servicio externo defp call_external_service () do # L\u00f3gica para llamar al servicio externo # En este ejemplo, se asume que la funci\u00f3n retorna un resultado o un error end # Utilizar Circuit Breaker para llamar al servicio externo result = CircuitBreaker . call ( call_external_service ()) # Verificar el resultado case result do { :ok , data } -> # L\u00f3gica para manejar el resultado exitoso { :error , reason } -> # L\u00f3gica para manejar el error o fallo end","title":"Implementaci\u00f3n de Circuit Breaker"},{"location":"elixir/mid/implementacion_de_tolerancia_a_fallos/#implementacion-de-supervisor","text":"El siguiente c\u00f3digo muestra c\u00f3mo utilizar la biblioteca Supervisor en una aplicaci\u00f3n Elixir: # Definir un m\u00f3dulo de proceso defmodule MyProcess do use GenServer # Definir el comportamiento del proceso def start_link () do GenServer . start_link ( __MODULE__ , nil , name : __MODULE__ ) end # Definir la l\u00f3gica del proceso def init ( _ ) do # L\u00f3gica de inicializaci\u00f3n { :ok , nil } end def handle_info ( :error , state ) do # L\u00f3gica para manejar un error o fallo { :noreply , state } end end # Utilizar Supervisor para iniciar y supervisar el proceso children = [ worker ( MyProcess , []) ] Supervisor . start_link ( children , strategy : :one_for_one )","title":"Implementaci\u00f3n de Supervisor"},{"location":"elixir/mid/implementacion_de_tolerancia_a_fallos/#ejercicios-practicos","text":"Utiliza la biblioteca Circuit Breaker para manejar llamadas a un servicio externo en tu propia aplicaci\u00f3n. Crea un proceso utilizando la biblioteca Supervisor y maneja un posible error o fallo en el proceso.","title":"Ejercicios pr\u00e1cticos"},{"location":"elixir/mid/implementacion_de_tolerancia_a_fallos/#consejos-o-mejores-practicas","text":"Utiliza Circuit Breaker para controlar el flujo de llamadas a servicios externos y evitar fallos en cascada. Utiliza Supervisor para supervisar y reiniciar procesos en caso de fallos. Utiliza un enfoque de \"fail fast\" en tu aplicaci\u00f3n, es decir, detectar y manejar los errores r\u00e1pidamente para evitar impactos mayores en el sistema. <- Lecci\u00f3n anterior : Optimizaci\u00f3n de rendimiento Siguiente lecci\u00f3n -> : Seguridad en aplicaciones Elixir","title":"Consejos o mejores pr\u00e1cticas"},{"location":"elixir/mid/integracion_con_bases_de_datos/","text":"Integraci\u00f3n con bases de datos \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 La integraci\u00f3n con bases de datos es un aspecto fundamental en el desarrollo de aplicaciones, ya que permite almacenar y recuperar datos de manera eficiente. En el caso de Elixir, existen diferentes opciones para integrar con bases de datos, pero la m\u00e1s utilizada es a trav\u00e9s del framework Ecto. Ecto es un m\u00f3dulo de Elixir que permite interactuar con bases de datos relacionales y no relacionales de manera sencilla y segura. Utiliza el patr\u00f3n de dise\u00f1o de Repositorio para manejar las operaciones de lectura y escritura en la base de datos. Adem\u00e1s, cuenta con un lenguaje de consulta propio llamado Ecto Query Language (EctoQL) que facilita la creaci\u00f3n de consultas y evita la inyecci\u00f3n de SQL. Palabras clave y su definici\u00f3n \u00b6 Base de datos: conjunto de informaci\u00f3n estructurada y almacenada en un sistema de computaci\u00f3n. Integraci\u00f3n: proceso de conectar diferentes sistemas para que puedan interactuar entre s\u00ed. Elixir: lenguaje de programaci\u00f3n funcional y concurrente basado en Erlang. Ecto: m\u00f3dulo de Elixir para interactuar con bases de datos. SQL: lenguaje de consulta estructurado utilizado para comunicarse con bases de datos relacionales. NoSQL: bases de datos no relacionales que no utilizan SQL como lenguaje de consulta. EctoQL: lenguaje de consulta utilizado por Ecto para realizar operaciones en la base de datos. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es Ecto y para qu\u00e9 se utiliza? \u00bfCu\u00e1l es el patr\u00f3n de dise\u00f1o utilizado por Ecto? \u00bfQu\u00e9 es EctoQL y para qu\u00e9 se utiliza? \u00bfQu\u00e9 es una base de datos NoSQL? \u00bfCu\u00e1l es la ventaja de utilizar Ecto en lugar de SQL directamente? Ejemplos de c\u00f3digo en Elixir \u00b6 Conexi\u00f3n a una base de datos utilizando Ecto \u00b6 defmodule MyApp.Repo do use Ecto.Repo , otp_app : :my_app , adapter : Ecto.Adapters.Postgres end Creaci\u00f3n de un modelo y migraci\u00f3n en Ecto \u00b6 defmodule MyApp.Post do use Ecto.Schema schema \"posts\" do field :title , :string field :content , :text field :author , :string timestamps () end end defmodule MyApp.Repo.Migrations.CreatePosts do use Ecto.Migration def change do create table ( :posts ) do add :title , :string add :content , :text add :author , :string timestamps () end end end Consulta utilizando EctoQL \u00b6 query = from p in Post , where : p . author == \"John\" , select : p Repo . all ( query ) Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea un modelo y migraci\u00f3n para una tabla \"users\" con los campos \"name\", \"email\" y \"password\" utilizando Ecto. Crea una consulta utilizando EctoQL para obtener todos los usuarios con el nombre \"John\". Conecta tu aplicaci\u00f3n de Elixir a una base de datos MySQL utilizando Ecto. Consejos o mejores pr\u00e1cticas \u00b6 Utilizar Ecto en lugar de SQL directamente para evitar la inyecci\u00f3n de SQL y facilitar el mantenimiento del c\u00f3digo. Seguir las convenciones de nomenclatura de Ecto para los modelos y migraciones. Utilizar transacciones en Ecto para asegurar la consistencia de los datos en la base de datos. Utilizar \u00edndices en la base de datos para mejorar el rendimiento de las consultas. <- Lecci\u00f3n anterior : Dise\u00f1o de APIs en Elixir Siguiente lecci\u00f3n -> : Optimizaci\u00f3n de rendimiento","title":"Integraci\u00f3n con bases de datos"},{"location":"elixir/mid/integracion_con_bases_de_datos/#integracion-con-bases-de-datos","text":"","title":"Integraci\u00f3n con bases de datos"},{"location":"elixir/mid/integracion_con_bases_de_datos/#explicacion-teorica","text":"La integraci\u00f3n con bases de datos es un aspecto fundamental en el desarrollo de aplicaciones, ya que permite almacenar y recuperar datos de manera eficiente. En el caso de Elixir, existen diferentes opciones para integrar con bases de datos, pero la m\u00e1s utilizada es a trav\u00e9s del framework Ecto. Ecto es un m\u00f3dulo de Elixir que permite interactuar con bases de datos relacionales y no relacionales de manera sencilla y segura. Utiliza el patr\u00f3n de dise\u00f1o de Repositorio para manejar las operaciones de lectura y escritura en la base de datos. Adem\u00e1s, cuenta con un lenguaje de consulta propio llamado Ecto Query Language (EctoQL) que facilita la creaci\u00f3n de consultas y evita la inyecci\u00f3n de SQL.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"elixir/mid/integracion_con_bases_de_datos/#palabras-clave-y-su-definicion","text":"Base de datos: conjunto de informaci\u00f3n estructurada y almacenada en un sistema de computaci\u00f3n. Integraci\u00f3n: proceso de conectar diferentes sistemas para que puedan interactuar entre s\u00ed. Elixir: lenguaje de programaci\u00f3n funcional y concurrente basado en Erlang. Ecto: m\u00f3dulo de Elixir para interactuar con bases de datos. SQL: lenguaje de consulta estructurado utilizado para comunicarse con bases de datos relacionales. NoSQL: bases de datos no relacionales que no utilizan SQL como lenguaje de consulta. EctoQL: lenguaje de consulta utilizado por Ecto para realizar operaciones en la base de datos.","title":"Palabras clave y su definici\u00f3n"},{"location":"elixir/mid/integracion_con_bases_de_datos/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Ecto y para qu\u00e9 se utiliza? \u00bfCu\u00e1l es el patr\u00f3n de dise\u00f1o utilizado por Ecto? \u00bfQu\u00e9 es EctoQL y para qu\u00e9 se utiliza? \u00bfQu\u00e9 es una base de datos NoSQL? \u00bfCu\u00e1l es la ventaja de utilizar Ecto en lugar de SQL directamente?","title":"Preguntas de repaso"},{"location":"elixir/mid/integracion_con_bases_de_datos/#ejemplos-de-codigo-en-elixir","text":"","title":"Ejemplos de c\u00f3digo en Elixir"},{"location":"elixir/mid/integracion_con_bases_de_datos/#conexion-a-una-base-de-datos-utilizando-ecto","text":"defmodule MyApp.Repo do use Ecto.Repo , otp_app : :my_app , adapter : Ecto.Adapters.Postgres end","title":"Conexi\u00f3n a una base de datos utilizando Ecto"},{"location":"elixir/mid/integracion_con_bases_de_datos/#creacion-de-un-modelo-y-migracion-en-ecto","text":"defmodule MyApp.Post do use Ecto.Schema schema \"posts\" do field :title , :string field :content , :text field :author , :string timestamps () end end defmodule MyApp.Repo.Migrations.CreatePosts do use Ecto.Migration def change do create table ( :posts ) do add :title , :string add :content , :text add :author , :string timestamps () end end end","title":"Creaci\u00f3n de un modelo y migraci\u00f3n en Ecto"},{"location":"elixir/mid/integracion_con_bases_de_datos/#consulta-utilizando-ectoql","text":"query = from p in Post , where : p . author == \"John\" , select : p Repo . all ( query )","title":"Consulta utilizando EctoQL"},{"location":"elixir/mid/integracion_con_bases_de_datos/#ejercicios-practicos-con-instrucciones-claras","text":"Crea un modelo y migraci\u00f3n para una tabla \"users\" con los campos \"name\", \"email\" y \"password\" utilizando Ecto. Crea una consulta utilizando EctoQL para obtener todos los usuarios con el nombre \"John\". Conecta tu aplicaci\u00f3n de Elixir a una base de datos MySQL utilizando Ecto.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"elixir/mid/integracion_con_bases_de_datos/#consejos-o-mejores-practicas","text":"Utilizar Ecto en lugar de SQL directamente para evitar la inyecci\u00f3n de SQL y facilitar el mantenimiento del c\u00f3digo. Seguir las convenciones de nomenclatura de Ecto para los modelos y migraciones. Utilizar transacciones en Ecto para asegurar la consistencia de los datos en la base de datos. Utilizar \u00edndices en la base de datos para mejorar el rendimiento de las consultas. <- Lecci\u00f3n anterior : Dise\u00f1o de APIs en Elixir Siguiente lecci\u00f3n -> : Optimizaci\u00f3n de rendimiento","title":"Consejos o mejores pr\u00e1cticas"},{"location":"elixir/mid/optimizacion_de_rendimiento/","text":"M\u00f3dulo: Optimizaci\u00f3n de rendimiento \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 La optimizaci\u00f3n de rendimiento en Elixir se refiere a la mejora del rendimiento de las aplicaciones escritas en este lenguaje funcional. El rendimiento se mide en t\u00e9rminos de la velocidad y eficiencia con la que una aplicaci\u00f3n puede realizar una tarea determinada. En este m\u00f3dulo, aprenderemos t\u00e9cnicas para mejorar el rendimiento de nuestras aplicaciones Elixir, lo que nos permitir\u00e1 crear aplicaciones m\u00e1s r\u00e1pidas y escalables. Una de las principales ventajas de Elixir es su capacidad para ejecutar procesos en paralelo. Esto significa que m\u00faltiples tareas pueden ejecutarse simult\u00e1neamente, lo que mejora significativamente el rendimiento de la aplicaci\u00f3n. Adem\u00e1s, Elixir utiliza una m\u00e1quina virtual (VM) llamada BEAM, que gestiona la memoria de manera eficiente y permite la ejecuci\u00f3n de procesos en paralelo sin afectar el rendimiento. Otra t\u00e9cnica importante para mejorar el rendimiento en Elixir es la gesti\u00f3n de memoria. Al ser un lenguaje funcional, Elixir utiliza la recolecci\u00f3n de basura para administrar la memoria, lo que significa que no es necesario que el programador se preocupe por liberar la memoria utilizada por los procesos. Sin embargo, existen algunas pr\u00e1cticas recomendadas para evitar problemas de memoria, como el uso de la funci\u00f3n spawn_link en lugar de spawn para crear procesos o la limitaci\u00f3n del n\u00famero de procesos activos en ejecuci\u00f3n. Palabras clave y su definici\u00f3n \u00b6 Rendimiento: Medida de la velocidad y eficiencia con la que una aplicaci\u00f3n puede realizar una tarea determinada. Procesos en paralelo: Ejecuci\u00f3n simult\u00e1nea de m\u00faltiples tareas. BEAM: M\u00e1quina virtual utilizada por Elixir para gestionar la memoria y ejecutar procesos en paralelo. Gesti\u00f3n de memoria: T\u00e9cnicas utilizadas para administrar la memoria de manera eficiente y evitar problemas de memoria. Recolecci\u00f3n de basura: Proceso de liberaci\u00f3n de memoria utilizada por procesos que ya no son necesarios. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la optimizaci\u00f3n de rendimiento en Elixir? \u00bfCu\u00e1l es una de las principales ventajas de Elixir en t\u00e9rminos de rendimiento? \u00bfQu\u00e9 es BEAM y c\u00f3mo contribuye a mejorar el rendimiento de las aplicaciones Elixir? \u00bfPor qu\u00e9 es importante la gesti\u00f3n de memoria en Elixir? \u00bfQu\u00e9 es la recolecci\u00f3n de basura y c\u00f3mo ayuda a administrar la memoria en Elixir? Ejemplos de c\u00f3digo en Elixir \u00b6 Ejemplo de ejecuci\u00f3n de procesos en paralelo: # Definir una funci\u00f3n que ejecuta una tarea en un proceso separado defmodule Paralelo do def ejecutar_tarea do spawn ( fn -> tarea () end ) end end # Ejecutar la tarea en paralelo Paralelo . ejecutar_tarea () Ejemplo de gesti\u00f3n de memoria utilizando spawn_link : # Definir una funci\u00f3n que ejecuta una tarea en un proceso separado defmodule Memoria do def ejecutar_tarea do spawn_link ( fn -> tarea () end ) end end # Ejecutar la tarea en paralelo Memoria . ejecutar_tarea () Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una funci\u00f3n que genere 10 procesos en paralelo y los ejecute simult\u00e1neamente. Modifica la funci\u00f3n anterior para que utilice spawn_link en lugar de spawn . Escribe una funci\u00f3n que genere una lista de 1000 n\u00fameros aleatorios y calcule la suma de todos ellos utilizando procesos en paralelo. Crea una funci\u00f3n que genere una lista de 1000 n\u00fameros aleatorios y los ordene de manera ascendente utilizando procesos en paralelo. Modifica la funci\u00f3n anterior para que utilice una t\u00e9cnica de particionamiento de datos, como map-reduce, para mejorar el rendimiento. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza spawn_link en lugar de spawn para crear procesos en paralelo, ya que esto permite una mejor gesti\u00f3n de memoria. Limita el n\u00famero de procesos activos en ejecuci\u00f3n para evitar problemas de memoria. Utiliza t\u00e9cnicas de particionamiento de datos, como map-reduce, para mejorar el rendimiento en operaciones que involucren grandes conjuntos de datos. Realiza pruebas de rendimiento para identificar posibles cuellos de botella y optimizar tu c\u00f3digo. Aprovecha al m\u00e1ximo las capacidades de la m\u00e1quina virtual BEAM para ejecutar procesos en paralelo y gestionar la memoria de manera eficiente. <- Lecci\u00f3n anterior : Integraci\u00f3n con bases de datos Siguiente lecci\u00f3n -> : Implementaci\u00f3n de tolerancia a fallos","title":"M\u00f3dulo: Optimizaci\u00f3n de rendimiento"},{"location":"elixir/mid/optimizacion_de_rendimiento/#modulo-optimizacion-de-rendimiento","text":"","title":"M\u00f3dulo: Optimizaci\u00f3n de rendimiento"},{"location":"elixir/mid/optimizacion_de_rendimiento/#explicacion-teorica","text":"La optimizaci\u00f3n de rendimiento en Elixir se refiere a la mejora del rendimiento de las aplicaciones escritas en este lenguaje funcional. El rendimiento se mide en t\u00e9rminos de la velocidad y eficiencia con la que una aplicaci\u00f3n puede realizar una tarea determinada. En este m\u00f3dulo, aprenderemos t\u00e9cnicas para mejorar el rendimiento de nuestras aplicaciones Elixir, lo que nos permitir\u00e1 crear aplicaciones m\u00e1s r\u00e1pidas y escalables. Una de las principales ventajas de Elixir es su capacidad para ejecutar procesos en paralelo. Esto significa que m\u00faltiples tareas pueden ejecutarse simult\u00e1neamente, lo que mejora significativamente el rendimiento de la aplicaci\u00f3n. Adem\u00e1s, Elixir utiliza una m\u00e1quina virtual (VM) llamada BEAM, que gestiona la memoria de manera eficiente y permite la ejecuci\u00f3n de procesos en paralelo sin afectar el rendimiento. Otra t\u00e9cnica importante para mejorar el rendimiento en Elixir es la gesti\u00f3n de memoria. Al ser un lenguaje funcional, Elixir utiliza la recolecci\u00f3n de basura para administrar la memoria, lo que significa que no es necesario que el programador se preocupe por liberar la memoria utilizada por los procesos. Sin embargo, existen algunas pr\u00e1cticas recomendadas para evitar problemas de memoria, como el uso de la funci\u00f3n spawn_link en lugar de spawn para crear procesos o la limitaci\u00f3n del n\u00famero de procesos activos en ejecuci\u00f3n.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"elixir/mid/optimizacion_de_rendimiento/#palabras-clave-y-su-definicion","text":"Rendimiento: Medida de la velocidad y eficiencia con la que una aplicaci\u00f3n puede realizar una tarea determinada. Procesos en paralelo: Ejecuci\u00f3n simult\u00e1nea de m\u00faltiples tareas. BEAM: M\u00e1quina virtual utilizada por Elixir para gestionar la memoria y ejecutar procesos en paralelo. Gesti\u00f3n de memoria: T\u00e9cnicas utilizadas para administrar la memoria de manera eficiente y evitar problemas de memoria. Recolecci\u00f3n de basura: Proceso de liberaci\u00f3n de memoria utilizada por procesos que ya no son necesarios.","title":"Palabras clave y su definici\u00f3n"},{"location":"elixir/mid/optimizacion_de_rendimiento/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la optimizaci\u00f3n de rendimiento en Elixir? \u00bfCu\u00e1l es una de las principales ventajas de Elixir en t\u00e9rminos de rendimiento? \u00bfQu\u00e9 es BEAM y c\u00f3mo contribuye a mejorar el rendimiento de las aplicaciones Elixir? \u00bfPor qu\u00e9 es importante la gesti\u00f3n de memoria en Elixir? \u00bfQu\u00e9 es la recolecci\u00f3n de basura y c\u00f3mo ayuda a administrar la memoria en Elixir?","title":"Preguntas de repaso"},{"location":"elixir/mid/optimizacion_de_rendimiento/#ejemplos-de-codigo-en-elixir","text":"Ejemplo de ejecuci\u00f3n de procesos en paralelo: # Definir una funci\u00f3n que ejecuta una tarea en un proceso separado defmodule Paralelo do def ejecutar_tarea do spawn ( fn -> tarea () end ) end end # Ejecutar la tarea en paralelo Paralelo . ejecutar_tarea () Ejemplo de gesti\u00f3n de memoria utilizando spawn_link : # Definir una funci\u00f3n que ejecuta una tarea en un proceso separado defmodule Memoria do def ejecutar_tarea do spawn_link ( fn -> tarea () end ) end end # Ejecutar la tarea en paralelo Memoria . ejecutar_tarea ()","title":"Ejemplos de c\u00f3digo en Elixir"},{"location":"elixir/mid/optimizacion_de_rendimiento/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una funci\u00f3n que genere 10 procesos en paralelo y los ejecute simult\u00e1neamente. Modifica la funci\u00f3n anterior para que utilice spawn_link en lugar de spawn . Escribe una funci\u00f3n que genere una lista de 1000 n\u00fameros aleatorios y calcule la suma de todos ellos utilizando procesos en paralelo. Crea una funci\u00f3n que genere una lista de 1000 n\u00fameros aleatorios y los ordene de manera ascendente utilizando procesos en paralelo. Modifica la funci\u00f3n anterior para que utilice una t\u00e9cnica de particionamiento de datos, como map-reduce, para mejorar el rendimiento.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"elixir/mid/optimizacion_de_rendimiento/#consejos-o-mejores-practicas","text":"Utiliza spawn_link en lugar de spawn para crear procesos en paralelo, ya que esto permite una mejor gesti\u00f3n de memoria. Limita el n\u00famero de procesos activos en ejecuci\u00f3n para evitar problemas de memoria. Utiliza t\u00e9cnicas de particionamiento de datos, como map-reduce, para mejorar el rendimiento en operaciones que involucren grandes conjuntos de datos. Realiza pruebas de rendimiento para identificar posibles cuellos de botella y optimizar tu c\u00f3digo. Aprovecha al m\u00e1ximo las capacidades de la m\u00e1quina virtual BEAM para ejecutar procesos en paralelo y gestionar la memoria de manera eficiente. <- Lecci\u00f3n anterior : Integraci\u00f3n con bases de datos Siguiente lecci\u00f3n -> : Implementaci\u00f3n de tolerancia a fallos","title":"Consejos o mejores pr\u00e1cticas"},{"location":"elixir/mid/programacion_funcional_avanzada/","text":"Programaci\u00f3n funcional avanzada \u00b6 En este m\u00f3dulo, profundizaremos en los conceptos de la programaci\u00f3n funcional en Elixir. La programaci\u00f3n funcional es un paradigma de programaci\u00f3n que se basa en el uso de funciones puras, es decir, funciones que no tienen efectos secundarios y siempre devuelven el mismo resultado para los mismos argumentos. En Elixir, la programaci\u00f3n funcional es una parte fundamental de su dise\u00f1o y permite escribir c\u00f3digo m\u00e1s conciso, mantenible y escalable. Funciones de orden superior \u00b6 Las funciones de orden superior son aquellas que pueden tomar otras funciones como argumentos o retornar funciones como resultado. En Elixir, esto se logra gracias a que las funciones son \"ciudadanos de primera clase\", lo que significa que pueden ser tratadas como cualquier otro valor. Algunas de las funciones de orden superior m\u00e1s comunes en Elixir son Enum.map , Enum.filter y Enum.reduce , que permiten aplicar una funci\u00f3n a cada elemento de una lista, filtrar elementos basado en una condici\u00f3n y reducir una lista en un solo valor, respectivamente. Funciones an\u00f3nimas \u00b6 Las funciones an\u00f3nimas son funciones que no tienen un nombre definido y se pueden crear en tiempo de ejecuci\u00f3n. En Elixir, se denotan con una sintaxis especial que utiliza el operador & seguido de una lista de argumentos y una expresi\u00f3n. Por ejemplo, &(&1 * 2) representa una funci\u00f3n an\u00f3nima que multiplica su primer argumento por 2. Las funciones an\u00f3nimas son muy \u00fatiles en combinaci\u00f3n con las funciones de orden superior, ya que permiten definir una funci\u00f3n \"ad hoc\" para su uso en una operaci\u00f3n espec\u00edfica. M\u00f3dulos de funciones \u00b6 Los m\u00f3dulos de funciones son una forma de agrupar funciones relacionadas en un mismo archivo. En Elixir, un m\u00f3dulo de funciones se define con la palabra clave defmodule seguida del nombre del m\u00f3dulo y su contenido se delimita por la palabra clave do y end . Dentro de un m\u00f3dulo de funciones, se pueden definir tanto funciones p\u00fablicas como privadas. Las funciones p\u00fablicas se pueden llamar desde fuera del m\u00f3dulo, mientras que las privadas solo se pueden llamar desde dentro del m\u00f3dulo. Palabras clave y su definici\u00f3n \u00b6 Programaci\u00f3n funcional: paradigma de programaci\u00f3n basado en el uso de funciones puras. Funci\u00f3n pura: funci\u00f3n que no tiene efectos secundarios y siempre devuelve el mismo resultado para los mismos argumentos. Funci\u00f3n de orden superior: funci\u00f3n que puede tomar otras funciones como argumentos o retornar funciones como resultado. Funci\u00f3n an\u00f3nima: funci\u00f3n sin un nombre definido que se puede crear en tiempo de ejecuci\u00f3n. M\u00f3dulo de funciones: agrupaci\u00f3n de funciones relacionadas en un mismo archivo. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la programaci\u00f3n funcional y por qu\u00e9 es importante en Elixir? \u00bfQu\u00e9 son las funciones de orden superior y cu\u00e1les son algunos ejemplos en Elixir? \u00bfC\u00f3mo se denotan las funciones an\u00f3nimas en Elixir? \u00bfQu\u00e9 ventajas tienen los m\u00f3dulos de funciones en Elixir? Ejemplos de c\u00f3digo en Elixir \u00b6 Funci\u00f3n de orden superior \u00b6 # Funci\u00f3n que toma una funci\u00f3n como argumento y la aplica a cada elemento de una lista lista = [ 1 , 2 , 3 , 4 ] doble = fn x -> x * 2 end Enum . map ( lista , doble ) # output: [2, 4, 6, 8] Funci\u00f3n an\u00f3nima \u00b6 # Funci\u00f3n que calcula el \u00e1rea de un c\u00edrculo utilizando una funci\u00f3n an\u00f3nima area_circulo = fn r -> & math . pi * r ^ 2 end area_circulo . ( 2 ) # output: 12.566370614359172 M\u00f3dulo de funciones \u00b6 # M\u00f3dulo que contiene funciones para trabajar con n\u00fameros defmodule MiModulo do # Funci\u00f3n p\u00fablica para sumar dos n\u00fameros def sumar ( a , b ) do a + b end # Funci\u00f3n privada para calcular el cuadrado de un n\u00famero defp cuadrado ( x ) do x * x end end MiModulo . sumar ( 2 , 3 ) # output: 5 MiModulo . cuadrado ( 4 ) # error: funci\u00f3n privada no accesible desde fuera del m\u00f3dulo Ejercicios pr\u00e1cticos \u00b6 Crea una funci\u00f3n de orden superior que tome una lista de n\u00fameros y devuelva una lista con los n\u00fameros pares. Define una funci\u00f3n an\u00f3nima que multiplique su argumento por 10 y apl\u00edcala a una lista de n\u00fameros. Crea un m\u00f3dulo de funciones con una funci\u00f3n p\u00fablica para calcular el \u00e1rea de un tri\u00e1ngulo y una funci\u00f3n privada para calcular su per\u00edmetro. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza funciones puras en la mayor medida posible para escribir c\u00f3digo m\u00e1s f\u00e1cil de entender y depurar. Utiliza funciones de orden superior para evitar repeticiones de c\u00f3digo y hacerlo m\u00e1s modular. Utiliza funciones an\u00f3nimas cuando necesites definir una funci\u00f3n temporal o ad hoc. Agrupa funciones relacionadas en m\u00f3dulos para facilitar su organizaci\u00f3n y reutilizaci\u00f3n. Navegaci\u00f3n de lecciones \u00b6 No hay lecci\u00f3n anterior Siguiente lecci\u00f3n -> : Composici\u00f3n de procesos","title":"Programaci\u00f3n funcional avanzada"},{"location":"elixir/mid/programacion_funcional_avanzada/#programacion-funcional-avanzada","text":"En este m\u00f3dulo, profundizaremos en los conceptos de la programaci\u00f3n funcional en Elixir. La programaci\u00f3n funcional es un paradigma de programaci\u00f3n que se basa en el uso de funciones puras, es decir, funciones que no tienen efectos secundarios y siempre devuelven el mismo resultado para los mismos argumentos. En Elixir, la programaci\u00f3n funcional es una parte fundamental de su dise\u00f1o y permite escribir c\u00f3digo m\u00e1s conciso, mantenible y escalable.","title":"Programaci\u00f3n funcional avanzada"},{"location":"elixir/mid/programacion_funcional_avanzada/#funciones-de-orden-superior","text":"Las funciones de orden superior son aquellas que pueden tomar otras funciones como argumentos o retornar funciones como resultado. En Elixir, esto se logra gracias a que las funciones son \"ciudadanos de primera clase\", lo que significa que pueden ser tratadas como cualquier otro valor. Algunas de las funciones de orden superior m\u00e1s comunes en Elixir son Enum.map , Enum.filter y Enum.reduce , que permiten aplicar una funci\u00f3n a cada elemento de una lista, filtrar elementos basado en una condici\u00f3n y reducir una lista en un solo valor, respectivamente.","title":"Funciones de orden superior"},{"location":"elixir/mid/programacion_funcional_avanzada/#funciones-anonimas","text":"Las funciones an\u00f3nimas son funciones que no tienen un nombre definido y se pueden crear en tiempo de ejecuci\u00f3n. En Elixir, se denotan con una sintaxis especial que utiliza el operador & seguido de una lista de argumentos y una expresi\u00f3n. Por ejemplo, &(&1 * 2) representa una funci\u00f3n an\u00f3nima que multiplica su primer argumento por 2. Las funciones an\u00f3nimas son muy \u00fatiles en combinaci\u00f3n con las funciones de orden superior, ya que permiten definir una funci\u00f3n \"ad hoc\" para su uso en una operaci\u00f3n espec\u00edfica.","title":"Funciones an\u00f3nimas"},{"location":"elixir/mid/programacion_funcional_avanzada/#modulos-de-funciones","text":"Los m\u00f3dulos de funciones son una forma de agrupar funciones relacionadas en un mismo archivo. En Elixir, un m\u00f3dulo de funciones se define con la palabra clave defmodule seguida del nombre del m\u00f3dulo y su contenido se delimita por la palabra clave do y end . Dentro de un m\u00f3dulo de funciones, se pueden definir tanto funciones p\u00fablicas como privadas. Las funciones p\u00fablicas se pueden llamar desde fuera del m\u00f3dulo, mientras que las privadas solo se pueden llamar desde dentro del m\u00f3dulo.","title":"M\u00f3dulos de funciones"},{"location":"elixir/mid/programacion_funcional_avanzada/#palabras-clave-y-su-definicion","text":"Programaci\u00f3n funcional: paradigma de programaci\u00f3n basado en el uso de funciones puras. Funci\u00f3n pura: funci\u00f3n que no tiene efectos secundarios y siempre devuelve el mismo resultado para los mismos argumentos. Funci\u00f3n de orden superior: funci\u00f3n que puede tomar otras funciones como argumentos o retornar funciones como resultado. Funci\u00f3n an\u00f3nima: funci\u00f3n sin un nombre definido que se puede crear en tiempo de ejecuci\u00f3n. M\u00f3dulo de funciones: agrupaci\u00f3n de funciones relacionadas en un mismo archivo.","title":"Palabras clave y su definici\u00f3n"},{"location":"elixir/mid/programacion_funcional_avanzada/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la programaci\u00f3n funcional y por qu\u00e9 es importante en Elixir? \u00bfQu\u00e9 son las funciones de orden superior y cu\u00e1les son algunos ejemplos en Elixir? \u00bfC\u00f3mo se denotan las funciones an\u00f3nimas en Elixir? \u00bfQu\u00e9 ventajas tienen los m\u00f3dulos de funciones en Elixir?","title":"Preguntas de repaso"},{"location":"elixir/mid/programacion_funcional_avanzada/#ejemplos-de-codigo-en-elixir","text":"","title":"Ejemplos de c\u00f3digo en Elixir"},{"location":"elixir/mid/programacion_funcional_avanzada/#funcion-de-orden-superior","text":"# Funci\u00f3n que toma una funci\u00f3n como argumento y la aplica a cada elemento de una lista lista = [ 1 , 2 , 3 , 4 ] doble = fn x -> x * 2 end Enum . map ( lista , doble ) # output: [2, 4, 6, 8]","title":"Funci\u00f3n de orden superior"},{"location":"elixir/mid/programacion_funcional_avanzada/#funcion-anonima","text":"# Funci\u00f3n que calcula el \u00e1rea de un c\u00edrculo utilizando una funci\u00f3n an\u00f3nima area_circulo = fn r -> & math . pi * r ^ 2 end area_circulo . ( 2 ) # output: 12.566370614359172","title":"Funci\u00f3n an\u00f3nima"},{"location":"elixir/mid/programacion_funcional_avanzada/#modulo-de-funciones","text":"# M\u00f3dulo que contiene funciones para trabajar con n\u00fameros defmodule MiModulo do # Funci\u00f3n p\u00fablica para sumar dos n\u00fameros def sumar ( a , b ) do a + b end # Funci\u00f3n privada para calcular el cuadrado de un n\u00famero defp cuadrado ( x ) do x * x end end MiModulo . sumar ( 2 , 3 ) # output: 5 MiModulo . cuadrado ( 4 ) # error: funci\u00f3n privada no accesible desde fuera del m\u00f3dulo","title":"M\u00f3dulo de funciones"},{"location":"elixir/mid/programacion_funcional_avanzada/#ejercicios-practicos","text":"Crea una funci\u00f3n de orden superior que tome una lista de n\u00fameros y devuelva una lista con los n\u00fameros pares. Define una funci\u00f3n an\u00f3nima que multiplique su argumento por 10 y apl\u00edcala a una lista de n\u00fameros. Crea un m\u00f3dulo de funciones con una funci\u00f3n p\u00fablica para calcular el \u00e1rea de un tri\u00e1ngulo y una funci\u00f3n privada para calcular su per\u00edmetro.","title":"Ejercicios pr\u00e1cticos"},{"location":"elixir/mid/programacion_funcional_avanzada/#consejos-o-mejores-practicas","text":"Utiliza funciones puras en la mayor medida posible para escribir c\u00f3digo m\u00e1s f\u00e1cil de entender y depurar. Utiliza funciones de orden superior para evitar repeticiones de c\u00f3digo y hacerlo m\u00e1s modular. Utiliza funciones an\u00f3nimas cuando necesites definir una funci\u00f3n temporal o ad hoc. Agrupa funciones relacionadas en m\u00f3dulos para facilitar su organizaci\u00f3n y reutilizaci\u00f3n.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"elixir/mid/programacion_funcional_avanzada/#navegacion-de-lecciones","text":"No hay lecci\u00f3n anterior Siguiente lecci\u00f3n -> : Composici\u00f3n de procesos","title":"Navegaci\u00f3n de lecciones"},{"location":"elixir/mid/seguridad_en_aplicaciones_elixir/","text":"Seguridad en aplicaciones Elixir \u00b6 En la actualidad, la seguridad en aplicaciones web es una preocupaci\u00f3n cada vez mayor debido a la gran cantidad de informaci\u00f3n y datos sensibles que se manejan en ellas. En este sentido, es importante que los desarrolladores est\u00e9n familiarizados con las mejores pr\u00e1cticas de seguridad y que las apliquen en el desarrollo de sus aplicaciones. En este m\u00f3dulo, nos enfocaremos en la seguridad en aplicaciones Elixir y c\u00f3mo podemos implementar medidas de seguridad efectivas. Autenticaci\u00f3n y Autorizaci\u00f3n \u00b6 Antes de entrar en detalles sobre c\u00f3mo podemos asegurar nuestras aplicaciones Elixir, es importante entender los conceptos de autenticaci\u00f3n y autorizaci\u00f3n. La autenticaci\u00f3n se refiere al proceso de verificar la identidad de un usuario, mientras que la autorizaci\u00f3n se refiere a los permisos que se le otorgan a un usuario una vez que su identidad ha sido verificada. Ambos son fundamentales para garantizar la seguridad en nuestras aplicaciones. Palabras clave y definiciones \u00b6 Autenticaci\u00f3n: proceso de verificar la identidad de un usuario. Autorizaci\u00f3n: permisos otorgados a un usuario una vez que su identidad ha sido verificada. Seguridad en aplicaciones: conjunto de medidas para proteger una aplicaci\u00f3n contra posibles vulnerabilidades y ataques. Criptograf\u00eda: t\u00e9cnica para proteger la informaci\u00f3n mediante el uso de algoritmos matem\u00e1ticos. Token: cadena de caracteres que representa una identidad o un permiso en una aplicaci\u00f3n. SSL/TLS: protocolos de seguridad para establecer una conexi\u00f3n segura entre un cliente y un servidor. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la autenticaci\u00f3n y por qu\u00e9 es importante en una aplicaci\u00f3n Elixir? \u00bfCu\u00e1l es la diferencia entre autenticaci\u00f3n y autorizaci\u00f3n? \u00bfQu\u00e9 es la criptograf\u00eda y c\u00f3mo se aplica en la seguridad de aplicaciones Elixir? \u00bfQu\u00e9 es un token y c\u00f3mo se utiliza en una aplicaci\u00f3n Elixir? \u00bfQu\u00e9 son SSL y TLS y por qu\u00e9 son importantes en la seguridad de aplicaciones web? Ejemplos de c\u00f3digo en Elixir \u00b6 Generaci\u00f3n de tokens seguros \u00b6 # Genera un token aleatorio de 32 caracteres token = :crypto . strong_rand_bytes ( 32 ) |> Base . encode64 () # Almacenamiento del token en una variable de sesi\u00f3n conn |> put_session ( :token , token ) |> redirect ( to : \"/dashboard\" ) Implementaci\u00f3n de SSL/TLS en una aplicaci\u00f3n Phoenix \u00b6 # Configuraci\u00f3n para utilizar SSL en producci\u00f3n config :my_app , MyApp.Endpoint , force_ssl : [ rewrite_on : [ :x_forwarded_proto ], hsts : true ], url : [ scheme : \"https\" , host : \"www.example.com\" ] # Configuraci\u00f3n para generar certificados SSL automaticamente config :my_app , MyApp.Endpoint , ssl : [ certfile : \"/path/to/cert.pem\" , keyfile : \"/path/to/key.pem\" ], http : [ port : 80 ], https : [ port : 443 ] Ejercicios pr\u00e1cticos \u00b6 Implementar la autenticaci\u00f3n en una aplicaci\u00f3n Elixir utilizando el m\u00f3dulo Comeonin para almacenar contrase\u00f1as de forma segura. Generar un token seguro en una aplicaci\u00f3n Elixir y utilizarlo para autenticar a un usuario en una ruta protegida. Configurar SSL/TLS en una aplicaci\u00f3n Phoenix y probar su funcionamiento en un servidor local. Consejos y mejores pr\u00e1cticas \u00b6 Aseg\u00farate de almacenar contrase\u00f1as utilizando t\u00e9cnicas de hashing y salting para evitar vulnerabilidades. Utiliza tokens en lugar de identificadores de sesi\u00f3n para evitar ataques de falsificaci\u00f3n de solicitudes entre sitios (CSRF). Implementa SSL/TLS en tu aplicaci\u00f3n para garantizar una conexi\u00f3n segura entre el cliente y el servidor. Realiza pruebas de seguridad constantes en tu aplicaci\u00f3n y aseg\u00farate de estar al d\u00eda con las \u00faltimas actualizaciones y parches de seguridad. Utiliza herramientas como Plug y Phoenix Action Protect para proteger tus rutas y controladores de posibles ataques. <- Lecci\u00f3n anterior : Implementaci\u00f3n de tolerancia a fallos Siguiente lecci\u00f3n -> : Supervisi\u00f3n avanzada de procesos","title":"Seguridad en aplicaciones elixir"},{"location":"elixir/mid/seguridad_en_aplicaciones_elixir/#seguridad-en-aplicaciones-elixir","text":"En la actualidad, la seguridad en aplicaciones web es una preocupaci\u00f3n cada vez mayor debido a la gran cantidad de informaci\u00f3n y datos sensibles que se manejan en ellas. En este sentido, es importante que los desarrolladores est\u00e9n familiarizados con las mejores pr\u00e1cticas de seguridad y que las apliquen en el desarrollo de sus aplicaciones. En este m\u00f3dulo, nos enfocaremos en la seguridad en aplicaciones Elixir y c\u00f3mo podemos implementar medidas de seguridad efectivas.","title":"Seguridad en aplicaciones Elixir"},{"location":"elixir/mid/seguridad_en_aplicaciones_elixir/#autenticacion-y-autorizacion","text":"Antes de entrar en detalles sobre c\u00f3mo podemos asegurar nuestras aplicaciones Elixir, es importante entender los conceptos de autenticaci\u00f3n y autorizaci\u00f3n. La autenticaci\u00f3n se refiere al proceso de verificar la identidad de un usuario, mientras que la autorizaci\u00f3n se refiere a los permisos que se le otorgan a un usuario una vez que su identidad ha sido verificada. Ambos son fundamentales para garantizar la seguridad en nuestras aplicaciones.","title":"Autenticaci\u00f3n y Autorizaci\u00f3n"},{"location":"elixir/mid/seguridad_en_aplicaciones_elixir/#palabras-clave-y-definiciones","text":"Autenticaci\u00f3n: proceso de verificar la identidad de un usuario. Autorizaci\u00f3n: permisos otorgados a un usuario una vez que su identidad ha sido verificada. Seguridad en aplicaciones: conjunto de medidas para proteger una aplicaci\u00f3n contra posibles vulnerabilidades y ataques. Criptograf\u00eda: t\u00e9cnica para proteger la informaci\u00f3n mediante el uso de algoritmos matem\u00e1ticos. Token: cadena de caracteres que representa una identidad o un permiso en una aplicaci\u00f3n. SSL/TLS: protocolos de seguridad para establecer una conexi\u00f3n segura entre un cliente y un servidor.","title":"Palabras clave y definiciones"},{"location":"elixir/mid/seguridad_en_aplicaciones_elixir/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la autenticaci\u00f3n y por qu\u00e9 es importante en una aplicaci\u00f3n Elixir? \u00bfCu\u00e1l es la diferencia entre autenticaci\u00f3n y autorizaci\u00f3n? \u00bfQu\u00e9 es la criptograf\u00eda y c\u00f3mo se aplica en la seguridad de aplicaciones Elixir? \u00bfQu\u00e9 es un token y c\u00f3mo se utiliza en una aplicaci\u00f3n Elixir? \u00bfQu\u00e9 son SSL y TLS y por qu\u00e9 son importantes en la seguridad de aplicaciones web?","title":"Preguntas de repaso"},{"location":"elixir/mid/seguridad_en_aplicaciones_elixir/#ejemplos-de-codigo-en-elixir","text":"","title":"Ejemplos de c\u00f3digo en Elixir"},{"location":"elixir/mid/seguridad_en_aplicaciones_elixir/#generacion-de-tokens-seguros","text":"# Genera un token aleatorio de 32 caracteres token = :crypto . strong_rand_bytes ( 32 ) |> Base . encode64 () # Almacenamiento del token en una variable de sesi\u00f3n conn |> put_session ( :token , token ) |> redirect ( to : \"/dashboard\" )","title":"Generaci\u00f3n de tokens seguros"},{"location":"elixir/mid/seguridad_en_aplicaciones_elixir/#implementacion-de-ssltls-en-una-aplicacion-phoenix","text":"# Configuraci\u00f3n para utilizar SSL en producci\u00f3n config :my_app , MyApp.Endpoint , force_ssl : [ rewrite_on : [ :x_forwarded_proto ], hsts : true ], url : [ scheme : \"https\" , host : \"www.example.com\" ] # Configuraci\u00f3n para generar certificados SSL automaticamente config :my_app , MyApp.Endpoint , ssl : [ certfile : \"/path/to/cert.pem\" , keyfile : \"/path/to/key.pem\" ], http : [ port : 80 ], https : [ port : 443 ]","title":"Implementaci\u00f3n de SSL/TLS en una aplicaci\u00f3n Phoenix"},{"location":"elixir/mid/seguridad_en_aplicaciones_elixir/#ejercicios-practicos","text":"Implementar la autenticaci\u00f3n en una aplicaci\u00f3n Elixir utilizando el m\u00f3dulo Comeonin para almacenar contrase\u00f1as de forma segura. Generar un token seguro en una aplicaci\u00f3n Elixir y utilizarlo para autenticar a un usuario en una ruta protegida. Configurar SSL/TLS en una aplicaci\u00f3n Phoenix y probar su funcionamiento en un servidor local.","title":"Ejercicios pr\u00e1cticos"},{"location":"elixir/mid/seguridad_en_aplicaciones_elixir/#consejos-y-mejores-practicas","text":"Aseg\u00farate de almacenar contrase\u00f1as utilizando t\u00e9cnicas de hashing y salting para evitar vulnerabilidades. Utiliza tokens en lugar de identificadores de sesi\u00f3n para evitar ataques de falsificaci\u00f3n de solicitudes entre sitios (CSRF). Implementa SSL/TLS en tu aplicaci\u00f3n para garantizar una conexi\u00f3n segura entre el cliente y el servidor. Realiza pruebas de seguridad constantes en tu aplicaci\u00f3n y aseg\u00farate de estar al d\u00eda con las \u00faltimas actualizaciones y parches de seguridad. Utiliza herramientas como Plug y Phoenix Action Protect para proteger tus rutas y controladores de posibles ataques. <- Lecci\u00f3n anterior : Implementaci\u00f3n de tolerancia a fallos Siguiente lecci\u00f3n -> : Supervisi\u00f3n avanzada de procesos","title":"Consejos y mejores pr\u00e1cticas"},{"location":"elixir/mid/supervision_avanzada_de_procesos/","text":"Supervisi\u00f3n avanzada de procesos \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 En Elixir, los procesos son la unidad b\u00e1sica de concurrencia y son esenciales para crear sistemas distribuidos y tolerantes a fallos. Sin embargo, estos procesos pueden fallar y es importante tener un sistema de supervisi\u00f3n robusto para manejar estos errores de manera eficiente. La supervisi\u00f3n en Elixir se basa en el modelo de \"padre e hijo\", donde un proceso supervisa a sus hijos y se encarga de reiniciarlos en caso de que fallen. Esto permite que el sistema sea capaz de recuperarse autom\u00e1ticamente de errores y continuar funcionando sin interrupciones. Palabras clave y su definici\u00f3n \u00b6 Proceso: Una unidad de concurrencia en Elixir que se ejecuta de manera independiente y puede comunicarse con otros procesos a trav\u00e9s de mensajes. Supervisi\u00f3n: Un mecanismo que permite a un proceso supervisar y gestionar a sus hijos. \u00c1rbol de supervisi\u00f3n: Una jerarqu\u00eda de procesos donde un proceso padre supervisa a sus hijos y estos, a su vez, pueden tener sus propios hijos. Reinicio de procesos: Un proceso que falla se reinicia autom\u00e1ticamente por su supervisor. Estrategia de reinicio: Determina c\u00f3mo se manejan los errores en un proceso y c\u00f3mo se debe reiniciar si falla. Registra de supervisi\u00f3n: Un proceso especial que se encarga de registrar y almacenar informaci\u00f3n sobre los procesos y su estado. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es un proceso en Elixir? \u00bfEn qu\u00e9 se basa el modelo de supervisi\u00f3n en Elixir? \u00bfQu\u00e9 es un \u00e1rbol de supervisi\u00f3n? \u00bfQu\u00e9 es una estrategia de reinicio? \u00bfCu\u00e1l es el papel del registro de supervisi\u00f3n en un sistema de Elixir? Ejemplos de c\u00f3digo en Elixir \u00b6 Crear un proceso supervisado \u00b6 defmodule MiProceso do use GenServer def start_link(arg) do GenServer.start_link(__MODULE__, arg, name: :mi_proceso) end # Definir el comportamiento del proceso def init(arg) do {:ok, arg} end end Crear un \u00e1rbol de supervisi\u00f3n \u00b6 defmodule Mi\u00c1rbolDeSupervisi\u00f3n do use Supervisor def start_link do Supervisor . start_link ( __MODULE__ , : ok ) end # Definir los procesos supervisados def init ( : ok ) do children = [ worker(MiProceso, [arg ] , id : : mi_proceso ) ] supervise ( children , strategy : : one_for_one ) end end Definir una estrategia de reinicio \u00b6 defmodule MiProceso do use GenServer def start_link(arg) do GenServer.start_link(__MODULE__, arg, name: :mi_proceso, restart: :permanent) end # Definir el comportamiento del proceso def init(arg) do {:ok, arg} end # Definir la estrategia de reinicio def handle_info(:terminate, state) do {:restart, :temporary, state} end end Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea un proceso supervisado llamado MiProceso que imprima \"Hola Mundo\" cada 5 segundos. Define un \u00e1rbol de supervisi\u00f3n que supervise al proceso MiProceso . Prueba el \u00e1rbol de supervisi\u00f3n reiniciando el proceso MiProceso y aseg\u00farate de que se reinicie correctamente. Modifica la estrategia de reinicio del proceso MiProceso para que sea :transient y comprueba c\u00f3mo se comporta el sistema al reiniciar el proceso. Consejos o mejores pr\u00e1cticas \u00b6 Es importante definir adecuadamente las estrategias de reinicio de los procesos, ya que esto afectar\u00e1 directamente a la recuperaci\u00f3n del sistema en caso de errores. Utilizar adecuadamente los registros de supervisi\u00f3n puede facilitar la detecci\u00f3n y resoluci\u00f3n de errores en un sistema distribuido. Es importante tener en cuenta la estructura de un \u00e1rbol de supervisi\u00f3n y asegurarse de que sea lo suficientemente robusto para manejar fallos en diferentes niveles del sistema. <- Lecci\u00f3n anterior : Seguridad en aplicaciones Elixir Siguiente lecci\u00f3n -> : Desarrollo de sistemas distribuidos","title":"Supervisi\u00f3n avanzada de procesos"},{"location":"elixir/mid/supervision_avanzada_de_procesos/#supervision-avanzada-de-procesos","text":"","title":"Supervisi\u00f3n avanzada de procesos"},{"location":"elixir/mid/supervision_avanzada_de_procesos/#explicacion-teorica","text":"En Elixir, los procesos son la unidad b\u00e1sica de concurrencia y son esenciales para crear sistemas distribuidos y tolerantes a fallos. Sin embargo, estos procesos pueden fallar y es importante tener un sistema de supervisi\u00f3n robusto para manejar estos errores de manera eficiente. La supervisi\u00f3n en Elixir se basa en el modelo de \"padre e hijo\", donde un proceso supervisa a sus hijos y se encarga de reiniciarlos en caso de que fallen. Esto permite que el sistema sea capaz de recuperarse autom\u00e1ticamente de errores y continuar funcionando sin interrupciones.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"elixir/mid/supervision_avanzada_de_procesos/#palabras-clave-y-su-definicion","text":"Proceso: Una unidad de concurrencia en Elixir que se ejecuta de manera independiente y puede comunicarse con otros procesos a trav\u00e9s de mensajes. Supervisi\u00f3n: Un mecanismo que permite a un proceso supervisar y gestionar a sus hijos. \u00c1rbol de supervisi\u00f3n: Una jerarqu\u00eda de procesos donde un proceso padre supervisa a sus hijos y estos, a su vez, pueden tener sus propios hijos. Reinicio de procesos: Un proceso que falla se reinicia autom\u00e1ticamente por su supervisor. Estrategia de reinicio: Determina c\u00f3mo se manejan los errores en un proceso y c\u00f3mo se debe reiniciar si falla. Registra de supervisi\u00f3n: Un proceso especial que se encarga de registrar y almacenar informaci\u00f3n sobre los procesos y su estado.","title":"Palabras clave y su definici\u00f3n"},{"location":"elixir/mid/supervision_avanzada_de_procesos/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es un proceso en Elixir? \u00bfEn qu\u00e9 se basa el modelo de supervisi\u00f3n en Elixir? \u00bfQu\u00e9 es un \u00e1rbol de supervisi\u00f3n? \u00bfQu\u00e9 es una estrategia de reinicio? \u00bfCu\u00e1l es el papel del registro de supervisi\u00f3n en un sistema de Elixir?","title":"Preguntas de repaso"},{"location":"elixir/mid/supervision_avanzada_de_procesos/#ejemplos-de-codigo-en-elixir","text":"","title":"Ejemplos de c\u00f3digo en Elixir"},{"location":"elixir/mid/supervision_avanzada_de_procesos/#crear-un-proceso-supervisado","text":"defmodule MiProceso do use GenServer def start_link(arg) do GenServer.start_link(__MODULE__, arg, name: :mi_proceso) end # Definir el comportamiento del proceso def init(arg) do {:ok, arg} end end","title":"Crear un proceso supervisado"},{"location":"elixir/mid/supervision_avanzada_de_procesos/#crear-un-arbol-de-supervision","text":"defmodule Mi\u00c1rbolDeSupervisi\u00f3n do use Supervisor def start_link do Supervisor . start_link ( __MODULE__ , : ok ) end # Definir los procesos supervisados def init ( : ok ) do children = [ worker(MiProceso, [arg ] , id : : mi_proceso ) ] supervise ( children , strategy : : one_for_one ) end end","title":"Crear un \u00e1rbol de supervisi\u00f3n"},{"location":"elixir/mid/supervision_avanzada_de_procesos/#definir-una-estrategia-de-reinicio","text":"defmodule MiProceso do use GenServer def start_link(arg) do GenServer.start_link(__MODULE__, arg, name: :mi_proceso, restart: :permanent) end # Definir el comportamiento del proceso def init(arg) do {:ok, arg} end # Definir la estrategia de reinicio def handle_info(:terminate, state) do {:restart, :temporary, state} end end","title":"Definir una estrategia de reinicio"},{"location":"elixir/mid/supervision_avanzada_de_procesos/#ejercicios-practicos-con-instrucciones-claras","text":"Crea un proceso supervisado llamado MiProceso que imprima \"Hola Mundo\" cada 5 segundos. Define un \u00e1rbol de supervisi\u00f3n que supervise al proceso MiProceso . Prueba el \u00e1rbol de supervisi\u00f3n reiniciando el proceso MiProceso y aseg\u00farate de que se reinicie correctamente. Modifica la estrategia de reinicio del proceso MiProceso para que sea :transient y comprueba c\u00f3mo se comporta el sistema al reiniciar el proceso.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"elixir/mid/supervision_avanzada_de_procesos/#consejos-o-mejores-practicas","text":"Es importante definir adecuadamente las estrategias de reinicio de los procesos, ya que esto afectar\u00e1 directamente a la recuperaci\u00f3n del sistema en caso de errores. Utilizar adecuadamente los registros de supervisi\u00f3n puede facilitar la detecci\u00f3n y resoluci\u00f3n de errores en un sistema distribuido. Es importante tener en cuenta la estructura de un \u00e1rbol de supervisi\u00f3n y asegurarse de que sea lo suficientemente robusto para manejar fallos en diferentes niveles del sistema. <- Lecci\u00f3n anterior : Seguridad en aplicaciones Elixir Siguiente lecci\u00f3n -> : Desarrollo de sistemas distribuidos","title":"Consejos o mejores pr\u00e1cticas"},{"location":"elixir/sr/","text":"Elixir - Nivel Senior \u00b6 \u00a1Bienvenido/a al nivel Senior del curso de Elixir! Aqu\u00ed ver\u00e1s temas especializados y de alto nivel: Profundizaci\u00f3n en Erlang Arquitectura de sistemas Elixir Desarrollo de aplicaciones de alta concurrencia y alto rendimiento Desarrollo de aplicaciones de blockchain en Elixir Desarrollo de aplicaciones de IA en Elixir Desarrollo de aplicaciones m\u00f3viles en Elixir Sistemas de mensajer\u00eda Seguridad avanzada en aplicaciones Elixir Desarrollo de aplicaciones de escritorio, IoT, juegos, VR, etc.","title":"Nivel Senior"},{"location":"elixir/sr/#elixir-nivel-senior","text":"\u00a1Bienvenido/a al nivel Senior del curso de Elixir! Aqu\u00ed ver\u00e1s temas especializados y de alto nivel: Profundizaci\u00f3n en Erlang Arquitectura de sistemas Elixir Desarrollo de aplicaciones de alta concurrencia y alto rendimiento Desarrollo de aplicaciones de blockchain en Elixir Desarrollo de aplicaciones de IA en Elixir Desarrollo de aplicaciones m\u00f3viles en Elixir Sistemas de mensajer\u00eda Seguridad avanzada en aplicaciones Elixir Desarrollo de aplicaciones de escritorio, IoT, juegos, VR, etc.","title":"Elixir - Nivel Senior"},{"location":"elixir/sr/arquitectura_de_sistemas_elixir/","text":"Arquitectura de sistemas Elixir \u00b6 La arquitectura de sistemas en Elixir se refiere al proceso de dise\u00f1ar y construir sistemas complejos en este lenguaje de programaci\u00f3n funcional. Esto incluye la elecci\u00f3n de patrones y arquitecturas adecuadas para garantizar la escalabilidad, robustez y mantenibilidad del sistema. En esta lecci\u00f3n, aprenderemos los conceptos b\u00e1sicos de la arquitectura de sistemas en Elixir y c\u00f3mo aplicarlos en la pr\u00e1ctica. Teor\u00eda \u00b6 Elixir es un lenguaje de programaci\u00f3n funcional que se ejecuta en la m\u00e1quina virtual de Erlang (BEAM). Por lo tanto, hereda ciertas caracter\u00edsticas de Erlang que lo hacen ideal para construir sistemas distribuidos y tolerantes a fallos. A continuaci\u00f3n, se explican los conceptos clave de la arquitectura de sistemas Elixir: Supervisi\u00f3n : Elixir utiliza el modelo de supervisi\u00f3n para manejar la escalabilidad y tolerancia a fallos en el sistema. En lugar de intentar prevenir los fallos, Elixir asume que estos suceder\u00e1n y proporciona herramientas para manejarlos de manera efectiva. Los supervisores son procesos que se encargan de monitorear y reiniciar otros procesos en caso de que falle alguno de ellos. OTP : OTP (Open Telecom Platform) es un conjunto de librer\u00edas y herramientas que vienen incluidas en Elixir y que proporcionan una base s\u00f3lida para construir sistemas distribuidos y tolerantes a fallos. Incluye patrones y arquitecturas comunes, como el modelo de actores y el sistema de supervisi\u00f3n. Modelo de actores : Elixir se basa en el modelo de actores, donde cada proceso es un actor que se comunica con otros a trav\u00e9s de mensajes. Esto permite una comunicaci\u00f3n as\u00edncrona y paralelismo en el sistema. Arquitecturas de sistemas : Elixir ofrece diferentes patrones y arquitecturas para dise\u00f1ar sistemas complejos, como el modelo de actores puro, el modelo de actores supervisados, y el modelo de procesos de fondo (GenServer). La elecci\u00f3n de la arquitectura adecuada depender\u00e1 de los requisitos y caracter\u00edsticas del sistema a construir. Palabras clave y definiciones \u00b6 Supervisi\u00f3n : modelo utilizado en Elixir para manejar la escalabilidad y tolerancia a fallos en el sistema. OTP : conjunto de librer\u00edas y herramientas incluidas en Elixir para construir sistemas distribuidos y tolerantes a fallos. Modelo de actores : modelo de programaci\u00f3n en el que cada proceso se comunica con otros a trav\u00e9s de mensajes. Arquitecturas de sistemas : patrones y modelos utilizados para dise\u00f1ar sistemas complejos en Elixir. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la supervisi\u00f3n en Elixir y para qu\u00e9 se utiliza? \u00bfQu\u00e9 es OTP y qu\u00e9 incluye? \u00bfEn qu\u00e9 se basa el modelo de actores en Elixir? \u00bfCu\u00e1les son algunas de las arquitecturas de sistemas disponibles en Elixir? Ejemplos de c\u00f3digo \u00b6 A continuaci\u00f3n, se muestra un ejemplo de c\u00f3digo en Elixir utilizando el modelo de actores y la supervisi\u00f3n: # Definir un supervisor defmodule Supervisor do use Supervisor # Definir la estrategia de reinicio en caso de fallos def start_link do Supervisor . start_link ( __MODULE__ , [], name : : supervisor ) end # Definir los procesos a supervisar def init ( _ ) do children = [ supervisor ( Task , [[ name : : worker1 ], [ name : : worker2 ]], restart : : temporary ) ] supervise ( children , strategy : : one_for_one ) end end # Definir un proceso que se supervisar\u00e1 defmodule Worker do def start_link ( name ) do Task . start_link ( fn -> do_some_work ( name ) end) end defp do_some_work ( name ) do IO . puts \"Trabajando en #{name}\" : timer . sleep ( 1000 ) raise \"Algo sali\u00f3 mal en #{name}\" end end # Iniciar el supervisor y los procesos supervisados Supervisor . start_link Worker . start_link ( : worker1 ) Worker . start_link ( : worker2 ) En este ejemplo, se define un supervisor que se encarga de monitorear dos procesos llamados worker1 y worker2 . Si alguno de estos procesos falla, el supervisor los reiniciar\u00e1 autom\u00e1ticamente. Esto permite que el sistema siga funcionando a pesar de los fallos en los procesos individuales. Ejercicios pr\u00e1cticos \u00b6 Crea un supervisor que se encargue de monitorear un proceso llamado database que se encarga de manejar la conexi\u00f3n con la base de datos. Utiliza el modelo de actores para crear un sistema que administre una cola de tareas utilizando la librer\u00eda Task . Implementa una arquitectura basada en GenServer para crear un sistema de chat en tiempo real utilizando el m\u00f3dulo GenServer y la librer\u00eda Phoenix . Consejos y mejores pr\u00e1cticas \u00b6 Utiliza el modelo de actores y la supervisi\u00f3n para garantizar la escalabilidad y tolerancia a fallos en el sistema. Aprovecha las herramientas y patrones proporcionados por OTP para construir sistemas distribuidos y tolerantes a fallos. Elige la arquitectura adecuada para cada sistema, teniendo en cuenta sus requisitos y caracter\u00edsticas. Navegaci\u00f3n de lecciones \u00b6 <- Lecci\u00f3n anterior : Profundizaci\u00f3n en Erlang Siguiente lecci\u00f3n -> : Desarrollo de aplicaciones de alta concurrencia y alto rendimiento","title":"Arquitectura de sistemas Elixir"},{"location":"elixir/sr/arquitectura_de_sistemas_elixir/#arquitectura-de-sistemas-elixir","text":"La arquitectura de sistemas en Elixir se refiere al proceso de dise\u00f1ar y construir sistemas complejos en este lenguaje de programaci\u00f3n funcional. Esto incluye la elecci\u00f3n de patrones y arquitecturas adecuadas para garantizar la escalabilidad, robustez y mantenibilidad del sistema. En esta lecci\u00f3n, aprenderemos los conceptos b\u00e1sicos de la arquitectura de sistemas en Elixir y c\u00f3mo aplicarlos en la pr\u00e1ctica.","title":"Arquitectura de sistemas Elixir"},{"location":"elixir/sr/arquitectura_de_sistemas_elixir/#teoria","text":"Elixir es un lenguaje de programaci\u00f3n funcional que se ejecuta en la m\u00e1quina virtual de Erlang (BEAM). Por lo tanto, hereda ciertas caracter\u00edsticas de Erlang que lo hacen ideal para construir sistemas distribuidos y tolerantes a fallos. A continuaci\u00f3n, se explican los conceptos clave de la arquitectura de sistemas Elixir: Supervisi\u00f3n : Elixir utiliza el modelo de supervisi\u00f3n para manejar la escalabilidad y tolerancia a fallos en el sistema. En lugar de intentar prevenir los fallos, Elixir asume que estos suceder\u00e1n y proporciona herramientas para manejarlos de manera efectiva. Los supervisores son procesos que se encargan de monitorear y reiniciar otros procesos en caso de que falle alguno de ellos. OTP : OTP (Open Telecom Platform) es un conjunto de librer\u00edas y herramientas que vienen incluidas en Elixir y que proporcionan una base s\u00f3lida para construir sistemas distribuidos y tolerantes a fallos. Incluye patrones y arquitecturas comunes, como el modelo de actores y el sistema de supervisi\u00f3n. Modelo de actores : Elixir se basa en el modelo de actores, donde cada proceso es un actor que se comunica con otros a trav\u00e9s de mensajes. Esto permite una comunicaci\u00f3n as\u00edncrona y paralelismo en el sistema. Arquitecturas de sistemas : Elixir ofrece diferentes patrones y arquitecturas para dise\u00f1ar sistemas complejos, como el modelo de actores puro, el modelo de actores supervisados, y el modelo de procesos de fondo (GenServer). La elecci\u00f3n de la arquitectura adecuada depender\u00e1 de los requisitos y caracter\u00edsticas del sistema a construir.","title":"Teor\u00eda"},{"location":"elixir/sr/arquitectura_de_sistemas_elixir/#palabras-clave-y-definiciones","text":"Supervisi\u00f3n : modelo utilizado en Elixir para manejar la escalabilidad y tolerancia a fallos en el sistema. OTP : conjunto de librer\u00edas y herramientas incluidas en Elixir para construir sistemas distribuidos y tolerantes a fallos. Modelo de actores : modelo de programaci\u00f3n en el que cada proceso se comunica con otros a trav\u00e9s de mensajes. Arquitecturas de sistemas : patrones y modelos utilizados para dise\u00f1ar sistemas complejos en Elixir.","title":"Palabras clave y definiciones"},{"location":"elixir/sr/arquitectura_de_sistemas_elixir/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la supervisi\u00f3n en Elixir y para qu\u00e9 se utiliza? \u00bfQu\u00e9 es OTP y qu\u00e9 incluye? \u00bfEn qu\u00e9 se basa el modelo de actores en Elixir? \u00bfCu\u00e1les son algunas de las arquitecturas de sistemas disponibles en Elixir?","title":"Preguntas de repaso"},{"location":"elixir/sr/arquitectura_de_sistemas_elixir/#ejemplos-de-codigo","text":"A continuaci\u00f3n, se muestra un ejemplo de c\u00f3digo en Elixir utilizando el modelo de actores y la supervisi\u00f3n: # Definir un supervisor defmodule Supervisor do use Supervisor # Definir la estrategia de reinicio en caso de fallos def start_link do Supervisor . start_link ( __MODULE__ , [], name : : supervisor ) end # Definir los procesos a supervisar def init ( _ ) do children = [ supervisor ( Task , [[ name : : worker1 ], [ name : : worker2 ]], restart : : temporary ) ] supervise ( children , strategy : : one_for_one ) end end # Definir un proceso que se supervisar\u00e1 defmodule Worker do def start_link ( name ) do Task . start_link ( fn -> do_some_work ( name ) end) end defp do_some_work ( name ) do IO . puts \"Trabajando en #{name}\" : timer . sleep ( 1000 ) raise \"Algo sali\u00f3 mal en #{name}\" end end # Iniciar el supervisor y los procesos supervisados Supervisor . start_link Worker . start_link ( : worker1 ) Worker . start_link ( : worker2 ) En este ejemplo, se define un supervisor que se encarga de monitorear dos procesos llamados worker1 y worker2 . Si alguno de estos procesos falla, el supervisor los reiniciar\u00e1 autom\u00e1ticamente. Esto permite que el sistema siga funcionando a pesar de los fallos en los procesos individuales.","title":"Ejemplos de c\u00f3digo"},{"location":"elixir/sr/arquitectura_de_sistemas_elixir/#ejercicios-practicos","text":"Crea un supervisor que se encargue de monitorear un proceso llamado database que se encarga de manejar la conexi\u00f3n con la base de datos. Utiliza el modelo de actores para crear un sistema que administre una cola de tareas utilizando la librer\u00eda Task . Implementa una arquitectura basada en GenServer para crear un sistema de chat en tiempo real utilizando el m\u00f3dulo GenServer y la librer\u00eda Phoenix .","title":"Ejercicios pr\u00e1cticos"},{"location":"elixir/sr/arquitectura_de_sistemas_elixir/#consejos-y-mejores-practicas","text":"Utiliza el modelo de actores y la supervisi\u00f3n para garantizar la escalabilidad y tolerancia a fallos en el sistema. Aprovecha las herramientas y patrones proporcionados por OTP para construir sistemas distribuidos y tolerantes a fallos. Elige la arquitectura adecuada para cada sistema, teniendo en cuenta sus requisitos y caracter\u00edsticas.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"elixir/sr/arquitectura_de_sistemas_elixir/#navegacion-de-lecciones","text":"<- Lecci\u00f3n anterior : Profundizaci\u00f3n en Erlang Siguiente lecci\u00f3n -> : Desarrollo de aplicaciones de alta concurrencia y alto rendimiento","title":"Navegaci\u00f3n de lecciones"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_blockchain_en_elixir/","text":"Desarrollo de aplicaciones de Blockchain en Elixir \u00b6 Teor\u00eda \u00b6 En los \u00faltimos a\u00f1os, la tecnolog\u00eda Blockchain ha revolucionado la forma en que se manejan las transacciones en l\u00ednea. Esta tecnolog\u00eda permite la creaci\u00f3n de registros de transacciones en una red descentralizada y segura, lo que la hace ideal para aplicaciones financieras, contratos inteligentes y otras aplicaciones que requieren un alto nivel de seguridad y confiabilidad. Elixir es un lenguaje de programaci\u00f3n funcional y concurrente que se ha vuelto muy popular en el desarrollo de aplicaciones de Blockchain. Su estilo de programaci\u00f3n funcional y su capacidad de manejar m\u00faltiples procesos al mismo tiempo lo hacen ideal para aplicaciones que requieren un alto rendimiento y escalabilidad. En este m\u00f3dulo, aprenderemos a desarrollar aplicaciones de Blockchain utilizando Elixir y frameworks como Exthereum y Exonum. Estos frameworks proporcionan una capa de abstracci\u00f3n sobre la red Blockchain y nos permiten enfocarnos en la l\u00f3gica de la aplicaci\u00f3n en s\u00ed. Palabras clave y definiciones \u00b6 Blockchain: Una red descentralizada y segura que registra transacciones en bloques enlazados de forma criptogr\u00e1fica. Cada bloque contiene un hash del bloque anterior, lo que asegura la integridad de la cadena. Elixir: Un lenguaje de programaci\u00f3n funcional y concurrente que se ejecuta en la m\u00e1quina virtual de Erlang (BEAM). Contratos inteligentes: Programas que se ejecutan autom\u00e1ticamente en una red Blockchain cuando se cumplen ciertas condiciones. Exthereum: Un framework de Elixir para el desarrollo de aplicaciones en la red Ethereum. Exonum: Un framework de Elixir para el desarrollo de aplicaciones Blockchain personalizadas. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la tecnolog\u00eda Blockchain? \u00bfPor qu\u00e9 Elixir es un lenguaje de programaci\u00f3n ideal para el desarrollo de aplicaciones de Blockchain? \u00bfQu\u00e9 son los contratos inteligentes? \u00bfCu\u00e1les son algunos frameworks de Elixir para el desarrollo de aplicaciones de Blockchain? Ejemplos de c\u00f3digo en Elixir \u00b6 # Crear un contrato inteligente simple en Exthereum defmodule SimpleContract do use Exthereum.Contract # Definir una funci\u00f3n que se ejecutar\u00e1 en la red Blockchain def deposit ( amount ) do # Registrar el evento de dep\u00f3sito en la Blockchain Exthereum.Event . emit ( :deposit , amount ) end end # Crear una aplicaci\u00f3n Blockchain personalizada en Exonum defmodule CustomBlockchain do use Exonum.Blockchain # Definir la estructura de un bloque en la cadena defblock Block do field :data , :string field :timestamp , :integer end # Definir una transacci\u00f3n en la cadena deftx Deposit ( data ) do # Realizar alguna l\u00f3gica de validaci\u00f3n y actualizaci\u00f3n de la cadena # ... # Registrar el evento de dep\u00f3sito en la cadena Exonum.Event . emit ( :deposit , data ) end end Ejercicios pr\u00e1cticos \u00b6 Utilizando el framework Exthereum, crea un contrato inteligente que permita a los usuarios intercambiar tokens en la red Ethereum. Utilizando el framework Exonum, crea una aplicaci\u00f3n Blockchain que registre transacciones de compraventa de bienes en una cadena de bloques personalizada. Consejos y mejores pr\u00e1cticas \u00b6 Familiar\u00edzate con los conceptos b\u00e1sicos de Blockchain antes de comenzar a desarrollar aplicaciones en Elixir. Utiliza frameworks como Exthereum y Exonum para facilitar el desarrollo de aplicaciones de Blockchain. Aseg\u00farate de tener conocimientos s\u00f3lidos de programaci\u00f3n funcional y concurrencia en Elixir para aprovechar al m\u00e1ximo su potencial en aplicaciones de Blockchain. Realiza pruebas exhaustivas para garantizar la seguridad y confiabilidad de tu aplicaci\u00f3n Blockchain. Mantente actualizado sobre las actualizaciones y mejoras en los frameworks de Elixir para el desarrollo de aplicaciones de Blockchain. Navegaci\u00f3n de lecciones \u00b6 <- Lecci\u00f3n anterior : Desarrollo de aplicaciones de alta concurrencia y alto rendimiento Siguiente lecci\u00f3n -> : Desarrollo de aplicaciones de IA en Elixir","title":"Desarrollo de aplicaciones de Blockchain en Elixir"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_blockchain_en_elixir/#desarrollo-de-aplicaciones-de-blockchain-en-elixir","text":"","title":"Desarrollo de aplicaciones de Blockchain en Elixir"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_blockchain_en_elixir/#teoria","text":"En los \u00faltimos a\u00f1os, la tecnolog\u00eda Blockchain ha revolucionado la forma en que se manejan las transacciones en l\u00ednea. Esta tecnolog\u00eda permite la creaci\u00f3n de registros de transacciones en una red descentralizada y segura, lo que la hace ideal para aplicaciones financieras, contratos inteligentes y otras aplicaciones que requieren un alto nivel de seguridad y confiabilidad. Elixir es un lenguaje de programaci\u00f3n funcional y concurrente que se ha vuelto muy popular en el desarrollo de aplicaciones de Blockchain. Su estilo de programaci\u00f3n funcional y su capacidad de manejar m\u00faltiples procesos al mismo tiempo lo hacen ideal para aplicaciones que requieren un alto rendimiento y escalabilidad. En este m\u00f3dulo, aprenderemos a desarrollar aplicaciones de Blockchain utilizando Elixir y frameworks como Exthereum y Exonum. Estos frameworks proporcionan una capa de abstracci\u00f3n sobre la red Blockchain y nos permiten enfocarnos en la l\u00f3gica de la aplicaci\u00f3n en s\u00ed.","title":"Teor\u00eda"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_blockchain_en_elixir/#palabras-clave-y-definiciones","text":"Blockchain: Una red descentralizada y segura que registra transacciones en bloques enlazados de forma criptogr\u00e1fica. Cada bloque contiene un hash del bloque anterior, lo que asegura la integridad de la cadena. Elixir: Un lenguaje de programaci\u00f3n funcional y concurrente que se ejecuta en la m\u00e1quina virtual de Erlang (BEAM). Contratos inteligentes: Programas que se ejecutan autom\u00e1ticamente en una red Blockchain cuando se cumplen ciertas condiciones. Exthereum: Un framework de Elixir para el desarrollo de aplicaciones en la red Ethereum. Exonum: Un framework de Elixir para el desarrollo de aplicaciones Blockchain personalizadas.","title":"Palabras clave y definiciones"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_blockchain_en_elixir/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la tecnolog\u00eda Blockchain? \u00bfPor qu\u00e9 Elixir es un lenguaje de programaci\u00f3n ideal para el desarrollo de aplicaciones de Blockchain? \u00bfQu\u00e9 son los contratos inteligentes? \u00bfCu\u00e1les son algunos frameworks de Elixir para el desarrollo de aplicaciones de Blockchain?","title":"Preguntas de repaso"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_blockchain_en_elixir/#ejemplos-de-codigo-en-elixir","text":"# Crear un contrato inteligente simple en Exthereum defmodule SimpleContract do use Exthereum.Contract # Definir una funci\u00f3n que se ejecutar\u00e1 en la red Blockchain def deposit ( amount ) do # Registrar el evento de dep\u00f3sito en la Blockchain Exthereum.Event . emit ( :deposit , amount ) end end # Crear una aplicaci\u00f3n Blockchain personalizada en Exonum defmodule CustomBlockchain do use Exonum.Blockchain # Definir la estructura de un bloque en la cadena defblock Block do field :data , :string field :timestamp , :integer end # Definir una transacci\u00f3n en la cadena deftx Deposit ( data ) do # Realizar alguna l\u00f3gica de validaci\u00f3n y actualizaci\u00f3n de la cadena # ... # Registrar el evento de dep\u00f3sito en la cadena Exonum.Event . emit ( :deposit , data ) end end","title":"Ejemplos de c\u00f3digo en Elixir"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_blockchain_en_elixir/#ejercicios-practicos","text":"Utilizando el framework Exthereum, crea un contrato inteligente que permita a los usuarios intercambiar tokens en la red Ethereum. Utilizando el framework Exonum, crea una aplicaci\u00f3n Blockchain que registre transacciones de compraventa de bienes en una cadena de bloques personalizada.","title":"Ejercicios pr\u00e1cticos"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_blockchain_en_elixir/#consejos-y-mejores-practicas","text":"Familiar\u00edzate con los conceptos b\u00e1sicos de Blockchain antes de comenzar a desarrollar aplicaciones en Elixir. Utiliza frameworks como Exthereum y Exonum para facilitar el desarrollo de aplicaciones de Blockchain. Aseg\u00farate de tener conocimientos s\u00f3lidos de programaci\u00f3n funcional y concurrencia en Elixir para aprovechar al m\u00e1ximo su potencial en aplicaciones de Blockchain. Realiza pruebas exhaustivas para garantizar la seguridad y confiabilidad de tu aplicaci\u00f3n Blockchain. Mantente actualizado sobre las actualizaciones y mejoras en los frameworks de Elixir para el desarrollo de aplicaciones de Blockchain.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_blockchain_en_elixir/#navegacion-de-lecciones","text":"<- Lecci\u00f3n anterior : Desarrollo de aplicaciones de alta concurrencia y alto rendimiento Siguiente lecci\u00f3n -> : Desarrollo de aplicaciones de IA en Elixir","title":"Navegaci\u00f3n de lecciones"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_escritorio_en_elixir/","text":"Desarrollo de aplicaciones de escritorio en Elixir \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 Elixir es un lenguaje de programaci\u00f3n funcional y din\u00e1mico que se ejecuta sobre la m\u00e1quina virtual de Erlang (BEAM). A pesar de que Elixir se utiliza principalmente para el desarrollo de aplicaciones web y sistemas distribuidos, tambi\u00e9n puede ser utilizado para crear aplicaciones de escritorio. Existen diferentes bibliotecas y herramientas en Elixir que facilitan el desarrollo de aplicaciones de escritorio, como Scenic y Nerves. Scenic es una biblioteca que permite crear interfaces de usuario interactivas y gr\u00e1ficas utilizando OpenGL, mientras que Nerves es un framework que permite desarrollar aplicaciones en tiempo real y de baja latencia. Para crear aplicaciones de escritorio en Elixir, es necesario tener conocimientos b\u00e1sicos sobre el lenguaje, as\u00ed como tambi\u00e9n sobre los conceptos de programaci\u00f3n funcional y la m\u00e1quina virtual de Erlang. Adem\u00e1s, se recomienda tener conocimientos previos sobre el desarrollo de aplicaciones web y sistemas distribuidos en Elixir, ya que muchas de las t\u00e9cnicas y herramientas utilizadas en estas \u00e1reas tambi\u00e9n se pueden aplicar en el desarrollo de aplicaciones de escritorio. Palabras clave y su definici\u00f3n \u00b6 Elixir: Lenguaje de programaci\u00f3n funcional y din\u00e1mico que se ejecuta sobre la m\u00e1quina virtual de Erlang (BEAM). Aplicaciones de escritorio: Programas que se ejecutan en la computadora del usuario y que tienen una interfaz gr\u00e1fica de usuario. Scenic: Biblioteca de Elixir que permite crear interfaces de usuario interactivas y gr\u00e1ficas utilizando OpenGL. Nerves: Framework de Elixir que permite desarrollar aplicaciones en tiempo real y de baja latencia. Erlang: Lenguaje de programaci\u00f3n funcional utilizado para el desarrollo de sistemas distribuidos y concurrentes. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es Elixir y en qu\u00e9 m\u00e1quina virtual se ejecuta? \u00bfQu\u00e9 biblioteca de Elixir se utiliza para crear interfaces de usuario interactivas y gr\u00e1ficas? \u00bfCu\u00e1l es el framework de Elixir utilizado para desarrollar aplicaciones en tiempo real y de baja latencia? \u00bfQu\u00e9 se recomienda tener conocimientos previos para desarrollar aplicaciones de escritorio en Elixir? Ejemplos de c\u00f3digo en Elixir \u00b6 # Crear una ventana con Scenic defmodule MyWindow do use Scenic.Window def handle_input ( input , state ) do # L\u00f3gica para manejar la entrada del usuario end def render ( state ) do # L\u00f3gica para dibujar la interfaz de usuario end end # Crear una aplicaci\u00f3n con Nerves defmodule MyApplication do use Nerves.App def start ( _type , _args ) do # L\u00f3gica para iniciar la aplicaci\u00f3n end def loop ( state ) do # L\u00f3gica para actualizar el estado de la aplicaci\u00f3n en cada ciclo end def draw ( state ) do # L\u00f3gica para dibujar la interfaz de usuario end end Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una ventana con Scenic que tenga un bot\u00f3n y un texto. Al hacer clic en el bot\u00f3n, el texto debe cambiar a \"\u00a1Hiciste clic en el bot\u00f3n!\". Utilizando Nerves, crea una aplicaci\u00f3n que muestre una imagen en la pantalla y que se actualice cada segundo con una imagen diferente. Crea una aplicaci\u00f3n de escritorio en Elixir que funcione como una calculadora b\u00e1sica. La interfaz debe tener dos campos de entrada para los n\u00fameros y botones para realizar las operaciones b\u00e1sicas: suma, resta, multiplicaci\u00f3n y divisi\u00f3n. Consejos o mejores pr\u00e1cticas \u00b6 Aprovecha los conceptos de programaci\u00f3n funcional en el desarrollo de aplicaciones de escritorio en Elixir, ya que te permitir\u00e1n escribir c\u00f3digo m\u00e1s limpio y mantenible. Utiliza las bibliotecas y frameworks disponibles para facilitar el desarrollo de tu aplicaci\u00f3n, como Scenic y Nerves. Ten en cuenta la compatibilidad con diferentes sistemas operativos al desarrollar tu aplicaci\u00f3n de escritorio. Aprovecha la concurrencia y la capacidad de manejo de errores de la m\u00e1quina virtual de Erlang en tu aplicaci\u00f3n de escritorio. Realiza pruebas unitarias y de integraci\u00f3n para garantizar el correcto funcionamiento de tu aplicaci\u00f3n. Mant\u00e9n tu c\u00f3digo organizado y documentado para facilitar su mantenimiento y escalabilidad. Navegaci\u00f3n de lecciones \u00b6 <- Lecci\u00f3n anterior : Seguridad avanzada en aplicaciones Elixir","title":"Desarrollo de aplicaciones de escritorio en Elixir"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_escritorio_en_elixir/#desarrollo-de-aplicaciones-de-escritorio-en-elixir","text":"","title":"Desarrollo de aplicaciones de escritorio en Elixir"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_escritorio_en_elixir/#explicacion-teorica","text":"Elixir es un lenguaje de programaci\u00f3n funcional y din\u00e1mico que se ejecuta sobre la m\u00e1quina virtual de Erlang (BEAM). A pesar de que Elixir se utiliza principalmente para el desarrollo de aplicaciones web y sistemas distribuidos, tambi\u00e9n puede ser utilizado para crear aplicaciones de escritorio. Existen diferentes bibliotecas y herramientas en Elixir que facilitan el desarrollo de aplicaciones de escritorio, como Scenic y Nerves. Scenic es una biblioteca que permite crear interfaces de usuario interactivas y gr\u00e1ficas utilizando OpenGL, mientras que Nerves es un framework que permite desarrollar aplicaciones en tiempo real y de baja latencia. Para crear aplicaciones de escritorio en Elixir, es necesario tener conocimientos b\u00e1sicos sobre el lenguaje, as\u00ed como tambi\u00e9n sobre los conceptos de programaci\u00f3n funcional y la m\u00e1quina virtual de Erlang. Adem\u00e1s, se recomienda tener conocimientos previos sobre el desarrollo de aplicaciones web y sistemas distribuidos en Elixir, ya que muchas de las t\u00e9cnicas y herramientas utilizadas en estas \u00e1reas tambi\u00e9n se pueden aplicar en el desarrollo de aplicaciones de escritorio.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_escritorio_en_elixir/#palabras-clave-y-su-definicion","text":"Elixir: Lenguaje de programaci\u00f3n funcional y din\u00e1mico que se ejecuta sobre la m\u00e1quina virtual de Erlang (BEAM). Aplicaciones de escritorio: Programas que se ejecutan en la computadora del usuario y que tienen una interfaz gr\u00e1fica de usuario. Scenic: Biblioteca de Elixir que permite crear interfaces de usuario interactivas y gr\u00e1ficas utilizando OpenGL. Nerves: Framework de Elixir que permite desarrollar aplicaciones en tiempo real y de baja latencia. Erlang: Lenguaje de programaci\u00f3n funcional utilizado para el desarrollo de sistemas distribuidos y concurrentes.","title":"Palabras clave y su definici\u00f3n"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_escritorio_en_elixir/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Elixir y en qu\u00e9 m\u00e1quina virtual se ejecuta? \u00bfQu\u00e9 biblioteca de Elixir se utiliza para crear interfaces de usuario interactivas y gr\u00e1ficas? \u00bfCu\u00e1l es el framework de Elixir utilizado para desarrollar aplicaciones en tiempo real y de baja latencia? \u00bfQu\u00e9 se recomienda tener conocimientos previos para desarrollar aplicaciones de escritorio en Elixir?","title":"Preguntas de repaso"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_escritorio_en_elixir/#ejemplos-de-codigo-en-elixir","text":"# Crear una ventana con Scenic defmodule MyWindow do use Scenic.Window def handle_input ( input , state ) do # L\u00f3gica para manejar la entrada del usuario end def render ( state ) do # L\u00f3gica para dibujar la interfaz de usuario end end # Crear una aplicaci\u00f3n con Nerves defmodule MyApplication do use Nerves.App def start ( _type , _args ) do # L\u00f3gica para iniciar la aplicaci\u00f3n end def loop ( state ) do # L\u00f3gica para actualizar el estado de la aplicaci\u00f3n en cada ciclo end def draw ( state ) do # L\u00f3gica para dibujar la interfaz de usuario end end","title":"Ejemplos de c\u00f3digo en Elixir"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_escritorio_en_elixir/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una ventana con Scenic que tenga un bot\u00f3n y un texto. Al hacer clic en el bot\u00f3n, el texto debe cambiar a \"\u00a1Hiciste clic en el bot\u00f3n!\". Utilizando Nerves, crea una aplicaci\u00f3n que muestre una imagen en la pantalla y que se actualice cada segundo con una imagen diferente. Crea una aplicaci\u00f3n de escritorio en Elixir que funcione como una calculadora b\u00e1sica. La interfaz debe tener dos campos de entrada para los n\u00fameros y botones para realizar las operaciones b\u00e1sicas: suma, resta, multiplicaci\u00f3n y divisi\u00f3n.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_escritorio_en_elixir/#consejos-o-mejores-practicas","text":"Aprovecha los conceptos de programaci\u00f3n funcional en el desarrollo de aplicaciones de escritorio en Elixir, ya que te permitir\u00e1n escribir c\u00f3digo m\u00e1s limpio y mantenible. Utiliza las bibliotecas y frameworks disponibles para facilitar el desarrollo de tu aplicaci\u00f3n, como Scenic y Nerves. Ten en cuenta la compatibilidad con diferentes sistemas operativos al desarrollar tu aplicaci\u00f3n de escritorio. Aprovecha la concurrencia y la capacidad de manejo de errores de la m\u00e1quina virtual de Erlang en tu aplicaci\u00f3n de escritorio. Realiza pruebas unitarias y de integraci\u00f3n para garantizar el correcto funcionamiento de tu aplicaci\u00f3n. Mant\u00e9n tu c\u00f3digo organizado y documentado para facilitar su mantenimiento y escalabilidad.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_escritorio_en_elixir/#navegacion-de-lecciones","text":"<- Lecci\u00f3n anterior : Seguridad avanzada en aplicaciones Elixir","title":"Navegaci\u00f3n de lecciones"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_inteligencia_artificial_en_elixir/","text":"Desarrollo de aplicaciones de inteligencia artificial en Elixir \u00b6 Descripci\u00f3n del m\u00f3dulo: \u00b6 Este m\u00f3dulo tiene como objetivo proporcionar a los estudiantes los conocimientos y habilidades necesarios para desarrollar aplicaciones de inteligencia artificial utilizando el lenguaje de programaci\u00f3n Elixir. A trav\u00e9s de la explicaci\u00f3n te\u00f3rica y la realizaci\u00f3n de ejercicios pr\u00e1cticos, los estudiantes aprender\u00e1n a utilizar bibliotecas populares como TensorFlow y OpenCV para crear aplicaciones de inteligencia artificial eficientes y escalables. Explicaci\u00f3n te\u00f3rica: \u00b6 Elixir es un lenguaje de programaci\u00f3n funcional y concurrente que se basa en la m\u00e1quina virtual de Erlang. Esta combinaci\u00f3n lo convierte en una excelente opci\u00f3n para el desarrollo de aplicaciones de inteligencia artificial, ya que permite aprovechar la concurrencia y la escalabilidad inherentes a Erlang, mientras se utiliza una sintaxis m\u00e1s sencilla y expresiva. Las aplicaciones de inteligencia artificial se basan en algoritmos y t\u00e9cnicas que permiten a las m\u00e1quinas aprender y realizar tareas de forma aut\u00f3noma, sin la necesidad de una programaci\u00f3n expl\u00edcita. Elixir se presta muy bien a este tipo de aplicaciones, ya que su enfoque funcional facilita la implementaci\u00f3n de algoritmos complejos y su capacidad de concurrencia permite un procesamiento de datos eficiente. Para desarrollar aplicaciones de inteligencia artificial en Elixir, es necesario tener conocimientos previos en programaci\u00f3n funcional y en el uso de la m\u00e1quina virtual de Erlang. Adem\u00e1s, es importante tener un buen entendimiento de los conceptos b\u00e1sicos de inteligencia artificial y de las bibliotecas y herramientas disponibles para su implementaci\u00f3n. Palabras clave y su definici\u00f3n: \u00b6 Elixir: Lenguaje de programaci\u00f3n funcional y concurrente basado en la m\u00e1quina virtual de Erlang. Inteligencia artificial: \u00c1rea de la inform\u00e1tica que se encarga de desarrollar algoritmos y t\u00e9cnicas que permiten a las m\u00e1quinas aprender y realizar tareas de forma aut\u00f3noma. TensorFlow: Biblioteca de c\u00f3digo abierto para el desarrollo de aplicaciones de inteligencia artificial, especialmente enfocada en el aprendizaje autom\u00e1tico. OpenCV: Biblioteca de c\u00f3digo abierto para el procesamiento de im\u00e1genes y visi\u00f3n por computadora, ampliamente utilizada en aplicaciones de inteligencia artificial. Preguntas de repaso: \u00b6 \u00bfQu\u00e9 es Elixir y por qu\u00e9 es adecuado para el desarrollo de aplicaciones de inteligencia artificial? \u00bfQu\u00e9 es la inteligencia artificial y cu\u00e1l es su objetivo? \u00bfCu\u00e1l es la diferencia entre TensorFlow y OpenCV? \u00bfQu\u00e9 conocimientos previos se requieren para desarrollar aplicaciones de inteligencia artificial en Elixir? Ejemplos de c\u00f3digo en Elixir: \u00b6 Ejemplo de funci\u00f3n que implementa el algoritmo de clasificaci\u00f3n K-nearest neighbors utilizando Elixir: def knn ( data , query , k ) do # Calcula la distancia entre el query y cada elemento de data distances = Enum . map ( data , fn element -> distance ( query , element ) end ) # Ordena las distancias de menor a mayor sorted_distances = Enum . sort ( distances ) # Selecciona los k vecinos m\u00e1s cercanos neighbors = Enum . take ( sorted_distances , k ) # Calcula la clase m\u00e1s com\u00fan entre los vecinos class = most_common ( neighbors ) # Retorna la clase predicha para el query class end Ejemplo de funci\u00f3n que utiliza la biblioteca TensorFlow para entrenar un modelo de aprendizaje autom\u00e1tico: def train_model ( data , labels ) do # Crea un nuevo grafo de TensorFlow graph = TensorFlow.Graph . new () # Define las entradas input = TensorFlow . placeholder ( :float32 , shape : [ nil , 4 ]) output = TensorFlow . placeholder ( :int32 , shape : [ nil , 1 ]) # Define las capas del modelo layer1 = TensorFlow . layers . dense ( input , 10 , activation : :relu ) layer2 = TensorFlow . layers . dense ( layer1 , 5 , activation : :relu ) logits = TensorFlow . layers . dense ( layer2 , 3 ) # Define la funci\u00f3n de p\u00e9rdida y el optimizador loss = TensorFlow . nn . sparse_softmax_cross_entropy_with_logits ( labels : output , logits : logits ) optimizer = TensorFlow . train . adam () minimize_op = TensorFlow . train . minimize ( optimizer , loss ) # Entrena el modelo session = TensorFlow.Session . new ( graph ) session |> TensorFlow.Session . run ([ minimize_op ], %{ input => data , output => labels }) end Ejercicios pr\u00e1cticos con instrucciones claras: \u00b6 Escribe una funci\u00f3n en Elixir que implemente el algoritmo de regresi\u00f3n lineal utilizando la biblioteca OpenCV. Crea un modelo de aprendizaje autom\u00e1tico en Elixir que pueda clasificar im\u00e1genes de gatos y perros utilizando TensorFlow y un conjunto de datos de im\u00e1genes etiquetadas. Implementa un algoritmo de clustering utilizando Elixir y la biblioteca de aprendizaje autom\u00e1tico MlBayes. Entrena un modelo de lenguaje utilizando Elixir y la biblioteca Keras, y util\u00edzalo para generar texto autom\u00e1ticamente. Consejos o mejores pr\u00e1cticas: \u00b6 Aprovecha al m\u00e1ximo la concurrencia y escalabilidad de Elixir al dise\u00f1ar tus aplicaciones de inteligencia artificial. Familiar\u00edzate con las bibliotecas y herramientas disponibles para el desarrollo de inteligencia artificial en Elixir, y utiliza las que mejor se adapten a tus necesidades. Aseg\u00farate de tener un buen entendimiento de los algoritmos y t\u00e9cnicas de inteligencia artificial antes de implementarlos en Elixir. Realiza pruebas y optimizaciones constantes para mejorar el rendimiento de tus aplicaciones de inteligencia artificial en Elixir. Mantente actualizado con las \u00faltimas tendencias y avances en el campo de la inteligencia artificial para seguir mejorando tus habilidades en Elixir. Navegaci\u00f3n de lecciones \u00b6 <- Lecci\u00f3n anterior : Desarrollo de aplicaciones de blockchain en Elixir Siguiente lecci\u00f3n -> : Desarrollo de aplicaciones m\u00f3viles en Elixir","title":"Desarrollo de aplicaciones de inteligencia artificial en Elixir"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_inteligencia_artificial_en_elixir/#desarrollo-de-aplicaciones-de-inteligencia-artificial-en-elixir","text":"","title":"Desarrollo de aplicaciones de inteligencia artificial en Elixir"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_inteligencia_artificial_en_elixir/#descripcion-del-modulo","text":"Este m\u00f3dulo tiene como objetivo proporcionar a los estudiantes los conocimientos y habilidades necesarios para desarrollar aplicaciones de inteligencia artificial utilizando el lenguaje de programaci\u00f3n Elixir. A trav\u00e9s de la explicaci\u00f3n te\u00f3rica y la realizaci\u00f3n de ejercicios pr\u00e1cticos, los estudiantes aprender\u00e1n a utilizar bibliotecas populares como TensorFlow y OpenCV para crear aplicaciones de inteligencia artificial eficientes y escalables.","title":"Descripci\u00f3n del m\u00f3dulo:"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_inteligencia_artificial_en_elixir/#explicacion-teorica","text":"Elixir es un lenguaje de programaci\u00f3n funcional y concurrente que se basa en la m\u00e1quina virtual de Erlang. Esta combinaci\u00f3n lo convierte en una excelente opci\u00f3n para el desarrollo de aplicaciones de inteligencia artificial, ya que permite aprovechar la concurrencia y la escalabilidad inherentes a Erlang, mientras se utiliza una sintaxis m\u00e1s sencilla y expresiva. Las aplicaciones de inteligencia artificial se basan en algoritmos y t\u00e9cnicas que permiten a las m\u00e1quinas aprender y realizar tareas de forma aut\u00f3noma, sin la necesidad de una programaci\u00f3n expl\u00edcita. Elixir se presta muy bien a este tipo de aplicaciones, ya que su enfoque funcional facilita la implementaci\u00f3n de algoritmos complejos y su capacidad de concurrencia permite un procesamiento de datos eficiente. Para desarrollar aplicaciones de inteligencia artificial en Elixir, es necesario tener conocimientos previos en programaci\u00f3n funcional y en el uso de la m\u00e1quina virtual de Erlang. Adem\u00e1s, es importante tener un buen entendimiento de los conceptos b\u00e1sicos de inteligencia artificial y de las bibliotecas y herramientas disponibles para su implementaci\u00f3n.","title":"Explicaci\u00f3n te\u00f3rica:"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_inteligencia_artificial_en_elixir/#palabras-clave-y-su-definicion","text":"Elixir: Lenguaje de programaci\u00f3n funcional y concurrente basado en la m\u00e1quina virtual de Erlang. Inteligencia artificial: \u00c1rea de la inform\u00e1tica que se encarga de desarrollar algoritmos y t\u00e9cnicas que permiten a las m\u00e1quinas aprender y realizar tareas de forma aut\u00f3noma. TensorFlow: Biblioteca de c\u00f3digo abierto para el desarrollo de aplicaciones de inteligencia artificial, especialmente enfocada en el aprendizaje autom\u00e1tico. OpenCV: Biblioteca de c\u00f3digo abierto para el procesamiento de im\u00e1genes y visi\u00f3n por computadora, ampliamente utilizada en aplicaciones de inteligencia artificial.","title":"Palabras clave y su definici\u00f3n:"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_inteligencia_artificial_en_elixir/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Elixir y por qu\u00e9 es adecuado para el desarrollo de aplicaciones de inteligencia artificial? \u00bfQu\u00e9 es la inteligencia artificial y cu\u00e1l es su objetivo? \u00bfCu\u00e1l es la diferencia entre TensorFlow y OpenCV? \u00bfQu\u00e9 conocimientos previos se requieren para desarrollar aplicaciones de inteligencia artificial en Elixir?","title":"Preguntas de repaso:"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_inteligencia_artificial_en_elixir/#ejemplos-de-codigo-en-elixir","text":"Ejemplo de funci\u00f3n que implementa el algoritmo de clasificaci\u00f3n K-nearest neighbors utilizando Elixir: def knn ( data , query , k ) do # Calcula la distancia entre el query y cada elemento de data distances = Enum . map ( data , fn element -> distance ( query , element ) end ) # Ordena las distancias de menor a mayor sorted_distances = Enum . sort ( distances ) # Selecciona los k vecinos m\u00e1s cercanos neighbors = Enum . take ( sorted_distances , k ) # Calcula la clase m\u00e1s com\u00fan entre los vecinos class = most_common ( neighbors ) # Retorna la clase predicha para el query class end Ejemplo de funci\u00f3n que utiliza la biblioteca TensorFlow para entrenar un modelo de aprendizaje autom\u00e1tico: def train_model ( data , labels ) do # Crea un nuevo grafo de TensorFlow graph = TensorFlow.Graph . new () # Define las entradas input = TensorFlow . placeholder ( :float32 , shape : [ nil , 4 ]) output = TensorFlow . placeholder ( :int32 , shape : [ nil , 1 ]) # Define las capas del modelo layer1 = TensorFlow . layers . dense ( input , 10 , activation : :relu ) layer2 = TensorFlow . layers . dense ( layer1 , 5 , activation : :relu ) logits = TensorFlow . layers . dense ( layer2 , 3 ) # Define la funci\u00f3n de p\u00e9rdida y el optimizador loss = TensorFlow . nn . sparse_softmax_cross_entropy_with_logits ( labels : output , logits : logits ) optimizer = TensorFlow . train . adam () minimize_op = TensorFlow . train . minimize ( optimizer , loss ) # Entrena el modelo session = TensorFlow.Session . new ( graph ) session |> TensorFlow.Session . run ([ minimize_op ], %{ input => data , output => labels }) end","title":"Ejemplos de c\u00f3digo en Elixir:"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_inteligencia_artificial_en_elixir/#ejercicios-practicos-con-instrucciones-claras","text":"Escribe una funci\u00f3n en Elixir que implemente el algoritmo de regresi\u00f3n lineal utilizando la biblioteca OpenCV. Crea un modelo de aprendizaje autom\u00e1tico en Elixir que pueda clasificar im\u00e1genes de gatos y perros utilizando TensorFlow y un conjunto de datos de im\u00e1genes etiquetadas. Implementa un algoritmo de clustering utilizando Elixir y la biblioteca de aprendizaje autom\u00e1tico MlBayes. Entrena un modelo de lenguaje utilizando Elixir y la biblioteca Keras, y util\u00edzalo para generar texto autom\u00e1ticamente.","title":"Ejercicios pr\u00e1cticos con instrucciones claras:"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_inteligencia_artificial_en_elixir/#consejos-o-mejores-practicas","text":"Aprovecha al m\u00e1ximo la concurrencia y escalabilidad de Elixir al dise\u00f1ar tus aplicaciones de inteligencia artificial. Familiar\u00edzate con las bibliotecas y herramientas disponibles para el desarrollo de inteligencia artificial en Elixir, y utiliza las que mejor se adapten a tus necesidades. Aseg\u00farate de tener un buen entendimiento de los algoritmos y t\u00e9cnicas de inteligencia artificial antes de implementarlos en Elixir. Realiza pruebas y optimizaciones constantes para mejorar el rendimiento de tus aplicaciones de inteligencia artificial en Elixir. Mantente actualizado con las \u00faltimas tendencias y avances en el campo de la inteligencia artificial para seguir mejorando tus habilidades en Elixir.","title":"Consejos o mejores pr\u00e1cticas:"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_inteligencia_artificial_en_elixir/#navegacion-de-lecciones","text":"<- Lecci\u00f3n anterior : Desarrollo de aplicaciones de blockchain en Elixir Siguiente lecci\u00f3n -> : Desarrollo de aplicaciones m\u00f3viles en Elixir","title":"Navegaci\u00f3n de lecciones"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_internet_de_las_cosas_en_elixir/","text":"Desarrollo de aplicaciones de Internet de las cosas en Elixir \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 Internet de las cosas (IoT) se refiere a la interconexi\u00f3n de dispositivos f\u00edsicos como sensores, c\u00e1maras, electrodom\u00e9sticos, entre otros, a trav\u00e9s de internet. Estos dispositivos pueden recopilar y transferir datos, as\u00ed como recibir y ejecutar comandos, lo que permite una amplia gama de aplicaciones en diferentes industrias. En el desarrollo de aplicaciones de IoT, es importante tener en cuenta la escalabilidad, la tolerancia a fallos y la gesti\u00f3n de recursos limitados. Elixir es un lenguaje de programaci\u00f3n funcional que se ejecuta en la m\u00e1quina virtual de Erlang (BEAM), lo que lo hace ideal para desarrollar aplicaciones de IoT. Elixir ofrece una sintaxis simple y elegante, una gran capacidad de concurrencia y tolerancia a fallos, y una gesti\u00f3n eficiente de recursos. Existen frameworks espec\u00edficos para el desarrollo de aplicaciones de IoT en Elixir, como Nerves y NervesHub. Nerves es un framework de c\u00f3digo abierto que permite crear im\u00e1genes de sistemas embebidos basados en Linux y ejecutar aplicaciones de Elixir en ellos. NervesHub es una plataforma de gesti\u00f3n de dispositivos de IoT que permite realizar actualizaciones de forma remota y gestionar m\u00faltiples dispositivos de manera centralizada. Palabras clave y su definici\u00f3n \u00b6 IoT: Siglas de Internet de las cosas, se refiere a la interconexi\u00f3n de dispositivos f\u00edsicos a trav\u00e9s de internet. Elixir: Lenguaje de programaci\u00f3n funcional que se ejecuta en la m\u00e1quina virtual de Erlang (BEAM). Nerves: Framework de c\u00f3digo abierto para el desarrollo de aplicaciones de IoT en Elixir. NervesHub: Plataforma de gesti\u00f3n de dispositivos de IoT basada en Elixir. Concurrencia: Capacidad de un sistema para realizar varias tareas al mismo tiempo. Tolerancia a fallos: Capacidad de un sistema para continuar funcionando a pesar de errores o fallos en uno o varios componentes. Escalabilidad: Capacidad de un sistema para manejar un aumento en el n\u00famero de dispositivos o usuarios. Recursos limitados: Disponibilidad limitada de memoria, procesamiento y almacenamiento en dispositivos embebidos. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es IoT y por qu\u00e9 es importante en el desarrollo de aplicaciones? \u00bfQu\u00e9 caracter\u00edsticas hacen de Elixir un lenguaje adecuado para el desarrollo de aplicaciones de IoT? \u00bfCu\u00e1l es el prop\u00f3sito de Nerves y NervesHub en el desarrollo de aplicaciones de IoT? \u00bfQu\u00e9 es la concurrencia y por qu\u00e9 es importante en aplicaciones de IoT? \u00bfQu\u00e9 es la tolerancia a fallos y por qu\u00e9 es esencial en aplicaciones de IoT? Ejemplos de c\u00f3digo en Elixir \u00b6 Crear una aplicaci\u00f3n de IoT en Nerves \u00b6 # Crear una nueva aplicaci\u00f3n de Nerves mix nerves.new my_app # Configurar los par\u00e1metros del dispositivo cd my_app mix nerves.config target=rpi0 # Compilar la imagen del sistema embebido mix firmware # Generar un archivo de imagen para grabar en una tarjeta SD mix firmware.burn Crear una aplicaci\u00f3n de IoT en NervesHub \u00b6 # Iniciar una nueva aplicaci\u00f3n en NervesHub mix nerves_hub . new my_app # Configurar los par\u00e1metros del dispositivo y la conexi\u00f3n a NervesHub cd my_app mix nerves_hub . config target = rpi0 hub_url = https: //nerves-hub.example.com # Realizar una actualizaci\u00f3n en un dispositivo registrado en NervesHub mix nerves_hub . update device_id = my_device Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crear una aplicaci\u00f3n en Nerves que controle un LED conectado a un dispositivo Raspberry Pi. El LED debe encenderse y apagarse cada segundo. Registrar un dispositivo en NervesHub y realizar una actualizaci\u00f3n remota de la aplicaci\u00f3n en ese dispositivo. Desarrollar una aplicaci\u00f3n en Elixir que recopile datos de temperatura y humedad de un sensor conectado a un dispositivo Raspberry Pi y los env\u00ede a un servidor remoto a trav\u00e9s de una conexi\u00f3n Wi-Fi. Consejos o mejores pr\u00e1cticas \u00b6 Utilizar patrones de dise\u00f1o de concurrencia como actores y procesos para gestionar m\u00faltiples tareas en dispositivos de IoT. Dise\u00f1ar aplicaciones con tolerancia a fallos en mente, utilizando estrategias como la supervisi\u00f3n y la recuperaci\u00f3n de errores. Utilizar herramientas de gesti\u00f3n de dispositivos como NervesHub para facilitar la actualizaci\u00f3n y el monitoreo de dispositivos. Optimizar el uso de recursos limitados en dispositivos embebidos, como el uso eficiente de la memoria y la minimizaci\u00f3n de los tiempos de espera. Realizar pruebas exhaustivas para garantizar la escalabilidad y la estabilidad de las aplicaciones de IoT en Elixir.","title":"Desarrollo de aplicaciones de Internet de las cosas en Elixir"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_internet_de_las_cosas_en_elixir/#desarrollo-de-aplicaciones-de-internet-de-las-cosas-en-elixir","text":"","title":"Desarrollo de aplicaciones de Internet de las cosas en Elixir"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_internet_de_las_cosas_en_elixir/#explicacion-teorica","text":"Internet de las cosas (IoT) se refiere a la interconexi\u00f3n de dispositivos f\u00edsicos como sensores, c\u00e1maras, electrodom\u00e9sticos, entre otros, a trav\u00e9s de internet. Estos dispositivos pueden recopilar y transferir datos, as\u00ed como recibir y ejecutar comandos, lo que permite una amplia gama de aplicaciones en diferentes industrias. En el desarrollo de aplicaciones de IoT, es importante tener en cuenta la escalabilidad, la tolerancia a fallos y la gesti\u00f3n de recursos limitados. Elixir es un lenguaje de programaci\u00f3n funcional que se ejecuta en la m\u00e1quina virtual de Erlang (BEAM), lo que lo hace ideal para desarrollar aplicaciones de IoT. Elixir ofrece una sintaxis simple y elegante, una gran capacidad de concurrencia y tolerancia a fallos, y una gesti\u00f3n eficiente de recursos. Existen frameworks espec\u00edficos para el desarrollo de aplicaciones de IoT en Elixir, como Nerves y NervesHub. Nerves es un framework de c\u00f3digo abierto que permite crear im\u00e1genes de sistemas embebidos basados en Linux y ejecutar aplicaciones de Elixir en ellos. NervesHub es una plataforma de gesti\u00f3n de dispositivos de IoT que permite realizar actualizaciones de forma remota y gestionar m\u00faltiples dispositivos de manera centralizada.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_internet_de_las_cosas_en_elixir/#palabras-clave-y-su-definicion","text":"IoT: Siglas de Internet de las cosas, se refiere a la interconexi\u00f3n de dispositivos f\u00edsicos a trav\u00e9s de internet. Elixir: Lenguaje de programaci\u00f3n funcional que se ejecuta en la m\u00e1quina virtual de Erlang (BEAM). Nerves: Framework de c\u00f3digo abierto para el desarrollo de aplicaciones de IoT en Elixir. NervesHub: Plataforma de gesti\u00f3n de dispositivos de IoT basada en Elixir. Concurrencia: Capacidad de un sistema para realizar varias tareas al mismo tiempo. Tolerancia a fallos: Capacidad de un sistema para continuar funcionando a pesar de errores o fallos en uno o varios componentes. Escalabilidad: Capacidad de un sistema para manejar un aumento en el n\u00famero de dispositivos o usuarios. Recursos limitados: Disponibilidad limitada de memoria, procesamiento y almacenamiento en dispositivos embebidos.","title":"Palabras clave y su definici\u00f3n"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_internet_de_las_cosas_en_elixir/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es IoT y por qu\u00e9 es importante en el desarrollo de aplicaciones? \u00bfQu\u00e9 caracter\u00edsticas hacen de Elixir un lenguaje adecuado para el desarrollo de aplicaciones de IoT? \u00bfCu\u00e1l es el prop\u00f3sito de Nerves y NervesHub en el desarrollo de aplicaciones de IoT? \u00bfQu\u00e9 es la concurrencia y por qu\u00e9 es importante en aplicaciones de IoT? \u00bfQu\u00e9 es la tolerancia a fallos y por qu\u00e9 es esencial en aplicaciones de IoT?","title":"Preguntas de repaso"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_internet_de_las_cosas_en_elixir/#ejemplos-de-codigo-en-elixir","text":"","title":"Ejemplos de c\u00f3digo en Elixir"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_internet_de_las_cosas_en_elixir/#crear-una-aplicacion-de-iot-en-nerves","text":"# Crear una nueva aplicaci\u00f3n de Nerves mix nerves.new my_app # Configurar los par\u00e1metros del dispositivo cd my_app mix nerves.config target=rpi0 # Compilar la imagen del sistema embebido mix firmware # Generar un archivo de imagen para grabar en una tarjeta SD mix firmware.burn","title":"Crear una aplicaci\u00f3n de IoT en Nerves"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_internet_de_las_cosas_en_elixir/#crear-una-aplicacion-de-iot-en-nerveshub","text":"# Iniciar una nueva aplicaci\u00f3n en NervesHub mix nerves_hub . new my_app # Configurar los par\u00e1metros del dispositivo y la conexi\u00f3n a NervesHub cd my_app mix nerves_hub . config target = rpi0 hub_url = https: //nerves-hub.example.com # Realizar una actualizaci\u00f3n en un dispositivo registrado en NervesHub mix nerves_hub . update device_id = my_device","title":"Crear una aplicaci\u00f3n de IoT en NervesHub"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_internet_de_las_cosas_en_elixir/#ejercicios-practicos-con-instrucciones-claras","text":"Crear una aplicaci\u00f3n en Nerves que controle un LED conectado a un dispositivo Raspberry Pi. El LED debe encenderse y apagarse cada segundo. Registrar un dispositivo en NervesHub y realizar una actualizaci\u00f3n remota de la aplicaci\u00f3n en ese dispositivo. Desarrollar una aplicaci\u00f3n en Elixir que recopile datos de temperatura y humedad de un sensor conectado a un dispositivo Raspberry Pi y los env\u00ede a un servidor remoto a trav\u00e9s de una conexi\u00f3n Wi-Fi.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_internet_de_las_cosas_en_elixir/#consejos-o-mejores-practicas","text":"Utilizar patrones de dise\u00f1o de concurrencia como actores y procesos para gestionar m\u00faltiples tareas en dispositivos de IoT. Dise\u00f1ar aplicaciones con tolerancia a fallos en mente, utilizando estrategias como la supervisi\u00f3n y la recuperaci\u00f3n de errores. Utilizar herramientas de gesti\u00f3n de dispositivos como NervesHub para facilitar la actualizaci\u00f3n y el monitoreo de dispositivos. Optimizar el uso de recursos limitados en dispositivos embebidos, como el uso eficiente de la memoria y la minimizaci\u00f3n de los tiempos de espera. Realizar pruebas exhaustivas para garantizar la escalabilidad y la estabilidad de las aplicaciones de IoT en Elixir.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_juegos_en_elixir/","text":"Desarrollo de aplicaciones de juegos en Elixir \u00b6 Introducci\u00f3n \u00b6 Elixir es un lenguaje de programaci\u00f3n funcional, dise\u00f1ado para construir aplicaciones escalables y confiables. Una de las \u00e1reas en las que se destaca Elixir es en el desarrollo de aplicaciones de juegos. En este m\u00f3dulo, aprenderemos c\u00f3mo utilizar Elixir y sus bibliotecas para desarrollar aplicaciones de juegos. Teor\u00eda \u00b6 Las aplicaciones de juegos son programas interactivos que permiten a los usuarios jugar y entretenerse. Estas aplicaciones pueden variar desde juegos sencillos hasta juegos complejos, con gr\u00e1ficos y funcionamiento avanzado. Algunos de los elementos clave en el desarrollo de aplicaciones de juegos en Elixir son: EctoGame : es una biblioteca de Elixir que proporciona una interfaz para interactuar con bases de datos, lo que resulta \u00fatil para almacenar y recuperar informaci\u00f3n de juegos, como puntuaciones y progreso del jugador. Drab : es una biblioteca de Elixir que permite crear interfaces de usuario interactivas para aplicaciones web. Esta biblioteca es \u00fatil para crear interfaces de usuario en tiempo real para juegos en l\u00ednea. Palabras clave \u00b6 Elixir: lenguaje de programaci\u00f3n funcional basado en Erlang y dise\u00f1ado para construir aplicaciones escalables y confiables. Aplicaciones de juegos: programas interactivos que permiten a los usuarios jugar y entretenerse. EctoGame: biblioteca de Elixir para interactuar con bases de datos. Drab: biblioteca de Elixir para crear interfaces de usuario interactivas para aplicaciones web. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es Elixir y para qu\u00e9 se utiliza? \u00bfQu\u00e9 son las aplicaciones de juegos? \u00bfCu\u00e1les son las bibliotecas de Elixir m\u00e1s \u00fatiles para el desarrollo de aplicaciones de juegos? \u00bfPara qu\u00e9 se utiliza EctoGame? \u00bfQu\u00e9 permite hacer Drab en el desarrollo de aplicaciones de juegos? Ejemplos de c\u00f3digo \u00b6 EctoGame \u00b6 # Crear una base de datos para almacenar informaci\u00f3n de jugadores defmodule Player do use Ecto.Schema schema \"players\" do field :name , :string field :score , :integer field :level , :integer end end # Insertar un nuevo jugador en la base de datos player = Player . changeset (% Player {}, %{ name : \"Juan\" , score : 100 , level : 5 }) |> Player . create () Drab \u00b6 # Crear una interfaz de usuario para un juego en l\u00ednea defmodule GameWeb do use Drab def index ( conn , _params ) do conn |> render ( \"index.html\" ) end # Actualizar la puntuaci\u00f3n del jugador en tiempo real def update_score ( conn , %{ \"player_id\" => player_id , \"score\" => score }) do Game . update_score ( player_id , score ) conn |> drab ( \" # score\" , :update , score ) end end Ejercicios pr\u00e1cticos \u00b6 Crea una base de datos utilizando EctoGame para almacenar nombres de jugadores y sus puntuaciones. Implementa una funci\u00f3n en Drab que actualice la puntuaci\u00f3n de un jugador en tiempo real. Crea una aplicaci\u00f3n de juego simple que utilice la base de datos y la interfaz de usuario creadas en los ejercicios anteriores. Consejos y mejores pr\u00e1cticas \u00b6 Utiliza EctoGame para almacenar y recuperar informaci\u00f3n de juegos, como puntuaciones y progreso del jugador. Utiliza Drab para crear interfaces de usuario interactivas en tiempo real para juegos en l\u00ednea. Dise\u00f1a una arquitectura escalable para tu aplicaci\u00f3n de juego, teniendo en cuenta la posible expansi\u00f3n y actualizaci\u00f3n en el futuro. Realiza pruebas y depuraci\u00f3n frecuentemente durante el desarrollo de tu aplicaci\u00f3n de juego para asegurar su correcto funcionamiento.","title":"Desarrollo de aplicaciones de juegos en Elixir"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_juegos_en_elixir/#desarrollo-de-aplicaciones-de-juegos-en-elixir","text":"","title":"Desarrollo de aplicaciones de juegos en Elixir"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_juegos_en_elixir/#introduccion","text":"Elixir es un lenguaje de programaci\u00f3n funcional, dise\u00f1ado para construir aplicaciones escalables y confiables. Una de las \u00e1reas en las que se destaca Elixir es en el desarrollo de aplicaciones de juegos. En este m\u00f3dulo, aprenderemos c\u00f3mo utilizar Elixir y sus bibliotecas para desarrollar aplicaciones de juegos.","title":"Introducci\u00f3n"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_juegos_en_elixir/#teoria","text":"Las aplicaciones de juegos son programas interactivos que permiten a los usuarios jugar y entretenerse. Estas aplicaciones pueden variar desde juegos sencillos hasta juegos complejos, con gr\u00e1ficos y funcionamiento avanzado. Algunos de los elementos clave en el desarrollo de aplicaciones de juegos en Elixir son: EctoGame : es una biblioteca de Elixir que proporciona una interfaz para interactuar con bases de datos, lo que resulta \u00fatil para almacenar y recuperar informaci\u00f3n de juegos, como puntuaciones y progreso del jugador. Drab : es una biblioteca de Elixir que permite crear interfaces de usuario interactivas para aplicaciones web. Esta biblioteca es \u00fatil para crear interfaces de usuario en tiempo real para juegos en l\u00ednea.","title":"Teor\u00eda"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_juegos_en_elixir/#palabras-clave","text":"Elixir: lenguaje de programaci\u00f3n funcional basado en Erlang y dise\u00f1ado para construir aplicaciones escalables y confiables. Aplicaciones de juegos: programas interactivos que permiten a los usuarios jugar y entretenerse. EctoGame: biblioteca de Elixir para interactuar con bases de datos. Drab: biblioteca de Elixir para crear interfaces de usuario interactivas para aplicaciones web.","title":"Palabras clave"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_juegos_en_elixir/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Elixir y para qu\u00e9 se utiliza? \u00bfQu\u00e9 son las aplicaciones de juegos? \u00bfCu\u00e1les son las bibliotecas de Elixir m\u00e1s \u00fatiles para el desarrollo de aplicaciones de juegos? \u00bfPara qu\u00e9 se utiliza EctoGame? \u00bfQu\u00e9 permite hacer Drab en el desarrollo de aplicaciones de juegos?","title":"Preguntas de repaso"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_juegos_en_elixir/#ejemplos-de-codigo","text":"","title":"Ejemplos de c\u00f3digo"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_juegos_en_elixir/#ectogame","text":"# Crear una base de datos para almacenar informaci\u00f3n de jugadores defmodule Player do use Ecto.Schema schema \"players\" do field :name , :string field :score , :integer field :level , :integer end end # Insertar un nuevo jugador en la base de datos player = Player . changeset (% Player {}, %{ name : \"Juan\" , score : 100 , level : 5 }) |> Player . create ()","title":"EctoGame"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_juegos_en_elixir/#drab","text":"# Crear una interfaz de usuario para un juego en l\u00ednea defmodule GameWeb do use Drab def index ( conn , _params ) do conn |> render ( \"index.html\" ) end # Actualizar la puntuaci\u00f3n del jugador en tiempo real def update_score ( conn , %{ \"player_id\" => player_id , \"score\" => score }) do Game . update_score ( player_id , score ) conn |> drab ( \" # score\" , :update , score ) end end","title":"Drab"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_juegos_en_elixir/#ejercicios-practicos","text":"Crea una base de datos utilizando EctoGame para almacenar nombres de jugadores y sus puntuaciones. Implementa una funci\u00f3n en Drab que actualice la puntuaci\u00f3n de un jugador en tiempo real. Crea una aplicaci\u00f3n de juego simple que utilice la base de datos y la interfaz de usuario creadas en los ejercicios anteriores.","title":"Ejercicios pr\u00e1cticos"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_juegos_en_elixir/#consejos-y-mejores-practicas","text":"Utiliza EctoGame para almacenar y recuperar informaci\u00f3n de juegos, como puntuaciones y progreso del jugador. Utiliza Drab para crear interfaces de usuario interactivas en tiempo real para juegos en l\u00ednea. Dise\u00f1a una arquitectura escalable para tu aplicaci\u00f3n de juego, teniendo en cuenta la posible expansi\u00f3n y actualizaci\u00f3n en el futuro. Realiza pruebas y depuraci\u00f3n frecuentemente durante el desarrollo de tu aplicaci\u00f3n de juego para asegurar su correcto funcionamiento.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_realidad_virtual_y_aumentada_en_elixir/","text":"Desarrollo de aplicaciones de realidad virtual y aumentada en Elixir \u00b6 En la actualidad, la industria de la tecnolog\u00eda est\u00e1 evolucionando r\u00e1pidamente y la realidad virtual (VR) y aumentada (AR) est\u00e1n ganando cada vez m\u00e1s popularidad. Estas tecnolog\u00edas permiten a los usuarios sumergirse en mundos virtuales o interactuar con elementos virtuales en el mundo real. En este m\u00f3dulo, aprender\u00e1s a desarrollar aplicaciones de realidad virtual y aumentada utilizando Elixir y frameworks como Luminus y PhoenixLiveView. Explicaci\u00f3n te\u00f3rica \u00b6 Elixir es un lenguaje de programaci\u00f3n funcional creado para construir aplicaciones escalables y de alta disponibilidad. Su sintaxis simple y concisa lo hace ideal para el desarrollo de aplicaciones de realidad virtual y aumentada. Adem\u00e1s, Elixir se ejecuta en la m\u00e1quina virtual de Erlang (BEAM), lo que le brinda una gran capacidad de procesamiento y tolerancia a fallos. Una de las ventajas de utilizar Elixir para el desarrollo de aplicaciones de realidad virtual y aumentada es su capacidad para manejar grandes cantidades de datos en tiempo real. Esto es esencial para crear experiencias inmersivas y fluidas para los usuarios. Adem\u00e1s, Elixir se integra f\u00e1cilmente con otros lenguajes y tecnolog\u00edas, lo que lo hace ideal para trabajar en conjunto con frameworks de realidad virtual y aumentada. Palabras clave y su definici\u00f3n \u00b6 Realidad virtual (VR): Tecnolog\u00eda que permite a los usuarios interactuar con un entorno totalmente generado por ordenador. Realidad aumentada (AR): Tecnolog\u00eda que superpone elementos virtuales en el mundo real. Elixir: Lenguaje de programaci\u00f3n funcional que se ejecuta en la m\u00e1quina virtual de Erlang (BEAM). Luminus: Framework de desarrollo web basado en Elixir y Clojure. PhoenixLiveView: Framework de Elixir para construir interfaces de usuario interactivas en tiempo real. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es Elixir y por qu\u00e9 es adecuado para el desarrollo de aplicaciones de realidad virtual y aumentada? \u00bfQu\u00e9 es la m\u00e1quina virtual de Erlang (BEAM) y c\u00f3mo beneficia a Elixir? \u00bfCu\u00e1les son las principales ventajas de utilizar Elixir para el desarrollo de aplicaciones de realidad virtual y aumentada? \u00bfQu\u00e9 son Luminus y PhoenixLiveView y c\u00f3mo se integran con Elixir? Ejemplos de c\u00f3digo en Elixir \u00b6 Creaci\u00f3n de una funci\u00f3n en Elixir para sumar dos n\u00fameros: defmodule Suma do def sumar ( a , b ) do a + b end end Suma . sumar ( 2 , 3 ) # resultado: 5 Creaci\u00f3n de una estructura de datos en Elixir para almacenar informaci\u00f3n de un objeto en realidad aumentada: defmodule Objeto do defstruct nombre : \"Sin nombre\" , posicion : { 0 , 0 , 0 }, rotacion : { 0 , 0 , 0 }, escala : { 1 , 1 , 1 } end objeto = % Objeto { nombre : \"Libro\" , posicion : { 5 , 2 , 0 }, rotacion : { 90 , 0 , 0 }, escala : { 0.5 , 0.5 , 0.5 }} Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una aplicaci\u00f3n de realidad virtual en Elixir que permita a los usuarios recorrer una casa virtual y ver los objetos en 3D en tiempo real. Utiliza PhoenixLiveView para desarrollar una aplicaci\u00f3n de realidad aumentada que muestre informaci\u00f3n sobre los monumentos hist\u00f3ricos mientras el usuario los visualiza a trav\u00e9s de la c\u00e1mara del tel\u00e9fono. Integra Luminus con un framework de realidad virtual para crear una experiencia de juego multijugador en l\u00ednea. Consejos o mejores pr\u00e1cticas \u00b6 Familiar\u00edzate con los conceptos de programaci\u00f3n funcional antes de comenzar a desarrollar aplicaciones de realidad virtual y aumentada en Elixir. Utiliza la documentaci\u00f3n oficial de Elixir y los frameworks de realidad virtual y aumentada para entender mejor su funcionamiento y aprovechar al m\u00e1ximo sus caracter\u00edsticas. Aseg\u00farate de optimizar el rendimiento de tu aplicaci\u00f3n para poder manejar grandes cantidades de datos en tiempo real. Mant\u00e9n tu c\u00f3digo limpio y modular para facilitar su mantenimiento y futuras actualizaciones.","title":"Desarrollo de aplicaciones de realidad virtual y aumentada en Elixir"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_realidad_virtual_y_aumentada_en_elixir/#desarrollo-de-aplicaciones-de-realidad-virtual-y-aumentada-en-elixir","text":"En la actualidad, la industria de la tecnolog\u00eda est\u00e1 evolucionando r\u00e1pidamente y la realidad virtual (VR) y aumentada (AR) est\u00e1n ganando cada vez m\u00e1s popularidad. Estas tecnolog\u00edas permiten a los usuarios sumergirse en mundos virtuales o interactuar con elementos virtuales en el mundo real. En este m\u00f3dulo, aprender\u00e1s a desarrollar aplicaciones de realidad virtual y aumentada utilizando Elixir y frameworks como Luminus y PhoenixLiveView.","title":"Desarrollo de aplicaciones de realidad virtual y aumentada en Elixir"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_realidad_virtual_y_aumentada_en_elixir/#explicacion-teorica","text":"Elixir es un lenguaje de programaci\u00f3n funcional creado para construir aplicaciones escalables y de alta disponibilidad. Su sintaxis simple y concisa lo hace ideal para el desarrollo de aplicaciones de realidad virtual y aumentada. Adem\u00e1s, Elixir se ejecuta en la m\u00e1quina virtual de Erlang (BEAM), lo que le brinda una gran capacidad de procesamiento y tolerancia a fallos. Una de las ventajas de utilizar Elixir para el desarrollo de aplicaciones de realidad virtual y aumentada es su capacidad para manejar grandes cantidades de datos en tiempo real. Esto es esencial para crear experiencias inmersivas y fluidas para los usuarios. Adem\u00e1s, Elixir se integra f\u00e1cilmente con otros lenguajes y tecnolog\u00edas, lo que lo hace ideal para trabajar en conjunto con frameworks de realidad virtual y aumentada.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_realidad_virtual_y_aumentada_en_elixir/#palabras-clave-y-su-definicion","text":"Realidad virtual (VR): Tecnolog\u00eda que permite a los usuarios interactuar con un entorno totalmente generado por ordenador. Realidad aumentada (AR): Tecnolog\u00eda que superpone elementos virtuales en el mundo real. Elixir: Lenguaje de programaci\u00f3n funcional que se ejecuta en la m\u00e1quina virtual de Erlang (BEAM). Luminus: Framework de desarrollo web basado en Elixir y Clojure. PhoenixLiveView: Framework de Elixir para construir interfaces de usuario interactivas en tiempo real.","title":"Palabras clave y su definici\u00f3n"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_realidad_virtual_y_aumentada_en_elixir/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Elixir y por qu\u00e9 es adecuado para el desarrollo de aplicaciones de realidad virtual y aumentada? \u00bfQu\u00e9 es la m\u00e1quina virtual de Erlang (BEAM) y c\u00f3mo beneficia a Elixir? \u00bfCu\u00e1les son las principales ventajas de utilizar Elixir para el desarrollo de aplicaciones de realidad virtual y aumentada? \u00bfQu\u00e9 son Luminus y PhoenixLiveView y c\u00f3mo se integran con Elixir?","title":"Preguntas de repaso"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_realidad_virtual_y_aumentada_en_elixir/#ejemplos-de-codigo-en-elixir","text":"Creaci\u00f3n de una funci\u00f3n en Elixir para sumar dos n\u00fameros: defmodule Suma do def sumar ( a , b ) do a + b end end Suma . sumar ( 2 , 3 ) # resultado: 5 Creaci\u00f3n de una estructura de datos en Elixir para almacenar informaci\u00f3n de un objeto en realidad aumentada: defmodule Objeto do defstruct nombre : \"Sin nombre\" , posicion : { 0 , 0 , 0 }, rotacion : { 0 , 0 , 0 }, escala : { 1 , 1 , 1 } end objeto = % Objeto { nombre : \"Libro\" , posicion : { 5 , 2 , 0 }, rotacion : { 90 , 0 , 0 }, escala : { 0.5 , 0.5 , 0.5 }}","title":"Ejemplos de c\u00f3digo en Elixir"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_realidad_virtual_y_aumentada_en_elixir/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una aplicaci\u00f3n de realidad virtual en Elixir que permita a los usuarios recorrer una casa virtual y ver los objetos en 3D en tiempo real. Utiliza PhoenixLiveView para desarrollar una aplicaci\u00f3n de realidad aumentada que muestre informaci\u00f3n sobre los monumentos hist\u00f3ricos mientras el usuario los visualiza a trav\u00e9s de la c\u00e1mara del tel\u00e9fono. Integra Luminus con un framework de realidad virtual para crear una experiencia de juego multijugador en l\u00ednea.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"elixir/sr/desarrollo_de_aplicaciones_de_realidad_virtual_y_aumentada_en_elixir/#consejos-o-mejores-practicas","text":"Familiar\u00edzate con los conceptos de programaci\u00f3n funcional antes de comenzar a desarrollar aplicaciones de realidad virtual y aumentada en Elixir. Utiliza la documentaci\u00f3n oficial de Elixir y los frameworks de realidad virtual y aumentada para entender mejor su funcionamiento y aprovechar al m\u00e1ximo sus caracter\u00edsticas. Aseg\u00farate de optimizar el rendimiento de tu aplicaci\u00f3n para poder manejar grandes cantidades de datos en tiempo real. Mant\u00e9n tu c\u00f3digo limpio y modular para facilitar su mantenimiento y futuras actualizaciones.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"elixir/sr/desarrollo_de_aplicaciones_moviles_en_elixir/","text":"Desarrollo de aplicaciones m\u00f3viles en Elixir \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 Elixir es un lenguaje de programaci\u00f3n funcional y din\u00e1mico que se ejecuta sobre la m\u00e1quina virtual de Erlang (BEAM). Esto significa que Elixir aprovecha la escalabilidad y la tolerancia a fallos de Erlang, y a su vez, proporciona una sintaxis m\u00e1s sencilla y elegante para los desarrolladores. Adem\u00e1s, Elixir cuenta con una comunidad activa y una amplia gama de bibliotecas y frameworks que lo hacen ideal para el desarrollo de aplicaciones m\u00f3viles. Una de las principales ventajas de utilizar Elixir para desarrollar aplicaciones m\u00f3viles es su capacidad para manejar una gran cantidad de peticiones concurrentes de manera eficiente. Esto es especialmente \u00fatil en el mundo m\u00f3vil, donde las aplicaciones deben manejar m\u00faltiples solicitudes de los usuarios al mismo tiempo. Adem\u00e1s, Elixir es conocido por su bajo tiempo de respuesta, lo que lo convierte en una excelente opci\u00f3n para aplicaciones m\u00f3viles que requieren una gran velocidad y rendimiento. Palabras clave y su definici\u00f3n \u00b6 Elixir: Lenguaje de programaci\u00f3n funcional y din\u00e1mico que se ejecuta sobre la m\u00e1quina virtual de Erlang (BEAM). Erlang: Lenguaje de programaci\u00f3n funcional y concurrente dise\u00f1ado para construir sistemas distribuidos y tolerantes a fallos. BEAM: M\u00e1quina virtual de Erlang, responsable de la ejecuci\u00f3n de c\u00f3digo. Phoenix: Framework web para Elixir que permite construir aplicaciones web y m\u00f3viles de manera r\u00e1pida y escalable. Flutter: Framework de Google para construir aplicaciones m\u00f3viles nativas y multiplataforma utilizando el lenguaje de programaci\u00f3n Dart. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es Elixir y qu\u00e9 ventajas ofrece para el desarrollo de aplicaciones m\u00f3viles? \u00bfEn qu\u00e9 m\u00e1quina virtual se ejecuta Elixir? \u00bfCu\u00e1l es la principal ventaja de utilizar Elixir para manejar solicitudes concurrentes? \u00bfQu\u00e9 es Phoenix y para qu\u00e9 se utiliza? \u00bfQu\u00e9 es Flutter y qu\u00e9 lenguaje de programaci\u00f3n utiliza? Ejemplos de c\u00f3digo en Elixir \u00b6 Hola mundo en Elixir \u00b6 IO . puts \"Hola mundo\" Funci\u00f3n que suma dos n\u00fameros en Elixir \u00b6 def suma ( a , b ) do a + b end Creaci\u00f3n de un m\u00f3dulo en Elixir \u00b6 defmodule Calculadora do def suma ( a , b ) do a + b end def resta ( a , b ) do a - b end def multiplicacion ( a , b ) do a * b end def division ( a , b ) do a / b end end Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una funci\u00f3n en Elixir que calcule el \u00e1rea de un c\u00edrculo dado su radio (puedes utilizar la constante pi = 3.14). Crea un m\u00f3dulo en Elixir que convierta una temperatura de grados Celsius a Fahrenheit y viceversa. Utiliza Phoenix para crear una aplicaci\u00f3n web que permita a los usuarios registrarse y iniciar sesi\u00f3n. Utiliza Flutter para crear una aplicaci\u00f3n m\u00f3vil que muestre una lista de tareas y permita agregar nuevas tareas y marcarlas como completadas. Crea una funci\u00f3n en Elixir que reciba una lista de n\u00fameros y devuelva la suma de los n\u00fameros pares. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza el patr\u00f3n de arquitectura MVC (Modelo-Vista-Controlador) al desarrollar aplicaciones web con Phoenix. Aprovecha los procesos concurrentes de Elixir para mejorar el rendimiento de tu aplicaci\u00f3n m\u00f3vil. Utiliza el protocolo GraphQL para crear una API eficiente y escalable en Elixir. Utiliza OTP (Open Telecom Platform) para construir sistemas distribuidos y tolerantes a fallos en Elixir. Sigue las convenciones de nomenclatura y estructura de c\u00f3digo de la comunidad de Elixir para mejorar la legibilidad y mantenibilidad de tu c\u00f3digo. Navegaci\u00f3n de lecciones \u00b6 <- Lecci\u00f3n anterior : Desarrollo de aplicaciones de IA en Elixir Siguiente lecci\u00f3n -> : Sistemas de mensajer\u00eda","title":"Desarrollo de aplicaciones m\u00f3viles en Elixir"},{"location":"elixir/sr/desarrollo_de_aplicaciones_moviles_en_elixir/#desarrollo-de-aplicaciones-moviles-en-elixir","text":"","title":"Desarrollo de aplicaciones m\u00f3viles en Elixir"},{"location":"elixir/sr/desarrollo_de_aplicaciones_moviles_en_elixir/#explicacion-teorica","text":"Elixir es un lenguaje de programaci\u00f3n funcional y din\u00e1mico que se ejecuta sobre la m\u00e1quina virtual de Erlang (BEAM). Esto significa que Elixir aprovecha la escalabilidad y la tolerancia a fallos de Erlang, y a su vez, proporciona una sintaxis m\u00e1s sencilla y elegante para los desarrolladores. Adem\u00e1s, Elixir cuenta con una comunidad activa y una amplia gama de bibliotecas y frameworks que lo hacen ideal para el desarrollo de aplicaciones m\u00f3viles. Una de las principales ventajas de utilizar Elixir para desarrollar aplicaciones m\u00f3viles es su capacidad para manejar una gran cantidad de peticiones concurrentes de manera eficiente. Esto es especialmente \u00fatil en el mundo m\u00f3vil, donde las aplicaciones deben manejar m\u00faltiples solicitudes de los usuarios al mismo tiempo. Adem\u00e1s, Elixir es conocido por su bajo tiempo de respuesta, lo que lo convierte en una excelente opci\u00f3n para aplicaciones m\u00f3viles que requieren una gran velocidad y rendimiento.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"elixir/sr/desarrollo_de_aplicaciones_moviles_en_elixir/#palabras-clave-y-su-definicion","text":"Elixir: Lenguaje de programaci\u00f3n funcional y din\u00e1mico que se ejecuta sobre la m\u00e1quina virtual de Erlang (BEAM). Erlang: Lenguaje de programaci\u00f3n funcional y concurrente dise\u00f1ado para construir sistemas distribuidos y tolerantes a fallos. BEAM: M\u00e1quina virtual de Erlang, responsable de la ejecuci\u00f3n de c\u00f3digo. Phoenix: Framework web para Elixir que permite construir aplicaciones web y m\u00f3viles de manera r\u00e1pida y escalable. Flutter: Framework de Google para construir aplicaciones m\u00f3viles nativas y multiplataforma utilizando el lenguaje de programaci\u00f3n Dart.","title":"Palabras clave y su definici\u00f3n"},{"location":"elixir/sr/desarrollo_de_aplicaciones_moviles_en_elixir/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Elixir y qu\u00e9 ventajas ofrece para el desarrollo de aplicaciones m\u00f3viles? \u00bfEn qu\u00e9 m\u00e1quina virtual se ejecuta Elixir? \u00bfCu\u00e1l es la principal ventaja de utilizar Elixir para manejar solicitudes concurrentes? \u00bfQu\u00e9 es Phoenix y para qu\u00e9 se utiliza? \u00bfQu\u00e9 es Flutter y qu\u00e9 lenguaje de programaci\u00f3n utiliza?","title":"Preguntas de repaso"},{"location":"elixir/sr/desarrollo_de_aplicaciones_moviles_en_elixir/#ejemplos-de-codigo-en-elixir","text":"","title":"Ejemplos de c\u00f3digo en Elixir"},{"location":"elixir/sr/desarrollo_de_aplicaciones_moviles_en_elixir/#hola-mundo-en-elixir","text":"IO . puts \"Hola mundo\"","title":"Hola mundo en Elixir"},{"location":"elixir/sr/desarrollo_de_aplicaciones_moviles_en_elixir/#funcion-que-suma-dos-numeros-en-elixir","text":"def suma ( a , b ) do a + b end","title":"Funci\u00f3n que suma dos n\u00fameros en Elixir"},{"location":"elixir/sr/desarrollo_de_aplicaciones_moviles_en_elixir/#creacion-de-un-modulo-en-elixir","text":"defmodule Calculadora do def suma ( a , b ) do a + b end def resta ( a , b ) do a - b end def multiplicacion ( a , b ) do a * b end def division ( a , b ) do a / b end end","title":"Creaci\u00f3n de un m\u00f3dulo en Elixir"},{"location":"elixir/sr/desarrollo_de_aplicaciones_moviles_en_elixir/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una funci\u00f3n en Elixir que calcule el \u00e1rea de un c\u00edrculo dado su radio (puedes utilizar la constante pi = 3.14). Crea un m\u00f3dulo en Elixir que convierta una temperatura de grados Celsius a Fahrenheit y viceversa. Utiliza Phoenix para crear una aplicaci\u00f3n web que permita a los usuarios registrarse y iniciar sesi\u00f3n. Utiliza Flutter para crear una aplicaci\u00f3n m\u00f3vil que muestre una lista de tareas y permita agregar nuevas tareas y marcarlas como completadas. Crea una funci\u00f3n en Elixir que reciba una lista de n\u00fameros y devuelva la suma de los n\u00fameros pares.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"elixir/sr/desarrollo_de_aplicaciones_moviles_en_elixir/#consejos-o-mejores-practicas","text":"Utiliza el patr\u00f3n de arquitectura MVC (Modelo-Vista-Controlador) al desarrollar aplicaciones web con Phoenix. Aprovecha los procesos concurrentes de Elixir para mejorar el rendimiento de tu aplicaci\u00f3n m\u00f3vil. Utiliza el protocolo GraphQL para crear una API eficiente y escalable en Elixir. Utiliza OTP (Open Telecom Platform) para construir sistemas distribuidos y tolerantes a fallos en Elixir. Sigue las convenciones de nomenclatura y estructura de c\u00f3digo de la comunidad de Elixir para mejorar la legibilidad y mantenibilidad de tu c\u00f3digo.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"elixir/sr/desarrollo_de_aplicaciones_moviles_en_elixir/#navegacion-de-lecciones","text":"<- Lecci\u00f3n anterior : Desarrollo de aplicaciones de IA en Elixir Siguiente lecci\u00f3n -> : Sistemas de mensajer\u00eda","title":"Navegaci\u00f3n de lecciones"},{"location":"elixir/sr/implementacion_de_sistemas_de_mensajeria/","text":"Implementaci\u00f3n de sistemas de mensajer\u00eda \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En este m\u00f3dulo exploraremos la implementaci\u00f3n de sistemas de mensajer\u00eda en aplicaciones Elixir utilizando herramientas como RabbitMQ y Kafka. Aprenderemos qu\u00e9 son los sistemas de mensajer\u00eda, c\u00f3mo funcionan y c\u00f3mo pueden ser utilizados para mejorar la comunicaci\u00f3n entre los componentes de una aplicaci\u00f3n. Explicaci\u00f3n te\u00f3rica \u00b6 Un sistema de mensajer\u00eda es una herramienta que permite la comunicaci\u00f3n asincr\u00f3nica entre diferentes componentes de una aplicaci\u00f3n. Esto significa que los componentes pueden enviar y recibir mensajes en cualquier momento, sin tener que esperar por una respuesta inmediata. Este enfoque de comunicaci\u00f3n es muy \u00fatil en aplicaciones distribuidas y escalables, ya que permite una mayor flexibilidad y tolerancia a fallos. Los sistemas de mensajer\u00eda suelen estar compuestos por tres partes: productores, colas y consumidores. Los productores son los encargados de enviar mensajes a una cola, que es un lugar de almacenamiento temporal de los mensajes. Los consumidores, por otro lado, son los encargados de recibir y procesar los mensajes de la cola. En Elixir, podemos utilizar diferentes herramientas para implementar sistemas de mensajer\u00eda, como RabbitMQ y Kafka. Estas herramientas ofrecen funcionalidades avanzadas como encolamiento, enrutamiento y persistencia de mensajes, lo que las hace ideales para aplicaciones de alta disponibilidad y rendimiento. Palabras clave y su definici\u00f3n \u00b6 Sistemas de mensajer\u00eda: herramientas que permiten la comunicaci\u00f3n asincr\u00f3nica entre diferentes componentes de una aplicaci\u00f3n. Productores: componentes encargados de enviar mensajes a una cola. Colas: lugar de almacenamiento temporal de los mensajes. Consumidores: componentes encargados de recibir y procesar los mensajes de la cola. RabbitMQ: herramienta de mensajer\u00eda que implementa el protocolo AMQP (Advanced Message Queuing Protocol). Kafka: plataforma de mensajer\u00eda distribuida que utiliza un modelo de publicaci\u00f3n/suscripci\u00f3n para el env\u00edo de mensajes. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es un sistema de mensajer\u00eda y para qu\u00e9 se utiliza? \u00bfCu\u00e1les son las partes principales de un sistema de mensajer\u00eda? \u00bfQu\u00e9 herramientas podemos utilizar para implementar sistemas de mensajer\u00eda en Elixir? \u00bfQu\u00e9 funcionalidades ofrecen RabbitMQ y Kafka? \u00bfQu\u00e9 protocolo implementa RabbitMQ? Ejemplos de c\u00f3digo en Elixir \u00b6 Productor \u00b6 # Conexi\u00f3n a RabbitMQ { :ok , connection } = Amqp.Connection . open # Creaci\u00f3n de un canal { :ok , channel } = Amqp.Channel . open ( connection ) # Declaraci\u00f3n de la cola Amqp.Queue . declare ( channel , \"mi_cola\" ) # Publicaci\u00f3n de un mensaje Amqp.Basic . publish ( channel , \"\" , \"mi_cola\" , \"Mensaje de prueba\" ) # Cierre de la conexi\u00f3n y el canal Amqp.Channel . close ( channel ) Amqp.Connection . close ( connection ) Consumidor \u00b6 # Conexi\u00f3n a RabbitMQ { :ok , connection } = Amqp.Connection . open # Creaci\u00f3n de un canal { :ok , channel } = Amqp.Channel . open ( connection ) # Declaraci\u00f3n de la cola Amqp.Queue . declare ( channel , \"mi_cola\" ) # Suscripci\u00f3n a la cola Amqp.Basic . consume ( channel , \"mi_cola\" ) # Recepci\u00f3n y procesamiento de mensajes receive do { :basic_deliver , payload , _meta } -> IO . puts \"Mensaje recibido: #{ payload } \" { :basic_cancel , _meta } -> IO . puts \"Se ha cancelado la suscripci\u00f3n a la cola\" end # Cierre de la conexi\u00f3n y el canal Amqp.Channel . close ( channel ) Amqp.Connection . close ( connection ) Ejercicios pr\u00e1cticos \u00b6 Implementar un sistema de mensajer\u00eda utilizando RabbitMQ en una aplicaci\u00f3n Elixir. Crear un productor que env\u00ede mensajes a una cola y un consumidor que los reciba y los imprima por pantalla. Utilizar Kafka para implementar un sistema de mensajer\u00eda distribuida en una aplicaci\u00f3n Elixir. Consejos o mejores pr\u00e1cticas \u00b6 Utilizar sistemas de mensajer\u00eda en aplicaciones distribuidas y escalables para mejorar la comunicaci\u00f3n entre los componentes. Dise\u00f1ar una arquitectura de mensajer\u00eda s\u00f3lida y escalable desde el principio. Utilizar herramientas como RabbitMQ y Kafka para aprovechar sus funcionalidades avanzadas. Implementar mecanismos de manejo de errores y reintentos en caso de fallos en la comunicaci\u00f3n. Realizar pruebas exhaustivas para garantizar una comunicaci\u00f3n fluida y sin errores entre los componentes. Navegaci\u00f3n de lecciones \u00b6 <- Lecci\u00f3n anterior : Desarrollo de aplicaciones m\u00f3viles en Elixir Siguiente lecci\u00f3n -> : Seguridad avanzada en aplicaciones Elixir","title":"Implementaci\u00f3n de sistemas de mensajer\u00eda"},{"location":"elixir/sr/implementacion_de_sistemas_de_mensajeria/#implementacion-de-sistemas-de-mensajeria","text":"","title":"Implementaci\u00f3n de sistemas de mensajer\u00eda"},{"location":"elixir/sr/implementacion_de_sistemas_de_mensajeria/#descripcion-del-modulo","text":"En este m\u00f3dulo exploraremos la implementaci\u00f3n de sistemas de mensajer\u00eda en aplicaciones Elixir utilizando herramientas como RabbitMQ y Kafka. Aprenderemos qu\u00e9 son los sistemas de mensajer\u00eda, c\u00f3mo funcionan y c\u00f3mo pueden ser utilizados para mejorar la comunicaci\u00f3n entre los componentes de una aplicaci\u00f3n.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"elixir/sr/implementacion_de_sistemas_de_mensajeria/#explicacion-teorica","text":"Un sistema de mensajer\u00eda es una herramienta que permite la comunicaci\u00f3n asincr\u00f3nica entre diferentes componentes de una aplicaci\u00f3n. Esto significa que los componentes pueden enviar y recibir mensajes en cualquier momento, sin tener que esperar por una respuesta inmediata. Este enfoque de comunicaci\u00f3n es muy \u00fatil en aplicaciones distribuidas y escalables, ya que permite una mayor flexibilidad y tolerancia a fallos. Los sistemas de mensajer\u00eda suelen estar compuestos por tres partes: productores, colas y consumidores. Los productores son los encargados de enviar mensajes a una cola, que es un lugar de almacenamiento temporal de los mensajes. Los consumidores, por otro lado, son los encargados de recibir y procesar los mensajes de la cola. En Elixir, podemos utilizar diferentes herramientas para implementar sistemas de mensajer\u00eda, como RabbitMQ y Kafka. Estas herramientas ofrecen funcionalidades avanzadas como encolamiento, enrutamiento y persistencia de mensajes, lo que las hace ideales para aplicaciones de alta disponibilidad y rendimiento.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"elixir/sr/implementacion_de_sistemas_de_mensajeria/#palabras-clave-y-su-definicion","text":"Sistemas de mensajer\u00eda: herramientas que permiten la comunicaci\u00f3n asincr\u00f3nica entre diferentes componentes de una aplicaci\u00f3n. Productores: componentes encargados de enviar mensajes a una cola. Colas: lugar de almacenamiento temporal de los mensajes. Consumidores: componentes encargados de recibir y procesar los mensajes de la cola. RabbitMQ: herramienta de mensajer\u00eda que implementa el protocolo AMQP (Advanced Message Queuing Protocol). Kafka: plataforma de mensajer\u00eda distribuida que utiliza un modelo de publicaci\u00f3n/suscripci\u00f3n para el env\u00edo de mensajes.","title":"Palabras clave y su definici\u00f3n"},{"location":"elixir/sr/implementacion_de_sistemas_de_mensajeria/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es un sistema de mensajer\u00eda y para qu\u00e9 se utiliza? \u00bfCu\u00e1les son las partes principales de un sistema de mensajer\u00eda? \u00bfQu\u00e9 herramientas podemos utilizar para implementar sistemas de mensajer\u00eda en Elixir? \u00bfQu\u00e9 funcionalidades ofrecen RabbitMQ y Kafka? \u00bfQu\u00e9 protocolo implementa RabbitMQ?","title":"Preguntas de repaso"},{"location":"elixir/sr/implementacion_de_sistemas_de_mensajeria/#ejemplos-de-codigo-en-elixir","text":"","title":"Ejemplos de c\u00f3digo en Elixir"},{"location":"elixir/sr/implementacion_de_sistemas_de_mensajeria/#productor","text":"# Conexi\u00f3n a RabbitMQ { :ok , connection } = Amqp.Connection . open # Creaci\u00f3n de un canal { :ok , channel } = Amqp.Channel . open ( connection ) # Declaraci\u00f3n de la cola Amqp.Queue . declare ( channel , \"mi_cola\" ) # Publicaci\u00f3n de un mensaje Amqp.Basic . publish ( channel , \"\" , \"mi_cola\" , \"Mensaje de prueba\" ) # Cierre de la conexi\u00f3n y el canal Amqp.Channel . close ( channel ) Amqp.Connection . close ( connection )","title":"Productor"},{"location":"elixir/sr/implementacion_de_sistemas_de_mensajeria/#consumidor","text":"# Conexi\u00f3n a RabbitMQ { :ok , connection } = Amqp.Connection . open # Creaci\u00f3n de un canal { :ok , channel } = Amqp.Channel . open ( connection ) # Declaraci\u00f3n de la cola Amqp.Queue . declare ( channel , \"mi_cola\" ) # Suscripci\u00f3n a la cola Amqp.Basic . consume ( channel , \"mi_cola\" ) # Recepci\u00f3n y procesamiento de mensajes receive do { :basic_deliver , payload , _meta } -> IO . puts \"Mensaje recibido: #{ payload } \" { :basic_cancel , _meta } -> IO . puts \"Se ha cancelado la suscripci\u00f3n a la cola\" end # Cierre de la conexi\u00f3n y el canal Amqp.Channel . close ( channel ) Amqp.Connection . close ( connection )","title":"Consumidor"},{"location":"elixir/sr/implementacion_de_sistemas_de_mensajeria/#ejercicios-practicos","text":"Implementar un sistema de mensajer\u00eda utilizando RabbitMQ en una aplicaci\u00f3n Elixir. Crear un productor que env\u00ede mensajes a una cola y un consumidor que los reciba y los imprima por pantalla. Utilizar Kafka para implementar un sistema de mensajer\u00eda distribuida en una aplicaci\u00f3n Elixir.","title":"Ejercicios pr\u00e1cticos"},{"location":"elixir/sr/implementacion_de_sistemas_de_mensajeria/#consejos-o-mejores-practicas","text":"Utilizar sistemas de mensajer\u00eda en aplicaciones distribuidas y escalables para mejorar la comunicaci\u00f3n entre los componentes. Dise\u00f1ar una arquitectura de mensajer\u00eda s\u00f3lida y escalable desde el principio. Utilizar herramientas como RabbitMQ y Kafka para aprovechar sus funcionalidades avanzadas. Implementar mecanismos de manejo de errores y reintentos en caso de fallos en la comunicaci\u00f3n. Realizar pruebas exhaustivas para garantizar una comunicaci\u00f3n fluida y sin errores entre los componentes.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"elixir/sr/implementacion_de_sistemas_de_mensajeria/#navegacion-de-lecciones","text":"<- Lecci\u00f3n anterior : Desarrollo de aplicaciones m\u00f3viles en Elixir Siguiente lecci\u00f3n -> : Seguridad avanzada en aplicaciones Elixir","title":"Navegaci\u00f3n de lecciones"},{"location":"elixir/sr/optimizacion_de_aplicaciones_de_alto_rendimiento/","text":"Optimizaci\u00f3n de aplicaciones de alto rendimiento \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 Este m\u00f3dulo est\u00e1 dise\u00f1ado para aquellos que deseen profundizar sus conocimientos sobre c\u00f3mo optimizar aplicaciones desarrolladas en Elixir para alcanzar un alto rendimiento en entornos de gran tr\u00e1fico y grandes cargas de datos. Durante esta lecci\u00f3n, aprenderemos t\u00e9cnicas avanzadas para mejorar el rendimiento de nuestras aplicaciones y hacerlas m\u00e1s eficientes en t\u00e9rminos de tiempo de respuesta y consumo de recursos. Explicaci\u00f3n te\u00f3rica \u00b6 La optimizaci\u00f3n de aplicaciones de alto rendimiento es un proceso que busca mejorar el rendimiento de una aplicaci\u00f3n en t\u00e9rminos de velocidad, escalabilidad y eficiencia. En entornos de alto tr\u00e1fico y grandes cargas de datos, es esencial que nuestras aplicaciones puedan manejar grandes cantidades de solicitudes y procesarlas de manera eficiente para garantizar una buena experiencia de usuario. En Elixir, podemos mejorar el rendimiento de nuestras aplicaciones utilizando t\u00e9cnicas como la concurrencia, la paralelizaci\u00f3n y la optimizaci\u00f3n de consultas a bases de datos. Tambi\u00e9n es importante tener en cuenta el dise\u00f1o de nuestra arquitectura y la elecci\u00f3n de herramientas y frameworks adecuados para nuestro proyecto. Palabras clave y su definici\u00f3n \u00b6 Rendimiento: la capacidad de una aplicaci\u00f3n para responder r\u00e1pidamente a las solicitudes y manejar grandes cargas de datos. Concurrency (concurrencia): la capacidad de una aplicaci\u00f3n para realizar m\u00faltiples tareas al mismo tiempo. Parallelization (paralelizaci\u00f3n): la t\u00e9cnica de dividir una tarea en sub-tareas y ejecutarlas simult\u00e1neamente en diferentes hilos o procesos. Scalability (escalabilidad): la capacidad de una aplicaci\u00f3n para manejar un aumento en la cantidad de solicitudes sin degradar su rendimiento. Database optimization (optimizaci\u00f3n de bases de datos): t\u00e9cnicas para mejorar la eficiencia y el rendimiento de las consultas a bases de datos. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la optimizaci\u00f3n de aplicaciones de alto rendimiento? \u00bfPor qu\u00e9 es importante optimizar nuestras aplicaciones en entornos de alto tr\u00e1fico y grandes cargas de datos? \u00bfCu\u00e1les son algunas t\u00e9cnicas que podemos utilizar para mejorar el rendimiento de nuestras aplicaciones en Elixir? \u00bfQu\u00e9 significa concurrency (concurrencia) y c\u00f3mo puede ayudar a mejorar el rendimiento de una aplicaci\u00f3n? \u00bfCu\u00e1l es la diferencia entre concurrency y parallelization (paralelizaci\u00f3n)? Ejemplos de c\u00f3digo en Elixir \u00b6 Concurrencia \u00b6 En Elixir, podemos lograr concurrencia utilizando procesos. Cada proceso tiene su propio espacio de memoria y se comunica con otros procesos a trav\u00e9s de mensajes. A continuaci\u00f3n, se muestra un ejemplo de c\u00f3mo crear un proceso y enviar un mensaje: defmodule Ejemplo do def iniciar_proceso do proceso = spawn ( fn -> IO . puts \"Soy un proceso\" end ) send ( proceso , \"Hola desde el proceso\" ) end end Paralelizaci\u00f3n \u00b6 La paralelizaci\u00f3n en Elixir se logra utilizando la librer\u00eda Task. Esta nos permite ejecutar tareas en diferentes hilos o procesos. A continuaci\u00f3n, se muestra un ejemplo de c\u00f3mo utilizar Task para ejecutar una tarea en paralelo: defmodule Ejemplo do defparalelizar do tareas = [ Task . async ( fn -> IO . puts \"Tarea 1\" end ), Task . async ( fn -> IO . puts \"Tarea 2\" end ) ] Task . await_many ( tareas ) end end Optimizaci\u00f3n de bases de datos \u00b6 En Elixir, podemos utilizar la librer\u00eda Ecto para optimizar nuestras consultas a bases de datos. Esta nos permite utilizar t\u00e9cnicas como carga ansiosa y consultas prefabricadas para mejorar el rendimiento. A continuaci\u00f3n, se muestra un ejemplo de c\u00f3mo utilizar Ecto para cargar ansiosamente los datos de una relaci\u00f3n: alias MyApp.Repo alias MyApp.Post posts = Repo . all ( Post ) |> Repo . preload ( :comments ) Ejercicios pr\u00e1cticos \u00b6 Crea una aplicaci\u00f3n en Elixir que utilice concurrencia para realizar m\u00faltiples tareas al mismo tiempo. Utiliza la librer\u00eda Task para ejecutar una tarea en paralelo. Implementa consultas prefabricadas en una aplicaci\u00f3n Elixir utilizando la librer\u00eda Ecto. Consejos o mejores pr\u00e1cticas \u00b6 Dise\u00f1a tu arquitectura teniendo en cuenta la escalabilidad y el rendimiento. Utiliza herramientas y frameworks adecuados para tu proyecto. Realiza pruebas de rendimiento y optimizaci\u00f3n de forma regular. Utiliza t\u00e9cnicas de concurrencia y paralelizaci\u00f3n en tus aplicaciones. Optimiza tus consultas a bases de datos utilizando herramientas como Ecto. Identifica y resuelve cuellos de botella en tu c\u00f3digo. Navegaci\u00f3n de lecciones \u00b6 <- Lecci\u00f3n anterior : Arquitectura de sistemas Elixir Siguiente lecci\u00f3n -> : Desarrollo de aplicaciones de blockchain en Elixir","title":"Optimizaci\u00f3n de aplicaciones de alto rendimiento"},{"location":"elixir/sr/optimizacion_de_aplicaciones_de_alto_rendimiento/#optimizacion-de-aplicaciones-de-alto-rendimiento","text":"","title":"Optimizaci\u00f3n de aplicaciones de alto rendimiento"},{"location":"elixir/sr/optimizacion_de_aplicaciones_de_alto_rendimiento/#descripcion-del-modulo","text":"Este m\u00f3dulo est\u00e1 dise\u00f1ado para aquellos que deseen profundizar sus conocimientos sobre c\u00f3mo optimizar aplicaciones desarrolladas en Elixir para alcanzar un alto rendimiento en entornos de gran tr\u00e1fico y grandes cargas de datos. Durante esta lecci\u00f3n, aprenderemos t\u00e9cnicas avanzadas para mejorar el rendimiento de nuestras aplicaciones y hacerlas m\u00e1s eficientes en t\u00e9rminos de tiempo de respuesta y consumo de recursos.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"elixir/sr/optimizacion_de_aplicaciones_de_alto_rendimiento/#explicacion-teorica","text":"La optimizaci\u00f3n de aplicaciones de alto rendimiento es un proceso que busca mejorar el rendimiento de una aplicaci\u00f3n en t\u00e9rminos de velocidad, escalabilidad y eficiencia. En entornos de alto tr\u00e1fico y grandes cargas de datos, es esencial que nuestras aplicaciones puedan manejar grandes cantidades de solicitudes y procesarlas de manera eficiente para garantizar una buena experiencia de usuario. En Elixir, podemos mejorar el rendimiento de nuestras aplicaciones utilizando t\u00e9cnicas como la concurrencia, la paralelizaci\u00f3n y la optimizaci\u00f3n de consultas a bases de datos. Tambi\u00e9n es importante tener en cuenta el dise\u00f1o de nuestra arquitectura y la elecci\u00f3n de herramientas y frameworks adecuados para nuestro proyecto.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"elixir/sr/optimizacion_de_aplicaciones_de_alto_rendimiento/#palabras-clave-y-su-definicion","text":"Rendimiento: la capacidad de una aplicaci\u00f3n para responder r\u00e1pidamente a las solicitudes y manejar grandes cargas de datos. Concurrency (concurrencia): la capacidad de una aplicaci\u00f3n para realizar m\u00faltiples tareas al mismo tiempo. Parallelization (paralelizaci\u00f3n): la t\u00e9cnica de dividir una tarea en sub-tareas y ejecutarlas simult\u00e1neamente en diferentes hilos o procesos. Scalability (escalabilidad): la capacidad de una aplicaci\u00f3n para manejar un aumento en la cantidad de solicitudes sin degradar su rendimiento. Database optimization (optimizaci\u00f3n de bases de datos): t\u00e9cnicas para mejorar la eficiencia y el rendimiento de las consultas a bases de datos.","title":"Palabras clave y su definici\u00f3n"},{"location":"elixir/sr/optimizacion_de_aplicaciones_de_alto_rendimiento/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la optimizaci\u00f3n de aplicaciones de alto rendimiento? \u00bfPor qu\u00e9 es importante optimizar nuestras aplicaciones en entornos de alto tr\u00e1fico y grandes cargas de datos? \u00bfCu\u00e1les son algunas t\u00e9cnicas que podemos utilizar para mejorar el rendimiento de nuestras aplicaciones en Elixir? \u00bfQu\u00e9 significa concurrency (concurrencia) y c\u00f3mo puede ayudar a mejorar el rendimiento de una aplicaci\u00f3n? \u00bfCu\u00e1l es la diferencia entre concurrency y parallelization (paralelizaci\u00f3n)?","title":"Preguntas de repaso"},{"location":"elixir/sr/optimizacion_de_aplicaciones_de_alto_rendimiento/#ejemplos-de-codigo-en-elixir","text":"","title":"Ejemplos de c\u00f3digo en Elixir"},{"location":"elixir/sr/optimizacion_de_aplicaciones_de_alto_rendimiento/#concurrencia","text":"En Elixir, podemos lograr concurrencia utilizando procesos. Cada proceso tiene su propio espacio de memoria y se comunica con otros procesos a trav\u00e9s de mensajes. A continuaci\u00f3n, se muestra un ejemplo de c\u00f3mo crear un proceso y enviar un mensaje: defmodule Ejemplo do def iniciar_proceso do proceso = spawn ( fn -> IO . puts \"Soy un proceso\" end ) send ( proceso , \"Hola desde el proceso\" ) end end","title":"Concurrencia"},{"location":"elixir/sr/optimizacion_de_aplicaciones_de_alto_rendimiento/#paralelizacion","text":"La paralelizaci\u00f3n en Elixir se logra utilizando la librer\u00eda Task. Esta nos permite ejecutar tareas en diferentes hilos o procesos. A continuaci\u00f3n, se muestra un ejemplo de c\u00f3mo utilizar Task para ejecutar una tarea en paralelo: defmodule Ejemplo do defparalelizar do tareas = [ Task . async ( fn -> IO . puts \"Tarea 1\" end ), Task . async ( fn -> IO . puts \"Tarea 2\" end ) ] Task . await_many ( tareas ) end end","title":"Paralelizaci\u00f3n"},{"location":"elixir/sr/optimizacion_de_aplicaciones_de_alto_rendimiento/#optimizacion-de-bases-de-datos","text":"En Elixir, podemos utilizar la librer\u00eda Ecto para optimizar nuestras consultas a bases de datos. Esta nos permite utilizar t\u00e9cnicas como carga ansiosa y consultas prefabricadas para mejorar el rendimiento. A continuaci\u00f3n, se muestra un ejemplo de c\u00f3mo utilizar Ecto para cargar ansiosamente los datos de una relaci\u00f3n: alias MyApp.Repo alias MyApp.Post posts = Repo . all ( Post ) |> Repo . preload ( :comments )","title":"Optimizaci\u00f3n de bases de datos"},{"location":"elixir/sr/optimizacion_de_aplicaciones_de_alto_rendimiento/#ejercicios-practicos","text":"Crea una aplicaci\u00f3n en Elixir que utilice concurrencia para realizar m\u00faltiples tareas al mismo tiempo. Utiliza la librer\u00eda Task para ejecutar una tarea en paralelo. Implementa consultas prefabricadas en una aplicaci\u00f3n Elixir utilizando la librer\u00eda Ecto.","title":"Ejercicios pr\u00e1cticos"},{"location":"elixir/sr/optimizacion_de_aplicaciones_de_alto_rendimiento/#consejos-o-mejores-practicas","text":"Dise\u00f1a tu arquitectura teniendo en cuenta la escalabilidad y el rendimiento. Utiliza herramientas y frameworks adecuados para tu proyecto. Realiza pruebas de rendimiento y optimizaci\u00f3n de forma regular. Utiliza t\u00e9cnicas de concurrencia y paralelizaci\u00f3n en tus aplicaciones. Optimiza tus consultas a bases de datos utilizando herramientas como Ecto. Identifica y resuelve cuellos de botella en tu c\u00f3digo.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"elixir/sr/optimizacion_de_aplicaciones_de_alto_rendimiento/#navegacion-de-lecciones","text":"<- Lecci\u00f3n anterior : Arquitectura de sistemas Elixir Siguiente lecci\u00f3n -> : Desarrollo de aplicaciones de blockchain en Elixir","title":"Navegaci\u00f3n de lecciones"},{"location":"elixir/sr/profundizacion_en_erlang/","text":"Profundizaci\u00f3n en Erlang \u00b6 En esta lecci\u00f3n, profundizaremos en el lenguaje de programaci\u00f3n Erlang y su relaci\u00f3n con Elixir. Conocer en detalle Erlang es fundamental para comprender plenamente Elixir, ya que este \u00faltimo se basa en gran medida en el primero. Explicaci\u00f3n te\u00f3rica \u00b6 Erlang es un lenguaje de programaci\u00f3n funcional y concurrente, desarrollado en la d\u00e9cada de 1980 por Ericsson para ser utilizado en sus sistemas de telecomunicaciones. Una de las caracter\u00edsticas principales de Erlang es su capacidad para manejar procesos concurrentes de forma eficiente y segura, lo que lo hace ideal para aplicaciones en tiempo real y distribuidas. Elixir, por otro lado, es un lenguaje de programaci\u00f3n funcional que se ejecuta en la m\u00e1quina virtual de Erlang (BEAM). Esto significa que el c\u00f3digo escrito en Elixir se compila a bytecode y se ejecuta en la misma m\u00e1quina virtual que los programas escritos en Erlang. Elixir aprovecha las caracter\u00edsticas de concurrencia y tolerancia a fallos de Erlang y las hace accesibles a los desarrolladores a trav\u00e9s de una sintaxis m\u00e1s amigable y moderna. Palabras clave y su definici\u00f3n \u00b6 Funci\u00f3n: Un bloque de c\u00f3digo que realiza una tarea espec\u00edfica y devuelve un valor. Patr\u00f3n: Una expresi\u00f3n utilizada para hacer coincidir valores y estructuras de datos. T\u00e9rmino: Cualquier valor en el lenguaje Erlang, incluyendo \u00e1tomos, enteros, flotantes, strings, listas y tuplas. Proceso: Una unidad de ejecuci\u00f3n concurrente en Erlang que se comunica con otros procesos a trav\u00e9s de mensajes. M\u00f3dulo: Una colecci\u00f3n de funciones y datos relacionados en Erlang. OTP (Open Telecom Platform): Una colecci\u00f3n de librer\u00edas y herramientas utilizadas para construir aplicaciones robustas y escalables en Erlang. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es Erlang y cu\u00e1l es su relaci\u00f3n con Elixir? \u00bfQu\u00e9 caracter\u00edstica principal de Erlang lo hace ideal para aplicaciones en tiempo real y distribuidas? \u00bfEn qu\u00e9 m\u00e1quina virtual se ejecuta el c\u00f3digo escrito en Elixir? \u00bfQu\u00e9 es un patr\u00f3n en Erlang? \u00bfQu\u00e9 es OTP y para qu\u00e9 se utiliza en Erlang? Ejemplos de c\u00f3digo en Elixir \u00b6 # Ejemplo de una funci\u00f3n en Elixir defmodule Calculator do def add ( a , b ) do a + b end end # Ejemplo de un patr\u00f3n en Erlang { ok , result } = Calculator . add ( 2 , 3 ) # Ejemplo de un proceso en Erlang spawn ( fn -> IO . puts ( \"Hello from a process!\" ) end ) Ejercicios pr\u00e1cticos \u00b6 Crea una funci\u00f3n en Elixir que calcule el \u00e1rea de un c\u00edrculo dado su radio. Utiliza un patr\u00f3n en Erlang para hacer coincidir una lista con los primeros tres elementos iguales. Crea un proceso en Erlang que imprima \"I'm alive!\" cada 3 segundos. Consejos o mejores pr\u00e1cticas \u00b6 Estudia la sintaxis y caracter\u00edsticas de Erlang para poder aprovechar al m\u00e1ximo las capacidades de Elixir. Utiliza patrones y funciones de forma eficiente para manejar la concurrencia en tus aplicaciones. Aprende y utiliza las librer\u00edas y herramientas de OTP para construir aplicaciones robustas y escalables en Erlang. Navegaci\u00f3n de lecciones \u00b6 Siguiente lecci\u00f3n -> : Arquitectura de sistemas Elixir","title":"Profundizaci\u00f3n en Erlang"},{"location":"elixir/sr/profundizacion_en_erlang/#profundizacion-en-erlang","text":"En esta lecci\u00f3n, profundizaremos en el lenguaje de programaci\u00f3n Erlang y su relaci\u00f3n con Elixir. Conocer en detalle Erlang es fundamental para comprender plenamente Elixir, ya que este \u00faltimo se basa en gran medida en el primero.","title":"Profundizaci\u00f3n en Erlang"},{"location":"elixir/sr/profundizacion_en_erlang/#explicacion-teorica","text":"Erlang es un lenguaje de programaci\u00f3n funcional y concurrente, desarrollado en la d\u00e9cada de 1980 por Ericsson para ser utilizado en sus sistemas de telecomunicaciones. Una de las caracter\u00edsticas principales de Erlang es su capacidad para manejar procesos concurrentes de forma eficiente y segura, lo que lo hace ideal para aplicaciones en tiempo real y distribuidas. Elixir, por otro lado, es un lenguaje de programaci\u00f3n funcional que se ejecuta en la m\u00e1quina virtual de Erlang (BEAM). Esto significa que el c\u00f3digo escrito en Elixir se compila a bytecode y se ejecuta en la misma m\u00e1quina virtual que los programas escritos en Erlang. Elixir aprovecha las caracter\u00edsticas de concurrencia y tolerancia a fallos de Erlang y las hace accesibles a los desarrolladores a trav\u00e9s de una sintaxis m\u00e1s amigable y moderna.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"elixir/sr/profundizacion_en_erlang/#palabras-clave-y-su-definicion","text":"Funci\u00f3n: Un bloque de c\u00f3digo que realiza una tarea espec\u00edfica y devuelve un valor. Patr\u00f3n: Una expresi\u00f3n utilizada para hacer coincidir valores y estructuras de datos. T\u00e9rmino: Cualquier valor en el lenguaje Erlang, incluyendo \u00e1tomos, enteros, flotantes, strings, listas y tuplas. Proceso: Una unidad de ejecuci\u00f3n concurrente en Erlang que se comunica con otros procesos a trav\u00e9s de mensajes. M\u00f3dulo: Una colecci\u00f3n de funciones y datos relacionados en Erlang. OTP (Open Telecom Platform): Una colecci\u00f3n de librer\u00edas y herramientas utilizadas para construir aplicaciones robustas y escalables en Erlang.","title":"Palabras clave y su definici\u00f3n"},{"location":"elixir/sr/profundizacion_en_erlang/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Erlang y cu\u00e1l es su relaci\u00f3n con Elixir? \u00bfQu\u00e9 caracter\u00edstica principal de Erlang lo hace ideal para aplicaciones en tiempo real y distribuidas? \u00bfEn qu\u00e9 m\u00e1quina virtual se ejecuta el c\u00f3digo escrito en Elixir? \u00bfQu\u00e9 es un patr\u00f3n en Erlang? \u00bfQu\u00e9 es OTP y para qu\u00e9 se utiliza en Erlang?","title":"Preguntas de repaso"},{"location":"elixir/sr/profundizacion_en_erlang/#ejemplos-de-codigo-en-elixir","text":"# Ejemplo de una funci\u00f3n en Elixir defmodule Calculator do def add ( a , b ) do a + b end end # Ejemplo de un patr\u00f3n en Erlang { ok , result } = Calculator . add ( 2 , 3 ) # Ejemplo de un proceso en Erlang spawn ( fn -> IO . puts ( \"Hello from a process!\" ) end )","title":"Ejemplos de c\u00f3digo en Elixir"},{"location":"elixir/sr/profundizacion_en_erlang/#ejercicios-practicos","text":"Crea una funci\u00f3n en Elixir que calcule el \u00e1rea de un c\u00edrculo dado su radio. Utiliza un patr\u00f3n en Erlang para hacer coincidir una lista con los primeros tres elementos iguales. Crea un proceso en Erlang que imprima \"I'm alive!\" cada 3 segundos.","title":"Ejercicios pr\u00e1cticos"},{"location":"elixir/sr/profundizacion_en_erlang/#consejos-o-mejores-practicas","text":"Estudia la sintaxis y caracter\u00edsticas de Erlang para poder aprovechar al m\u00e1ximo las capacidades de Elixir. Utiliza patrones y funciones de forma eficiente para manejar la concurrencia en tus aplicaciones. Aprende y utiliza las librer\u00edas y herramientas de OTP para construir aplicaciones robustas y escalables en Erlang.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"elixir/sr/profundizacion_en_erlang/#navegacion-de-lecciones","text":"Siguiente lecci\u00f3n -> : Arquitectura de sistemas Elixir","title":"Navegaci\u00f3n de lecciones"},{"location":"elixir/sr/seguridad_avanzada_en_aplicaciones_elixir/","text":"Seguridad avanzada en aplicaciones Elixir \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 Este m\u00f3dulo tiene como objetivo ense\u00f1ar a los desarrolladores a aplicar medidas de seguridad avanzadas en el desarrollo de aplicaciones Elixir. Se abordar\u00e1n temas como el cifrado de datos y la autenticaci\u00f3n de dos factores, que son fundamentales para garantizar la protecci\u00f3n de la informaci\u00f3n y la integridad de las aplicaciones. Explicaci\u00f3n te\u00f3rica \u00b6 La seguridad en aplicaciones Elixir es un tema de gran importancia, ya que cada d\u00eda se manejan grandes cantidades de datos sensibles en l\u00ednea. Por lo tanto, es necesario implementar medidas de seguridad adecuadas para proteger la informaci\u00f3n de posibles ataques maliciosos. El cifrado es una t\u00e9cnica que se utiliza para convertir datos en un formato ilegible, lo que dificulta su acceso por parte de terceros no autorizados. En el caso de aplicaciones Elixir, se puede utilizar el m\u00f3dulo de criptograf\u00eda para cifrar los datos en tr\u00e1nsito o en reposo. Esto garantiza que, incluso si alguien logra acceder a los datos, no podr\u00e1 entender su contenido sin la clave de descifrado. La autenticaci\u00f3n de dos factores es una medida de seguridad que requiere que el usuario proporcione dos formas de identificaci\u00f3n para acceder a la aplicaci\u00f3n. Adem\u00e1s de la contrase\u00f1a, se utiliza un segundo factor como un c\u00f3digo generado por una aplicaci\u00f3n de autenticaci\u00f3n o un mensaje de texto enviado al tel\u00e9fono del usuario. Esto agrega una capa adicional de seguridad, ya que incluso si alguien conoce la contrase\u00f1a, no podr\u00e1 acceder a la aplicaci\u00f3n sin el segundo factor de autenticaci\u00f3n. Palabras clave y su definici\u00f3n \u00b6 Cifrado: Proceso de convertir datos en un formato ilegible mediante algoritmos criptogr\u00e1ficos. Autenticaci\u00f3n de dos factores: M\u00e9todo de seguridad que requiere que el usuario proporcione dos formas de identificaci\u00f3n para acceder a la aplicaci\u00f3n. M\u00f3dulo de criptograf\u00eda: Herramienta utilizada en aplicaciones Elixir para cifrar y descifrar datos. Datos sensibles: Informaci\u00f3n confidencial que debe ser protegida, como contrase\u00f1as, n\u00fameros de tarjeta de cr\u00e9dito, entre otros. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es el cifrado y por qu\u00e9 es importante en aplicaciones Elixir? \u00bfEn qu\u00e9 consiste la autenticaci\u00f3n de dos factores y c\u00f3mo ayuda a aumentar la seguridad en las aplicaciones? \u00bfQu\u00e9 es un m\u00f3dulo de criptograf\u00eda y para qu\u00e9 se utiliza en Elixir? \u00bfPor qu\u00e9 es importante proteger los datos sensibles en una aplicaci\u00f3n? Ejemplos de c\u00f3digo en Elixir \u00b6 Cifrado de datos \u00b6 # Cifrar un texto utilizando el algoritmo AES y una clave secreta text = \"Ejemplo de texto a cifrar\" key = \"clave_secreta\" { :ok , encrypted_text } = :crypto . encrypt ( :aes_cbc256 , key , key , text ) Autenticaci\u00f3n de dos factores \u00b6 # Generar un c\u00f3digo de autenticaci\u00f3n utilizando la biblioteca Comeonin secret = \"clave_secreta\" { :ok , token } = Comeonin.TOTP . generate ( secret ) Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una funci\u00f3n en Elixir que reciba como par\u00e1metros un texto y una clave secreta y retorne el texto cifrado utilizando el algoritmo AES con una longitud de clave de 128 bits. Implementa la autenticaci\u00f3n de dos factores en una aplicaci\u00f3n Elixir utilizando la biblioteca Comeonin. Crea una aplicaci\u00f3n Elixir que guarde los datos de una tarjeta de cr\u00e9dito. Utiliza el m\u00f3dulo de criptograf\u00eda para cifrar los datos antes de almacenarlos en la base de datos. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza siempre un m\u00f3dulo de criptograf\u00eda confiable para cifrar los datos en tus aplicaciones Elixir. No guardes las claves secretas en tu c\u00f3digo, es recomendable almacenarlas en un archivo de configuraci\u00f3n o en variables de entorno. Implementa la autenticaci\u00f3n de dos factores en aplicaciones que manejen informaci\u00f3n sensible. Mant\u00e9n tus aplicaciones Elixir actualizadas para evitar posibles vulnerabilidades de seguridad. Navegaci\u00f3n de lecciones \u00b6 <- Lecci\u00f3n anterior : Sistemas de mensajer\u00eda Siguiente lecci\u00f3n -> : Desarrollo de aplicaciones de escritorio, IoT, juegos, VR, etc.","title":"Seguridad avanzada en aplicaciones Elixir"},{"location":"elixir/sr/seguridad_avanzada_en_aplicaciones_elixir/#seguridad-avanzada-en-aplicaciones-elixir","text":"","title":"Seguridad avanzada en aplicaciones Elixir"},{"location":"elixir/sr/seguridad_avanzada_en_aplicaciones_elixir/#descripcion-del-modulo","text":"Este m\u00f3dulo tiene como objetivo ense\u00f1ar a los desarrolladores a aplicar medidas de seguridad avanzadas en el desarrollo de aplicaciones Elixir. Se abordar\u00e1n temas como el cifrado de datos y la autenticaci\u00f3n de dos factores, que son fundamentales para garantizar la protecci\u00f3n de la informaci\u00f3n y la integridad de las aplicaciones.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"elixir/sr/seguridad_avanzada_en_aplicaciones_elixir/#explicacion-teorica","text":"La seguridad en aplicaciones Elixir es un tema de gran importancia, ya que cada d\u00eda se manejan grandes cantidades de datos sensibles en l\u00ednea. Por lo tanto, es necesario implementar medidas de seguridad adecuadas para proteger la informaci\u00f3n de posibles ataques maliciosos. El cifrado es una t\u00e9cnica que se utiliza para convertir datos en un formato ilegible, lo que dificulta su acceso por parte de terceros no autorizados. En el caso de aplicaciones Elixir, se puede utilizar el m\u00f3dulo de criptograf\u00eda para cifrar los datos en tr\u00e1nsito o en reposo. Esto garantiza que, incluso si alguien logra acceder a los datos, no podr\u00e1 entender su contenido sin la clave de descifrado. La autenticaci\u00f3n de dos factores es una medida de seguridad que requiere que el usuario proporcione dos formas de identificaci\u00f3n para acceder a la aplicaci\u00f3n. Adem\u00e1s de la contrase\u00f1a, se utiliza un segundo factor como un c\u00f3digo generado por una aplicaci\u00f3n de autenticaci\u00f3n o un mensaje de texto enviado al tel\u00e9fono del usuario. Esto agrega una capa adicional de seguridad, ya que incluso si alguien conoce la contrase\u00f1a, no podr\u00e1 acceder a la aplicaci\u00f3n sin el segundo factor de autenticaci\u00f3n.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"elixir/sr/seguridad_avanzada_en_aplicaciones_elixir/#palabras-clave-y-su-definicion","text":"Cifrado: Proceso de convertir datos en un formato ilegible mediante algoritmos criptogr\u00e1ficos. Autenticaci\u00f3n de dos factores: M\u00e9todo de seguridad que requiere que el usuario proporcione dos formas de identificaci\u00f3n para acceder a la aplicaci\u00f3n. M\u00f3dulo de criptograf\u00eda: Herramienta utilizada en aplicaciones Elixir para cifrar y descifrar datos. Datos sensibles: Informaci\u00f3n confidencial que debe ser protegida, como contrase\u00f1as, n\u00fameros de tarjeta de cr\u00e9dito, entre otros.","title":"Palabras clave y su definici\u00f3n"},{"location":"elixir/sr/seguridad_avanzada_en_aplicaciones_elixir/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es el cifrado y por qu\u00e9 es importante en aplicaciones Elixir? \u00bfEn qu\u00e9 consiste la autenticaci\u00f3n de dos factores y c\u00f3mo ayuda a aumentar la seguridad en las aplicaciones? \u00bfQu\u00e9 es un m\u00f3dulo de criptograf\u00eda y para qu\u00e9 se utiliza en Elixir? \u00bfPor qu\u00e9 es importante proteger los datos sensibles en una aplicaci\u00f3n?","title":"Preguntas de repaso"},{"location":"elixir/sr/seguridad_avanzada_en_aplicaciones_elixir/#ejemplos-de-codigo-en-elixir","text":"","title":"Ejemplos de c\u00f3digo en Elixir"},{"location":"elixir/sr/seguridad_avanzada_en_aplicaciones_elixir/#cifrado-de-datos","text":"# Cifrar un texto utilizando el algoritmo AES y una clave secreta text = \"Ejemplo de texto a cifrar\" key = \"clave_secreta\" { :ok , encrypted_text } = :crypto . encrypt ( :aes_cbc256 , key , key , text )","title":"Cifrado de datos"},{"location":"elixir/sr/seguridad_avanzada_en_aplicaciones_elixir/#autenticacion-de-dos-factores","text":"# Generar un c\u00f3digo de autenticaci\u00f3n utilizando la biblioteca Comeonin secret = \"clave_secreta\" { :ok , token } = Comeonin.TOTP . generate ( secret )","title":"Autenticaci\u00f3n de dos factores"},{"location":"elixir/sr/seguridad_avanzada_en_aplicaciones_elixir/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una funci\u00f3n en Elixir que reciba como par\u00e1metros un texto y una clave secreta y retorne el texto cifrado utilizando el algoritmo AES con una longitud de clave de 128 bits. Implementa la autenticaci\u00f3n de dos factores en una aplicaci\u00f3n Elixir utilizando la biblioteca Comeonin. Crea una aplicaci\u00f3n Elixir que guarde los datos de una tarjeta de cr\u00e9dito. Utiliza el m\u00f3dulo de criptograf\u00eda para cifrar los datos antes de almacenarlos en la base de datos.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"elixir/sr/seguridad_avanzada_en_aplicaciones_elixir/#consejos-o-mejores-practicas","text":"Utiliza siempre un m\u00f3dulo de criptograf\u00eda confiable para cifrar los datos en tus aplicaciones Elixir. No guardes las claves secretas en tu c\u00f3digo, es recomendable almacenarlas en un archivo de configuraci\u00f3n o en variables de entorno. Implementa la autenticaci\u00f3n de dos factores en aplicaciones que manejen informaci\u00f3n sensible. Mant\u00e9n tus aplicaciones Elixir actualizadas para evitar posibles vulnerabilidades de seguridad.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"elixir/sr/seguridad_avanzada_en_aplicaciones_elixir/#navegacion-de-lecciones","text":"<- Lecci\u00f3n anterior : Sistemas de mensajer\u00eda Siguiente lecci\u00f3n -> : Desarrollo de aplicaciones de escritorio, IoT, juegos, VR, etc.","title":"Navegaci\u00f3n de lecciones"},{"location":"go/jr/concurrencia/","text":"Concurrencia \u00b6 La concurrencia es un enfoque de programaci\u00f3n que permite que varias tareas se ejecuten de forma simult\u00e1nea en un programa. En lugar de ejecutar una tarea a la vez, la concurrencia permite que varias tareas se ejecuten de manera intercalada, lo que puede mejorar significativamente el rendimiento y la eficiencia de un programa. En Go lang, la concurrencia se logra utilizando goroutines y canales. Palabras clave \u00b6 Goroutine: Una goroutine es una funci\u00f3n que se ejecuta de forma independiente en el programa. Canal: Un canal es una estructura de datos que permite la comunicaci\u00f3n entre goroutines. Sincronizaci\u00f3n: La sincronizaci\u00f3n es el proceso de asegurar que las goroutines se ejecuten en el orden correcto y evitando posibles conflictos en el acceso a datos compartidos. Planificaci\u00f3n: La planificaci\u00f3n es el proceso de asignar tiempo de ejecuci\u00f3n a cada goroutine activa en el programa. WaitGroup: Un WaitGroup es una estructura de datos que permite a una goroutine esperar a que otras goroutines finalicen su ejecuci\u00f3n. Mutex: Un Mutex es un mecanismo de sincronizaci\u00f3n que se utiliza para controlar el acceso a datos compartidos entre goroutines. Select: El select es una estructura de control que permite a una goroutine esperar la llegada de datos en varios canales. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la concurrencia y por qu\u00e9 es importante en la programaci\u00f3n? \u00bfCu\u00e1l es la diferencia entre una goroutine y una funci\u00f3n normal? \u00bfQu\u00e9 es un canal y c\u00f3mo se utiliza en la concurrencia? \u00bfQu\u00e9 es la sincronizaci\u00f3n y por qu\u00e9 es necesaria en la concurrencia? \u00bfC\u00f3mo se evitan posibles conflictos en el acceso a datos compartidos entre goroutines? \u00bfQu\u00e9 es un WaitGroup y c\u00f3mo se utiliza en la concurrencia? \u00bfQu\u00e9 es un Mutex y en qu\u00e9 casos se utiliza? \u00bfQu\u00e9 es el select y cu\u00e1l es su funci\u00f3n en la concurrencia? \u00bfCu\u00e1les son algunas mejores pr\u00e1cticas para el uso de la concurrencia en Go lang? \u00bfC\u00f3mo se puede medir el rendimiento de un programa que utiliza concurrencia? Ejemplos de c\u00f3digo \u00b6 Goroutines \u00b6 Una goroutine se crea agregando la palabra clave \"go\" antes de llamar a una funci\u00f3n: func main () { go imprimir ( \"Hola\" ) imprimir ( \"Mundo\" ) } func imprimir ( texto string ) { fmt . Println ( texto ) } Este c\u00f3digo crear\u00e1 dos goroutines, una para imprimir \"Hola\" y otra para imprimir \"Mundo\". Como las goroutines se ejecutan de forma independiente, el orden en que se imprimen los textos puede variar en cada ejecuci\u00f3n del programa. Canales \u00b6 Los canales se utilizan para la comunicaci\u00f3n entre goroutines. En el siguiente ejemplo, una goroutine env\u00eda un mensaje a trav\u00e9s de un canal y otra goroutine lo recibe: func main () { canal := make ( chan string ) go enviarMensaje ( canal , \"Hola\" ) mensaje := <- canal fmt . Println ( mensaje ) } func enviarMensaje ( canal chan string , mensaje string ) { canal <- mensaje } El operador \"<-\" se utiliza para enviar y recibir datos a trav\u00e9s de un canal. En este ejemplo, la goroutine enviarMensaje env\u00eda el mensaje \"Hola\" al canal y la goroutine principal lo recibe y lo imprime. WaitGroup \u00b6 Un WaitGroup se utiliza para esperar a que varias goroutines finalicen su ejecuci\u00f3n antes de continuar con la ejecuci\u00f3n del programa. En el siguiente ejemplo, se utilizan dos goroutines y un WaitGroup para imprimir un mensaje solo despu\u00e9s de que ambas goroutines hayan finalizado su ejecuci\u00f3n: func main () { var wg sync . WaitGroup wg . Add ( 2 ) go imprimir ( \"Hola\" , & wg ) go imprimir ( \"Mundo\" , & wg ) wg . Wait () fmt . Println ( \"Fin del programa\" ) } func imprimir ( texto string , wg * sync . WaitGroup ) { defer wg . Done () fmt . Println ( texto ) } La funci\u00f3n sync.WaitGroup permite a una goroutine esperar a que otras goroutines finalicen su ejecuci\u00f3n mediante el m\u00e9todo Wait(). El m\u00e9todo Add() se utiliza para indicar cu\u00e1ntas goroutines deben finalizar antes de continuar. Mutex \u00b6 Los Mutex se utilizan para controlar el acceso a datos compartidos entre goroutines. En el siguiente ejemplo, se utiliza un Mutex para evitar posibles conflictos en el acceso a una variable compartida: var contador int var mutex sync . Mutex func incrementar () { mutex . Lock () contador ++ mutex . Unlock () } La funci\u00f3n Lock() se utiliza para bloquear el acceso a la variable compartida mientras se est\u00e1 modificando, y el m\u00e9todo Unlock() se utiliza para desbloquearla despu\u00e9s de su modificaci\u00f3n. Select \u00b6 El select se utiliza para esperar la llegada de datos en varios canales. En el siguiente ejemplo, se utiliza un select para imprimir un mensaje solo cuando se reciba un dato en cualquiera de los canales especificados: func main () { canal1 := make ( chan string ) canal2 := make ( chan string ) go enviarMensaje ( canal1 , \"Hola\" ) go enviarMensaje ( canal2 , \"Mundo\" ) select { case mensaje1 := <- canal1 : fmt . Println ( mensaje1 ) case mensaje2 := <- canal2 : fmt . Println ( mensaje2 ) } } func enviarMensaje ( canal chan string , mensaje string ) { canal <- mensaje } Ejercicios pr\u00e1cticos \u00b6 Crea un programa que genere 10 goroutines y cada una imprima un n\u00famero del 1 al 10. Modifica el programa anterior para que las goroutines impriman los n\u00fameros en orden aleatorio. Crea un programa que genere dos goroutines, una que genere n\u00fameros aleatorios y los env\u00ede a trav\u00e9s de un canal, y otra que reciba los n\u00fameros y los imprima en pantalla. Modifica el programa anterior para que la goroutine que recibe los n\u00fameros termine cuando reciba un n\u00famero mayor a 100. Crea un programa que utilice un WaitGroup para imprimir un mensaje solo despu\u00e9s de que se hayan completado 5 goroutines. Modifica el programa anterior para que el mensaje se imprima despu\u00e9s de que se completen un n\u00famero especificado de goroutines. Crea un programa que utilice un Mutex para controlar el acceso a una variable compartida y que incremente su valor en cada iteraci\u00f3n de un bucle en una goroutine. Modifica el programa anterior para que utilice dos goroutines que incrementen el valor en 100 y 200, y comprueba que el resultado final es correcto mediante el uso de un Mutex. Crea un programa que utilice un select para imprimir un mensaje solo cuando se reciba un dato en cualquiera de los canales especificados. Modifica el programa anterior para que se utilicen tres canales y se imprima un mensaje solo cuando se reciban datos en todos ellos. Consejos y mejores pr\u00e1cticas \u00b6 Utiliza goroutines y canales solo cuando sea necesario. No es recomendable utilizar concurrencia para tareas simples o que se puedan resolver de forma secuencial. Planifica y sincroniza cuidadosamente las goroutines para evitar posibles conflictos en el acceso a datos compartidos. Utiliza estructuras de datos como WaitGroup y Mutex para controlar la ejecuci\u00f3n y el acceso a datos compartidos entre goroutines. Utiliza el select para esperar la llegada de datos en varios canales en lugar de usar un bucle infinito con sentencias de recepci\u00f3n. Utiliza la funci\u00f3n runtime.GOMAXPROCS() para especificar el n\u00famero m\u00e1ximo de procesadores que se pueden utilizar para ejecutar goroutines. Esto puede mejorar el rendimiento en sistemas con m\u00faltiples procesadores. Realiza pruebas exhaustivas para asegurarte de que la concurrencia no afecte el funcionamiento correcto de tu programa. Ten en cuenta que la concurrencia no siempre mejora el rendimiento de un programa y puede incluso empeorarlo en algunos casos. Eval\u00faa cuidadosamente si la concurrencia es necesaria antes de implementarla.","title":"Concurrencia"},{"location":"go/jr/concurrencia/#concurrencia","text":"La concurrencia es un enfoque de programaci\u00f3n que permite que varias tareas se ejecuten de forma simult\u00e1nea en un programa. En lugar de ejecutar una tarea a la vez, la concurrencia permite que varias tareas se ejecuten de manera intercalada, lo que puede mejorar significativamente el rendimiento y la eficiencia de un programa. En Go lang, la concurrencia se logra utilizando goroutines y canales.","title":"Concurrencia"},{"location":"go/jr/concurrencia/#palabras-clave","text":"Goroutine: Una goroutine es una funci\u00f3n que se ejecuta de forma independiente en el programa. Canal: Un canal es una estructura de datos que permite la comunicaci\u00f3n entre goroutines. Sincronizaci\u00f3n: La sincronizaci\u00f3n es el proceso de asegurar que las goroutines se ejecuten en el orden correcto y evitando posibles conflictos en el acceso a datos compartidos. Planificaci\u00f3n: La planificaci\u00f3n es el proceso de asignar tiempo de ejecuci\u00f3n a cada goroutine activa en el programa. WaitGroup: Un WaitGroup es una estructura de datos que permite a una goroutine esperar a que otras goroutines finalicen su ejecuci\u00f3n. Mutex: Un Mutex es un mecanismo de sincronizaci\u00f3n que se utiliza para controlar el acceso a datos compartidos entre goroutines. Select: El select es una estructura de control que permite a una goroutine esperar la llegada de datos en varios canales.","title":"Palabras clave"},{"location":"go/jr/concurrencia/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la concurrencia y por qu\u00e9 es importante en la programaci\u00f3n? \u00bfCu\u00e1l es la diferencia entre una goroutine y una funci\u00f3n normal? \u00bfQu\u00e9 es un canal y c\u00f3mo se utiliza en la concurrencia? \u00bfQu\u00e9 es la sincronizaci\u00f3n y por qu\u00e9 es necesaria en la concurrencia? \u00bfC\u00f3mo se evitan posibles conflictos en el acceso a datos compartidos entre goroutines? \u00bfQu\u00e9 es un WaitGroup y c\u00f3mo se utiliza en la concurrencia? \u00bfQu\u00e9 es un Mutex y en qu\u00e9 casos se utiliza? \u00bfQu\u00e9 es el select y cu\u00e1l es su funci\u00f3n en la concurrencia? \u00bfCu\u00e1les son algunas mejores pr\u00e1cticas para el uso de la concurrencia en Go lang? \u00bfC\u00f3mo se puede medir el rendimiento de un programa que utiliza concurrencia?","title":"Preguntas de repaso"},{"location":"go/jr/concurrencia/#ejemplos-de-codigo","text":"","title":"Ejemplos de c\u00f3digo"},{"location":"go/jr/concurrencia/#goroutines","text":"Una goroutine se crea agregando la palabra clave \"go\" antes de llamar a una funci\u00f3n: func main () { go imprimir ( \"Hola\" ) imprimir ( \"Mundo\" ) } func imprimir ( texto string ) { fmt . Println ( texto ) } Este c\u00f3digo crear\u00e1 dos goroutines, una para imprimir \"Hola\" y otra para imprimir \"Mundo\". Como las goroutines se ejecutan de forma independiente, el orden en que se imprimen los textos puede variar en cada ejecuci\u00f3n del programa.","title":"Goroutines"},{"location":"go/jr/concurrencia/#canales","text":"Los canales se utilizan para la comunicaci\u00f3n entre goroutines. En el siguiente ejemplo, una goroutine env\u00eda un mensaje a trav\u00e9s de un canal y otra goroutine lo recibe: func main () { canal := make ( chan string ) go enviarMensaje ( canal , \"Hola\" ) mensaje := <- canal fmt . Println ( mensaje ) } func enviarMensaje ( canal chan string , mensaje string ) { canal <- mensaje } El operador \"<-\" se utiliza para enviar y recibir datos a trav\u00e9s de un canal. En este ejemplo, la goroutine enviarMensaje env\u00eda el mensaje \"Hola\" al canal y la goroutine principal lo recibe y lo imprime.","title":"Canales"},{"location":"go/jr/concurrencia/#waitgroup","text":"Un WaitGroup se utiliza para esperar a que varias goroutines finalicen su ejecuci\u00f3n antes de continuar con la ejecuci\u00f3n del programa. En el siguiente ejemplo, se utilizan dos goroutines y un WaitGroup para imprimir un mensaje solo despu\u00e9s de que ambas goroutines hayan finalizado su ejecuci\u00f3n: func main () { var wg sync . WaitGroup wg . Add ( 2 ) go imprimir ( \"Hola\" , & wg ) go imprimir ( \"Mundo\" , & wg ) wg . Wait () fmt . Println ( \"Fin del programa\" ) } func imprimir ( texto string , wg * sync . WaitGroup ) { defer wg . Done () fmt . Println ( texto ) } La funci\u00f3n sync.WaitGroup permite a una goroutine esperar a que otras goroutines finalicen su ejecuci\u00f3n mediante el m\u00e9todo Wait(). El m\u00e9todo Add() se utiliza para indicar cu\u00e1ntas goroutines deben finalizar antes de continuar.","title":"WaitGroup"},{"location":"go/jr/concurrencia/#mutex","text":"Los Mutex se utilizan para controlar el acceso a datos compartidos entre goroutines. En el siguiente ejemplo, se utiliza un Mutex para evitar posibles conflictos en el acceso a una variable compartida: var contador int var mutex sync . Mutex func incrementar () { mutex . Lock () contador ++ mutex . Unlock () } La funci\u00f3n Lock() se utiliza para bloquear el acceso a la variable compartida mientras se est\u00e1 modificando, y el m\u00e9todo Unlock() se utiliza para desbloquearla despu\u00e9s de su modificaci\u00f3n.","title":"Mutex"},{"location":"go/jr/concurrencia/#select","text":"El select se utiliza para esperar la llegada de datos en varios canales. En el siguiente ejemplo, se utiliza un select para imprimir un mensaje solo cuando se reciba un dato en cualquiera de los canales especificados: func main () { canal1 := make ( chan string ) canal2 := make ( chan string ) go enviarMensaje ( canal1 , \"Hola\" ) go enviarMensaje ( canal2 , \"Mundo\" ) select { case mensaje1 := <- canal1 : fmt . Println ( mensaje1 ) case mensaje2 := <- canal2 : fmt . Println ( mensaje2 ) } } func enviarMensaje ( canal chan string , mensaje string ) { canal <- mensaje }","title":"Select"},{"location":"go/jr/concurrencia/#ejercicios-practicos","text":"Crea un programa que genere 10 goroutines y cada una imprima un n\u00famero del 1 al 10. Modifica el programa anterior para que las goroutines impriman los n\u00fameros en orden aleatorio. Crea un programa que genere dos goroutines, una que genere n\u00fameros aleatorios y los env\u00ede a trav\u00e9s de un canal, y otra que reciba los n\u00fameros y los imprima en pantalla. Modifica el programa anterior para que la goroutine que recibe los n\u00fameros termine cuando reciba un n\u00famero mayor a 100. Crea un programa que utilice un WaitGroup para imprimir un mensaje solo despu\u00e9s de que se hayan completado 5 goroutines. Modifica el programa anterior para que el mensaje se imprima despu\u00e9s de que se completen un n\u00famero especificado de goroutines. Crea un programa que utilice un Mutex para controlar el acceso a una variable compartida y que incremente su valor en cada iteraci\u00f3n de un bucle en una goroutine. Modifica el programa anterior para que utilice dos goroutines que incrementen el valor en 100 y 200, y comprueba que el resultado final es correcto mediante el uso de un Mutex. Crea un programa que utilice un select para imprimir un mensaje solo cuando se reciba un dato en cualquiera de los canales especificados. Modifica el programa anterior para que se utilicen tres canales y se imprima un mensaje solo cuando se reciban datos en todos ellos.","title":"Ejercicios pr\u00e1cticos"},{"location":"go/jr/concurrencia/#consejos-y-mejores-practicas","text":"Utiliza goroutines y canales solo cuando sea necesario. No es recomendable utilizar concurrencia para tareas simples o que se puedan resolver de forma secuencial. Planifica y sincroniza cuidadosamente las goroutines para evitar posibles conflictos en el acceso a datos compartidos. Utiliza estructuras de datos como WaitGroup y Mutex para controlar la ejecuci\u00f3n y el acceso a datos compartidos entre goroutines. Utiliza el select para esperar la llegada de datos en varios canales en lugar de usar un bucle infinito con sentencias de recepci\u00f3n. Utiliza la funci\u00f3n runtime.GOMAXPROCS() para especificar el n\u00famero m\u00e1ximo de procesadores que se pueden utilizar para ejecutar goroutines. Esto puede mejorar el rendimiento en sistemas con m\u00faltiples procesadores. Realiza pruebas exhaustivas para asegurarte de que la concurrencia no afecte el funcionamiento correcto de tu programa. Ten en cuenta que la concurrencia no siempre mejora el rendimiento de un programa y puede incluso empeorarlo en algunos casos. Eval\u00faa cuidadosamente si la concurrencia es necesaria antes de implementarla.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"go/jr/control_de_flujo/","text":"Control de flujo \u00b6 El control de flujo en Go lang se refiere a la forma en que el programa toma decisiones y maneja el flujo de ejecuci\u00f3n en funci\u00f3n de esas decisiones. Esto es esencial para crear programas eficientes y l\u00f3gicos que puedan realizar tareas espec\u00edficas de manera efectiva. Explicaci\u00f3n te\u00f3rica \u00b6 En Go lang, el control de flujo se logra mediante el uso de condicionales, bucles y otras estructuras de control. Las condicionales permiten al programa elegir entre diferentes acciones o rutas de ejecuci\u00f3n en funci\u00f3n de una o varias condiciones. Los bucles, por otro lado, permiten que una acci\u00f3n se repita varias veces hasta que se cumpla una condici\u00f3n espec\u00edfica. Las estructuras de control de flujo tambi\u00e9n incluyen declaraciones de control, que son instrucciones que permiten al programador controlar directamente el flujo de ejecuci\u00f3n del programa. Estas incluyen la declaraci\u00f3n \"break\" para salir de un bucle, la declaraci\u00f3n \"continue\" para saltar una iteraci\u00f3n de un bucle y la declaraci\u00f3n \"goto\" para saltar a una secci\u00f3n espec\u00edfica del c\u00f3digo. Palabras clave y su definici\u00f3n \u00b6 Condicionales: Son estructuras de control que permiten al programa elegir entre diferentes opciones de ejecuci\u00f3n en funci\u00f3n de una o varias condiciones. Bucles: Son estructuras de control que permiten que una acci\u00f3n se repita varias veces hasta que se cumpla una condici\u00f3n espec\u00edfica. Declaraciones de control: Son instrucciones que permiten al programador controlar directamente el flujo de ejecuci\u00f3n del programa. If-else: Es una estructura de control condicional que ejecuta un bloque de c\u00f3digo si se cumple una condici\u00f3n y otro bloque de c\u00f3digo si no se cumple. For: Es una estructura de control de bucle que permite repetir una acci\u00f3n un n\u00famero espec\u00edfico de veces. Break: Es una declaraci\u00f3n de control que permite salir de un bucle o una estructura de control de flujo. Continue: Es una declaraci\u00f3n de control que permite saltar una iteraci\u00f3n de un bucle y continuar con la siguiente. Goto: Es una declaraci\u00f3n de control que permite saltar a una secci\u00f3n espec\u00edfica del c\u00f3digo. Preguntas de repaso \u00b6 \u00bfQu\u00e9 son las estructuras de control de flujo en Go lang? \u00bfCu\u00e1l es la diferencia entre una estructura de control condicional y una estructura de control de bucle? \u00bfQu\u00e9 son las declaraciones de control y cu\u00e1les son algunas de las m\u00e1s comunes en Go lang? \u00bfC\u00f3mo se utiliza la estructura de control \"if-else\" en Go lang? \u00bfQu\u00e9 es la declaraci\u00f3n \"break\" y en qu\u00e9 situaciones se puede utilizar? \u00bfQu\u00e9 es la declaraci\u00f3n \"continue\" y en qu\u00e9 situaciones se puede utilizar? \u00bfQu\u00e9 es la declaraci\u00f3n \"goto\" y en qu\u00e9 situaciones se puede utilizar? Ejemplos de c\u00f3digo en Go lang \u00b6 If-else \u00b6 num := 10 if num > 0 { fmt . Println ( \"El n\u00famero es positivo\" ) } else if num < 0 { fmt . Println ( \"El n\u00famero es negativo\" ) } else { fmt . Println ( \"El n\u00famero es cero\" ) } For \u00b6 for i := 0 ; i < 5 ; i ++ { fmt . Println ( i ) } Break \u00b6 for i := 0 ; i < 10 ; i ++ { if i == 5 { break } fmt . Println ( i ) } Continue \u00b6 for i := 0 ; i < 10 ; i ++ { if i == 5 { continue } fmt . Println ( i ) } Goto \u00b6 num := 10 if num > 0 { goto positive } else { goto negative } positive : fmt . Println ( \"El n\u00famero es positivo\" ) goto end negative : fmt . Println ( \"El n\u00famero es negativo\" ) end : fmt . Println ( \"Fin del programa\" ) Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea un programa que imprima los n\u00fameros del 1 al 10 utilizando un bucle \"for\". Modifica el programa anterior para que solo imprima los n\u00fameros pares. Crea un programa que pida al usuario un n\u00famero y determine si es positivo, negativo o cero utilizando una estructura de control \"if-else\". Crea un programa que pida al usuario una palabra y determine si es un pal\u00edndromo (se lee igual de izquierda a derecha que de derecha a izquierda) utilizando un bucle \"for\". Crea un programa que pida al usuario un n\u00famero y calcule su factorial utilizando un bucle \"for\". Consejos o mejores pr\u00e1cticas \u00b6 Utiliza nombres descriptivos para tus variables y declaraciones de control para que sea m\u00e1s f\u00e1cil entender el flujo de tu programa. Aseg\u00farate de tener en cuenta todas las posibles condiciones y situaciones al utilizar declaraciones de control para evitar errores o resultados inesperados. Utiliza comentarios para explicar el prop\u00f3sito de tus declaraciones de control y facilitar la lectura y el mantenimiento del c\u00f3digo. Practica con ejercicios y retos para mejorar tus habilidades en el uso de condicionales, bucles y otras estructuras de control de flujo en Go lang.","title":"Control de flujo"},{"location":"go/jr/control_de_flujo/#control-de-flujo","text":"El control de flujo en Go lang se refiere a la forma en que el programa toma decisiones y maneja el flujo de ejecuci\u00f3n en funci\u00f3n de esas decisiones. Esto es esencial para crear programas eficientes y l\u00f3gicos que puedan realizar tareas espec\u00edficas de manera efectiva.","title":"Control de flujo"},{"location":"go/jr/control_de_flujo/#explicacion-teorica","text":"En Go lang, el control de flujo se logra mediante el uso de condicionales, bucles y otras estructuras de control. Las condicionales permiten al programa elegir entre diferentes acciones o rutas de ejecuci\u00f3n en funci\u00f3n de una o varias condiciones. Los bucles, por otro lado, permiten que una acci\u00f3n se repita varias veces hasta que se cumpla una condici\u00f3n espec\u00edfica. Las estructuras de control de flujo tambi\u00e9n incluyen declaraciones de control, que son instrucciones que permiten al programador controlar directamente el flujo de ejecuci\u00f3n del programa. Estas incluyen la declaraci\u00f3n \"break\" para salir de un bucle, la declaraci\u00f3n \"continue\" para saltar una iteraci\u00f3n de un bucle y la declaraci\u00f3n \"goto\" para saltar a una secci\u00f3n espec\u00edfica del c\u00f3digo.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"go/jr/control_de_flujo/#palabras-clave-y-su-definicion","text":"Condicionales: Son estructuras de control que permiten al programa elegir entre diferentes opciones de ejecuci\u00f3n en funci\u00f3n de una o varias condiciones. Bucles: Son estructuras de control que permiten que una acci\u00f3n se repita varias veces hasta que se cumpla una condici\u00f3n espec\u00edfica. Declaraciones de control: Son instrucciones que permiten al programador controlar directamente el flujo de ejecuci\u00f3n del programa. If-else: Es una estructura de control condicional que ejecuta un bloque de c\u00f3digo si se cumple una condici\u00f3n y otro bloque de c\u00f3digo si no se cumple. For: Es una estructura de control de bucle que permite repetir una acci\u00f3n un n\u00famero espec\u00edfico de veces. Break: Es una declaraci\u00f3n de control que permite salir de un bucle o una estructura de control de flujo. Continue: Es una declaraci\u00f3n de control que permite saltar una iteraci\u00f3n de un bucle y continuar con la siguiente. Goto: Es una declaraci\u00f3n de control que permite saltar a una secci\u00f3n espec\u00edfica del c\u00f3digo.","title":"Palabras clave y su definici\u00f3n"},{"location":"go/jr/control_de_flujo/#preguntas-de-repaso","text":"\u00bfQu\u00e9 son las estructuras de control de flujo en Go lang? \u00bfCu\u00e1l es la diferencia entre una estructura de control condicional y una estructura de control de bucle? \u00bfQu\u00e9 son las declaraciones de control y cu\u00e1les son algunas de las m\u00e1s comunes en Go lang? \u00bfC\u00f3mo se utiliza la estructura de control \"if-else\" en Go lang? \u00bfQu\u00e9 es la declaraci\u00f3n \"break\" y en qu\u00e9 situaciones se puede utilizar? \u00bfQu\u00e9 es la declaraci\u00f3n \"continue\" y en qu\u00e9 situaciones se puede utilizar? \u00bfQu\u00e9 es la declaraci\u00f3n \"goto\" y en qu\u00e9 situaciones se puede utilizar?","title":"Preguntas de repaso"},{"location":"go/jr/control_de_flujo/#ejemplos-de-codigo-en-go-lang","text":"","title":"Ejemplos de c\u00f3digo en Go lang"},{"location":"go/jr/control_de_flujo/#if-else","text":"num := 10 if num > 0 { fmt . Println ( \"El n\u00famero es positivo\" ) } else if num < 0 { fmt . Println ( \"El n\u00famero es negativo\" ) } else { fmt . Println ( \"El n\u00famero es cero\" ) }","title":"If-else"},{"location":"go/jr/control_de_flujo/#for","text":"for i := 0 ; i < 5 ; i ++ { fmt . Println ( i ) }","title":"For"},{"location":"go/jr/control_de_flujo/#break","text":"for i := 0 ; i < 10 ; i ++ { if i == 5 { break } fmt . Println ( i ) }","title":"Break"},{"location":"go/jr/control_de_flujo/#continue","text":"for i := 0 ; i < 10 ; i ++ { if i == 5 { continue } fmt . Println ( i ) }","title":"Continue"},{"location":"go/jr/control_de_flujo/#goto","text":"num := 10 if num > 0 { goto positive } else { goto negative } positive : fmt . Println ( \"El n\u00famero es positivo\" ) goto end negative : fmt . Println ( \"El n\u00famero es negativo\" ) end : fmt . Println ( \"Fin del programa\" )","title":"Goto"},{"location":"go/jr/control_de_flujo/#ejercicios-practicos-con-instrucciones-claras","text":"Crea un programa que imprima los n\u00fameros del 1 al 10 utilizando un bucle \"for\". Modifica el programa anterior para que solo imprima los n\u00fameros pares. Crea un programa que pida al usuario un n\u00famero y determine si es positivo, negativo o cero utilizando una estructura de control \"if-else\". Crea un programa que pida al usuario una palabra y determine si es un pal\u00edndromo (se lee igual de izquierda a derecha que de derecha a izquierda) utilizando un bucle \"for\". Crea un programa que pida al usuario un n\u00famero y calcule su factorial utilizando un bucle \"for\".","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"go/jr/control_de_flujo/#consejos-o-mejores-practicas","text":"Utiliza nombres descriptivos para tus variables y declaraciones de control para que sea m\u00e1s f\u00e1cil entender el flujo de tu programa. Aseg\u00farate de tener en cuenta todas las posibles condiciones y situaciones al utilizar declaraciones de control para evitar errores o resultados inesperados. Utiliza comentarios para explicar el prop\u00f3sito de tus declaraciones de control y facilitar la lectura y el mantenimiento del c\u00f3digo. Practica con ejercicios y retos para mejorar tus habilidades en el uso de condicionales, bucles y otras estructuras de control de flujo en Go lang.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"go/jr/despliegue_e_integraci%C3%B3n/","text":"Despliegue e integraci\u00f3n en Go \u00b6 El despliegue e integraci\u00f3n son dos procesos fundamentales en el desarrollo de aplicaciones en Go. El despliegue se refiere a la puesta en producci\u00f3n de una aplicaci\u00f3n, mientras que la integraci\u00f3n se refiere a la conexi\u00f3n de diferentes tecnolog\u00edas y servicios para que trabajen juntos de manera eficiente. Explicaci\u00f3n te\u00f3rica \u00b6 El despliegue de una aplicaci\u00f3n en Go puede realizarse de diversas formas, pero una de las m\u00e1s comunes es a trav\u00e9s de la compilaci\u00f3n del c\u00f3digo en un binario ejecutable que puede ser transferido a un servidor y ejecutado. Otra opci\u00f3n es utilizar contenedores como Docker para empaquetar la aplicaci\u00f3n junto con todas sus dependencias y desplegarla en un entorno de producci\u00f3n. Por otro lado, la integraci\u00f3n en Go se logra a trav\u00e9s del uso de librer\u00edas y paquetes que permiten la conexi\u00f3n y comunicaci\u00f3n con diferentes tecnolog\u00edas y servicios. Algunas de estas librer\u00edas incluyen HTTP, SQL y gRPC, entre otras. Tambi\u00e9n es posible integrar la aplicaci\u00f3n con servicios en la nube como AWS o Google Cloud Platform. Palabras clave y su definici\u00f3n \u00b6 Despliegue: proceso de puesta en producci\u00f3n de una aplicaci\u00f3n. Integraci\u00f3n: conexi\u00f3n de diferentes tecnolog\u00edas y servicios para trabajar juntos. Compilaci\u00f3n: proceso de convertir el c\u00f3digo fuente en un binario ejecutable. Contenedores: tecnolog\u00eda que permite empaquetar una aplicaci\u00f3n con todas sus dependencias para su despliegue en un entorno de producci\u00f3n. Librer\u00edas: conjunto de funciones y m\u00e9todos que pueden ser utilizados en una aplicaci\u00f3n para realizar una tarea espec\u00edfica. Paquetes: conjunto de librer\u00edas y archivos que pueden ser importados en una aplicaci\u00f3n. HTTP: protocolo de transferencia de hipertexto, utilizado para la comunicaci\u00f3n entre aplicaciones web. SQL: lenguaje de consultas estructurado, utilizado para comunicarse con bases de datos relacionales. gRPC: framework de comunicaci\u00f3n entre aplicaciones basado en el protocolo HTTP/2. Preguntas de repaso \u00b6 \u00bfCu\u00e1l es la diferencia entre despliegue e integraci\u00f3n en Go? \u00bfC\u00f3mo se puede desplegar una aplicaci\u00f3n en Go? \u00bfQu\u00e9 son los contenedores y c\u00f3mo se utilizan en el despliegue de aplicaciones en Go? \u00bfQu\u00e9 son las librer\u00edas y paquetes en Go? \u00bfCu\u00e1l es la importancia de la integraci\u00f3n en el desarrollo de aplicaciones en Go? \u00bfQu\u00e9 es HTTP y c\u00f3mo se utiliza en la integraci\u00f3n de aplicaciones en Go? \u00bfQu\u00e9 es SQL y c\u00f3mo se integra con aplicaciones en Go? \u00bfQu\u00e9 es gRPC y para qu\u00e9 se utiliza en la integraci\u00f3n de aplicaciones en Go? Ejemplos de c\u00f3digo en Go lang \u00b6 Ejemplo de despliegue utilizando compilaci\u00f3n \u00b6 // Archivo main . go package main import \"fmt\" func main () { fmt . Println ( \"Hola mundo!\" ) } En la terminal: go build main . go . / main Ejemplo de despliegue utilizando contenedores \u00b6 // Archivo Dockerfile FROM golang : alpine COPY . / app WORKDIR / app RUN go build - o main . CMD [ \"/app/main\" ] En la terminal: docker build -t mi-app . docker run -p 8080:8080 mi-app Ejemplo de integraci\u00f3n con HTTP \u00b6 // Archivo main . go package main import ( \"fmt\" \"net/http\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { fmt . Fprint ( w , \"Hola mundo!\" ) }) http . ListenAndServe ( \":8080\" , nil ) } Ejemplo de integraci\u00f3n con SQL \u00b6 // Archivo main . go package main import ( \"database/sql\" \"fmt\" _ \"github.com/go-sql-driver/mysql\" ) func main () { db , err := sql . Open ( \"mysql\" , \"usuario:contrase\u00f1a@tcp(127.0.0.1:3306)/mi_db\" ) if err != nil { panic ( err . Error ()) } defer db . Close () result , err := db . Query ( \"SELECT * FROM usuarios\" ) if err != nil { panic ( err . Error ()) } for result . Next () { var id int var nombre string err = result . Scan ( & id , & nombre ) if err != nil { panic ( err . Error ()) } fmt . Println ( id , nombre ) } } Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Despliegue una aplicaci\u00f3n en Go utilizando la t\u00e9cnica de compilaci\u00f3n. Despliegue una aplicaci\u00f3n en Go utilizando contenedores y Docker. Crea una aplicaci\u00f3n en Go que se comunique con una API externa utilizando la librer\u00eda HTTP. Integra una base de datos MySQL con una aplicaci\u00f3n en Go y realiza consultas utilizando SQL. Crea una aplicaci\u00f3n en Go que se comunique con un servicio en la nube como AWS o Google Cloud Platform. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza herramientas como Git y sistemas de control de versiones para facilitar el despliegue de tu aplicaci\u00f3n. Realiza pruebas en diferentes ambientes antes de realizar el despliegue en producci\u00f3n. Utiliza la modularidad en tu c\u00f3digo para facilitar la integraci\u00f3n con otras tecnolog\u00edas y servicios. Utiliza librer\u00edas y paquetes de confianza y mant\u00e9nlos actualizados para evitar problemas de seguridad.","title":"Despliegue e integraci\u00f3n en Go"},{"location":"go/jr/despliegue_e_integraci%C3%B3n/#despliegue-e-integracion-en-go","text":"El despliegue e integraci\u00f3n son dos procesos fundamentales en el desarrollo de aplicaciones en Go. El despliegue se refiere a la puesta en producci\u00f3n de una aplicaci\u00f3n, mientras que la integraci\u00f3n se refiere a la conexi\u00f3n de diferentes tecnolog\u00edas y servicios para que trabajen juntos de manera eficiente.","title":"Despliegue e integraci\u00f3n en Go"},{"location":"go/jr/despliegue_e_integraci%C3%B3n/#explicacion-teorica","text":"El despliegue de una aplicaci\u00f3n en Go puede realizarse de diversas formas, pero una de las m\u00e1s comunes es a trav\u00e9s de la compilaci\u00f3n del c\u00f3digo en un binario ejecutable que puede ser transferido a un servidor y ejecutado. Otra opci\u00f3n es utilizar contenedores como Docker para empaquetar la aplicaci\u00f3n junto con todas sus dependencias y desplegarla en un entorno de producci\u00f3n. Por otro lado, la integraci\u00f3n en Go se logra a trav\u00e9s del uso de librer\u00edas y paquetes que permiten la conexi\u00f3n y comunicaci\u00f3n con diferentes tecnolog\u00edas y servicios. Algunas de estas librer\u00edas incluyen HTTP, SQL y gRPC, entre otras. Tambi\u00e9n es posible integrar la aplicaci\u00f3n con servicios en la nube como AWS o Google Cloud Platform.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"go/jr/despliegue_e_integraci%C3%B3n/#palabras-clave-y-su-definicion","text":"Despliegue: proceso de puesta en producci\u00f3n de una aplicaci\u00f3n. Integraci\u00f3n: conexi\u00f3n de diferentes tecnolog\u00edas y servicios para trabajar juntos. Compilaci\u00f3n: proceso de convertir el c\u00f3digo fuente en un binario ejecutable. Contenedores: tecnolog\u00eda que permite empaquetar una aplicaci\u00f3n con todas sus dependencias para su despliegue en un entorno de producci\u00f3n. Librer\u00edas: conjunto de funciones y m\u00e9todos que pueden ser utilizados en una aplicaci\u00f3n para realizar una tarea espec\u00edfica. Paquetes: conjunto de librer\u00edas y archivos que pueden ser importados en una aplicaci\u00f3n. HTTP: protocolo de transferencia de hipertexto, utilizado para la comunicaci\u00f3n entre aplicaciones web. SQL: lenguaje de consultas estructurado, utilizado para comunicarse con bases de datos relacionales. gRPC: framework de comunicaci\u00f3n entre aplicaciones basado en el protocolo HTTP/2.","title":"Palabras clave y su definici\u00f3n"},{"location":"go/jr/despliegue_e_integraci%C3%B3n/#preguntas-de-repaso","text":"\u00bfCu\u00e1l es la diferencia entre despliegue e integraci\u00f3n en Go? \u00bfC\u00f3mo se puede desplegar una aplicaci\u00f3n en Go? \u00bfQu\u00e9 son los contenedores y c\u00f3mo se utilizan en el despliegue de aplicaciones en Go? \u00bfQu\u00e9 son las librer\u00edas y paquetes en Go? \u00bfCu\u00e1l es la importancia de la integraci\u00f3n en el desarrollo de aplicaciones en Go? \u00bfQu\u00e9 es HTTP y c\u00f3mo se utiliza en la integraci\u00f3n de aplicaciones en Go? \u00bfQu\u00e9 es SQL y c\u00f3mo se integra con aplicaciones en Go? \u00bfQu\u00e9 es gRPC y para qu\u00e9 se utiliza en la integraci\u00f3n de aplicaciones en Go?","title":"Preguntas de repaso"},{"location":"go/jr/despliegue_e_integraci%C3%B3n/#ejemplos-de-codigo-en-go-lang","text":"","title":"Ejemplos de c\u00f3digo en Go lang"},{"location":"go/jr/despliegue_e_integraci%C3%B3n/#ejemplo-de-despliegue-utilizando-compilacion","text":"// Archivo main . go package main import \"fmt\" func main () { fmt . Println ( \"Hola mundo!\" ) } En la terminal: go build main . go . / main","title":"Ejemplo de despliegue utilizando compilaci\u00f3n"},{"location":"go/jr/despliegue_e_integraci%C3%B3n/#ejemplo-de-despliegue-utilizando-contenedores","text":"// Archivo Dockerfile FROM golang : alpine COPY . / app WORKDIR / app RUN go build - o main . CMD [ \"/app/main\" ] En la terminal: docker build -t mi-app . docker run -p 8080:8080 mi-app","title":"Ejemplo de despliegue utilizando contenedores"},{"location":"go/jr/despliegue_e_integraci%C3%B3n/#ejemplo-de-integracion-con-http","text":"// Archivo main . go package main import ( \"fmt\" \"net/http\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { fmt . Fprint ( w , \"Hola mundo!\" ) }) http . ListenAndServe ( \":8080\" , nil ) }","title":"Ejemplo de integraci\u00f3n con HTTP"},{"location":"go/jr/despliegue_e_integraci%C3%B3n/#ejemplo-de-integracion-con-sql","text":"// Archivo main . go package main import ( \"database/sql\" \"fmt\" _ \"github.com/go-sql-driver/mysql\" ) func main () { db , err := sql . Open ( \"mysql\" , \"usuario:contrase\u00f1a@tcp(127.0.0.1:3306)/mi_db\" ) if err != nil { panic ( err . Error ()) } defer db . Close () result , err := db . Query ( \"SELECT * FROM usuarios\" ) if err != nil { panic ( err . Error ()) } for result . Next () { var id int var nombre string err = result . Scan ( & id , & nombre ) if err != nil { panic ( err . Error ()) } fmt . Println ( id , nombre ) } }","title":"Ejemplo de integraci\u00f3n con SQL"},{"location":"go/jr/despliegue_e_integraci%C3%B3n/#ejercicios-practicos-con-instrucciones-claras","text":"Despliegue una aplicaci\u00f3n en Go utilizando la t\u00e9cnica de compilaci\u00f3n. Despliegue una aplicaci\u00f3n en Go utilizando contenedores y Docker. Crea una aplicaci\u00f3n en Go que se comunique con una API externa utilizando la librer\u00eda HTTP. Integra una base de datos MySQL con una aplicaci\u00f3n en Go y realiza consultas utilizando SQL. Crea una aplicaci\u00f3n en Go que se comunique con un servicio en la nube como AWS o Google Cloud Platform.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"go/jr/despliegue_e_integraci%C3%B3n/#consejos-o-mejores-practicas","text":"Utiliza herramientas como Git y sistemas de control de versiones para facilitar el despliegue de tu aplicaci\u00f3n. Realiza pruebas en diferentes ambientes antes de realizar el despliegue en producci\u00f3n. Utiliza la modularidad en tu c\u00f3digo para facilitar la integraci\u00f3n con otras tecnolog\u00edas y servicios. Utiliza librer\u00edas y paquetes de confianza y mant\u00e9nlos actualizados para evitar problemas de seguridad.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"go/jr/estructuras_de_datos_y_variables/","text":"Estructuras de datos y variables en Go \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En este m\u00f3dulo, aprender\u00e1s sobre los tipos de datos, variables y constantes en Go. Adem\u00e1s, te familiarizar\u00e1s con el uso de estructuras de datos b\u00e1sicas como arrays, slices y maps. Esta lecci\u00f3n es esencial para comprender c\u00f3mo almacenar y manipular datos en Go y es fundamental para cualquier programador en este lenguaje. Explicaci\u00f3n te\u00f3rica \u00b6 Tipos de datos \u00b6 Los tipos de datos en Go se dividen en dos categor\u00edas: tipos b\u00e1sicos y tipos compuestos. Los tipos b\u00e1sicos son los tipos de datos m\u00e1s simples y se utilizan para representar valores num\u00e9ricos, booleanos y cadenas de texto. Algunos ejemplos de tipos b\u00e1sicos en Go son int para n\u00fameros enteros, float para n\u00fameros de punto flotante y string para cadenas de texto. Por otro lado, los tipos compuestos son tipos de datos que est\u00e1n formados por la combinaci\u00f3n de uno o m\u00e1s tipos b\u00e1sicos. Algunos ejemplos de tipos compuestos en Go son arrays, slices y maps, que se explicar\u00e1n m\u00e1s adelante en este m\u00f3dulo. Variables y constantes \u00b6 En Go, una variable es un nombre que se utiliza para almacenar un valor en la memoria. Para declarar una variable en Go, se utiliza la siguiente sintaxis: var nombre_variable tipo_dato Por ejemplo, para declarar una variable llamada edad de tipo int , se utilizar\u00eda la siguiente l\u00ednea de c\u00f3digo: var edad int Adem\u00e1s de las variables, tambi\u00e9n se pueden utilizar constantes en Go. Una constante es similar a una variable en el sentido de que tambi\u00e9n se utiliza para almacenar un valor en la memoria, pero a diferencia de una variable, su valor no puede cambiar durante la ejecuci\u00f3n del programa. Para declarar una constante en Go, se utiliza la siguiente sintaxis: const nombre_constante tipo_dato = valor Por ejemplo, para declarar una constante llamada pi de tipo float con valor 3.14, se utilizar\u00eda la siguiente l\u00ednea de c\u00f3digo: const pi float = 3.14 Estructuras de datos b\u00e1sicas \u00b6 Arrays \u00b6 Un array en Go es una estructura de datos que se utiliza para almacenar una colecci\u00f3n de elementos del mismo tipo. La principal caracter\u00edstica de los arrays es que tienen una longitud fija, lo que significa que una vez definidos, no se pueden modificar. La sintaxis para declarar un array en Go es la siguiente: var nombre_array [ longitud ] tipo_dato Donde nombre_array es el nombre del array, longitud es el n\u00famero de elementos que se pueden almacenar en el array y tipo_dato es el tipo de dato de los elementos que se almacenar\u00e1n en el array. Por ejemplo, para declarar un array llamado numeros con una longitud de 5 y de tipo int , se utilizar\u00eda la siguiente l\u00ednea de c\u00f3digo: var numeros [ 5 ] int Slices \u00b6 Un slice en Go es una estructura de datos similar a un array, pero con una longitud variable. Esto significa que se pueden agregar o eliminar elementos del slice durante la ejecuci\u00f3n del programa. La sintaxis para declarar un slice en Go es la siguiente: var nombre_slice [] tipo_dato Donde nombre_slice es el nombre del slice y tipo_dato es el tipo de dato de los elementos que se almacenar\u00e1n en el slice. Por ejemplo, para declarar un slice llamado nombres de tipo string , se utilizar\u00eda la siguiente l\u00ednea de c\u00f3digo: var nombres [] string Maps \u00b6 Un map en Go es una estructura de datos que se utiliza para almacenar una colecci\u00f3n de pares clave-valor. Esto significa que cada elemento en un map tiene una clave \u00fanica que se utiliza para acceder a su valor correspondiente. La sintaxis para declarar un map en Go es la siguiente: var nombre_map map [ tipo_clave ] tipo_valor Donde nombre_map es el nombre del map, tipo_clave es el tipo de dato de las claves y tipo_valor es el tipo de dato de los valores. Por ejemplo, para declarar un map llamado edades con claves de tipo string y valores de tipo int , se utilizar\u00eda la siguiente l\u00ednea de c\u00f3digo: var edades map [ string ] int Palabras clave y su definici\u00f3n \u00b6 int : tipo de dato que representa n\u00fameros enteros en Go. float : tipo de dato que representa n\u00fameros de punto flotante en Go. string : tipo de dato que representa cadenas de texto en Go. var : palabra clave utilizada para declarar variables en Go. const : palabra clave utilizada para declarar constantes en Go. array : estructura de datos que almacena una colecci\u00f3n de elementos del mismo tipo con una longitud fija. slice : estructura de datos que almacena una colecci\u00f3n de elementos del mismo tipo con una longitud variable. map : estructura de datos que almacena una colecci\u00f3n de pares clave-valor. Preguntas de repaso \u00b6 \u00bfCu\u00e1les son las dos categor\u00edas de tipos de datos en Go? \u00bfC\u00f3mo se declara una variable en Go? \u00bfCu\u00e1l es la principal diferencia entre un array y un slice? \u00bfC\u00f3mo se declara un map en Go? \u00bfQu\u00e9 es una constante en Go? Ejemplos de c\u00f3digo en Go lang \u00b6 Declaraci\u00f3n de una variable y una constante \u00b6 var nombre string // declaraci\u00f3n de una variable de tipo string nombre = \"Juan\" // asignaci\u00f3n del valor \"Juan\" a la variable nombre const pi float = 3.14 // declaraci\u00f3n de una constante de tipo float con valor 3.14 Declaraci\u00f3n de un array y un slice \u00b6 var numeros [ 5 ] int // declaraci\u00f3n de un array de tipo int con longitud 5 numeros [ 0 ] = 1 // asignaci\u00f3n del valor 1 al primer elemento del array numeros [ 1 ] = 2 // asignaci\u00f3n del valor 2 al segundo elemento del array var nombres [] string // declaraci\u00f3n de un slice de tipo string nombres = append ( nombres , \"Ana\" ) // agregamos el valor \"Ana\" al slice nombres = append ( nombres , \"Carlos\" ) // agregamos el valor \"Carlos\" al slice Declaraci\u00f3n de un map \u00b6 var edades map [ string ] int // declaraci\u00f3n de un map con claves de tipo string y valores de tipo int edades [ \"Ana\" ] = 25 // asignaci\u00f3n del valor 25 a la clave \"Ana\" edades [ \"Carlos\" ] = 30 // asignaci\u00f3n del valor 30 a la clave \"Carlos\" Ejercicios pr\u00e1cticos \u00b6 Crea un programa en Go que declare e imprima una variable de cada tipo b\u00e1sico. Crea una constante en Go con el valor de tu a\u00f1o de nacimiento y utiliza una variable para calcular tu edad y mostrarla en pantalla. Crea un programa en Go que declare un array de 5 n\u00fameros enteros y los muestre en pantalla. Crea un programa en Go que declare un slice de nombres y le permita al usuario agregar nuevos nombres a trav\u00e9s de la entrada est\u00e1ndar. Crea un programa en Go que declare un map con tus comidas favoritas y sus precios, y luego muestre la informaci\u00f3n en pantalla. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza nombres descriptivos para tus variables y constantes para que sea m\u00e1s f\u00e1cil entender tu c\u00f3digo. Aprovecha el poder de los slices y maps en lugar de utilizar arrays, ya que te permiten tener una mayor flexibilidad en la manipulaci\u00f3n de datos. Utiliza constantes en lugar de valores num\u00e9ricos o cadenas de texto directamente en tu c\u00f3digo, ya que esto ayuda a que tu c\u00f3digo sea m\u00e1s legible y f\u00e1cil de mantener. No olvides inicializar tus arrays, slices y maps antes de utilizarlos para evitar errores de ejecuci\u00f3n.","title":"Estructuras de datos y variables en Go"},{"location":"go/jr/estructuras_de_datos_y_variables/#estructuras-de-datos-y-variables-en-go","text":"","title":"Estructuras de datos y variables en Go"},{"location":"go/jr/estructuras_de_datos_y_variables/#descripcion-del-modulo","text":"En este m\u00f3dulo, aprender\u00e1s sobre los tipos de datos, variables y constantes en Go. Adem\u00e1s, te familiarizar\u00e1s con el uso de estructuras de datos b\u00e1sicas como arrays, slices y maps. Esta lecci\u00f3n es esencial para comprender c\u00f3mo almacenar y manipular datos en Go y es fundamental para cualquier programador en este lenguaje.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"go/jr/estructuras_de_datos_y_variables/#explicacion-teorica","text":"","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"go/jr/estructuras_de_datos_y_variables/#tipos-de-datos","text":"Los tipos de datos en Go se dividen en dos categor\u00edas: tipos b\u00e1sicos y tipos compuestos. Los tipos b\u00e1sicos son los tipos de datos m\u00e1s simples y se utilizan para representar valores num\u00e9ricos, booleanos y cadenas de texto. Algunos ejemplos de tipos b\u00e1sicos en Go son int para n\u00fameros enteros, float para n\u00fameros de punto flotante y string para cadenas de texto. Por otro lado, los tipos compuestos son tipos de datos que est\u00e1n formados por la combinaci\u00f3n de uno o m\u00e1s tipos b\u00e1sicos. Algunos ejemplos de tipos compuestos en Go son arrays, slices y maps, que se explicar\u00e1n m\u00e1s adelante en este m\u00f3dulo.","title":"Tipos de datos"},{"location":"go/jr/estructuras_de_datos_y_variables/#variables-y-constantes","text":"En Go, una variable es un nombre que se utiliza para almacenar un valor en la memoria. Para declarar una variable en Go, se utiliza la siguiente sintaxis: var nombre_variable tipo_dato Por ejemplo, para declarar una variable llamada edad de tipo int , se utilizar\u00eda la siguiente l\u00ednea de c\u00f3digo: var edad int Adem\u00e1s de las variables, tambi\u00e9n se pueden utilizar constantes en Go. Una constante es similar a una variable en el sentido de que tambi\u00e9n se utiliza para almacenar un valor en la memoria, pero a diferencia de una variable, su valor no puede cambiar durante la ejecuci\u00f3n del programa. Para declarar una constante en Go, se utiliza la siguiente sintaxis: const nombre_constante tipo_dato = valor Por ejemplo, para declarar una constante llamada pi de tipo float con valor 3.14, se utilizar\u00eda la siguiente l\u00ednea de c\u00f3digo: const pi float = 3.14","title":"Variables y constantes"},{"location":"go/jr/estructuras_de_datos_y_variables/#estructuras-de-datos-basicas","text":"","title":"Estructuras de datos b\u00e1sicas"},{"location":"go/jr/estructuras_de_datos_y_variables/#arrays","text":"Un array en Go es una estructura de datos que se utiliza para almacenar una colecci\u00f3n de elementos del mismo tipo. La principal caracter\u00edstica de los arrays es que tienen una longitud fija, lo que significa que una vez definidos, no se pueden modificar. La sintaxis para declarar un array en Go es la siguiente: var nombre_array [ longitud ] tipo_dato Donde nombre_array es el nombre del array, longitud es el n\u00famero de elementos que se pueden almacenar en el array y tipo_dato es el tipo de dato de los elementos que se almacenar\u00e1n en el array. Por ejemplo, para declarar un array llamado numeros con una longitud de 5 y de tipo int , se utilizar\u00eda la siguiente l\u00ednea de c\u00f3digo: var numeros [ 5 ] int","title":"Arrays"},{"location":"go/jr/estructuras_de_datos_y_variables/#slices","text":"Un slice en Go es una estructura de datos similar a un array, pero con una longitud variable. Esto significa que se pueden agregar o eliminar elementos del slice durante la ejecuci\u00f3n del programa. La sintaxis para declarar un slice en Go es la siguiente: var nombre_slice [] tipo_dato Donde nombre_slice es el nombre del slice y tipo_dato es el tipo de dato de los elementos que se almacenar\u00e1n en el slice. Por ejemplo, para declarar un slice llamado nombres de tipo string , se utilizar\u00eda la siguiente l\u00ednea de c\u00f3digo: var nombres [] string","title":"Slices"},{"location":"go/jr/estructuras_de_datos_y_variables/#maps","text":"Un map en Go es una estructura de datos que se utiliza para almacenar una colecci\u00f3n de pares clave-valor. Esto significa que cada elemento en un map tiene una clave \u00fanica que se utiliza para acceder a su valor correspondiente. La sintaxis para declarar un map en Go es la siguiente: var nombre_map map [ tipo_clave ] tipo_valor Donde nombre_map es el nombre del map, tipo_clave es el tipo de dato de las claves y tipo_valor es el tipo de dato de los valores. Por ejemplo, para declarar un map llamado edades con claves de tipo string y valores de tipo int , se utilizar\u00eda la siguiente l\u00ednea de c\u00f3digo: var edades map [ string ] int","title":"Maps"},{"location":"go/jr/estructuras_de_datos_y_variables/#palabras-clave-y-su-definicion","text":"int : tipo de dato que representa n\u00fameros enteros en Go. float : tipo de dato que representa n\u00fameros de punto flotante en Go. string : tipo de dato que representa cadenas de texto en Go. var : palabra clave utilizada para declarar variables en Go. const : palabra clave utilizada para declarar constantes en Go. array : estructura de datos que almacena una colecci\u00f3n de elementos del mismo tipo con una longitud fija. slice : estructura de datos que almacena una colecci\u00f3n de elementos del mismo tipo con una longitud variable. map : estructura de datos que almacena una colecci\u00f3n de pares clave-valor.","title":"Palabras clave y su definici\u00f3n"},{"location":"go/jr/estructuras_de_datos_y_variables/#preguntas-de-repaso","text":"\u00bfCu\u00e1les son las dos categor\u00edas de tipos de datos en Go? \u00bfC\u00f3mo se declara una variable en Go? \u00bfCu\u00e1l es la principal diferencia entre un array y un slice? \u00bfC\u00f3mo se declara un map en Go? \u00bfQu\u00e9 es una constante en Go?","title":"Preguntas de repaso"},{"location":"go/jr/estructuras_de_datos_y_variables/#ejemplos-de-codigo-en-go-lang","text":"","title":"Ejemplos de c\u00f3digo en Go lang"},{"location":"go/jr/estructuras_de_datos_y_variables/#declaracion-de-una-variable-y-una-constante","text":"var nombre string // declaraci\u00f3n de una variable de tipo string nombre = \"Juan\" // asignaci\u00f3n del valor \"Juan\" a la variable nombre const pi float = 3.14 // declaraci\u00f3n de una constante de tipo float con valor 3.14","title":"Declaraci\u00f3n de una variable y una constante"},{"location":"go/jr/estructuras_de_datos_y_variables/#declaracion-de-un-array-y-un-slice","text":"var numeros [ 5 ] int // declaraci\u00f3n de un array de tipo int con longitud 5 numeros [ 0 ] = 1 // asignaci\u00f3n del valor 1 al primer elemento del array numeros [ 1 ] = 2 // asignaci\u00f3n del valor 2 al segundo elemento del array var nombres [] string // declaraci\u00f3n de un slice de tipo string nombres = append ( nombres , \"Ana\" ) // agregamos el valor \"Ana\" al slice nombres = append ( nombres , \"Carlos\" ) // agregamos el valor \"Carlos\" al slice","title":"Declaraci\u00f3n de un array y un slice"},{"location":"go/jr/estructuras_de_datos_y_variables/#declaracion-de-un-map","text":"var edades map [ string ] int // declaraci\u00f3n de un map con claves de tipo string y valores de tipo int edades [ \"Ana\" ] = 25 // asignaci\u00f3n del valor 25 a la clave \"Ana\" edades [ \"Carlos\" ] = 30 // asignaci\u00f3n del valor 30 a la clave \"Carlos\"","title":"Declaraci\u00f3n de un map"},{"location":"go/jr/estructuras_de_datos_y_variables/#ejercicios-practicos","text":"Crea un programa en Go que declare e imprima una variable de cada tipo b\u00e1sico. Crea una constante en Go con el valor de tu a\u00f1o de nacimiento y utiliza una variable para calcular tu edad y mostrarla en pantalla. Crea un programa en Go que declare un array de 5 n\u00fameros enteros y los muestre en pantalla. Crea un programa en Go que declare un slice de nombres y le permita al usuario agregar nuevos nombres a trav\u00e9s de la entrada est\u00e1ndar. Crea un programa en Go que declare un map con tus comidas favoritas y sus precios, y luego muestre la informaci\u00f3n en pantalla.","title":"Ejercicios pr\u00e1cticos"},{"location":"go/jr/estructuras_de_datos_y_variables/#consejos-o-mejores-practicas","text":"Utiliza nombres descriptivos para tus variables y constantes para que sea m\u00e1s f\u00e1cil entender tu c\u00f3digo. Aprovecha el poder de los slices y maps en lugar de utilizar arrays, ya que te permiten tener una mayor flexibilidad en la manipulaci\u00f3n de datos. Utiliza constantes en lugar de valores num\u00e9ricos o cadenas de texto directamente en tu c\u00f3digo, ya que esto ayuda a que tu c\u00f3digo sea m\u00e1s legible y f\u00e1cil de mantener. No olvides inicializar tus arrays, slices y maps antes de utilizarlos para evitar errores de ejecuci\u00f3n.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"go/jr/funciones_y_paquetes/","text":"Funciones y Paquetes en Go \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En este m\u00f3dulo, aprenderemos sobre funciones y paquetes en Go lang. Las funciones son bloques de c\u00f3digo que realizan una tarea espec\u00edfica y pueden ser reutilizadas en diferentes partes de un programa. Los paquetes, por otro lado, son conjuntos de funciones y tipos de datos que se pueden importar y utilizar en un programa. Palabras clave y su definici\u00f3n \u00b6 Funci\u00f3n: Una funci\u00f3n es un bloque de c\u00f3digo que realiza una tarea espec\u00edfica y puede ser llamada desde diferentes partes del programa. Par\u00e1metro: Un par\u00e1metro es una variable que se define en la declaraci\u00f3n de una funci\u00f3n y que recibe un valor cuando se llama a la funci\u00f3n. Argumento: Un argumento es el valor que se pasa a una funci\u00f3n cuando se llama a la misma. Return: La palabra clave \"return\" se utiliza para devolver un valor de una funci\u00f3n. Paquete: Un paquete es un conjunto de funciones y tipos de datos que se pueden importar y utilizar en un programa. Import: La palabra clave \"import\" se utiliza para importar un paquete en un programa. Main: La funci\u00f3n \"main\" es el punto de entrada de un programa en Go. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es una funci\u00f3n en Go lang? \u00bfQu\u00e9 son los par\u00e1metros y argumentos en una funci\u00f3n? \u00bfCu\u00e1l es la palabra clave utilizada para devolver un valor en una funci\u00f3n? \u00bfQu\u00e9 es un paquete en Go lang? \u00bfC\u00f3mo se importa un paquete en un programa? \u00bfCu\u00e1l es la funci\u00f3n principal en Go lang y cu\u00e1l es su prop\u00f3sito? Ejemplos de c\u00f3digo en Go lang \u00b6 Funciones \u00b6 Una funci\u00f3n en Go lang se declara con la palabra clave \"func\" seguida del nombre de la funci\u00f3n y los par\u00e1metros entre par\u00e9ntesis. El cuerpo de la funci\u00f3n se define entre llaves. func sum ( a int , b int ) int { return a + b } func main () { result : = sum ( 2 , 3 ) fmt . Println ( result ) // Output : 5 } En el ejemplo anterior, se declara una funci\u00f3n llamada \"sum\" que toma dos par\u00e1metros de tipo entero y devuelve la suma de los mismos. Luego, en la funci\u00f3n \"main\" se llama a la funci\u00f3n \"sum\" con los argumentos 2 y 3, y se imprime el resultado. Paquetes \u00b6 Para utilizar un paquete en un programa de Go, primero se debe importar utilizando la palabra clave \"import\" seguida del nombre del paquete. import \"fmt\" func main () { fmt . Println ( \"Hola Mundo\" ) // Output : Hola Mundo } En este ejemplo, se importa el paquete \"fmt\" que contiene la funci\u00f3n \"Println\" para imprimir un mensaje en la consola. Luego, en la funci\u00f3n \"main\" se llama a la funci\u00f3n \"Println\" para imprimir el mensaje \"Hola Mundo\". Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una funci\u00f3n en Go lang que tome dos par\u00e1metros de tipo entero y devuelva el resultado de la multiplicaci\u00f3n de ambos. Importa el paquete \"math\" y utiliza la funci\u00f3n \"Pow\" para elevar un n\u00famero al cuadrado. Crea una funci\u00f3n para calcular la hipotenusa de un tri\u00e1ngulo rect\u00e1ngulo utilizando las funciones del paquete \"math\". Consejos o mejores pr\u00e1cticas \u00b6 Utiliza nombres descriptivos para tus funciones y variables para que sea m\u00e1s f\u00e1cil entender su prop\u00f3sito. Si una funci\u00f3n tiene m\u00faltiples par\u00e1metros, es recomendable utilizar tipos de datos diferentes para cada uno. Siempre verifica los errores al importar un paquete para evitar problemas en tu programa. Es una buena pr\u00e1ctica documentar tus funciones para que otros puedan entender su prop\u00f3sito y c\u00f3mo utilizarlas.","title":"Funciones y Paquetes en Go"},{"location":"go/jr/funciones_y_paquetes/#funciones-y-paquetes-en-go","text":"","title":"Funciones y Paquetes en Go"},{"location":"go/jr/funciones_y_paquetes/#descripcion-del-modulo","text":"En este m\u00f3dulo, aprenderemos sobre funciones y paquetes en Go lang. Las funciones son bloques de c\u00f3digo que realizan una tarea espec\u00edfica y pueden ser reutilizadas en diferentes partes de un programa. Los paquetes, por otro lado, son conjuntos de funciones y tipos de datos que se pueden importar y utilizar en un programa.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"go/jr/funciones_y_paquetes/#palabras-clave-y-su-definicion","text":"Funci\u00f3n: Una funci\u00f3n es un bloque de c\u00f3digo que realiza una tarea espec\u00edfica y puede ser llamada desde diferentes partes del programa. Par\u00e1metro: Un par\u00e1metro es una variable que se define en la declaraci\u00f3n de una funci\u00f3n y que recibe un valor cuando se llama a la funci\u00f3n. Argumento: Un argumento es el valor que se pasa a una funci\u00f3n cuando se llama a la misma. Return: La palabra clave \"return\" se utiliza para devolver un valor de una funci\u00f3n. Paquete: Un paquete es un conjunto de funciones y tipos de datos que se pueden importar y utilizar en un programa. Import: La palabra clave \"import\" se utiliza para importar un paquete en un programa. Main: La funci\u00f3n \"main\" es el punto de entrada de un programa en Go.","title":"Palabras clave y su definici\u00f3n"},{"location":"go/jr/funciones_y_paquetes/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es una funci\u00f3n en Go lang? \u00bfQu\u00e9 son los par\u00e1metros y argumentos en una funci\u00f3n? \u00bfCu\u00e1l es la palabra clave utilizada para devolver un valor en una funci\u00f3n? \u00bfQu\u00e9 es un paquete en Go lang? \u00bfC\u00f3mo se importa un paquete en un programa? \u00bfCu\u00e1l es la funci\u00f3n principal en Go lang y cu\u00e1l es su prop\u00f3sito?","title":"Preguntas de repaso"},{"location":"go/jr/funciones_y_paquetes/#ejemplos-de-codigo-en-go-lang","text":"","title":"Ejemplos de c\u00f3digo en Go lang"},{"location":"go/jr/funciones_y_paquetes/#funciones","text":"Una funci\u00f3n en Go lang se declara con la palabra clave \"func\" seguida del nombre de la funci\u00f3n y los par\u00e1metros entre par\u00e9ntesis. El cuerpo de la funci\u00f3n se define entre llaves. func sum ( a int , b int ) int { return a + b } func main () { result : = sum ( 2 , 3 ) fmt . Println ( result ) // Output : 5 } En el ejemplo anterior, se declara una funci\u00f3n llamada \"sum\" que toma dos par\u00e1metros de tipo entero y devuelve la suma de los mismos. Luego, en la funci\u00f3n \"main\" se llama a la funci\u00f3n \"sum\" con los argumentos 2 y 3, y se imprime el resultado.","title":"Funciones"},{"location":"go/jr/funciones_y_paquetes/#paquetes","text":"Para utilizar un paquete en un programa de Go, primero se debe importar utilizando la palabra clave \"import\" seguida del nombre del paquete. import \"fmt\" func main () { fmt . Println ( \"Hola Mundo\" ) // Output : Hola Mundo } En este ejemplo, se importa el paquete \"fmt\" que contiene la funci\u00f3n \"Println\" para imprimir un mensaje en la consola. Luego, en la funci\u00f3n \"main\" se llama a la funci\u00f3n \"Println\" para imprimir el mensaje \"Hola Mundo\".","title":"Paquetes"},{"location":"go/jr/funciones_y_paquetes/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una funci\u00f3n en Go lang que tome dos par\u00e1metros de tipo entero y devuelva el resultado de la multiplicaci\u00f3n de ambos. Importa el paquete \"math\" y utiliza la funci\u00f3n \"Pow\" para elevar un n\u00famero al cuadrado. Crea una funci\u00f3n para calcular la hipotenusa de un tri\u00e1ngulo rect\u00e1ngulo utilizando las funciones del paquete \"math\".","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"go/jr/funciones_y_paquetes/#consejos-o-mejores-practicas","text":"Utiliza nombres descriptivos para tus funciones y variables para que sea m\u00e1s f\u00e1cil entender su prop\u00f3sito. Si una funci\u00f3n tiene m\u00faltiples par\u00e1metros, es recomendable utilizar tipos de datos diferentes para cada uno. Siempre verifica los errores al importar un paquete para evitar problemas en tu programa. Es una buena pr\u00e1ctica documentar tus funciones para que otros puedan entender su prop\u00f3sito y c\u00f3mo utilizarlas.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"go/jr/instalaci%C3%B3n_de_go/","text":"Instalaci\u00f3n de Go \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En este m\u00f3dulo, aprender\u00e1s c\u00f3mo instalar y configurar Go en diferentes sistemas operativos. Go es un lenguaje de programaci\u00f3n de c\u00f3digo abierto desarrollado por Google, dise\u00f1ado para ser eficiente, sencillo y r\u00e1pido. A trav\u00e9s de este m\u00f3dulo, podr\u00e1s entender c\u00f3mo instalar Go en tu sistema y c\u00f3mo configurar tu entorno de desarrollo para empezar a programar en este lenguaje. Palabras clave y su definici\u00f3n \u00b6 Lenguaje de programaci\u00f3n: conjunto de reglas y s\u00edmbolos utilizados para crear programas inform\u00e1ticos. C\u00f3digo abierto: software cuyo c\u00f3digo fuente es accesible y modificable por cualquier persona. Eficiencia: capacidad de lograr un resultado con el m\u00ednimo de recursos. Sencillo: f\u00e1cil de entender y utilizar. Entorno de desarrollo: conjunto de herramientas y configuraciones utilizadas para escribir y depurar c\u00f3digo. Programar: escribir c\u00f3digo para crear un programa inform\u00e1tico. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es Go y para qu\u00e9 fue creado? \u00bfQu\u00e9 significa que Go sea un lenguaje de c\u00f3digo abierto? \u00bfCu\u00e1les son las caracter\u00edsticas principales de Go? \u00bfQu\u00e9 es un entorno de desarrollo? \u00bfPor qu\u00e9 es importante configurar correctamente el entorno de desarrollo para programar en Go? Ejemplos de c\u00f3digo en Go \u00b6 Hola mundo en Go \u00b6 package main import \"fmt\" func main () { fmt . Println ( \"Hola mundo!\" ) } Declaraci\u00f3n de variables en Go \u00b6 package main import \"fmt\" func main () { // Declaraci\u00f3n de una variable entera var edad int edad = 25 // Declaraci\u00f3n de una variable string var nombre string = \"Juan\" // Declaraci\u00f3n de una variable booleana var esMayor bool = true fmt . Println ( \"Mi nombre es\" , nombre , \"y tengo\" , edad , \"a\u00f1os.\" ) fmt . Println ( \"\u00bfSoy mayor de edad?\" , esMayor ) } Ejercicios pr\u00e1cticos \u00b6 Instala Go en tu sistema operativo siguiendo los pasos que se explican a continuaci\u00f3n. Configura tu entorno de desarrollo para programar en Go. Escribe un programa que solicite al usuario su nombre y edad, y luego imprima un mensaje con esa informaci\u00f3n. Instrucciones para instalar Go en diferentes sistemas operativos \u00b6 Windows \u00b6 Descarga el instalador de Go desde la p\u00e1gina oficial: https://golang.org/dl/ Ejecuta el instalador y sigue las instrucciones. Una vez finalizada la instalaci\u00f3n, verifica que se haya configurado correctamente ejecutando el comando go version en la terminal. Deber\u00eda mostrar la versi\u00f3n de Go instalada. macOS \u00b6 Descarga el archivo .pkg de Go desde la p\u00e1gina oficial: https://golang.org/dl/ Ejecuta el archivo descargado y sigue las instrucciones. Una vez finalizada la instalaci\u00f3n, verifica que se haya configurado correctamente ejecutando el comando go version en la terminal. Deber\u00eda mostrar la versi\u00f3n de Go instalada. Linux \u00b6 Abre la terminal y ejecuta el siguiente comando para descargar el archivo de instalaci\u00f3n de Go: wget https://golang.org/dl/go<version>.linux-amd64.tar.gz (reemplaza <version> por la versi\u00f3n m\u00e1s reciente disponible). Descomprime el archivo descargado con el comando tar -xvf go<version>.linux-amd64.tar.gz . Mueve la carpeta resultante a una ubicaci\u00f3n adecuada en tu sistema con el comando sudo mv go /usr/local . Configura las variables de entorno ejecutando los siguientes comandos en la terminal: export GOPATH=$HOME/go export PATH=$PATH:/usr/local/go/bin:$GOPATH/bin Verifica que se haya configurado correctamente ejecutando el comando go version en la terminal. Deber\u00eda mostrar la versi\u00f3n de Go instalada. Consejos y mejores pr\u00e1cticas \u00b6 Es importante verificar que la instalaci\u00f3n y configuraci\u00f3n de Go se hayan realizado correctamente antes de comenzar a programar. Siempre utiliza la versi\u00f3n m\u00e1s reciente de Go para aprovechar las mejoras y correcciones de errores. Aseg\u00farate de tener suficiente espacio en tu sistema antes de instalar Go, ya que suele ocupar varios gigabytes. Sigue las instrucciones de instalaci\u00f3n espec\u00edficas para tu sistema operativo para evitar errores. Actualiza regularmente tu entorno de desarrollo y las herramientas que utilices para programar en Go.","title":"Instalaci\u00f3n de Go"},{"location":"go/jr/instalaci%C3%B3n_de_go/#instalacion-de-go","text":"","title":"Instalaci\u00f3n de Go"},{"location":"go/jr/instalaci%C3%B3n_de_go/#descripcion-del-modulo","text":"En este m\u00f3dulo, aprender\u00e1s c\u00f3mo instalar y configurar Go en diferentes sistemas operativos. Go es un lenguaje de programaci\u00f3n de c\u00f3digo abierto desarrollado por Google, dise\u00f1ado para ser eficiente, sencillo y r\u00e1pido. A trav\u00e9s de este m\u00f3dulo, podr\u00e1s entender c\u00f3mo instalar Go en tu sistema y c\u00f3mo configurar tu entorno de desarrollo para empezar a programar en este lenguaje.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"go/jr/instalaci%C3%B3n_de_go/#palabras-clave-y-su-definicion","text":"Lenguaje de programaci\u00f3n: conjunto de reglas y s\u00edmbolos utilizados para crear programas inform\u00e1ticos. C\u00f3digo abierto: software cuyo c\u00f3digo fuente es accesible y modificable por cualquier persona. Eficiencia: capacidad de lograr un resultado con el m\u00ednimo de recursos. Sencillo: f\u00e1cil de entender y utilizar. Entorno de desarrollo: conjunto de herramientas y configuraciones utilizadas para escribir y depurar c\u00f3digo. Programar: escribir c\u00f3digo para crear un programa inform\u00e1tico.","title":"Palabras clave y su definici\u00f3n"},{"location":"go/jr/instalaci%C3%B3n_de_go/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Go y para qu\u00e9 fue creado? \u00bfQu\u00e9 significa que Go sea un lenguaje de c\u00f3digo abierto? \u00bfCu\u00e1les son las caracter\u00edsticas principales de Go? \u00bfQu\u00e9 es un entorno de desarrollo? \u00bfPor qu\u00e9 es importante configurar correctamente el entorno de desarrollo para programar en Go?","title":"Preguntas de repaso"},{"location":"go/jr/instalaci%C3%B3n_de_go/#ejemplos-de-codigo-en-go","text":"","title":"Ejemplos de c\u00f3digo en Go"},{"location":"go/jr/instalaci%C3%B3n_de_go/#hola-mundo-en-go","text":"package main import \"fmt\" func main () { fmt . Println ( \"Hola mundo!\" ) }","title":"Hola mundo en Go"},{"location":"go/jr/instalaci%C3%B3n_de_go/#declaracion-de-variables-en-go","text":"package main import \"fmt\" func main () { // Declaraci\u00f3n de una variable entera var edad int edad = 25 // Declaraci\u00f3n de una variable string var nombre string = \"Juan\" // Declaraci\u00f3n de una variable booleana var esMayor bool = true fmt . Println ( \"Mi nombre es\" , nombre , \"y tengo\" , edad , \"a\u00f1os.\" ) fmt . Println ( \"\u00bfSoy mayor de edad?\" , esMayor ) }","title":"Declaraci\u00f3n de variables en Go"},{"location":"go/jr/instalaci%C3%B3n_de_go/#ejercicios-practicos","text":"Instala Go en tu sistema operativo siguiendo los pasos que se explican a continuaci\u00f3n. Configura tu entorno de desarrollo para programar en Go. Escribe un programa que solicite al usuario su nombre y edad, y luego imprima un mensaje con esa informaci\u00f3n.","title":"Ejercicios pr\u00e1cticos"},{"location":"go/jr/instalaci%C3%B3n_de_go/#instrucciones-para-instalar-go-en-diferentes-sistemas-operativos","text":"","title":"Instrucciones para instalar Go en diferentes sistemas operativos"},{"location":"go/jr/instalaci%C3%B3n_de_go/#windows","text":"Descarga el instalador de Go desde la p\u00e1gina oficial: https://golang.org/dl/ Ejecuta el instalador y sigue las instrucciones. Una vez finalizada la instalaci\u00f3n, verifica que se haya configurado correctamente ejecutando el comando go version en la terminal. Deber\u00eda mostrar la versi\u00f3n de Go instalada.","title":"Windows"},{"location":"go/jr/instalaci%C3%B3n_de_go/#macos","text":"Descarga el archivo .pkg de Go desde la p\u00e1gina oficial: https://golang.org/dl/ Ejecuta el archivo descargado y sigue las instrucciones. Una vez finalizada la instalaci\u00f3n, verifica que se haya configurado correctamente ejecutando el comando go version en la terminal. Deber\u00eda mostrar la versi\u00f3n de Go instalada.","title":"macOS"},{"location":"go/jr/instalaci%C3%B3n_de_go/#linux","text":"Abre la terminal y ejecuta el siguiente comando para descargar el archivo de instalaci\u00f3n de Go: wget https://golang.org/dl/go<version>.linux-amd64.tar.gz (reemplaza <version> por la versi\u00f3n m\u00e1s reciente disponible). Descomprime el archivo descargado con el comando tar -xvf go<version>.linux-amd64.tar.gz . Mueve la carpeta resultante a una ubicaci\u00f3n adecuada en tu sistema con el comando sudo mv go /usr/local . Configura las variables de entorno ejecutando los siguientes comandos en la terminal: export GOPATH=$HOME/go export PATH=$PATH:/usr/local/go/bin:$GOPATH/bin Verifica que se haya configurado correctamente ejecutando el comando go version en la terminal. Deber\u00eda mostrar la versi\u00f3n de Go instalada.","title":"Linux"},{"location":"go/jr/instalaci%C3%B3n_de_go/#consejos-y-mejores-practicas","text":"Es importante verificar que la instalaci\u00f3n y configuraci\u00f3n de Go se hayan realizado correctamente antes de comenzar a programar. Siempre utiliza la versi\u00f3n m\u00e1s reciente de Go para aprovechar las mejoras y correcciones de errores. Aseg\u00farate de tener suficiente espacio en tu sistema antes de instalar Go, ya que suele ocupar varios gigabytes. Sigue las instrucciones de instalaci\u00f3n espec\u00edficas para tu sistema operativo para evitar errores. Actualiza regularmente tu entorno de desarrollo y las herramientas que utilices para programar en Go.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"go/jr/introducci%C3%B3n_a_go/","text":"Introducci\u00f3n a Go \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En este m\u00f3dulo, aprenderemos sobre Go, un lenguaje de programaci\u00f3n de c\u00f3digo abierto creado por Google en el a\u00f1o 2009. Exploraremos su breve historia, caracter\u00edsticas y su uso en la actualidad. Al final de este m\u00f3dulo, tendr\u00e1s una comprensi\u00f3n b\u00e1sica de Go y estar\u00e1s listo para comenzar a escribir tus propios programas en este lenguaje. Explicaci\u00f3n te\u00f3rica \u00b6 Go es un lenguaje de programaci\u00f3n compilado y concurrente dise\u00f1ado para construir aplicaciones escalables y eficientes. Fue creado por Robert Griesemer, Rob Pike y Ken Thompson en Google, inspirados en otros lenguajes como C, Pascal y Oberon. Una de las principales caracter\u00edsticas de Go es su enfoque en la simplicidad y legibilidad del c\u00f3digo. Esto se logra mediante la eliminaci\u00f3n de caracter\u00edsticas complejas y redundantes presentes en otros lenguajes. Go tambi\u00e9n se destaca por su capacidad para manejar la concurrencia de manera eficiente, lo que lo hace ideal para aplicaciones web y de servidor. Palabras clave y su definici\u00f3n \u00b6 Lenguaje de programaci\u00f3n: un conjunto de s\u00edmbolos y reglas utilizados para crear programas de computadora. C\u00f3digo abierto: un software cuyo c\u00f3digo fuente est\u00e1 disponible para su uso, modificaci\u00f3n y distribuci\u00f3n por parte de cualquier persona. Compilado: un programa que traduce el c\u00f3digo escrito por un programador a un lenguaje que la computadora puede entender y ejecutar. Concurrente: la capacidad de realizar varias tareas al mismo tiempo. Simplicidad: la cualidad de ser f\u00e1cil de entender y usar. Legibilidad: la facilidad con la que el c\u00f3digo puede ser le\u00eddo y comprendido por otros programadores. Preguntas de repaso \u00b6 \u00bfQui\u00e9nes crearon Go? \u00bfEn qu\u00e9 a\u00f1o fue creado Go? \u00bfQu\u00e9 inspir\u00f3 el dise\u00f1o de Go? \u00bfCu\u00e1l es una de las principales caracter\u00edsticas de Go? \u00bfPara qu\u00e9 tipo de aplicaciones es ideal Go? Ejemplos de c\u00f3digo en Go lang \u00b6 Hola mundo \u00b6 package main import \"fmt\" func main () { fmt . Println ( \"Hola mundo\" ) } Funci\u00f3n factorial \u00b6 package main import \"fmt\" func factorial ( n int ) int { if n == 0 { return 1 } return n * factorial ( n - 1 ) } func main () { fmt . Println ( factorial ( 5 )) // salida: 120 } Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Escribe un programa en Go que imprima los n\u00fameros del 1 al 10. Crea una funci\u00f3n en Go que calcule el \u00e1rea de un tri\u00e1ngulo dado su base y altura. Escribe un programa en Go que ordene un arreglo de n\u00fameros de manera ascendente utilizando el algoritmo de burbuja. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza nombres descriptivos para tus variables y funciones. Aprovecha la concurrencia de Go para crear aplicaciones eficientes y escalables. Lee y sigue las convenciones de estilo de c\u00f3digo de Go para mantener una base de c\u00f3digo consistente y legible.","title":"Introducci\u00f3n a Go"},{"location":"go/jr/introducci%C3%B3n_a_go/#introduccion-a-go","text":"","title":"Introducci\u00f3n a Go"},{"location":"go/jr/introducci%C3%B3n_a_go/#descripcion-del-modulo","text":"En este m\u00f3dulo, aprenderemos sobre Go, un lenguaje de programaci\u00f3n de c\u00f3digo abierto creado por Google en el a\u00f1o 2009. Exploraremos su breve historia, caracter\u00edsticas y su uso en la actualidad. Al final de este m\u00f3dulo, tendr\u00e1s una comprensi\u00f3n b\u00e1sica de Go y estar\u00e1s listo para comenzar a escribir tus propios programas en este lenguaje.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"go/jr/introducci%C3%B3n_a_go/#explicacion-teorica","text":"Go es un lenguaje de programaci\u00f3n compilado y concurrente dise\u00f1ado para construir aplicaciones escalables y eficientes. Fue creado por Robert Griesemer, Rob Pike y Ken Thompson en Google, inspirados en otros lenguajes como C, Pascal y Oberon. Una de las principales caracter\u00edsticas de Go es su enfoque en la simplicidad y legibilidad del c\u00f3digo. Esto se logra mediante la eliminaci\u00f3n de caracter\u00edsticas complejas y redundantes presentes en otros lenguajes. Go tambi\u00e9n se destaca por su capacidad para manejar la concurrencia de manera eficiente, lo que lo hace ideal para aplicaciones web y de servidor.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"go/jr/introducci%C3%B3n_a_go/#palabras-clave-y-su-definicion","text":"Lenguaje de programaci\u00f3n: un conjunto de s\u00edmbolos y reglas utilizados para crear programas de computadora. C\u00f3digo abierto: un software cuyo c\u00f3digo fuente est\u00e1 disponible para su uso, modificaci\u00f3n y distribuci\u00f3n por parte de cualquier persona. Compilado: un programa que traduce el c\u00f3digo escrito por un programador a un lenguaje que la computadora puede entender y ejecutar. Concurrente: la capacidad de realizar varias tareas al mismo tiempo. Simplicidad: la cualidad de ser f\u00e1cil de entender y usar. Legibilidad: la facilidad con la que el c\u00f3digo puede ser le\u00eddo y comprendido por otros programadores.","title":"Palabras clave y su definici\u00f3n"},{"location":"go/jr/introducci%C3%B3n_a_go/#preguntas-de-repaso","text":"\u00bfQui\u00e9nes crearon Go? \u00bfEn qu\u00e9 a\u00f1o fue creado Go? \u00bfQu\u00e9 inspir\u00f3 el dise\u00f1o de Go? \u00bfCu\u00e1l es una de las principales caracter\u00edsticas de Go? \u00bfPara qu\u00e9 tipo de aplicaciones es ideal Go?","title":"Preguntas de repaso"},{"location":"go/jr/introducci%C3%B3n_a_go/#ejemplos-de-codigo-en-go-lang","text":"","title":"Ejemplos de c\u00f3digo en Go lang"},{"location":"go/jr/introducci%C3%B3n_a_go/#hola-mundo","text":"package main import \"fmt\" func main () { fmt . Println ( \"Hola mundo\" ) }","title":"Hola mundo"},{"location":"go/jr/introducci%C3%B3n_a_go/#funcion-factorial","text":"package main import \"fmt\" func factorial ( n int ) int { if n == 0 { return 1 } return n * factorial ( n - 1 ) } func main () { fmt . Println ( factorial ( 5 )) // salida: 120 }","title":"Funci\u00f3n factorial"},{"location":"go/jr/introducci%C3%B3n_a_go/#ejercicios-practicos-con-instrucciones-claras","text":"Escribe un programa en Go que imprima los n\u00fameros del 1 al 10. Crea una funci\u00f3n en Go que calcule el \u00e1rea de un tri\u00e1ngulo dado su base y altura. Escribe un programa en Go que ordene un arreglo de n\u00fameros de manera ascendente utilizando el algoritmo de burbuja.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"go/jr/introducci%C3%B3n_a_go/#consejos-o-mejores-practicas","text":"Utiliza nombres descriptivos para tus variables y funciones. Aprovecha la concurrencia de Go para crear aplicaciones eficientes y escalables. Lee y sigue las convenciones de estilo de c\u00f3digo de Go para mantener una base de c\u00f3digo consistente y legible.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"go/jr/manejo_de_errores/","text":"Manejo de errores en Go lang \u00b6 El manejo de errores es una parte fundamental en cualquier lenguaje de programaci\u00f3n, ya que permite controlar y manejar situaciones inesperadas que pueden ocurrir durante la ejecuci\u00f3n de un programa. En Go lang, el manejo de errores se realiza a trav\u00e9s de estructuras de errores y manejo de excepciones. Explicaci\u00f3n te\u00f3rica \u00b6 En Go lang, los errores se manejan a trav\u00e9s de la interfaz error , que es una estructura que contiene un mensaje descriptivo del error. Esta interfaz se puede utilizar para crear tipos de errores personalizados o para devolver errores espec\u00edficos en funciones y m\u00e9todos. Para manejar los errores, se utiliza la declaraci\u00f3n if para verificar si el valor de error es diferente de nil , lo que indica que ha ocurrido un error. En caso de que haya ocurrido un error, se puede utilizar la declaraci\u00f3n log.Fatal() para imprimir el mensaje de error y terminar la ejecuci\u00f3n del programa. Adem\u00e1s, Go lang tambi\u00e9n cuenta con la declaraci\u00f3n defer que permite ejecutar una funci\u00f3n al final de una funci\u00f3n, incluso si ocurre un error durante su ejecuci\u00f3n. Esto es \u00fatil para realizar tareas de limpieza o cierre de recursos. Palabras clave y su definici\u00f3n \u00b6 Error: Una situaci\u00f3n inesperada o no deseada que ocurre durante la ejecuci\u00f3n de un programa. Interfaz error : Una estructura que contiene un mensaje descriptivo del error. nil : Un valor nulo que indica que no ha ocurrido ning\u00fan error. Declaraci\u00f3n if : Una estructura de control que permite evaluar una condici\u00f3n y ejecutar un bloque de c\u00f3digo si la condici\u00f3n es verdadera. Declaraci\u00f3n log.Fatal() : Una funci\u00f3n que imprime un mensaje de error y termina la ejecuci\u00f3n del programa. Declaraci\u00f3n defer : Una estructura de control que permite ejecutar una funci\u00f3n al final de una funci\u00f3n, incluso si ocurre un error durante su ejecuci\u00f3n. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es un error en Go lang? \u00bfC\u00f3mo se manejan los errores en Go lang? \u00bfQu\u00e9 es la interfaz error y para qu\u00e9 se utiliza? \u00bfQu\u00e9 significa el valor nil en Go lang? \u00bfQu\u00e9 es la declaraci\u00f3n if y c\u00f3mo se utiliza en el manejo de errores? \u00bfCu\u00e1l es la funci\u00f3n de la declaraci\u00f3n log.Fatal() ? \u00bfPara qu\u00e9 se utiliza la declaraci\u00f3n defer en el manejo de errores? Ejemplos de c\u00f3digo en Go lang \u00b6 Creaci\u00f3n de un error personalizado: package main import ( \"errors\" \"fmt\" ) func divide ( dividend , divisor float64 ) ( float64 , error ) { if divisor == 0 { return 0 , errors . New ( \"No se puede dividir por cero\" ) } return dividend / divisor , nil } func main () { result , err := divide ( 10 , 0 ) if err != nil { fmt . Println ( err ) } else { fmt . Println ( result ) } } Manejo de errores con la declaraci\u00f3n if y log.Fatal() : package main import ( \"log\" ) func divide ( dividend , divisor float64 ) float64 { if divisor == 0 { log . Fatal ( \"No se puede dividir por cero\" ) } return dividend / divisor } func main () { result := divide ( 10 , 0 ) } Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una funci\u00f3n que acepte dos n\u00fameros enteros como par\u00e1metros y devuelva la divisi\u00f3n de ambos. En caso de que el divisor sea cero, devuelve un error personalizado. Escribe un programa que lea un archivo de texto y cuente el n\u00famero de l\u00edneas que contiene. En caso de que ocurra un error, imprime un mensaje de error y termina la ejecuci\u00f3n. Crea una funci\u00f3n que reciba un n\u00famero entero y devuelva su ra\u00edz cuadrada. En caso de que el n\u00famero sea negativo, devuelve un error personalizado. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza errores personalizados para proporcionar informaci\u00f3n m\u00e1s espec\u00edfica sobre el error que ha ocurrido. Utiliza la declaraci\u00f3n defer para realizar tareas de limpieza o cierre de recursos. Evita manejar los errores de manera gen\u00e9rica, trata de manejarlos de manera espec\u00edfica seg\u00fan el tipo de error que pueda ocurrir.","title":"Manejo de errores en Go lang"},{"location":"go/jr/manejo_de_errores/#manejo-de-errores-en-go-lang","text":"El manejo de errores es una parte fundamental en cualquier lenguaje de programaci\u00f3n, ya que permite controlar y manejar situaciones inesperadas que pueden ocurrir durante la ejecuci\u00f3n de un programa. En Go lang, el manejo de errores se realiza a trav\u00e9s de estructuras de errores y manejo de excepciones.","title":"Manejo de errores en Go lang"},{"location":"go/jr/manejo_de_errores/#explicacion-teorica","text":"En Go lang, los errores se manejan a trav\u00e9s de la interfaz error , que es una estructura que contiene un mensaje descriptivo del error. Esta interfaz se puede utilizar para crear tipos de errores personalizados o para devolver errores espec\u00edficos en funciones y m\u00e9todos. Para manejar los errores, se utiliza la declaraci\u00f3n if para verificar si el valor de error es diferente de nil , lo que indica que ha ocurrido un error. En caso de que haya ocurrido un error, se puede utilizar la declaraci\u00f3n log.Fatal() para imprimir el mensaje de error y terminar la ejecuci\u00f3n del programa. Adem\u00e1s, Go lang tambi\u00e9n cuenta con la declaraci\u00f3n defer que permite ejecutar una funci\u00f3n al final de una funci\u00f3n, incluso si ocurre un error durante su ejecuci\u00f3n. Esto es \u00fatil para realizar tareas de limpieza o cierre de recursos.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"go/jr/manejo_de_errores/#palabras-clave-y-su-definicion","text":"Error: Una situaci\u00f3n inesperada o no deseada que ocurre durante la ejecuci\u00f3n de un programa. Interfaz error : Una estructura que contiene un mensaje descriptivo del error. nil : Un valor nulo que indica que no ha ocurrido ning\u00fan error. Declaraci\u00f3n if : Una estructura de control que permite evaluar una condici\u00f3n y ejecutar un bloque de c\u00f3digo si la condici\u00f3n es verdadera. Declaraci\u00f3n log.Fatal() : Una funci\u00f3n que imprime un mensaje de error y termina la ejecuci\u00f3n del programa. Declaraci\u00f3n defer : Una estructura de control que permite ejecutar una funci\u00f3n al final de una funci\u00f3n, incluso si ocurre un error durante su ejecuci\u00f3n.","title":"Palabras clave y su definici\u00f3n"},{"location":"go/jr/manejo_de_errores/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es un error en Go lang? \u00bfC\u00f3mo se manejan los errores en Go lang? \u00bfQu\u00e9 es la interfaz error y para qu\u00e9 se utiliza? \u00bfQu\u00e9 significa el valor nil en Go lang? \u00bfQu\u00e9 es la declaraci\u00f3n if y c\u00f3mo se utiliza en el manejo de errores? \u00bfCu\u00e1l es la funci\u00f3n de la declaraci\u00f3n log.Fatal() ? \u00bfPara qu\u00e9 se utiliza la declaraci\u00f3n defer en el manejo de errores?","title":"Preguntas de repaso"},{"location":"go/jr/manejo_de_errores/#ejemplos-de-codigo-en-go-lang","text":"Creaci\u00f3n de un error personalizado: package main import ( \"errors\" \"fmt\" ) func divide ( dividend , divisor float64 ) ( float64 , error ) { if divisor == 0 { return 0 , errors . New ( \"No se puede dividir por cero\" ) } return dividend / divisor , nil } func main () { result , err := divide ( 10 , 0 ) if err != nil { fmt . Println ( err ) } else { fmt . Println ( result ) } } Manejo de errores con la declaraci\u00f3n if y log.Fatal() : package main import ( \"log\" ) func divide ( dividend , divisor float64 ) float64 { if divisor == 0 { log . Fatal ( \"No se puede dividir por cero\" ) } return dividend / divisor } func main () { result := divide ( 10 , 0 ) }","title":"Ejemplos de c\u00f3digo en Go lang"},{"location":"go/jr/manejo_de_errores/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una funci\u00f3n que acepte dos n\u00fameros enteros como par\u00e1metros y devuelva la divisi\u00f3n de ambos. En caso de que el divisor sea cero, devuelve un error personalizado. Escribe un programa que lea un archivo de texto y cuente el n\u00famero de l\u00edneas que contiene. En caso de que ocurra un error, imprime un mensaje de error y termina la ejecuci\u00f3n. Crea una funci\u00f3n que reciba un n\u00famero entero y devuelva su ra\u00edz cuadrada. En caso de que el n\u00famero sea negativo, devuelve un error personalizado.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"go/jr/manejo_de_errores/#consejos-o-mejores-practicas","text":"Utiliza errores personalizados para proporcionar informaci\u00f3n m\u00e1s espec\u00edfica sobre el error que ha ocurrido. Utiliza la declaraci\u00f3n defer para realizar tareas de limpieza o cierre de recursos. Evita manejar los errores de manera gen\u00e9rica, trata de manejarlos de manera espec\u00edfica seg\u00fan el tipo de error que pueda ocurrir.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"go/jr/programaci%C3%B3n_orientada_a_objetos/","text":"Programaci\u00f3n orientada a objetos en Go \u00b6 La programaci\u00f3n orientada a objetos (POO) es un paradigma de programaci\u00f3n que se basa en la creaci\u00f3n de objetos que tienen propiedades y m\u00e9todos. Esta metodolog\u00eda de programaci\u00f3n ayuda a organizar y estructurar mejor el c\u00f3digo, lo que lo hace m\u00e1s f\u00e1cil de leer, mantener y escalar. En Go, un lenguaje de programaci\u00f3n compilado desarrollado por Google, tambi\u00e9n se pueden aplicar conceptos de POO para crear programas m\u00e1s eficientes y robustos. Palabras clave: - Objetos: entidades que tienen propiedades y m\u00e9todos. - M\u00e9todos: funciones que pertenecen a un objeto y pueden acceder a sus propiedades. - Interfaces: estructuras de datos que definen un conjunto de m\u00e9todos que deben ser implementados por un objeto. - Structs: tipos de datos que permiten agrupar diferentes tipos de datos en una sola entidad. Teor\u00eda de la programaci\u00f3n orientada a objetos en Go \u00b6 En POO, los objetos son la pieza fundamental. Estos contienen datos y funciones relacionados que se combinan para formar una unidad funcional. En Go, los structs se utilizan para crear objetos. Un struct es una colecci\u00f3n de campos (variables) que pueden ser de diferentes tipos de datos, como int, string, float, etc. Por ejemplo, podemos crear un struct llamado \"Auto\" con los campos \"marca\", \"modelo\" y \"a\u00f1o\". Adem\u00e1s de los campos, los structs tambi\u00e9n pueden tener m\u00e9todos, que son funciones que se pueden llamar en el objeto para realizar ciertas operaciones. Por ejemplo, podemos crear un m\u00e9todo \"acelerar\" en nuestro struct \"Auto\" que incremente la velocidad del auto. Las interfaces en Go son similares a las interfaces en otros lenguajes de programaci\u00f3n. Son un conjunto de m\u00e9todos que deben ser implementados por un objeto para cumplir con la interfaz. Esto permite una mayor flexibilidad en la programaci\u00f3n, ya que se pueden crear diferentes objetos que implementen la misma interfaz y, por lo tanto, se pueden utilizar de la misma manera en el c\u00f3digo. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es un objeto en POO? \u00bfC\u00f3mo se definen los m\u00e9todos en Go? \u00bfQu\u00e9 es una interfaz en Go y para qu\u00e9 se utiliza? Ejemplos de c\u00f3digo en Go \u00b6 // Definici\u00f3n de un struct en Go type Auto struct { marca string modelo string a\u00f1o int } // Definici\u00f3n de un m\u00e9todo en Go func ( a * Auto ) acelerar () { a . velocidad += 10 } // Definici\u00f3n de una interfaz en Go type Vehiculo interface { acelerar () } Ejercicios pr\u00e1cticos \u00b6 Crea un struct llamado \"Persona\" con los campos \"nombre\", \"edad\" y \"profesi\u00f3n\". Luego, crea un m\u00e9todo \"presentarse\" que imprima en pantalla la frase \"Hola, mi nombre es [nombre] y tengo [edad] a\u00f1os. Soy [profesi\u00f3n].\" Crea una interfaz llamada \"FiguraGeometrica\" con el m\u00e9todo \"calcularArea\". Luego, crea dos structs que implementen esta interfaz: \"Triangulo\" y \"Rectangulo\". En cada uno, define los campos necesarios y el m\u00e9todo \"calcularArea\" que devuelva el \u00e1rea correspondiente a cada figura. Utilizando los structs y m\u00e9todos anteriores, crea un programa que permita calcular el \u00e1rea de un tri\u00e1ngulo o un rect\u00e1ngulo, seg\u00fan la elecci\u00f3n del usuario. Consejos y mejores pr\u00e1cticas \u00b6 Utiliza structs para agrupar datos relacionados en un solo objeto. Utiliza m\u00e9todos para manipular los datos de un objeto. Utiliza interfaces para crear c\u00f3digo m\u00e1s flexible y escalable. Planifica y organiza bien la estructura de tus objetos y m\u00e9todos antes de comenzar a escribir c\u00f3digo. Utiliza nombres descriptivos para tus structs, m\u00e9todos e interfaces para facilitar la lectura y comprensi\u00f3n del c\u00f3digo.","title":"Programaci\u00f3n orientada a objetos en Go"},{"location":"go/jr/programaci%C3%B3n_orientada_a_objetos/#programacion-orientada-a-objetos-en-go","text":"La programaci\u00f3n orientada a objetos (POO) es un paradigma de programaci\u00f3n que se basa en la creaci\u00f3n de objetos que tienen propiedades y m\u00e9todos. Esta metodolog\u00eda de programaci\u00f3n ayuda a organizar y estructurar mejor el c\u00f3digo, lo que lo hace m\u00e1s f\u00e1cil de leer, mantener y escalar. En Go, un lenguaje de programaci\u00f3n compilado desarrollado por Google, tambi\u00e9n se pueden aplicar conceptos de POO para crear programas m\u00e1s eficientes y robustos. Palabras clave: - Objetos: entidades que tienen propiedades y m\u00e9todos. - M\u00e9todos: funciones que pertenecen a un objeto y pueden acceder a sus propiedades. - Interfaces: estructuras de datos que definen un conjunto de m\u00e9todos que deben ser implementados por un objeto. - Structs: tipos de datos que permiten agrupar diferentes tipos de datos en una sola entidad.","title":"Programaci\u00f3n orientada a objetos en Go"},{"location":"go/jr/programaci%C3%B3n_orientada_a_objetos/#teoria-de-la-programacion-orientada-a-objetos-en-go","text":"En POO, los objetos son la pieza fundamental. Estos contienen datos y funciones relacionados que se combinan para formar una unidad funcional. En Go, los structs se utilizan para crear objetos. Un struct es una colecci\u00f3n de campos (variables) que pueden ser de diferentes tipos de datos, como int, string, float, etc. Por ejemplo, podemos crear un struct llamado \"Auto\" con los campos \"marca\", \"modelo\" y \"a\u00f1o\". Adem\u00e1s de los campos, los structs tambi\u00e9n pueden tener m\u00e9todos, que son funciones que se pueden llamar en el objeto para realizar ciertas operaciones. Por ejemplo, podemos crear un m\u00e9todo \"acelerar\" en nuestro struct \"Auto\" que incremente la velocidad del auto. Las interfaces en Go son similares a las interfaces en otros lenguajes de programaci\u00f3n. Son un conjunto de m\u00e9todos que deben ser implementados por un objeto para cumplir con la interfaz. Esto permite una mayor flexibilidad en la programaci\u00f3n, ya que se pueden crear diferentes objetos que implementen la misma interfaz y, por lo tanto, se pueden utilizar de la misma manera en el c\u00f3digo.","title":"Teor\u00eda de la programaci\u00f3n orientada a objetos en Go"},{"location":"go/jr/programaci%C3%B3n_orientada_a_objetos/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es un objeto en POO? \u00bfC\u00f3mo se definen los m\u00e9todos en Go? \u00bfQu\u00e9 es una interfaz en Go y para qu\u00e9 se utiliza?","title":"Preguntas de repaso"},{"location":"go/jr/programaci%C3%B3n_orientada_a_objetos/#ejemplos-de-codigo-en-go","text":"// Definici\u00f3n de un struct en Go type Auto struct { marca string modelo string a\u00f1o int } // Definici\u00f3n de un m\u00e9todo en Go func ( a * Auto ) acelerar () { a . velocidad += 10 } // Definici\u00f3n de una interfaz en Go type Vehiculo interface { acelerar () }","title":"Ejemplos de c\u00f3digo en Go"},{"location":"go/jr/programaci%C3%B3n_orientada_a_objetos/#ejercicios-practicos","text":"Crea un struct llamado \"Persona\" con los campos \"nombre\", \"edad\" y \"profesi\u00f3n\". Luego, crea un m\u00e9todo \"presentarse\" que imprima en pantalla la frase \"Hola, mi nombre es [nombre] y tengo [edad] a\u00f1os. Soy [profesi\u00f3n].\" Crea una interfaz llamada \"FiguraGeometrica\" con el m\u00e9todo \"calcularArea\". Luego, crea dos structs que implementen esta interfaz: \"Triangulo\" y \"Rectangulo\". En cada uno, define los campos necesarios y el m\u00e9todo \"calcularArea\" que devuelva el \u00e1rea correspondiente a cada figura. Utilizando los structs y m\u00e9todos anteriores, crea un programa que permita calcular el \u00e1rea de un tri\u00e1ngulo o un rect\u00e1ngulo, seg\u00fan la elecci\u00f3n del usuario.","title":"Ejercicios pr\u00e1cticos"},{"location":"go/jr/programaci%C3%B3n_orientada_a_objetos/#consejos-y-mejores-practicas","text":"Utiliza structs para agrupar datos relacionados en un solo objeto. Utiliza m\u00e9todos para manipular los datos de un objeto. Utiliza interfaces para crear c\u00f3digo m\u00e1s flexible y escalable. Planifica y organiza bien la estructura de tus objetos y m\u00e9todos antes de comenzar a escribir c\u00f3digo. Utiliza nombres descriptivos para tus structs, m\u00e9todos e interfaces para facilitar la lectura y comprensi\u00f3n del c\u00f3digo.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"go/jr/pruebas_y_debugging/","text":"Pruebas y debugging en Go lang \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 Las pruebas y el debugging son dos aspectos fundamentales en el proceso de desarrollo de software. Las pruebas nos permiten verificar que nuestro c\u00f3digo funciona correctamente y cumple con los requisitos establecidos, mientras que el debugging nos ayuda a identificar y corregir errores en nuestro c\u00f3digo. En Go lang, existen diversas herramientas y t\u00e9cnicas que nos ayudan a realizar pruebas y debugging de manera eficiente. A continuaci\u00f3n, se presentan algunas de ellas. Palabras clave y su definici\u00f3n \u00b6 Pruebas unitarias: Son pruebas que se realizan de manera aislada en peque\u00f1as partes de c\u00f3digo, generalmente funciones o m\u00e9todos, para verificar su correcto funcionamiento. Integraci\u00f3n continua: Es una pr\u00e1ctica en la que se realizan pruebas de manera autom\u00e1tica y constante durante el proceso de desarrollo, para detectar errores de forma temprana. Depurador (Debugger): Es una herramienta que nos permite ejecutar nuestro c\u00f3digo paso a paso, detener su ejecuci\u00f3n en puntos espec\u00edficos y examinar el estado de las variables, para identificar y corregir errores. Profiling: Es una t\u00e9cnica que nos permite medir el rendimiento de nuestro c\u00f3digo, identificar posibles cuellos de botella y optimizar su ejecuci\u00f3n. Preguntas de repaso \u00b6 \u00bfQu\u00e9 son las pruebas unitarias y por qu\u00e9 son importantes en el desarrollo de software? \u00bfEn qu\u00e9 consiste la integraci\u00f3n continua y c\u00f3mo puede ayudar en el proceso de desarrollo? \u00bfQu\u00e9 es un depurador y cu\u00e1l es su funci\u00f3n en el debugging? \u00bfEn qu\u00e9 consiste el profiling y c\u00f3mo puede ayudar a mejorar el rendimiento de nuestro c\u00f3digo? Ejemplos de c\u00f3digo en Go lang \u00b6 Ejemplo de prueba unitaria: func sum ( a , b int ) int { return a + b } func TestSum ( t * testing . T ) { result := sum ( 2 , 3 ) if result != 5 { t . Errorf ( \"Expected 5, got %d\" , result ) } } Ejemplo de integraci\u00f3n continua con Travis CI: Archivo .travis.yml language : go go : - \"1.15\" script : - go test -v ./... Ejemplo de debugging con VS Code: Agregar un punto de interrupci\u00f3n en una l\u00ednea de c\u00f3digo. Ejecutar el programa en modo de depuraci\u00f3n. Utilizar los botones de control (continuar, paso a paso, etc.) para avanzar en la ejecuci\u00f3n del programa y examinar el estado de las variables en el panel de depuraci\u00f3n. Ejemplo de profiling con Go tool pprof: func sum ( a , b int ) int { return a + b } func main () { var result int for i := 0 ; i < 100000 ; i ++ { result += sum ( i , i + 1 ) } } Ejecutar en la terminal: go test -bench = . -cpuprofile = cpu.prof go tool pprof cpu.prof ( pprof ) list sum Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una funci\u00f3n en Go lang que reciba dos n\u00fameros enteros y devuelva la suma de ambos. Realiza una prueba unitaria para verificar que la funci\u00f3n anterior devuelve el resultado esperado. Configura un proyecto en Travis CI para que realice las pruebas de manera autom\u00e1tica cada vez que se haga un push al repositorio. Agrega un punto de interrupci\u00f3n en una l\u00ednea de c\u00f3digo en un proyecto de Go lang y utiliza el depurador para examinar el estado de una variable en ese punto. Utiliza la herramienta de profiling para medir el rendimiento de una funci\u00f3n en tu c\u00f3digo y realiza las optimizaciones necesarias para mejorar su ejecuci\u00f3n. Consejos o mejores pr\u00e1cticas \u00b6 Realizar pruebas unitarias en todas las funciones y m\u00e9todos de nuestro c\u00f3digo. Utilizar herramientas de integraci\u00f3n continua para automatizar las pruebas y detectar errores de manera temprana. Aprender a utilizar un depurador para identificar y corregir errores de forma eficiente. Utilizar t\u00e9cnicas de profiling para mejorar el rendimiento de nuestro c\u00f3digo. Realizar pruebas de manera constante y mantener un buen nivel de cobertura de pruebas en nuestro c\u00f3digo.","title":"Pruebas y debugging en Go lang"},{"location":"go/jr/pruebas_y_debugging/#pruebas-y-debugging-en-go-lang","text":"","title":"Pruebas y debugging en Go lang"},{"location":"go/jr/pruebas_y_debugging/#explicacion-teorica","text":"Las pruebas y el debugging son dos aspectos fundamentales en el proceso de desarrollo de software. Las pruebas nos permiten verificar que nuestro c\u00f3digo funciona correctamente y cumple con los requisitos establecidos, mientras que el debugging nos ayuda a identificar y corregir errores en nuestro c\u00f3digo. En Go lang, existen diversas herramientas y t\u00e9cnicas que nos ayudan a realizar pruebas y debugging de manera eficiente. A continuaci\u00f3n, se presentan algunas de ellas.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"go/jr/pruebas_y_debugging/#palabras-clave-y-su-definicion","text":"Pruebas unitarias: Son pruebas que se realizan de manera aislada en peque\u00f1as partes de c\u00f3digo, generalmente funciones o m\u00e9todos, para verificar su correcto funcionamiento. Integraci\u00f3n continua: Es una pr\u00e1ctica en la que se realizan pruebas de manera autom\u00e1tica y constante durante el proceso de desarrollo, para detectar errores de forma temprana. Depurador (Debugger): Es una herramienta que nos permite ejecutar nuestro c\u00f3digo paso a paso, detener su ejecuci\u00f3n en puntos espec\u00edficos y examinar el estado de las variables, para identificar y corregir errores. Profiling: Es una t\u00e9cnica que nos permite medir el rendimiento de nuestro c\u00f3digo, identificar posibles cuellos de botella y optimizar su ejecuci\u00f3n.","title":"Palabras clave y su definici\u00f3n"},{"location":"go/jr/pruebas_y_debugging/#preguntas-de-repaso","text":"\u00bfQu\u00e9 son las pruebas unitarias y por qu\u00e9 son importantes en el desarrollo de software? \u00bfEn qu\u00e9 consiste la integraci\u00f3n continua y c\u00f3mo puede ayudar en el proceso de desarrollo? \u00bfQu\u00e9 es un depurador y cu\u00e1l es su funci\u00f3n en el debugging? \u00bfEn qu\u00e9 consiste el profiling y c\u00f3mo puede ayudar a mejorar el rendimiento de nuestro c\u00f3digo?","title":"Preguntas de repaso"},{"location":"go/jr/pruebas_y_debugging/#ejemplos-de-codigo-en-go-lang","text":"Ejemplo de prueba unitaria: func sum ( a , b int ) int { return a + b } func TestSum ( t * testing . T ) { result := sum ( 2 , 3 ) if result != 5 { t . Errorf ( \"Expected 5, got %d\" , result ) } } Ejemplo de integraci\u00f3n continua con Travis CI: Archivo .travis.yml language : go go : - \"1.15\" script : - go test -v ./... Ejemplo de debugging con VS Code: Agregar un punto de interrupci\u00f3n en una l\u00ednea de c\u00f3digo. Ejecutar el programa en modo de depuraci\u00f3n. Utilizar los botones de control (continuar, paso a paso, etc.) para avanzar en la ejecuci\u00f3n del programa y examinar el estado de las variables en el panel de depuraci\u00f3n. Ejemplo de profiling con Go tool pprof: func sum ( a , b int ) int { return a + b } func main () { var result int for i := 0 ; i < 100000 ; i ++ { result += sum ( i , i + 1 ) } } Ejecutar en la terminal: go test -bench = . -cpuprofile = cpu.prof go tool pprof cpu.prof ( pprof ) list sum","title":"Ejemplos de c\u00f3digo en Go lang"},{"location":"go/jr/pruebas_y_debugging/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una funci\u00f3n en Go lang que reciba dos n\u00fameros enteros y devuelva la suma de ambos. Realiza una prueba unitaria para verificar que la funci\u00f3n anterior devuelve el resultado esperado. Configura un proyecto en Travis CI para que realice las pruebas de manera autom\u00e1tica cada vez que se haga un push al repositorio. Agrega un punto de interrupci\u00f3n en una l\u00ednea de c\u00f3digo en un proyecto de Go lang y utiliza el depurador para examinar el estado de una variable en ese punto. Utiliza la herramienta de profiling para medir el rendimiento de una funci\u00f3n en tu c\u00f3digo y realiza las optimizaciones necesarias para mejorar su ejecuci\u00f3n.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"go/jr/pruebas_y_debugging/#consejos-o-mejores-practicas","text":"Realizar pruebas unitarias en todas las funciones y m\u00e9todos de nuestro c\u00f3digo. Utilizar herramientas de integraci\u00f3n continua para automatizar las pruebas y detectar errores de manera temprana. Aprender a utilizar un depurador para identificar y corregir errores de forma eficiente. Utilizar t\u00e9cnicas de profiling para mejorar el rendimiento de nuestro c\u00f3digo. Realizar pruebas de manera constante y mantener un buen nivel de cobertura de pruebas en nuestro c\u00f3digo.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"go/mid/conexi%C3%B3n_a_bases_de_datos/","text":"Conexi\u00f3n a bases de datos \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En este m\u00f3dulo aprender\u00e1s a utilizar bases de datos relacionales y no relacionales en tus aplicaciones en Go lang. Las bases de datos son una parte fundamental en el desarrollo de aplicaciones ya que permiten almacenar y gestionar grandes cantidades de datos. En este caso, nos enfocaremos en c\u00f3mo conectarnos a estas bases de datos desde Go lang y realizar operaciones de lectura y escritura. Explicaci\u00f3n te\u00f3rica \u00b6 Las bases de datos se utilizan para almacenar y gestionar grandes cantidades de datos de manera estructurada. Existen dos tipos principales de bases de datos: las relacionales y las no relacionales. Las bases de datos relacionales utilizan tablas para almacenar los datos, donde cada fila representa un registro y cada columna representa un campo de ese registro. Estas bases de datos utilizan el lenguaje SQL (Structured Query Language) para realizar consultas y manipular los datos almacenados. Por otro lado, las bases de datos no relacionales no utilizan tablas, sino que almacenan los datos en formato de documentos o gr\u00e1ficos. No utilizan SQL, sino que cada base de datos tiene su propio lenguaje de consulta. En Go lang, podemos conectarnos a estos dos tipos de bases de datos utilizando librer\u00edas y paquetes espec\u00edficos. En el caso de bases de datos relacionales, la librer\u00eda m\u00e1s utilizada es \"database/sql\" que nos permite conectarnos a cualquier base de datos que tenga un driver compatible. Para bases de datos no relacionales, existen diferentes opciones como \"mgo\" para MongoDB o \"neoism\" para Neo4j. Palabras clave y su definici\u00f3n \u00b6 Bases de datos: sistemas que permiten almacenar y gestionar grandes cantidades de datos de manera estructurada. Relacionales: bases de datos que utilizan tablas para almacenar los datos y SQL para realizar consultas. No relacionales: bases de datos que no utilizan tablas y tienen su propio lenguaje de consulta. SQL: lenguaje de consulta estructurado utilizado en bases de datos relacionales. Driver: programa que permite la comunicaci\u00f3n entre una aplicaci\u00f3n y una base de datos. Librer\u00eda: conjunto de funciones y estructuras de datos que facilitan la realizaci\u00f3n de una tarea espec\u00edfica. Preguntas de repaso \u00b6 \u00bfQu\u00e9 son las bases de datos y para qu\u00e9 se utilizan? \u00bfCu\u00e1l es la diferencia entre una base de datos relacional y una no relacional? \u00bfQu\u00e9 es SQL y en qu\u00e9 tipo de bases de datos se utiliza? \u00bfC\u00f3mo podemos conectarnos a bases de datos desde Go lang? \u00bfQu\u00e9 es un driver y una librer\u00eda en el contexto de bases de datos? Ejemplos de c\u00f3digo en Go lang \u00b6 Conexi\u00f3n a una base de datos relacional utilizando \"database/sql\" \u00b6 import ( \"database/sql\" \"fmt\" _ \"github.com/go-sql-driver/mysql\" // importamos el driver para MySQL ) func main () { // establecemos la conexi\u00f3n con la base de datos db , err := sql . Open ( \"mysql\" , \"usuario:contrase\u00f1a@tcp(direccion:puerto)/nombre_basededatos\" ) if err != nil { panic ( err ) } // cerramos la conexi\u00f3n al finalizar la ejecuci\u00f3n defer db . Close () // realizamos una consulta a la base de datos rows , err := db . Query ( \"SELECT * FROM usuarios\" ) if err != nil { panic ( err ) } // recorremos los resultados y los imprimimos en pantalla for rows . Next () { var id int var nombre string var apellido string err = rows . Scan ( & id , & nombre , & apellido ) if err != nil { panic ( err ) } fmt . Println ( id , nombre , apellido ) } } Conexi\u00f3n a una base de datos no relacional utilizando \"mgo\" \u00b6 import ( \"fmt\" \"gopkg.in/mgo.v2\" ) func main () { // establecemos la conexi\u00f3n con la base de datos session , err := mgo . Dial ( \"direccion:puerto\" ) if err != nil { panic ( err ) } // cerramos la conexi\u00f3n al finalizar la ejecuci\u00f3n defer session . Close () // obtenemos una referencia a la colecci\u00f3n que queremos utilizar c := session . DB ( \"nombre_basededatos\" ). C ( \"usuarios\" ) // insertamos un nuevo registro en la colecci\u00f3n err = c . Insert ( & Usuario { Nombre : \"Juan\" , Apellido : \"P\u00e9rez\" }) if err != nil { panic ( err ) } // realizamos una consulta a la base de datos var resultado [] Usuario err = c . Find ( nil ). All ( & resultado ) if err != nil { panic ( err ) } // imprimimos los resultados en pantalla for _ , usuario := range resultado { fmt . Println ( usuario . Nombre , usuario . Apellido ) } } // estructura que representa un registro en la base de datos type Usuario struct { Nombre string Apellido string } Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Conecta tu aplicaci\u00f3n en Go lang a una base de datos MySQL utilizando \"database/sql\". Realiza una consulta y muestra los resultados en pantalla. Crea una base de datos MongoDB y conecta tu aplicaci\u00f3n en Go lang utilizando \"mgo\". Inserta un nuevo registro en la colecci\u00f3n \"usuarios\" y muestra todos los registros en pantalla. Utiliza la librer\u00eda \"neoism\" para conectarte a una base de datos Neo4j. Realiza una consulta que filtre los nodos de tipo \"usuario\" y sus relaciones con otros nodos. Muestra los resultados en pantalla. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza siempre los par\u00e1metros de conexi\u00f3n de manera segura, evitando incluir los datos de acceso a la base de datos en el c\u00f3digo. Reutiliza las conexiones a la base de datos cuando sea posible para mejorar el rendimiento de la aplicaci\u00f3n. Aseg\u00farate de cerrar las conexiones y liberar los recursos al finalizar la ejecuci\u00f3n de la aplicaci\u00f3n.","title":"Conexi\u00f3n a bases de datos"},{"location":"go/mid/conexi%C3%B3n_a_bases_de_datos/#conexion-a-bases-de-datos","text":"","title":"Conexi\u00f3n a bases de datos"},{"location":"go/mid/conexi%C3%B3n_a_bases_de_datos/#descripcion-del-modulo","text":"En este m\u00f3dulo aprender\u00e1s a utilizar bases de datos relacionales y no relacionales en tus aplicaciones en Go lang. Las bases de datos son una parte fundamental en el desarrollo de aplicaciones ya que permiten almacenar y gestionar grandes cantidades de datos. En este caso, nos enfocaremos en c\u00f3mo conectarnos a estas bases de datos desde Go lang y realizar operaciones de lectura y escritura.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"go/mid/conexi%C3%B3n_a_bases_de_datos/#explicacion-teorica","text":"Las bases de datos se utilizan para almacenar y gestionar grandes cantidades de datos de manera estructurada. Existen dos tipos principales de bases de datos: las relacionales y las no relacionales. Las bases de datos relacionales utilizan tablas para almacenar los datos, donde cada fila representa un registro y cada columna representa un campo de ese registro. Estas bases de datos utilizan el lenguaje SQL (Structured Query Language) para realizar consultas y manipular los datos almacenados. Por otro lado, las bases de datos no relacionales no utilizan tablas, sino que almacenan los datos en formato de documentos o gr\u00e1ficos. No utilizan SQL, sino que cada base de datos tiene su propio lenguaje de consulta. En Go lang, podemos conectarnos a estos dos tipos de bases de datos utilizando librer\u00edas y paquetes espec\u00edficos. En el caso de bases de datos relacionales, la librer\u00eda m\u00e1s utilizada es \"database/sql\" que nos permite conectarnos a cualquier base de datos que tenga un driver compatible. Para bases de datos no relacionales, existen diferentes opciones como \"mgo\" para MongoDB o \"neoism\" para Neo4j.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"go/mid/conexi%C3%B3n_a_bases_de_datos/#palabras-clave-y-su-definicion","text":"Bases de datos: sistemas que permiten almacenar y gestionar grandes cantidades de datos de manera estructurada. Relacionales: bases de datos que utilizan tablas para almacenar los datos y SQL para realizar consultas. No relacionales: bases de datos que no utilizan tablas y tienen su propio lenguaje de consulta. SQL: lenguaje de consulta estructurado utilizado en bases de datos relacionales. Driver: programa que permite la comunicaci\u00f3n entre una aplicaci\u00f3n y una base de datos. Librer\u00eda: conjunto de funciones y estructuras de datos que facilitan la realizaci\u00f3n de una tarea espec\u00edfica.","title":"Palabras clave y su definici\u00f3n"},{"location":"go/mid/conexi%C3%B3n_a_bases_de_datos/#preguntas-de-repaso","text":"\u00bfQu\u00e9 son las bases de datos y para qu\u00e9 se utilizan? \u00bfCu\u00e1l es la diferencia entre una base de datos relacional y una no relacional? \u00bfQu\u00e9 es SQL y en qu\u00e9 tipo de bases de datos se utiliza? \u00bfC\u00f3mo podemos conectarnos a bases de datos desde Go lang? \u00bfQu\u00e9 es un driver y una librer\u00eda en el contexto de bases de datos?","title":"Preguntas de repaso"},{"location":"go/mid/conexi%C3%B3n_a_bases_de_datos/#ejemplos-de-codigo-en-go-lang","text":"","title":"Ejemplos de c\u00f3digo en Go lang"},{"location":"go/mid/conexi%C3%B3n_a_bases_de_datos/#conexion-a-una-base-de-datos-relacional-utilizando-databasesql","text":"import ( \"database/sql\" \"fmt\" _ \"github.com/go-sql-driver/mysql\" // importamos el driver para MySQL ) func main () { // establecemos la conexi\u00f3n con la base de datos db , err := sql . Open ( \"mysql\" , \"usuario:contrase\u00f1a@tcp(direccion:puerto)/nombre_basededatos\" ) if err != nil { panic ( err ) } // cerramos la conexi\u00f3n al finalizar la ejecuci\u00f3n defer db . Close () // realizamos una consulta a la base de datos rows , err := db . Query ( \"SELECT * FROM usuarios\" ) if err != nil { panic ( err ) } // recorremos los resultados y los imprimimos en pantalla for rows . Next () { var id int var nombre string var apellido string err = rows . Scan ( & id , & nombre , & apellido ) if err != nil { panic ( err ) } fmt . Println ( id , nombre , apellido ) } }","title":"Conexi\u00f3n a una base de datos relacional utilizando \"database/sql\""},{"location":"go/mid/conexi%C3%B3n_a_bases_de_datos/#conexion-a-una-base-de-datos-no-relacional-utilizando-mgo","text":"import ( \"fmt\" \"gopkg.in/mgo.v2\" ) func main () { // establecemos la conexi\u00f3n con la base de datos session , err := mgo . Dial ( \"direccion:puerto\" ) if err != nil { panic ( err ) } // cerramos la conexi\u00f3n al finalizar la ejecuci\u00f3n defer session . Close () // obtenemos una referencia a la colecci\u00f3n que queremos utilizar c := session . DB ( \"nombre_basededatos\" ). C ( \"usuarios\" ) // insertamos un nuevo registro en la colecci\u00f3n err = c . Insert ( & Usuario { Nombre : \"Juan\" , Apellido : \"P\u00e9rez\" }) if err != nil { panic ( err ) } // realizamos una consulta a la base de datos var resultado [] Usuario err = c . Find ( nil ). All ( & resultado ) if err != nil { panic ( err ) } // imprimimos los resultados en pantalla for _ , usuario := range resultado { fmt . Println ( usuario . Nombre , usuario . Apellido ) } } // estructura que representa un registro en la base de datos type Usuario struct { Nombre string Apellido string }","title":"Conexi\u00f3n a una base de datos no relacional utilizando \"mgo\""},{"location":"go/mid/conexi%C3%B3n_a_bases_de_datos/#ejercicios-practicos-con-instrucciones-claras","text":"Conecta tu aplicaci\u00f3n en Go lang a una base de datos MySQL utilizando \"database/sql\". Realiza una consulta y muestra los resultados en pantalla. Crea una base de datos MongoDB y conecta tu aplicaci\u00f3n en Go lang utilizando \"mgo\". Inserta un nuevo registro en la colecci\u00f3n \"usuarios\" y muestra todos los registros en pantalla. Utiliza la librer\u00eda \"neoism\" para conectarte a una base de datos Neo4j. Realiza una consulta que filtre los nodos de tipo \"usuario\" y sus relaciones con otros nodos. Muestra los resultados en pantalla.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"go/mid/conexi%C3%B3n_a_bases_de_datos/#consejos-o-mejores-practicas","text":"Utiliza siempre los par\u00e1metros de conexi\u00f3n de manera segura, evitando incluir los datos de acceso a la base de datos en el c\u00f3digo. Reutiliza las conexiones a la base de datos cuando sea posible para mejorar el rendimiento de la aplicaci\u00f3n. Aseg\u00farate de cerrar las conexiones y liberar los recursos al finalizar la ejecuci\u00f3n de la aplicaci\u00f3n.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"go/mid/dise%C3%B1o_de_aplicaciones_escalables/","text":"Dise\u00f1o de aplicaciones escalables en Go \u00b6 En la actualidad, el dise\u00f1o de aplicaciones escalables se ha vuelto una necesidad para cualquier empresa o negocio que busque expandirse y crecer en el mercado. Una aplicaci\u00f3n escalable es aquella que puede manejar un aumento en la demanda sin ver afectado su rendimiento o su capacidad de respuesta. En este m\u00f3dulo, aprenderemos las estrategias y mejores pr\u00e1cticas para dise\u00f1ar aplicaciones escalables en Go lang. Palabras clave y su definici\u00f3n \u00b6 Escalabilidad: capacidad de una aplicaci\u00f3n para manejar un aumento en la demanda sin comprometer su rendimiento. Alta disponibilidad: capacidad de una aplicaci\u00f3n para estar siempre disponible y responder a las solicitudes de los usuarios. Concurrencia: capacidad de una aplicaci\u00f3n para manejar m\u00faltiples tareas al mismo tiempo. Paralelismo: capacidad de una aplicaci\u00f3n para ejecutar m\u00faltiples tareas de forma simult\u00e1nea. Goroutines: funciones que se ejecutan de forma concurrente en Go. Channels: mecanismo de comunicaci\u00f3n entre goroutines en Go. Load balancing: t\u00e9cnica para distribuir la carga de trabajo entre m\u00faltiples servidores o procesos. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la escalabilidad en una aplicaci\u00f3n? \u00bfPor qu\u00e9 es importante dise\u00f1ar aplicaciones escalables? \u00bfCu\u00e1l es la diferencia entre concurrencia y paralelismo? \u00bfQu\u00e9 son las goroutines y los channels en Go? \u00bfQu\u00e9 es el load balancing y c\u00f3mo se puede implementar en una aplicaci\u00f3n escalable? Ejemplos de c\u00f3digo en Go lang. \u00b6 Concurrente vs Paralelo \u00b6 // Ejemplo de concurrencia func main () { go imprimir ( \"Hola\" ) imprimir ( \"Mundo\" ) } func imprimir ( texto string ) { fmt . Println ( texto ) } // Salida: Mundo Hola // Ejemplo de paralelismo func main () { go imprimir ( \"Hola\" ) go imprimir ( \"Mundo\" ) } func imprimir ( texto string ) { fmt . Println ( texto ) } // Salida: Hola Mundo Goroutines y Channels \u00b6 func main () { // Crear un channel de tipo string ch := make ( chan string ) // Ejecutar la goroutine imprimir go imprimir ( \"Hola\" , ch ) // Recibir el mensaje del channel y mostrarlo mensaje := <- ch fmt . Println ( mensaje ) } func imprimir ( texto string , ch chan string ) { // Enviar el mensaje al channel ch <- texto } // Salida: Hola Ejercicios pr\u00e1cticos \u00b6 Crea una aplicaci\u00f3n que realice una tarea intensiva de forma concurrente utilizando goroutines. Implementa un sistema de load balancing en una aplicaci\u00f3n web utilizando Go y goroutines. Crea una aplicaci\u00f3n que utilice channels para comunicarse entre diferentes procesos. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza goroutines y channels para manejar la concurrencia en tu aplicaci\u00f3n Go. Divide tu aplicaci\u00f3n en m\u00f3dulos y servicios para facilitar la escalabilidad. Implementa t\u00e9cnicas de cacheo para reducir la carga en la base de datos. Utiliza herramientas de monitoreo y m\u00e9tricas para identificar cuellos de botella en tu aplicaci\u00f3n. Prueba tu aplicaci\u00f3n en diferentes niveles de carga para asegurar su escalabilidad y alta disponibilidad. Utiliza el principio de \"fail-fast\" para detectar y solucionar errores r\u00e1pidamente en tu aplicaci\u00f3n escalable. \u00a1Enhorabuena! Ahora tienes los conocimientos necesarios para dise\u00f1ar aplicaciones escalables y de alta disponibilidad en Go lang. Recuerda aplicar estos conceptos en tus proyectos y seguir aprendiendo para mejorar tus habilidades en Go. \u00a1Sigue adelante!","title":"Dise\u00f1o de aplicaciones escalables"},{"location":"go/mid/dise%C3%B1o_de_aplicaciones_escalables/#diseno-de-aplicaciones-escalables-en-go","text":"En la actualidad, el dise\u00f1o de aplicaciones escalables se ha vuelto una necesidad para cualquier empresa o negocio que busque expandirse y crecer en el mercado. Una aplicaci\u00f3n escalable es aquella que puede manejar un aumento en la demanda sin ver afectado su rendimiento o su capacidad de respuesta. En este m\u00f3dulo, aprenderemos las estrategias y mejores pr\u00e1cticas para dise\u00f1ar aplicaciones escalables en Go lang.","title":"Dise\u00f1o de aplicaciones escalables en Go"},{"location":"go/mid/dise%C3%B1o_de_aplicaciones_escalables/#palabras-clave-y-su-definicion","text":"Escalabilidad: capacidad de una aplicaci\u00f3n para manejar un aumento en la demanda sin comprometer su rendimiento. Alta disponibilidad: capacidad de una aplicaci\u00f3n para estar siempre disponible y responder a las solicitudes de los usuarios. Concurrencia: capacidad de una aplicaci\u00f3n para manejar m\u00faltiples tareas al mismo tiempo. Paralelismo: capacidad de una aplicaci\u00f3n para ejecutar m\u00faltiples tareas de forma simult\u00e1nea. Goroutines: funciones que se ejecutan de forma concurrente en Go. Channels: mecanismo de comunicaci\u00f3n entre goroutines en Go. Load balancing: t\u00e9cnica para distribuir la carga de trabajo entre m\u00faltiples servidores o procesos.","title":"Palabras clave y su definici\u00f3n"},{"location":"go/mid/dise%C3%B1o_de_aplicaciones_escalables/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la escalabilidad en una aplicaci\u00f3n? \u00bfPor qu\u00e9 es importante dise\u00f1ar aplicaciones escalables? \u00bfCu\u00e1l es la diferencia entre concurrencia y paralelismo? \u00bfQu\u00e9 son las goroutines y los channels en Go? \u00bfQu\u00e9 es el load balancing y c\u00f3mo se puede implementar en una aplicaci\u00f3n escalable?","title":"Preguntas de repaso"},{"location":"go/mid/dise%C3%B1o_de_aplicaciones_escalables/#ejemplos-de-codigo-en-go-lang","text":"","title":"Ejemplos de c\u00f3digo en Go lang."},{"location":"go/mid/dise%C3%B1o_de_aplicaciones_escalables/#concurrente-vs-paralelo","text":"// Ejemplo de concurrencia func main () { go imprimir ( \"Hola\" ) imprimir ( \"Mundo\" ) } func imprimir ( texto string ) { fmt . Println ( texto ) } // Salida: Mundo Hola // Ejemplo de paralelismo func main () { go imprimir ( \"Hola\" ) go imprimir ( \"Mundo\" ) } func imprimir ( texto string ) { fmt . Println ( texto ) } // Salida: Hola Mundo","title":"Concurrente vs Paralelo"},{"location":"go/mid/dise%C3%B1o_de_aplicaciones_escalables/#goroutines-y-channels","text":"func main () { // Crear un channel de tipo string ch := make ( chan string ) // Ejecutar la goroutine imprimir go imprimir ( \"Hola\" , ch ) // Recibir el mensaje del channel y mostrarlo mensaje := <- ch fmt . Println ( mensaje ) } func imprimir ( texto string , ch chan string ) { // Enviar el mensaje al channel ch <- texto } // Salida: Hola","title":"Goroutines y Channels"},{"location":"go/mid/dise%C3%B1o_de_aplicaciones_escalables/#ejercicios-practicos","text":"Crea una aplicaci\u00f3n que realice una tarea intensiva de forma concurrente utilizando goroutines. Implementa un sistema de load balancing en una aplicaci\u00f3n web utilizando Go y goroutines. Crea una aplicaci\u00f3n que utilice channels para comunicarse entre diferentes procesos.","title":"Ejercicios pr\u00e1cticos"},{"location":"go/mid/dise%C3%B1o_de_aplicaciones_escalables/#consejos-o-mejores-practicas","text":"Utiliza goroutines y channels para manejar la concurrencia en tu aplicaci\u00f3n Go. Divide tu aplicaci\u00f3n en m\u00f3dulos y servicios para facilitar la escalabilidad. Implementa t\u00e9cnicas de cacheo para reducir la carga en la base de datos. Utiliza herramientas de monitoreo y m\u00e9tricas para identificar cuellos de botella en tu aplicaci\u00f3n. Prueba tu aplicaci\u00f3n en diferentes niveles de carga para asegurar su escalabilidad y alta disponibilidad. Utiliza el principio de \"fail-fast\" para detectar y solucionar errores r\u00e1pidamente en tu aplicaci\u00f3n escalable. \u00a1Enhorabuena! Ahora tienes los conocimientos necesarios para dise\u00f1ar aplicaciones escalables y de alta disponibilidad en Go lang. Recuerda aplicar estos conceptos en tus proyectos y seguir aprendiendo para mejorar tus habilidades en Go. \u00a1Sigue adelante!","title":"Consejos o mejores pr\u00e1cticas"},{"location":"go/mid/manipulaci%C3%B3n_de_datos/","text":"Manipulaci\u00f3n de datos en Go lang \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En este m\u00f3dulo aprenderemos c\u00f3mo manipular datos de manera eficiente en Go lang. Utilizaremos estructuras de datos avanzadas como slices multidimensionales y tipos de datos personalizados para realizar operaciones complejas en nuestros programas. Teor\u00eda \u00b6 Go es un lenguaje de programaci\u00f3n compilado y est\u00e1tico que se enfoca en la simplicidad y eficiencia en el manejo de datos. Esto significa que Go nos proporciona herramientas poderosas para manejar datos de manera efectiva, lo que nos permite escribir programas m\u00e1s r\u00e1pidos y robustos. En Go, los datos se almacenan en variables, que son espacios en la memoria reservados para almacenar un valor espec\u00edfico. Estas variables pueden ser de diferentes tipos, como int (entero), float (n\u00famero decimal), string (cadena de caracteres), entre otros. Tambi\u00e9n podemos crear nuestras propias estructuras de datos personalizadas utilizando la palabra clave \"struct\". Las estructuras de datos m\u00e1s utilizadas en Go son los slices y los maps. Los slices son una colecci\u00f3n din\u00e1mica de elementos del mismo tipo, mientras que los maps son una estructura de datos que asocia una clave con un valor. Ambos nos permiten almacenar y manipular grandes cantidades de datos de manera eficiente. Palabras clave \u00b6 Variables: espacios en la memoria reservados para almacenar valores. Tipos de datos: categor\u00edas de valores que pueden ser almacenados en variables. Slices: estructuras de datos din\u00e1micas que nos permiten almacenar y manipular colecciones de elementos. Maps: estructuras de datos que asocian una clave con un valor. Struct: palabra clave utilizada para crear estructuras de datos personalizadas. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es una variable en Go lang? \u00bfC\u00f3mo se crean estructuras de datos personalizadas en Go? \u00bfCu\u00e1les son las diferencias entre slices y maps? \u00bfQu\u00e9 palabra clave se utiliza para crear una estructura de datos personalizada? \u00bfPor qu\u00e9 es importante manipular datos de manera eficiente en Go lang? Ejemplos de c\u00f3digo \u00b6 Creaci\u00f3n de un slice multidimensional \u00b6 // Creamos un slice de 2 dimensiones con 3 filas y 4 columnas var matriz [][] int = [][] int {{ 1 , 2 , 3 , 4 }, { 5 , 6 , 7 , 8 }, { 9 , 10 , 11 , 12 }} // Accedemos al valor de la segunda fila y tercera columna valor : = matriz [ 1 ][ 2 ] fmt . Println ( valor ) // Imprime : 7 Creaci\u00f3n de un map \u00b6 // Creamos un map que asocia nombres con edades edades : = map [ string ] int { \"Juan\" : 25 , \"Mar\u00eda\" : 30 , \"Pedro\" : 40 , } // Agregamos un nuevo elemento al map edades [ \"Ana\" ] = 35 fmt . Println ( edades ) // Imprime : map [ Juan:25 Mar\u00eda:30 Pedro:40 Ana:35 ] Ejercicios pr\u00e1cticos \u00b6 Crea un slice de strings con los nombres de tus 5 mejores amigos. Imprime el nombre de tu tercer amigo. Crea un map que asocie nombres de pa\u00edses con su poblaci\u00f3n. Agrega 3 pa\u00edses y sus respectivas poblaciones y luego imprime el map completo. Crea una estructura de datos personalizada llamada \"persona\" que contenga los campos \"nombre\", \"edad\" y \"ciudad\". Crea una variable de tipo \"persona\" con tus datos y luego imprime su nombre. Consejos \u00b6 Utiliza slices y maps en lugar de arrays y arrays asociativos para manipular grandes cantidades de datos de manera eficiente. Evita crear estructuras de datos demasiado complejas, ya que pueden dificultar la lectura y el mantenimiento del c\u00f3digo. Aprovecha la capacidad de Go de crear estructuras de datos personalizadas para adaptarlas a tus necesidades espec\u00edficas.","title":"Manipulaci\u00f3n de datos en Go lang"},{"location":"go/mid/manipulaci%C3%B3n_de_datos/#manipulacion-de-datos-en-go-lang","text":"","title":"Manipulaci\u00f3n de datos en Go lang"},{"location":"go/mid/manipulaci%C3%B3n_de_datos/#descripcion-del-modulo","text":"En este m\u00f3dulo aprenderemos c\u00f3mo manipular datos de manera eficiente en Go lang. Utilizaremos estructuras de datos avanzadas como slices multidimensionales y tipos de datos personalizados para realizar operaciones complejas en nuestros programas.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"go/mid/manipulaci%C3%B3n_de_datos/#teoria","text":"Go es un lenguaje de programaci\u00f3n compilado y est\u00e1tico que se enfoca en la simplicidad y eficiencia en el manejo de datos. Esto significa que Go nos proporciona herramientas poderosas para manejar datos de manera efectiva, lo que nos permite escribir programas m\u00e1s r\u00e1pidos y robustos. En Go, los datos se almacenan en variables, que son espacios en la memoria reservados para almacenar un valor espec\u00edfico. Estas variables pueden ser de diferentes tipos, como int (entero), float (n\u00famero decimal), string (cadena de caracteres), entre otros. Tambi\u00e9n podemos crear nuestras propias estructuras de datos personalizadas utilizando la palabra clave \"struct\". Las estructuras de datos m\u00e1s utilizadas en Go son los slices y los maps. Los slices son una colecci\u00f3n din\u00e1mica de elementos del mismo tipo, mientras que los maps son una estructura de datos que asocia una clave con un valor. Ambos nos permiten almacenar y manipular grandes cantidades de datos de manera eficiente.","title":"Teor\u00eda"},{"location":"go/mid/manipulaci%C3%B3n_de_datos/#palabras-clave","text":"Variables: espacios en la memoria reservados para almacenar valores. Tipos de datos: categor\u00edas de valores que pueden ser almacenados en variables. Slices: estructuras de datos din\u00e1micas que nos permiten almacenar y manipular colecciones de elementos. Maps: estructuras de datos que asocian una clave con un valor. Struct: palabra clave utilizada para crear estructuras de datos personalizadas.","title":"Palabras clave"},{"location":"go/mid/manipulaci%C3%B3n_de_datos/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es una variable en Go lang? \u00bfC\u00f3mo se crean estructuras de datos personalizadas en Go? \u00bfCu\u00e1les son las diferencias entre slices y maps? \u00bfQu\u00e9 palabra clave se utiliza para crear una estructura de datos personalizada? \u00bfPor qu\u00e9 es importante manipular datos de manera eficiente en Go lang?","title":"Preguntas de repaso"},{"location":"go/mid/manipulaci%C3%B3n_de_datos/#ejemplos-de-codigo","text":"","title":"Ejemplos de c\u00f3digo"},{"location":"go/mid/manipulaci%C3%B3n_de_datos/#creacion-de-un-slice-multidimensional","text":"// Creamos un slice de 2 dimensiones con 3 filas y 4 columnas var matriz [][] int = [][] int {{ 1 , 2 , 3 , 4 }, { 5 , 6 , 7 , 8 }, { 9 , 10 , 11 , 12 }} // Accedemos al valor de la segunda fila y tercera columna valor : = matriz [ 1 ][ 2 ] fmt . Println ( valor ) // Imprime : 7","title":"Creaci\u00f3n de un slice multidimensional"},{"location":"go/mid/manipulaci%C3%B3n_de_datos/#creacion-de-un-map","text":"// Creamos un map que asocia nombres con edades edades : = map [ string ] int { \"Juan\" : 25 , \"Mar\u00eda\" : 30 , \"Pedro\" : 40 , } // Agregamos un nuevo elemento al map edades [ \"Ana\" ] = 35 fmt . Println ( edades ) // Imprime : map [ Juan:25 Mar\u00eda:30 Pedro:40 Ana:35 ]","title":"Creaci\u00f3n de un map"},{"location":"go/mid/manipulaci%C3%B3n_de_datos/#ejercicios-practicos","text":"Crea un slice de strings con los nombres de tus 5 mejores amigos. Imprime el nombre de tu tercer amigo. Crea un map que asocie nombres de pa\u00edses con su poblaci\u00f3n. Agrega 3 pa\u00edses y sus respectivas poblaciones y luego imprime el map completo. Crea una estructura de datos personalizada llamada \"persona\" que contenga los campos \"nombre\", \"edad\" y \"ciudad\". Crea una variable de tipo \"persona\" con tus datos y luego imprime su nombre.","title":"Ejercicios pr\u00e1cticos"},{"location":"go/mid/manipulaci%C3%B3n_de_datos/#consejos","text":"Utiliza slices y maps en lugar de arrays y arrays asociativos para manipular grandes cantidades de datos de manera eficiente. Evita crear estructuras de datos demasiado complejas, ya que pueden dificultar la lectura y el mantenimiento del c\u00f3digo. Aprovecha la capacidad de Go de crear estructuras de datos personalizadas para adaptarlas a tus necesidades espec\u00edficas.","title":"Consejos"},{"location":"go/mid/mantenimiento_y_actualizaciones/","text":"Mantenimiento y actualizaciones \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En este m\u00f3dulo aprender\u00e1s sobre las estrategias y herramientas para el mantenimiento y actualizaci\u00f3n de aplicaciones en Go. A medida que las aplicaciones crecen y evolucionan, es importante tener una buena estrategia de mantenimiento y actualizaci\u00f3n para asegurar su estabilidad y eficiencia. Explicaci\u00f3n te\u00f3rica \u00b6 El mantenimiento y las actualizaciones son procesos importantes en cualquier aplicaci\u00f3n, ya que permiten corregir errores, agregar nuevas funcionalidades y mejorar el rendimiento. En Go, existen varias herramientas y pr\u00e1cticas que facilitan estos procesos. Para el mantenimiento, es importante realizar pruebas de manera regular para identificar y corregir errores. Tambi\u00e9n es recomendable realizar refactorizaciones para mejorar la calidad del c\u00f3digo y eliminar posibles problemas en el futuro. Otra pr\u00e1ctica \u00fatil es mantener un registro de cambios y actualizaciones para tener un seguimiento de las modificaciones realizadas en la aplicaci\u00f3n. En cuanto a las actualizaciones, es importante tener una buena estrategia para minimizar los tiempos de inactividad y asegurar una transici\u00f3n suave hacia la nueva versi\u00f3n. Algunas estrategias comunes incluyen el uso de despliegues en etapas, donde la aplicaci\u00f3n se actualiza gradualmente en diferentes servidores, y el uso de herramientas de gesti\u00f3n de configuraci\u00f3n como Ansible o Chef. Palabras clave y su definici\u00f3n \u00b6 Mantenimiento: Proceso de correcci\u00f3n y mejora de una aplicaci\u00f3n para asegurar su estabilidad y eficiencia. Actualizaci\u00f3n: Proceso de reemplazar una versi\u00f3n anterior de una aplicaci\u00f3n con una nueva versi\u00f3n que incluye correcciones y mejoras. Pruebas: Evaluaci\u00f3n de una aplicaci\u00f3n para identificar y corregir errores. Refactorizaci\u00f3n: Proceso de reorganizar el c\u00f3digo de una aplicaci\u00f3n para mejorar su calidad y eficiencia. Registro de cambios: Documentaci\u00f3n de las modificaciones y actualizaciones realizadas en una aplicaci\u00f3n. Tiempos de inactividad: Periodo en el que una aplicaci\u00f3n no est\u00e1 disponible debido a una actualizaci\u00f3n o mantenimiento. Despliegues en etapas: Estrategia de actualizaci\u00f3n en la que la aplicaci\u00f3n se actualiza gradualmente en diferentes servidores. Herramientas de gesti\u00f3n de configuraci\u00f3n: Programas que automatizan la configuraci\u00f3n y actualizaci\u00f3n de aplicaciones en diferentes servidores. Preguntas de repaso \u00b6 \u00bfCu\u00e1l es la diferencia entre mantenimiento y actualizaci\u00f3n? \u00bfPor qu\u00e9 es importante realizar pruebas y refactorizaciones en una aplicaci\u00f3n? \u00bfQu\u00e9 es un registro de cambios y por qu\u00e9 es \u00fatil? \u00bfCu\u00e1les son algunas estrategias para minimizar los tiempos de inactividad durante una actualizaci\u00f3n? \u00bfQu\u00e9 son las herramientas de gesti\u00f3n de configuraci\u00f3n y c\u00f3mo pueden ayudar en el proceso de actualizaci\u00f3n de una aplicaci\u00f3n en Go? Ejemplos de c\u00f3digo en Go lang \u00b6 Mantenimiento \u00b6 // Funci\u00f3n para verificar si un n\u00famero es primo func isPrime ( n int ) bool { // Si el n\u00famero es menor a 2 , no es primo if n < 2 { return false } // Si es igual a 2 , es primo if n == 2 { return true } // Si es divisible por 2 , no es primo if n % 2 == 0 { return false } // Verificar si es divisible por alg\u00fan otro n\u00famero impar for i : = 3 ; i * i <= n ; i += 2 { if n % i == 0 { return false } } // Si no se cumple ninguna condici\u00f3n , es primo return true } Actualizaci\u00f3n \u00b6 // Funci\u00f3n para calcular el \u00e1 rea de un c\u00edrculo func calculateArea ( radius float64 ) float64 { return math . Pi * radius * radius } // Funci\u00f3n para calcular el per\u00edmetro de un c\u00edrculo func calculatePerimeter ( radius float64 ) float64 { return 2 * math . Pi * radius } // Funci\u00f3n para imprimir el \u00e1 rea y per\u00edmetro de un c\u00edrculo func printCircleInfo ( radius float64 ) { fmt . Printf ( \"El \u00e1rea del c\u00edrculo es: %f \\n \" , calculateArea ( radius )) fmt . Printf ( \"El per\u00edmetro del c\u00edrculo es: %f \\n \" , calculatePerimeter ( radius )) } // Funci\u00f3n main para ejecutar el programa func main () { // Prompt para ingresar el radio del c\u00edrculo fmt . Print ( \"Ingrese el radio del c\u00edrculo: \" ) // Leer el valor ingresado por el usuario var radius float64 fmt . Scanf ( \" %f \" , & radius ) // Imprimir informaci\u00f3n del c\u00edrculo printCircleInfo ( radius ) } Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una funci\u00f3n en Go que reciba como par\u00e1metro una cadena de texto y devuelva el n\u00famero de palabras que contiene. Implementa una funci\u00f3n en Go que reciba un n\u00famero entero positivo y devuelva el factorial de ese n\u00famero. Escribe una funci\u00f3n en Go que reciba como par\u00e1metros dos arreglos de enteros y devuelva un nuevo arreglo que contenga la suma de los elementos de cada posici\u00f3n. Actualiza la funci\u00f3n del ejercicio 1 para que tambi\u00e9n cuente el n\u00famero de caracteres en la cadena de texto. Crea una aplicaci\u00f3n en Go que le permita al usuario ingresar un n\u00famero entero y luego le muestre la tabla de multiplicar de ese n\u00famero. Consejos o mejores pr\u00e1cticas \u00b6 Realiza pruebas de manera regular para identificar y corregir errores. Mant\u00e9n un registro de cambios para tener un seguimiento de las modificaciones realizadas en la aplicaci\u00f3n. Realiza refactorizaciones para mejorar la calidad del c\u00f3digo y eliminar posibles problemas en el futuro. Utiliza herramientas de gesti\u00f3n de configuraci\u00f3n para automatizar el proceso de actualizaci\u00f3n de la aplicaci\u00f3n. Realiza actualizaciones en etapas para minimizar los tiempos de inactividad.","title":"Mantenimiento y actualizaciones"},{"location":"go/mid/mantenimiento_y_actualizaciones/#mantenimiento-y-actualizaciones","text":"","title":"Mantenimiento y actualizaciones"},{"location":"go/mid/mantenimiento_y_actualizaciones/#descripcion-del-modulo","text":"En este m\u00f3dulo aprender\u00e1s sobre las estrategias y herramientas para el mantenimiento y actualizaci\u00f3n de aplicaciones en Go. A medida que las aplicaciones crecen y evolucionan, es importante tener una buena estrategia de mantenimiento y actualizaci\u00f3n para asegurar su estabilidad y eficiencia.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"go/mid/mantenimiento_y_actualizaciones/#explicacion-teorica","text":"El mantenimiento y las actualizaciones son procesos importantes en cualquier aplicaci\u00f3n, ya que permiten corregir errores, agregar nuevas funcionalidades y mejorar el rendimiento. En Go, existen varias herramientas y pr\u00e1cticas que facilitan estos procesos. Para el mantenimiento, es importante realizar pruebas de manera regular para identificar y corregir errores. Tambi\u00e9n es recomendable realizar refactorizaciones para mejorar la calidad del c\u00f3digo y eliminar posibles problemas en el futuro. Otra pr\u00e1ctica \u00fatil es mantener un registro de cambios y actualizaciones para tener un seguimiento de las modificaciones realizadas en la aplicaci\u00f3n. En cuanto a las actualizaciones, es importante tener una buena estrategia para minimizar los tiempos de inactividad y asegurar una transici\u00f3n suave hacia la nueva versi\u00f3n. Algunas estrategias comunes incluyen el uso de despliegues en etapas, donde la aplicaci\u00f3n se actualiza gradualmente en diferentes servidores, y el uso de herramientas de gesti\u00f3n de configuraci\u00f3n como Ansible o Chef.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"go/mid/mantenimiento_y_actualizaciones/#palabras-clave-y-su-definicion","text":"Mantenimiento: Proceso de correcci\u00f3n y mejora de una aplicaci\u00f3n para asegurar su estabilidad y eficiencia. Actualizaci\u00f3n: Proceso de reemplazar una versi\u00f3n anterior de una aplicaci\u00f3n con una nueva versi\u00f3n que incluye correcciones y mejoras. Pruebas: Evaluaci\u00f3n de una aplicaci\u00f3n para identificar y corregir errores. Refactorizaci\u00f3n: Proceso de reorganizar el c\u00f3digo de una aplicaci\u00f3n para mejorar su calidad y eficiencia. Registro de cambios: Documentaci\u00f3n de las modificaciones y actualizaciones realizadas en una aplicaci\u00f3n. Tiempos de inactividad: Periodo en el que una aplicaci\u00f3n no est\u00e1 disponible debido a una actualizaci\u00f3n o mantenimiento. Despliegues en etapas: Estrategia de actualizaci\u00f3n en la que la aplicaci\u00f3n se actualiza gradualmente en diferentes servidores. Herramientas de gesti\u00f3n de configuraci\u00f3n: Programas que automatizan la configuraci\u00f3n y actualizaci\u00f3n de aplicaciones en diferentes servidores.","title":"Palabras clave y su definici\u00f3n"},{"location":"go/mid/mantenimiento_y_actualizaciones/#preguntas-de-repaso","text":"\u00bfCu\u00e1l es la diferencia entre mantenimiento y actualizaci\u00f3n? \u00bfPor qu\u00e9 es importante realizar pruebas y refactorizaciones en una aplicaci\u00f3n? \u00bfQu\u00e9 es un registro de cambios y por qu\u00e9 es \u00fatil? \u00bfCu\u00e1les son algunas estrategias para minimizar los tiempos de inactividad durante una actualizaci\u00f3n? \u00bfQu\u00e9 son las herramientas de gesti\u00f3n de configuraci\u00f3n y c\u00f3mo pueden ayudar en el proceso de actualizaci\u00f3n de una aplicaci\u00f3n en Go?","title":"Preguntas de repaso"},{"location":"go/mid/mantenimiento_y_actualizaciones/#ejemplos-de-codigo-en-go-lang","text":"","title":"Ejemplos de c\u00f3digo en Go lang"},{"location":"go/mid/mantenimiento_y_actualizaciones/#mantenimiento","text":"// Funci\u00f3n para verificar si un n\u00famero es primo func isPrime ( n int ) bool { // Si el n\u00famero es menor a 2 , no es primo if n < 2 { return false } // Si es igual a 2 , es primo if n == 2 { return true } // Si es divisible por 2 , no es primo if n % 2 == 0 { return false } // Verificar si es divisible por alg\u00fan otro n\u00famero impar for i : = 3 ; i * i <= n ; i += 2 { if n % i == 0 { return false } } // Si no se cumple ninguna condici\u00f3n , es primo return true }","title":"Mantenimiento"},{"location":"go/mid/mantenimiento_y_actualizaciones/#actualizacion","text":"// Funci\u00f3n para calcular el \u00e1 rea de un c\u00edrculo func calculateArea ( radius float64 ) float64 { return math . Pi * radius * radius } // Funci\u00f3n para calcular el per\u00edmetro de un c\u00edrculo func calculatePerimeter ( radius float64 ) float64 { return 2 * math . Pi * radius } // Funci\u00f3n para imprimir el \u00e1 rea y per\u00edmetro de un c\u00edrculo func printCircleInfo ( radius float64 ) { fmt . Printf ( \"El \u00e1rea del c\u00edrculo es: %f \\n \" , calculateArea ( radius )) fmt . Printf ( \"El per\u00edmetro del c\u00edrculo es: %f \\n \" , calculatePerimeter ( radius )) } // Funci\u00f3n main para ejecutar el programa func main () { // Prompt para ingresar el radio del c\u00edrculo fmt . Print ( \"Ingrese el radio del c\u00edrculo: \" ) // Leer el valor ingresado por el usuario var radius float64 fmt . Scanf ( \" %f \" , & radius ) // Imprimir informaci\u00f3n del c\u00edrculo printCircleInfo ( radius ) }","title":"Actualizaci\u00f3n"},{"location":"go/mid/mantenimiento_y_actualizaciones/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una funci\u00f3n en Go que reciba como par\u00e1metro una cadena de texto y devuelva el n\u00famero de palabras que contiene. Implementa una funci\u00f3n en Go que reciba un n\u00famero entero positivo y devuelva el factorial de ese n\u00famero. Escribe una funci\u00f3n en Go que reciba como par\u00e1metros dos arreglos de enteros y devuelva un nuevo arreglo que contenga la suma de los elementos de cada posici\u00f3n. Actualiza la funci\u00f3n del ejercicio 1 para que tambi\u00e9n cuente el n\u00famero de caracteres en la cadena de texto. Crea una aplicaci\u00f3n en Go que le permita al usuario ingresar un n\u00famero entero y luego le muestre la tabla de multiplicar de ese n\u00famero.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"go/mid/mantenimiento_y_actualizaciones/#consejos-o-mejores-practicas","text":"Realiza pruebas de manera regular para identificar y corregir errores. Mant\u00e9n un registro de cambios para tener un seguimiento de las modificaciones realizadas en la aplicaci\u00f3n. Realiza refactorizaciones para mejorar la calidad del c\u00f3digo y eliminar posibles problemas en el futuro. Utiliza herramientas de gesti\u00f3n de configuraci\u00f3n para automatizar el proceso de actualizaci\u00f3n de la aplicaci\u00f3n. Realiza actualizaciones en etapas para minimizar los tiempos de inactividad.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"go/mid/optimizaci%C3%B3n_de_rendimiento/","text":"Optimizaci\u00f3n de rendimiento en Go \u00b6 La optimizaci\u00f3n de rendimiento en Go es un tema importante para cualquier desarrollador que busque mejorar la eficiencia y velocidad de sus aplicaciones. En esta lecci\u00f3n, exploraremos algunas t\u00e9cnicas para mejorar el rendimiento en Go, incluyendo el uso de concurrencia y la optimizaci\u00f3n de recursos. Palabras clave: \u00b6 Rendimiento: se refiere a la velocidad y eficiencia de una aplicaci\u00f3n, medida en t\u00e9rminos de tiempo de ejecuci\u00f3n y uso de recursos. Go: un lenguaje de programaci\u00f3n de c\u00f3digo abierto desarrollado por Google, conocido por su facilidad de uso y eficiencia en el manejo de concurrencia. Concurrencia: la capacidad de una aplicaci\u00f3n para realizar m\u00faltiples tareas al mismo tiempo. Goroutines: hilos de ejecuci\u00f3n ligeros en Go, utilizados para lograr concurrencia. Channels: canales de comunicaci\u00f3n utilizados para sincronizar y comunicar datos entre goroutines. Mutex: abreviatura de \"mutual exclusion\", es una estructura de datos utilizada para evitar que m\u00faltiples goroutines accedan a los mismos recursos al mismo tiempo. Profiling: herramienta utilizada para analizar el rendimiento de una aplicaci\u00f3n y encontrar posibles cuellos de botella o problemas de eficiencia. Explicaci\u00f3n te\u00f3rica: \u00b6 Una de las principales caracter\u00edsticas de Go es su capacidad para manejar la concurrencia de manera eficiente. Esto se logra mediante el uso de goroutines, que son hilos de ejecuci\u00f3n ligeros que pueden ser creados y manejados f\u00e1cilmente. Con el uso de goroutines, una aplicaci\u00f3n puede realizar m\u00faltiples tareas al mismo tiempo, lo que puede mejorar significativamente su rendimiento. Adem\u00e1s de las goroutines, Go tambi\u00e9n cuenta con canales, que son utilizados para sincronizar y comunicar datos entre goroutines. Los canales son una forma segura de compartir datos entre m\u00faltiples goroutines, ya que evitan problemas de concurrencia como las condiciones de carrera. Otra t\u00e9cnica importante para mejorar el rendimiento en Go es el uso de mutex. Un mutex es una estructura de datos que se utiliza para controlar el acceso a recursos compartidos entre goroutines. Al bloquear un mutex, se asegura que solo una goroutine tenga acceso al recurso en un momento dado, evitando as\u00ed problemas de concurrencia. Adem\u00e1s de estas t\u00e9cnicas de concurrencia, tambi\u00e9n es importante optimizar el uso de recursos en una aplicaci\u00f3n en Go. Esto incluye el uso eficiente de la memoria y la minimizaci\u00f3n de la cantidad de operaciones de E/S (entrada/salida) realizadas. Una forma de lograr esto es utilizando el profiling para analizar el rendimiento de la aplicaci\u00f3n y encontrar posibles cuellos de botella o \u00e1reas que requieran mejoras. Preguntas de repaso: \u00b6 \u00bfQu\u00e9 es el rendimiento en una aplicaci\u00f3n? \u00bfQu\u00e9 es la concurrencia en Go? \u00bfCu\u00e1l es la diferencia entre una goroutine y un hilo de ejecuci\u00f3n tradicional? \u00bfQu\u00e9 son los canales y c\u00f3mo se utilizan en Go? \u00bfPor qu\u00e9 es importante utilizar mutex en aplicaciones concurrentes? \u00bfQu\u00e9 es el profiling y c\u00f3mo puede ayudar a mejorar el rendimiento de una aplicaci\u00f3n? Ejemplos de c\u00f3digo en Go: \u00b6 Goroutines y canales: \u00b6 // Crear una goroutine para imprimir n\u00fameros del 1 al 10 go func () { for i := 1 ; i <= 10 ; i ++ { fmt . Println ( i ) } }() // Crear un canal para comunicar datos entre goroutines c := make ( chan int ) // Enviar datos al canal desde una goroutine go func () { c <- 100 }() // Recibir datos del canal en la goroutine principal num := <- c fmt . Println ( num ) // Output: 100 Mutex: \u00b6 var mutex sync . Mutex // Crear un mutex // Utilizar el mutex para controlar el acceso a una variable compartida go func () { mutex . Lock () // Bloquear el mutex defer mutex . Unlock () // Desbloquear el mutex al final de la funci\u00f3n count ++ }() // Utilizar el mutex para evitar condiciones de carrera go func () { mutex . Lock () defer mutex . Unlock () // C\u00f3digo que accede a una variable compartida }() Profiling: \u00b6 // Importar el paquete \"runtime/pprof\" import \"runtime/pprof\" // Iniciar el profiling f , err := os . Create ( \"profile.prof\" ) if err != nil { log . Fatal ( err ) } pprof . StartCPUProfile ( f ) defer pprof . StopCPUProfile () // C\u00f3digo a ser analizado for i := 0 ; i < 1000000 ; i ++ { // Operaciones de c\u00e1lculo intensivas } Ejercicios pr\u00e1cticos: \u00b6 Crea una aplicaci\u00f3n en Go que calcule la suma de los primeros 100 n\u00fameros naturales utilizando goroutines y canales. Modifica la aplicaci\u00f3n anterior para que utilice un mutex y evite condiciones de carrera. Realiza el profiling de una aplicaci\u00f3n en Go que realice operaciones de escritura intensivas en disco y encuentra posibles mejoras para optimizar su rendimiento. Consejos y mejores pr\u00e1cticas: \u00b6 Utiliza goroutines y canales para lograr concurrencia en tu aplicaci\u00f3n en Go. Evita problemas de concurrencia utilizando mutex para controlar el acceso a recursos compartidos. Utiliza el profiling para analizar el rendimiento de tu aplicaci\u00f3n y encontrar posibles \u00e1reas de mejora. Optimiza el uso de recursos, como la memoria y las operaciones de E/S, para mejorar el rendimiento de tu aplicaci\u00f3n en Go. Prueba y mide el rendimiento de tu aplicaci\u00f3n antes y despu\u00e9s de realizar cambios para asegurarte de que est\u00e1s logrando mejoras significativas.","title":"Optimizaci\u00f3n de rendimiento en Go"},{"location":"go/mid/optimizaci%C3%B3n_de_rendimiento/#optimizacion-de-rendimiento-en-go","text":"La optimizaci\u00f3n de rendimiento en Go es un tema importante para cualquier desarrollador que busque mejorar la eficiencia y velocidad de sus aplicaciones. En esta lecci\u00f3n, exploraremos algunas t\u00e9cnicas para mejorar el rendimiento en Go, incluyendo el uso de concurrencia y la optimizaci\u00f3n de recursos.","title":"Optimizaci\u00f3n de rendimiento en Go"},{"location":"go/mid/optimizaci%C3%B3n_de_rendimiento/#palabras-clave","text":"Rendimiento: se refiere a la velocidad y eficiencia de una aplicaci\u00f3n, medida en t\u00e9rminos de tiempo de ejecuci\u00f3n y uso de recursos. Go: un lenguaje de programaci\u00f3n de c\u00f3digo abierto desarrollado por Google, conocido por su facilidad de uso y eficiencia en el manejo de concurrencia. Concurrencia: la capacidad de una aplicaci\u00f3n para realizar m\u00faltiples tareas al mismo tiempo. Goroutines: hilos de ejecuci\u00f3n ligeros en Go, utilizados para lograr concurrencia. Channels: canales de comunicaci\u00f3n utilizados para sincronizar y comunicar datos entre goroutines. Mutex: abreviatura de \"mutual exclusion\", es una estructura de datos utilizada para evitar que m\u00faltiples goroutines accedan a los mismos recursos al mismo tiempo. Profiling: herramienta utilizada para analizar el rendimiento de una aplicaci\u00f3n y encontrar posibles cuellos de botella o problemas de eficiencia.","title":"Palabras clave:"},{"location":"go/mid/optimizaci%C3%B3n_de_rendimiento/#explicacion-teorica","text":"Una de las principales caracter\u00edsticas de Go es su capacidad para manejar la concurrencia de manera eficiente. Esto se logra mediante el uso de goroutines, que son hilos de ejecuci\u00f3n ligeros que pueden ser creados y manejados f\u00e1cilmente. Con el uso de goroutines, una aplicaci\u00f3n puede realizar m\u00faltiples tareas al mismo tiempo, lo que puede mejorar significativamente su rendimiento. Adem\u00e1s de las goroutines, Go tambi\u00e9n cuenta con canales, que son utilizados para sincronizar y comunicar datos entre goroutines. Los canales son una forma segura de compartir datos entre m\u00faltiples goroutines, ya que evitan problemas de concurrencia como las condiciones de carrera. Otra t\u00e9cnica importante para mejorar el rendimiento en Go es el uso de mutex. Un mutex es una estructura de datos que se utiliza para controlar el acceso a recursos compartidos entre goroutines. Al bloquear un mutex, se asegura que solo una goroutine tenga acceso al recurso en un momento dado, evitando as\u00ed problemas de concurrencia. Adem\u00e1s de estas t\u00e9cnicas de concurrencia, tambi\u00e9n es importante optimizar el uso de recursos en una aplicaci\u00f3n en Go. Esto incluye el uso eficiente de la memoria y la minimizaci\u00f3n de la cantidad de operaciones de E/S (entrada/salida) realizadas. Una forma de lograr esto es utilizando el profiling para analizar el rendimiento de la aplicaci\u00f3n y encontrar posibles cuellos de botella o \u00e1reas que requieran mejoras.","title":"Explicaci\u00f3n te\u00f3rica:"},{"location":"go/mid/optimizaci%C3%B3n_de_rendimiento/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es el rendimiento en una aplicaci\u00f3n? \u00bfQu\u00e9 es la concurrencia en Go? \u00bfCu\u00e1l es la diferencia entre una goroutine y un hilo de ejecuci\u00f3n tradicional? \u00bfQu\u00e9 son los canales y c\u00f3mo se utilizan en Go? \u00bfPor qu\u00e9 es importante utilizar mutex en aplicaciones concurrentes? \u00bfQu\u00e9 es el profiling y c\u00f3mo puede ayudar a mejorar el rendimiento de una aplicaci\u00f3n?","title":"Preguntas de repaso:"},{"location":"go/mid/optimizaci%C3%B3n_de_rendimiento/#ejemplos-de-codigo-en-go","text":"","title":"Ejemplos de c\u00f3digo en Go:"},{"location":"go/mid/optimizaci%C3%B3n_de_rendimiento/#goroutines-y-canales","text":"// Crear una goroutine para imprimir n\u00fameros del 1 al 10 go func () { for i := 1 ; i <= 10 ; i ++ { fmt . Println ( i ) } }() // Crear un canal para comunicar datos entre goroutines c := make ( chan int ) // Enviar datos al canal desde una goroutine go func () { c <- 100 }() // Recibir datos del canal en la goroutine principal num := <- c fmt . Println ( num ) // Output: 100","title":"Goroutines y canales:"},{"location":"go/mid/optimizaci%C3%B3n_de_rendimiento/#mutex","text":"var mutex sync . Mutex // Crear un mutex // Utilizar el mutex para controlar el acceso a una variable compartida go func () { mutex . Lock () // Bloquear el mutex defer mutex . Unlock () // Desbloquear el mutex al final de la funci\u00f3n count ++ }() // Utilizar el mutex para evitar condiciones de carrera go func () { mutex . Lock () defer mutex . Unlock () // C\u00f3digo que accede a una variable compartida }()","title":"Mutex:"},{"location":"go/mid/optimizaci%C3%B3n_de_rendimiento/#profiling","text":"// Importar el paquete \"runtime/pprof\" import \"runtime/pprof\" // Iniciar el profiling f , err := os . Create ( \"profile.prof\" ) if err != nil { log . Fatal ( err ) } pprof . StartCPUProfile ( f ) defer pprof . StopCPUProfile () // C\u00f3digo a ser analizado for i := 0 ; i < 1000000 ; i ++ { // Operaciones de c\u00e1lculo intensivas }","title":"Profiling:"},{"location":"go/mid/optimizaci%C3%B3n_de_rendimiento/#ejercicios-practicos","text":"Crea una aplicaci\u00f3n en Go que calcule la suma de los primeros 100 n\u00fameros naturales utilizando goroutines y canales. Modifica la aplicaci\u00f3n anterior para que utilice un mutex y evite condiciones de carrera. Realiza el profiling de una aplicaci\u00f3n en Go que realice operaciones de escritura intensivas en disco y encuentra posibles mejoras para optimizar su rendimiento.","title":"Ejercicios pr\u00e1cticos:"},{"location":"go/mid/optimizaci%C3%B3n_de_rendimiento/#consejos-y-mejores-practicas","text":"Utiliza goroutines y canales para lograr concurrencia en tu aplicaci\u00f3n en Go. Evita problemas de concurrencia utilizando mutex para controlar el acceso a recursos compartidos. Utiliza el profiling para analizar el rendimiento de tu aplicaci\u00f3n y encontrar posibles \u00e1reas de mejora. Optimiza el uso de recursos, como la memoria y las operaciones de E/S, para mejorar el rendimiento de tu aplicaci\u00f3n en Go. Prueba y mide el rendimiento de tu aplicaci\u00f3n antes y despu\u00e9s de realizar cambios para asegurarte de que est\u00e1s logrando mejoras significativas.","title":"Consejos y mejores pr\u00e1cticas:"},{"location":"go/mid/programaci%C3%B3n_funcional/","text":"Programaci\u00f3n funcional en Go \u00b6 La programaci\u00f3n funcional es un paradigma de programaci\u00f3n que se basa en el uso de funciones como elementos fundamentales del desarrollo de software. A diferencia de otros paradigmas, en la programaci\u00f3n funcional se enfoca en la evaluaci\u00f3n de expresiones y en la ausencia de cambio de estado y datos mutables. En Go, un lenguaje de programaci\u00f3n compilado y concurrente, tambi\u00e9n es posible utilizar conceptos de programaci\u00f3n funcional para escribir c\u00f3digo m\u00e1s conciso y legible. Palabras clave y definiciones \u00b6 Funci\u00f3n de orden superior: Una funci\u00f3n que puede recibir como par\u00e1metros otras funciones o devolver una funci\u00f3n como resultado. En Go, se pueden utilizar funciones de orden superior para crear abstracciones y reutilizar c\u00f3digo. Closures: Una funci\u00f3n an\u00f3nima que puede acceder y modificar variables definidas fuera de su alcance. En Go, los closures se utilizan com\u00fanmente para crear funciones que recuerden el estado de una variable. Evaluaci\u00f3n de expresiones: El proceso de calcular el valor de una expresi\u00f3n matem\u00e1tica o l\u00f3gica. En la programaci\u00f3n funcional, se prioriza la evaluaci\u00f3n de expresiones sobre la ejecuci\u00f3n de instrucciones. Estado y datos mutables: La capacidad de cambiar el valor de una variable o estructura de datos durante la ejecuci\u00f3n del programa. En la programaci\u00f3n funcional, se evita el uso de datos mutables para prevenir efectos secundarios y aumentar la seguridad del c\u00f3digo. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es una funci\u00f3n de orden superior y c\u00f3mo se utiliza en Go? \u00bfQu\u00e9 es un closure y en qu\u00e9 casos se pueden utilizar en Go? \u00bfCu\u00e1l es la diferencia entre la evaluaci\u00f3n de expresiones y la ejecuci\u00f3n de instrucciones? \u00bfPor qu\u00e9 se evita el uso de datos mutables en la programaci\u00f3n funcional? Ejemplos de c\u00f3digo en Go \u00b6 Funciones de orden superior \u00b6 En el siguiente ejemplo, se define una funci\u00f3n map que recibe como par\u00e1metros una funci\u00f3n f y un slice s de enteros, y devuelve un nuevo slice con los resultados de aplicar la funci\u00f3n f a cada elemento de s . func map ( f func ( int ) int , s [] int ) [] int { result := make ([] int , len ( s )) for i , v := range s { result [ i ] = f ( v ) } return result } func main () { numbers := [] int { 1 , 2 , 3 , 4 , 5 } // Se define una funci\u00f3n an\u00f3nima que multiplica por 2 cada elemento. doubled := map ( func ( x int ) int { return x * 2 }, numbers ) fmt . Println ( doubled ) // Output: [2 4 6 8 10] } Closures \u00b6 En este ejemplo, se declara una funci\u00f3n counter que devuelve una funci\u00f3n an\u00f3nima que incrementa un contador cada vez que es llamada. func counter () func () int { count := 0 return func () int { count ++ return count } } func main () { nextNum := counter () fmt . Println ( nextNum ()) // Output: 1 fmt . Println ( nextNum ()) // Output: 2 fmt . Println ( nextNum ()) // Output: 3 } Ejercicios pr\u00e1cticos \u00b6 Crea una funci\u00f3n de orden superior llamada filter que reciba como par\u00e1metros una funci\u00f3n f y un slice de strings s , y devuelva un nuevo slice con los elementos de s que cumplan con la condici\u00f3n de f . Utiliza closures para crear una funci\u00f3n calculator que reciba un operando y devuelva una funci\u00f3n que realice una operaci\u00f3n matem\u00e1tica con ese operando. Escribe una funci\u00f3n de orden superior llamada reduce que reciba como par\u00e1metros una funci\u00f3n f , un valor inicial y un slice de enteros s , y devuelva el resultado de aplicar la funci\u00f3n f a cada elemento de s y el valor inicial. Crea una funci\u00f3n makeSuffixer que reciba una cadena de texto suffix y devuelva una funci\u00f3n que a\u00f1ada el sufijo suffix a cualquier cadena de texto que se le pase como argumento. Consejos y mejores pr\u00e1cticas \u00b6 Utiliza funciones de orden superior y closures para crear abstracciones y evitar la repetici\u00f3n de c\u00f3digo. Evita el uso de variables mutables para mantener un c\u00f3digo m\u00e1s seguro y prevenir efectos secundarios. Practica la evaluaci\u00f3n de expresiones y el uso de funciones como elementos fundamentales de la programaci\u00f3n funcional en Go.","title":"Programaci\u00f3n funcional en Go"},{"location":"go/mid/programaci%C3%B3n_funcional/#programacion-funcional-en-go","text":"La programaci\u00f3n funcional es un paradigma de programaci\u00f3n que se basa en el uso de funciones como elementos fundamentales del desarrollo de software. A diferencia de otros paradigmas, en la programaci\u00f3n funcional se enfoca en la evaluaci\u00f3n de expresiones y en la ausencia de cambio de estado y datos mutables. En Go, un lenguaje de programaci\u00f3n compilado y concurrente, tambi\u00e9n es posible utilizar conceptos de programaci\u00f3n funcional para escribir c\u00f3digo m\u00e1s conciso y legible.","title":"Programaci\u00f3n funcional en Go"},{"location":"go/mid/programaci%C3%B3n_funcional/#palabras-clave-y-definiciones","text":"Funci\u00f3n de orden superior: Una funci\u00f3n que puede recibir como par\u00e1metros otras funciones o devolver una funci\u00f3n como resultado. En Go, se pueden utilizar funciones de orden superior para crear abstracciones y reutilizar c\u00f3digo. Closures: Una funci\u00f3n an\u00f3nima que puede acceder y modificar variables definidas fuera de su alcance. En Go, los closures se utilizan com\u00fanmente para crear funciones que recuerden el estado de una variable. Evaluaci\u00f3n de expresiones: El proceso de calcular el valor de una expresi\u00f3n matem\u00e1tica o l\u00f3gica. En la programaci\u00f3n funcional, se prioriza la evaluaci\u00f3n de expresiones sobre la ejecuci\u00f3n de instrucciones. Estado y datos mutables: La capacidad de cambiar el valor de una variable o estructura de datos durante la ejecuci\u00f3n del programa. En la programaci\u00f3n funcional, se evita el uso de datos mutables para prevenir efectos secundarios y aumentar la seguridad del c\u00f3digo.","title":"Palabras clave y definiciones"},{"location":"go/mid/programaci%C3%B3n_funcional/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es una funci\u00f3n de orden superior y c\u00f3mo se utiliza en Go? \u00bfQu\u00e9 es un closure y en qu\u00e9 casos se pueden utilizar en Go? \u00bfCu\u00e1l es la diferencia entre la evaluaci\u00f3n de expresiones y la ejecuci\u00f3n de instrucciones? \u00bfPor qu\u00e9 se evita el uso de datos mutables en la programaci\u00f3n funcional?","title":"Preguntas de repaso"},{"location":"go/mid/programaci%C3%B3n_funcional/#ejemplos-de-codigo-en-go","text":"","title":"Ejemplos de c\u00f3digo en Go"},{"location":"go/mid/programaci%C3%B3n_funcional/#funciones-de-orden-superior","text":"En el siguiente ejemplo, se define una funci\u00f3n map que recibe como par\u00e1metros una funci\u00f3n f y un slice s de enteros, y devuelve un nuevo slice con los resultados de aplicar la funci\u00f3n f a cada elemento de s . func map ( f func ( int ) int , s [] int ) [] int { result := make ([] int , len ( s )) for i , v := range s { result [ i ] = f ( v ) } return result } func main () { numbers := [] int { 1 , 2 , 3 , 4 , 5 } // Se define una funci\u00f3n an\u00f3nima que multiplica por 2 cada elemento. doubled := map ( func ( x int ) int { return x * 2 }, numbers ) fmt . Println ( doubled ) // Output: [2 4 6 8 10] }","title":"Funciones de orden superior"},{"location":"go/mid/programaci%C3%B3n_funcional/#closures","text":"En este ejemplo, se declara una funci\u00f3n counter que devuelve una funci\u00f3n an\u00f3nima que incrementa un contador cada vez que es llamada. func counter () func () int { count := 0 return func () int { count ++ return count } } func main () { nextNum := counter () fmt . Println ( nextNum ()) // Output: 1 fmt . Println ( nextNum ()) // Output: 2 fmt . Println ( nextNum ()) // Output: 3 }","title":"Closures"},{"location":"go/mid/programaci%C3%B3n_funcional/#ejercicios-practicos","text":"Crea una funci\u00f3n de orden superior llamada filter que reciba como par\u00e1metros una funci\u00f3n f y un slice de strings s , y devuelva un nuevo slice con los elementos de s que cumplan con la condici\u00f3n de f . Utiliza closures para crear una funci\u00f3n calculator que reciba un operando y devuelva una funci\u00f3n que realice una operaci\u00f3n matem\u00e1tica con ese operando. Escribe una funci\u00f3n de orden superior llamada reduce que reciba como par\u00e1metros una funci\u00f3n f , un valor inicial y un slice de enteros s , y devuelva el resultado de aplicar la funci\u00f3n f a cada elemento de s y el valor inicial. Crea una funci\u00f3n makeSuffixer que reciba una cadena de texto suffix y devuelva una funci\u00f3n que a\u00f1ada el sufijo suffix a cualquier cadena de texto que se le pase como argumento.","title":"Ejercicios pr\u00e1cticos"},{"location":"go/mid/programaci%C3%B3n_funcional/#consejos-y-mejores-practicas","text":"Utiliza funciones de orden superior y closures para crear abstracciones y evitar la repetici\u00f3n de c\u00f3digo. Evita el uso de variables mutables para mantener un c\u00f3digo m\u00e1s seguro y prevenir efectos secundarios. Practica la evaluaci\u00f3n de expresiones y el uso de funciones como elementos fundamentales de la programaci\u00f3n funcional en Go.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"go/mid/seguridad_y_autenticaci%C3%B3n/","text":"Seguridad y autenticaci\u00f3n en Go lang \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En este m\u00f3dulo, aprenderemos c\u00f3mo implementar medidas de seguridad y autenticaci\u00f3n en aplicaciones desarrolladas en Go lang. La seguridad y autenticaci\u00f3n son aspectos fundamentales en el desarrollo de aplicaciones, ya que garantizan la protecci\u00f3n de los datos y la identidad de los usuarios. En esta lecci\u00f3n, abordaremos los conceptos te\u00f3ricos y pr\u00e1cticos para mejorar la seguridad en nuestras aplicaciones en Go. Explicaci\u00f3n te\u00f3rica \u00b6 La seguridad en aplicaciones en Go se refiere a la protecci\u00f3n de datos y recursos de posibles ataques externos. Esto incluye la prevenci\u00f3n de accesos no autorizados, la protecci\u00f3n de datos sensibles y la detecci\u00f3n y respuesta ante ataques de seguridad. La autenticaci\u00f3n, por otro lado, es el proceso de verificar la identidad de un usuario para garantizar que tenga acceso autorizado a la aplicaci\u00f3n y sus recursos. En Go, la autenticaci\u00f3n se puede implementar utilizando diferentes m\u00e9todos, como contrase\u00f1as, tokens, certificados digitales, entre otros. Palabras clave y su definici\u00f3n \u00b6 Seguridad: conjunto de medidas y t\u00e9cnicas para proteger datos y recursos ante posibles ataques externos. Autenticaci\u00f3n: proceso de verificaci\u00f3n de la identidad de un usuario para garantizar el acceso autorizado a una aplicaci\u00f3n. Contrase\u00f1as: m\u00e9todo de autenticaci\u00f3n basado en la verificaci\u00f3n de una combinaci\u00f3n de caracteres secreta. Tokens: cadenas de texto generadas por la aplicaci\u00f3n para permitir el acceso autorizado a recursos protegidos. Certificados digitales: documentos digitales que garantizan la identidad de una entidad y se utilizan para autenticaci\u00f3n y cifrado de datos. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la seguridad en aplicaciones en Go? \u00bfQu\u00e9 es la autenticaci\u00f3n y por qu\u00e9 es importante en el desarrollo de aplicaciones? \u00bfCu\u00e1les son los m\u00e9todos de autenticaci\u00f3n m\u00e1s comunes en Go? \u00bfQu\u00e9 son los tokens y c\u00f3mo se utilizan en la autenticaci\u00f3n? \u00bfQu\u00e9 son los certificados digitales y c\u00f3mo se utilizan en la seguridad de aplicaciones en Go? Ejemplos de c\u00f3digo en Go lang \u00b6 Implementaci\u00f3n de autenticaci\u00f3n con contrase\u00f1as \u00b6 // Funci\u00f3n para verificar la contrase\u00f1a ingresada por el usuario func verificarContrasena ( contrasena string ) bool { // Obtener la contrase\u00f1a almacenada en la base de datos para el usuario contrasenaAlmacenada := obtenerContrasena ( usuario ) // Verificar que la contrase\u00f1a ingresada coincida con la almacenada return contrasena == contrasenaAlmacenada } // Funci\u00f3n para iniciar sesi\u00f3n con autenticaci\u00f3n por contrasena func iniciarSesion ( usuario string , contrasena string ) { // Verificar que el usuario exista en la base de datos if verificarUsuario ( usuario ) { // Verificar la contrase\u00f1a ingresada if verificarContrasena ( contrasena ) { // Iniciar sesi\u00f3n en la aplicaci\u00f3n iniciarSesion ( usuario ) } else { // Mostrar mensaje de error si la contrase\u00f1a no coincide fmt . Println ( \"Contrase\u00f1a incorrecta.\" ) } } else { // Mostrar mensaje de error si el usuario no existe fmt . Println ( \"Usuario no encontrado.\" ) } } Implementaci\u00f3n de autenticaci\u00f3n con tokens \u00b6 // Funci\u00f3n para generar un token para el usuario func generarToken ( usuario string ) string { // Generar una cadena de texto aleatoria como token token := generadorAleatorio () // Guardar el token en la base de datos para el usuario guardarToken ( usuario , token ) return token } // Funci\u00f3n para verificar el token recibido de un usuario func verificarToken ( usuario string , token string ) bool { // Obtener el token almacenado en la base de datos para el usuario tokenAlmacenado := obtenerToken ( usuario ) // Verificar que el token recibido coincida con el almacenado return token == tokenAlmacenado } // Funci\u00f3n para acceder a recursos protegidos con autenticaci\u00f3n por token func accederRecurso ( usuario string , token string ) { // Verificar que el usuario y el token sean v\u00e1lidos if verificarUsuario ( usuario ) && verificarToken ( usuario , token ) { // Acceder al recurso protegido accederRecursoProtegido () } else { // Mostrar mensaje de error si el usuario o el token son inv\u00e1lidos fmt . Println ( \"Acceso no autorizado.\" ) } } Ejercicios pr\u00e1cticos \u00b6 Implementar un sistema de autenticaci\u00f3n con contrase\u00f1as en una aplicaci\u00f3n en Go. La aplicaci\u00f3n debe tener una funci\u00f3n para registrar usuarios y otra para iniciar sesi\u00f3n con autenticaci\u00f3n por contrase\u00f1a. Mejorar el sistema de autenticaci\u00f3n anterior para utilizar tokens en lugar de contrase\u00f1as. Crear una funci\u00f3n en la aplicaci\u00f3n que permita a los usuarios cambiar su contrase\u00f1a. Consejos o mejores pr\u00e1cticas \u00b6 Utilizar contrase\u00f1as seguras y almacenarlas encriptadas en la base de datos. Utilizar tokens con un tiempo de expiraci\u00f3n para mejorar la seguridad. Implementar medidas de seguridad adicionales, como cifrado de datos y protecci\u00f3n contra ataques de fuerza bruta. Realizar pruebas de seguridad peri\u00f3dicas para identificar posibles vulnerabilidades en la aplicaci\u00f3n. Mantener actualizadas las librer\u00edas y dependencias utilizadas en la aplicaci\u00f3n para evitar posibles fallos de seguridad.","title":"Seguridad y autenticaci\u00f3n en Go lang"},{"location":"go/mid/seguridad_y_autenticaci%C3%B3n/#seguridad-y-autenticacion-en-go-lang","text":"","title":"Seguridad y autenticaci\u00f3n en Go lang"},{"location":"go/mid/seguridad_y_autenticaci%C3%B3n/#descripcion-del-modulo","text":"En este m\u00f3dulo, aprenderemos c\u00f3mo implementar medidas de seguridad y autenticaci\u00f3n en aplicaciones desarrolladas en Go lang. La seguridad y autenticaci\u00f3n son aspectos fundamentales en el desarrollo de aplicaciones, ya que garantizan la protecci\u00f3n de los datos y la identidad de los usuarios. En esta lecci\u00f3n, abordaremos los conceptos te\u00f3ricos y pr\u00e1cticos para mejorar la seguridad en nuestras aplicaciones en Go.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"go/mid/seguridad_y_autenticaci%C3%B3n/#explicacion-teorica","text":"La seguridad en aplicaciones en Go se refiere a la protecci\u00f3n de datos y recursos de posibles ataques externos. Esto incluye la prevenci\u00f3n de accesos no autorizados, la protecci\u00f3n de datos sensibles y la detecci\u00f3n y respuesta ante ataques de seguridad. La autenticaci\u00f3n, por otro lado, es el proceso de verificar la identidad de un usuario para garantizar que tenga acceso autorizado a la aplicaci\u00f3n y sus recursos. En Go, la autenticaci\u00f3n se puede implementar utilizando diferentes m\u00e9todos, como contrase\u00f1as, tokens, certificados digitales, entre otros.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"go/mid/seguridad_y_autenticaci%C3%B3n/#palabras-clave-y-su-definicion","text":"Seguridad: conjunto de medidas y t\u00e9cnicas para proteger datos y recursos ante posibles ataques externos. Autenticaci\u00f3n: proceso de verificaci\u00f3n de la identidad de un usuario para garantizar el acceso autorizado a una aplicaci\u00f3n. Contrase\u00f1as: m\u00e9todo de autenticaci\u00f3n basado en la verificaci\u00f3n de una combinaci\u00f3n de caracteres secreta. Tokens: cadenas de texto generadas por la aplicaci\u00f3n para permitir el acceso autorizado a recursos protegidos. Certificados digitales: documentos digitales que garantizan la identidad de una entidad y se utilizan para autenticaci\u00f3n y cifrado de datos.","title":"Palabras clave y su definici\u00f3n"},{"location":"go/mid/seguridad_y_autenticaci%C3%B3n/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la seguridad en aplicaciones en Go? \u00bfQu\u00e9 es la autenticaci\u00f3n y por qu\u00e9 es importante en el desarrollo de aplicaciones? \u00bfCu\u00e1les son los m\u00e9todos de autenticaci\u00f3n m\u00e1s comunes en Go? \u00bfQu\u00e9 son los tokens y c\u00f3mo se utilizan en la autenticaci\u00f3n? \u00bfQu\u00e9 son los certificados digitales y c\u00f3mo se utilizan en la seguridad de aplicaciones en Go?","title":"Preguntas de repaso"},{"location":"go/mid/seguridad_y_autenticaci%C3%B3n/#ejemplos-de-codigo-en-go-lang","text":"","title":"Ejemplos de c\u00f3digo en Go lang"},{"location":"go/mid/seguridad_y_autenticaci%C3%B3n/#implementacion-de-autenticacion-con-contrasenas","text":"// Funci\u00f3n para verificar la contrase\u00f1a ingresada por el usuario func verificarContrasena ( contrasena string ) bool { // Obtener la contrase\u00f1a almacenada en la base de datos para el usuario contrasenaAlmacenada := obtenerContrasena ( usuario ) // Verificar que la contrase\u00f1a ingresada coincida con la almacenada return contrasena == contrasenaAlmacenada } // Funci\u00f3n para iniciar sesi\u00f3n con autenticaci\u00f3n por contrasena func iniciarSesion ( usuario string , contrasena string ) { // Verificar que el usuario exista en la base de datos if verificarUsuario ( usuario ) { // Verificar la contrase\u00f1a ingresada if verificarContrasena ( contrasena ) { // Iniciar sesi\u00f3n en la aplicaci\u00f3n iniciarSesion ( usuario ) } else { // Mostrar mensaje de error si la contrase\u00f1a no coincide fmt . Println ( \"Contrase\u00f1a incorrecta.\" ) } } else { // Mostrar mensaje de error si el usuario no existe fmt . Println ( \"Usuario no encontrado.\" ) } }","title":"Implementaci\u00f3n de autenticaci\u00f3n con contrase\u00f1as"},{"location":"go/mid/seguridad_y_autenticaci%C3%B3n/#implementacion-de-autenticacion-con-tokens","text":"// Funci\u00f3n para generar un token para el usuario func generarToken ( usuario string ) string { // Generar una cadena de texto aleatoria como token token := generadorAleatorio () // Guardar el token en la base de datos para el usuario guardarToken ( usuario , token ) return token } // Funci\u00f3n para verificar el token recibido de un usuario func verificarToken ( usuario string , token string ) bool { // Obtener el token almacenado en la base de datos para el usuario tokenAlmacenado := obtenerToken ( usuario ) // Verificar que el token recibido coincida con el almacenado return token == tokenAlmacenado } // Funci\u00f3n para acceder a recursos protegidos con autenticaci\u00f3n por token func accederRecurso ( usuario string , token string ) { // Verificar que el usuario y el token sean v\u00e1lidos if verificarUsuario ( usuario ) && verificarToken ( usuario , token ) { // Acceder al recurso protegido accederRecursoProtegido () } else { // Mostrar mensaje de error si el usuario o el token son inv\u00e1lidos fmt . Println ( \"Acceso no autorizado.\" ) } }","title":"Implementaci\u00f3n de autenticaci\u00f3n con tokens"},{"location":"go/mid/seguridad_y_autenticaci%C3%B3n/#ejercicios-practicos","text":"Implementar un sistema de autenticaci\u00f3n con contrase\u00f1as en una aplicaci\u00f3n en Go. La aplicaci\u00f3n debe tener una funci\u00f3n para registrar usuarios y otra para iniciar sesi\u00f3n con autenticaci\u00f3n por contrase\u00f1a. Mejorar el sistema de autenticaci\u00f3n anterior para utilizar tokens en lugar de contrase\u00f1as. Crear una funci\u00f3n en la aplicaci\u00f3n que permita a los usuarios cambiar su contrase\u00f1a.","title":"Ejercicios pr\u00e1cticos"},{"location":"go/mid/seguridad_y_autenticaci%C3%B3n/#consejos-o-mejores-practicas","text":"Utilizar contrase\u00f1as seguras y almacenarlas encriptadas en la base de datos. Utilizar tokens con un tiempo de expiraci\u00f3n para mejorar la seguridad. Implementar medidas de seguridad adicionales, como cifrado de datos y protecci\u00f3n contra ataques de fuerza bruta. Realizar pruebas de seguridad peri\u00f3dicas para identificar posibles vulnerabilidades en la aplicaci\u00f3n. Mantener actualizadas las librer\u00edas y dependencias utilizadas en la aplicaci\u00f3n para evitar posibles fallos de seguridad.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"go/mid/uso_de_bibliotecas_y_frameworks/","text":"Uso de bibliotecas y frameworks en Go \u00b6 En el mundo de la programaci\u00f3n, las bibliotecas y frameworks son herramientas esenciales para simplificar el desarrollo de aplicaciones y mejorar la eficiencia del c\u00f3digo. En Go, un lenguaje de programaci\u00f3n de c\u00f3digo abierto desarrollado por Google, tambi\u00e9n existen una gran variedad de bibliotecas y frameworks para facilitar el trabajo de los desarrolladores. En este m\u00f3dulo, exploraremos el uso de algunas de las bibliotecas y frameworks m\u00e1s populares en Go y c\u00f3mo pueden ser implementados en tus proyectos. Palabras clave \u00b6 Biblioteca: conjunto de funciones y m\u00e9todos que pueden ser utilizados en un programa para realizar tareas espec\u00edficas. Framework: estructura de trabajo que proporciona una base s\u00f3lida para el desarrollo de aplicaciones, incluyendo herramientas y componentes predefinidos. Gin: framework web ligero y de alto rendimiento para crear API en Go. Beego: framework web completo y de c\u00f3digo abierto para el desarrollo de aplicaciones y servicios en Go. Preguntas de repaso \u00b6 \u00bfQu\u00e9 son las bibliotecas y frameworks en programaci\u00f3n? \u00bfCu\u00e1l es la diferencia entre una biblioteca y un framework? \u00bfPor qu\u00e9 es importante utilizar bibliotecas y frameworks en el desarrollo de aplicaciones en Go? \u00bfQu\u00e9 es Gin y para qu\u00e9 se utiliza? \u00bfCu\u00e1les son las caracter\u00edsticas principales de Beego? Ejemplos de c\u00f3digo \u00b6 Uso de la biblioteca \"fmt\" \u00b6 package main import \"fmt\" func main () { fmt . Println ( \"\u00a1Hola mundo!\" ) } Creaci\u00f3n de un servidor web b\u00e1sico con Gin \u00b6 package main import ( \"github.com/gin-gonic/gin\" ) func main () { r := gin . Default () r . GET ( \"/\" , func ( c * gin . Context ) { c . JSON ( 200 , gin . H { \"message\" : \"\u00a1Hola mundo!\" , }) }) r . Run () // corre el servidor en el puerto 8080 } Creaci\u00f3n de un controlador con Beego \u00b6 package controllers import ( \"github.com/astaxie/beego\" ) type MainController struct { beego . Controller } func ( c * MainController ) Get () { c . Data [ \"json\" ] = \"\u00a1Hola mundo!\" c . ServeJSON () } Ejercicios pr\u00e1cticos \u00b6 Crea un programa que utilice la biblioteca \"math\" para calcular el \u00e1rea de un c\u00edrculo. Utiliza el framework Gin para crear una API que devuelva una lista de productos en formato JSON. Implementa una aplicaci\u00f3n web con Beego que permita a los usuarios registrarse y hacer login. Consejos y mejores pr\u00e1cticas \u00b6 Antes de utilizar cualquier biblioteca o framework, aseg\u00farate de entender su funcionalidad y c\u00f3mo se integra en tu proyecto. Lee la documentaci\u00f3n y ejemplos de c\u00f3digo de la biblioteca o framework que est\u00e9s utilizando para aprovechar al m\u00e1ximo sus caracter\u00edsticas. No utilices varias bibliotecas o frameworks para realizar la misma tarea, ya que puede resultar en conflictos y c\u00f3digo innecesario. Actualiza regularmente las bibliotecas y frameworks utilizados para aprovechar las \u00faltimas mejoras y solucionar posibles problemas de seguridad. Aprende a utilizar herramientas como \"go get\" para instalar y gestionar bibliotecas y frameworks en tus proyectos de Go.","title":"Uso de bibliotecas y frameworks en Go"},{"location":"go/mid/uso_de_bibliotecas_y_frameworks/#uso-de-bibliotecas-y-frameworks-en-go","text":"En el mundo de la programaci\u00f3n, las bibliotecas y frameworks son herramientas esenciales para simplificar el desarrollo de aplicaciones y mejorar la eficiencia del c\u00f3digo. En Go, un lenguaje de programaci\u00f3n de c\u00f3digo abierto desarrollado por Google, tambi\u00e9n existen una gran variedad de bibliotecas y frameworks para facilitar el trabajo de los desarrolladores. En este m\u00f3dulo, exploraremos el uso de algunas de las bibliotecas y frameworks m\u00e1s populares en Go y c\u00f3mo pueden ser implementados en tus proyectos.","title":"Uso de bibliotecas y frameworks en Go"},{"location":"go/mid/uso_de_bibliotecas_y_frameworks/#palabras-clave","text":"Biblioteca: conjunto de funciones y m\u00e9todos que pueden ser utilizados en un programa para realizar tareas espec\u00edficas. Framework: estructura de trabajo que proporciona una base s\u00f3lida para el desarrollo de aplicaciones, incluyendo herramientas y componentes predefinidos. Gin: framework web ligero y de alto rendimiento para crear API en Go. Beego: framework web completo y de c\u00f3digo abierto para el desarrollo de aplicaciones y servicios en Go.","title":"Palabras clave"},{"location":"go/mid/uso_de_bibliotecas_y_frameworks/#preguntas-de-repaso","text":"\u00bfQu\u00e9 son las bibliotecas y frameworks en programaci\u00f3n? \u00bfCu\u00e1l es la diferencia entre una biblioteca y un framework? \u00bfPor qu\u00e9 es importante utilizar bibliotecas y frameworks en el desarrollo de aplicaciones en Go? \u00bfQu\u00e9 es Gin y para qu\u00e9 se utiliza? \u00bfCu\u00e1les son las caracter\u00edsticas principales de Beego?","title":"Preguntas de repaso"},{"location":"go/mid/uso_de_bibliotecas_y_frameworks/#ejemplos-de-codigo","text":"","title":"Ejemplos de c\u00f3digo"},{"location":"go/mid/uso_de_bibliotecas_y_frameworks/#uso-de-la-biblioteca-fmt","text":"package main import \"fmt\" func main () { fmt . Println ( \"\u00a1Hola mundo!\" ) }","title":"Uso de la biblioteca \"fmt\""},{"location":"go/mid/uso_de_bibliotecas_y_frameworks/#creacion-de-un-servidor-web-basico-con-gin","text":"package main import ( \"github.com/gin-gonic/gin\" ) func main () { r := gin . Default () r . GET ( \"/\" , func ( c * gin . Context ) { c . JSON ( 200 , gin . H { \"message\" : \"\u00a1Hola mundo!\" , }) }) r . Run () // corre el servidor en el puerto 8080 }","title":"Creaci\u00f3n de un servidor web b\u00e1sico con Gin"},{"location":"go/mid/uso_de_bibliotecas_y_frameworks/#creacion-de-un-controlador-con-beego","text":"package controllers import ( \"github.com/astaxie/beego\" ) type MainController struct { beego . Controller } func ( c * MainController ) Get () { c . Data [ \"json\" ] = \"\u00a1Hola mundo!\" c . ServeJSON () }","title":"Creaci\u00f3n de un controlador con Beego"},{"location":"go/mid/uso_de_bibliotecas_y_frameworks/#ejercicios-practicos","text":"Crea un programa que utilice la biblioteca \"math\" para calcular el \u00e1rea de un c\u00edrculo. Utiliza el framework Gin para crear una API que devuelva una lista de productos en formato JSON. Implementa una aplicaci\u00f3n web con Beego que permita a los usuarios registrarse y hacer login.","title":"Ejercicios pr\u00e1cticos"},{"location":"go/mid/uso_de_bibliotecas_y_frameworks/#consejos-y-mejores-practicas","text":"Antes de utilizar cualquier biblioteca o framework, aseg\u00farate de entender su funcionalidad y c\u00f3mo se integra en tu proyecto. Lee la documentaci\u00f3n y ejemplos de c\u00f3digo de la biblioteca o framework que est\u00e9s utilizando para aprovechar al m\u00e1ximo sus caracter\u00edsticas. No utilices varias bibliotecas o frameworks para realizar la misma tarea, ya que puede resultar en conflictos y c\u00f3digo innecesario. Actualiza regularmente las bibliotecas y frameworks utilizados para aprovechar las \u00faltimas mejoras y solucionar posibles problemas de seguridad. Aprende a utilizar herramientas como \"go get\" para instalar y gestionar bibliotecas y frameworks en tus proyectos de Go.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"go/mid/web_services_y_apis/","text":"Web services y APIs \u00b6 Descripci\u00f3n \u00b6 En el mundo actual de la tecnolog\u00eda, la comunicaci\u00f3n entre sistemas es esencial para el funcionamiento de aplicaciones y servicios. Los web services y las APIs (Application Programming Interfaces) son herramientas que permiten la comunicaci\u00f3n entre aplicaciones de manera eficiente y segura. En este m\u00f3dulo, aprender\u00e1s c\u00f3mo crear y consumir servicios web y APIs utilizando el lenguaje de programaci\u00f3n Go. Teor\u00eda \u00b6 Web services \u00b6 Un web service es un conjunto de tecnolog\u00edas y est\u00e1ndares que permiten la comunicaci\u00f3n entre sistemas a trav\u00e9s de una red, como Internet. Estos servicios se basan en el protocolo HTTP y utilizan formatos de intercambio de datos como XML o JSON para transmitir informaci\u00f3n. Los web services pueden ser usados para compartir datos o funcionalidades entre aplicaciones, sin importar el lenguaje de programaci\u00f3n utilizado. Existen diferentes tipos de web services, entre los que destacan: REST (Representational State Transfer): es un estilo de arquitectura de software que define c\u00f3mo se deben comunicar los sistemas a trav\u00e9s de la web. Utiliza los m\u00e9todos HTTP (GET, POST, PUT, DELETE) para realizar operaciones sobre los recursos. SOAP (Simple Object Access Protocol): es un protocolo que define c\u00f3mo se debe estructurar la informaci\u00f3n para ser intercambiada entre sistemas. Utiliza XML para el intercambio de datos y requiere un formato de mensaje espec\u00edfico. gRPC: es un framework de c\u00f3digo abierto desarrollado por Google que permite la comunicaci\u00f3n entre sistemas de manera eficiente y segura utilizando RPC (Remote Procedure Call). APIs \u00b6 Las APIs son un conjunto de reglas y protocolos que definen c\u00f3mo se debe interactuar con una aplicaci\u00f3n o servicio. Estas interfaces permiten a los desarrolladores acceder a ciertas funciones o datos de una aplicaci\u00f3n de manera controlada y segura. Las APIs pueden ser p\u00fablicas o privadas, y pueden ser utilizadas para compartir datos o funcionalidades entre aplicaciones. Palabras clave y definiciones \u00b6 Web service: conjunto de tecnolog\u00edas y est\u00e1ndares que permiten la comunicaci\u00f3n entre sistemas a trav\u00e9s de una red. API: conjunto de reglas y protocolos que definen c\u00f3mo se debe interactuar con una aplicaci\u00f3n o servicio. REST: estilo de arquitectura de software que define c\u00f3mo se deben comunicar los sistemas a trav\u00e9s de la web. SOAP: protocolo que define c\u00f3mo se debe estructurar la informaci\u00f3n para ser intercambiada entre sistemas. gRPC: framework de c\u00f3digo abierto que permite la comunicaci\u00f3n entre sistemas utilizando RPC. RPC: Remote Procedure Call, m\u00e9todo de comunicaci\u00f3n entre procesos que permite a un programa llamar a una funci\u00f3n en otro proceso. HTTP: Hypertext Transfer Protocol, protocolo de comunicaci\u00f3n utilizado en la web. XML: Extensible Markup Language, lenguaje de marcado utilizado para estructurar datos. JSON: JavaScript Object Notation, formato de intercambio de datos ligero y f\u00e1cil de leer. API p\u00fablica: interfaz que permite a cualquier desarrollador acceder a sus funciones o datos. API privada: interfaz que requiere autorizaci\u00f3n para ser utilizada y solo est\u00e1 disponible para ciertos desarrolladores o aplicaciones. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es un web service y para qu\u00e9 se utiliza? \u00bfCu\u00e1les son los tipos de web services m\u00e1s comunes? \u00bfQu\u00e9 es una API y cu\u00e1l es su funci\u00f3n? \u00bfCu\u00e1l es la diferencia entre REST y SOAP? \u00bfQu\u00e9 es gRPC y cu\u00e1les son sus ventajas? Ejemplos de c\u00f3digo \u00b6 Creaci\u00f3n de un servidor REST utilizando el framework Gin \u00b6 package main import ( \"github.com/gin-gonic/gin\" ) func main () { // Creamos un router utilizando el framework Gin router := gin . Default () // Definimos una ruta GET con el endpoint \"/saludo\" router . GET ( \"/saludo\" , func ( c * gin . Context ) { // Enviamos un mensaje de saludo como respuesta c . JSON ( 200 , gin . H { \"mensaje\" : \"\u00a1Hola desde mi servidor REST!\" , }) }) // Iniciamos el servidor en el puerto 8080 router . Run ( \":8080\" ) } Consumo de una API utilizando la librer\u00eda net/http \u00b6 package main import ( \"encoding/json\" \"fmt\" \"net/http\" ) func main () { // Realizamos una petici\u00f3n GET a la API response , err := http . Get ( \"https://jsonplaceholder.typicode.com/posts/1\" ) if err != nil { fmt . Println ( err ) } // Creamos una estructura para almacenar la respuesta var post struct { UserID int `json:\"userId\"` ID int `json:\"id\"` Title string `json:\"title\"` Body string `json:\"body\"` } // Decodificamos la respuesta en formato JSON y la almacenamos en la estructura err = json . NewDecoder ( response . Body ). Decode ( & post ) if err != nil { fmt . Println ( err ) } // Imprimimos el t\u00edtulo y el cuerpo del post fmt . Println ( post . Title ) fmt . Println ( post . Body ) } Creaci\u00f3n de un servidor gRPC \u00b6 package main import ( \"context\" \"fmt\" \"log\" \"net\" \"google.golang.org/grpc\" \"example.com/server/proto\" ) // Implementamos la interfaz generada por gRPC type server struct {} // Definimos un m\u00e9todo para saludar al cliente func ( s * server ) Saludar ( ctx context . Context , req * proto . SaludoRequest ) ( * proto . SaludoResponse , error ) { // Obtenemos el nombre del cliente desde la petici\u00f3n nombre := req . GetNombre () // Creamos un mensaje de saludo y lo enviamos como respuesta mensaje := fmt . Sprintf ( \"\u00a1Hola %s desde mi servidor gRPC!\" , nombre ) return & proto . SaludoResponse { Mensaje : mensaje }, nil } func main () { // Creamos un servidor gRPC y lo registramos en el puerto 50051 servidor := grpc . NewServer () proto . RegisterSaludoServiceServer ( servidor , & server {}) direccion , err := net . Listen ( \"tcp\" , \":50051\" ) if err != nil { log . Fatalf ( \"Error al iniciar el servidor: %v\" , err ) } // Iniciamos el servidor if err := servidor . Serve ( direccion ); err != nil { log . Fatalf ( \"Error al iniciar el servidor: %v\" , err ) } } Consumo de un servicio gRPC \u00b6 package main import ( \"context\" \"fmt\" \"log\" \"google.golang.org/grpc\" \"example.com/client/proto\" ) func main () { // Creamos una conexi\u00f3n con el servidor gRPC conn , err := grpc . Dial ( \":50051\" , grpc . WithInsecure ()) if err != nil { log . Fatalf ( \"Error al conectar con el servidor: %v\" , err ) } defer conn . Close () // Creamos un cliente utilizando la conexi\u00f3n cliente := proto . NewSaludoServiceClient ( conn ) // Realizamos una petici\u00f3n al servidor respuesta , err := cliente . Saludar ( context . Background (), & proto . SaludoRequest { Nombre : \"Juan\" }) if err != nil { log . Fatalf ( \"Error al llamar al servidor: %v\" , err ) } // Imprimimos el mensaje de respuesta fmt . Println ( respuesta . GetMensaje ()) } Ejercicios pr\u00e1cticos \u00b6 Crea un servidor REST utilizando el framework Gin que permita realizar operaciones CRUD (Create, Read, Update, Delete) sobre una lista de tareas. Consuma la API p\u00fablica de OpenWeatherMap para obtener la informaci\u00f3n del clima de una ciudad espec\u00edfica y la muestre por consola. Crea un servidor gRPC que permita realizar la operaci\u00f3n de suma de dos n\u00fameros y devuelve el resultado como respuesta. Consejos y mejores pr\u00e1cticas \u00b6 Utiliza el framework o librer\u00eda que mejor se adapte a tus necesidades, ya sea para crear o consumir servicios web y APIs. Documenta tus servicios y APIs de manera clara y concisa, incluyendo la estructura de los datos que se env\u00edan y reciben. Valida siempre los datos que se env\u00edan y reciben para evitar errores y posibles vulnerabilidades. Utiliza HTTPS para proteger la comunicaci\u00f3n entre sistemas y asegurarte de que los datos no sean interceptados por terceros. Realiza pruebas exhaustivas para garantizar el correcto funcionamiento de tus servicios y APIs antes de ponerlos en producci\u00f3n. Sigue las mejores pr\u00e1cticas y est\u00e1ndares establecidos para asegurar la interoperabilidad y la compatibilidad con otros sistemas.","title":"Web services y APIs"},{"location":"go/mid/web_services_y_apis/#web-services-y-apis","text":"","title":"Web services y APIs"},{"location":"go/mid/web_services_y_apis/#descripcion","text":"En el mundo actual de la tecnolog\u00eda, la comunicaci\u00f3n entre sistemas es esencial para el funcionamiento de aplicaciones y servicios. Los web services y las APIs (Application Programming Interfaces) son herramientas que permiten la comunicaci\u00f3n entre aplicaciones de manera eficiente y segura. En este m\u00f3dulo, aprender\u00e1s c\u00f3mo crear y consumir servicios web y APIs utilizando el lenguaje de programaci\u00f3n Go.","title":"Descripci\u00f3n"},{"location":"go/mid/web_services_y_apis/#teoria","text":"","title":"Teor\u00eda"},{"location":"go/mid/web_services_y_apis/#web-services","text":"Un web service es un conjunto de tecnolog\u00edas y est\u00e1ndares que permiten la comunicaci\u00f3n entre sistemas a trav\u00e9s de una red, como Internet. Estos servicios se basan en el protocolo HTTP y utilizan formatos de intercambio de datos como XML o JSON para transmitir informaci\u00f3n. Los web services pueden ser usados para compartir datos o funcionalidades entre aplicaciones, sin importar el lenguaje de programaci\u00f3n utilizado. Existen diferentes tipos de web services, entre los que destacan: REST (Representational State Transfer): es un estilo de arquitectura de software que define c\u00f3mo se deben comunicar los sistemas a trav\u00e9s de la web. Utiliza los m\u00e9todos HTTP (GET, POST, PUT, DELETE) para realizar operaciones sobre los recursos. SOAP (Simple Object Access Protocol): es un protocolo que define c\u00f3mo se debe estructurar la informaci\u00f3n para ser intercambiada entre sistemas. Utiliza XML para el intercambio de datos y requiere un formato de mensaje espec\u00edfico. gRPC: es un framework de c\u00f3digo abierto desarrollado por Google que permite la comunicaci\u00f3n entre sistemas de manera eficiente y segura utilizando RPC (Remote Procedure Call).","title":"Web services"},{"location":"go/mid/web_services_y_apis/#apis","text":"Las APIs son un conjunto de reglas y protocolos que definen c\u00f3mo se debe interactuar con una aplicaci\u00f3n o servicio. Estas interfaces permiten a los desarrolladores acceder a ciertas funciones o datos de una aplicaci\u00f3n de manera controlada y segura. Las APIs pueden ser p\u00fablicas o privadas, y pueden ser utilizadas para compartir datos o funcionalidades entre aplicaciones.","title":"APIs"},{"location":"go/mid/web_services_y_apis/#palabras-clave-y-definiciones","text":"Web service: conjunto de tecnolog\u00edas y est\u00e1ndares que permiten la comunicaci\u00f3n entre sistemas a trav\u00e9s de una red. API: conjunto de reglas y protocolos que definen c\u00f3mo se debe interactuar con una aplicaci\u00f3n o servicio. REST: estilo de arquitectura de software que define c\u00f3mo se deben comunicar los sistemas a trav\u00e9s de la web. SOAP: protocolo que define c\u00f3mo se debe estructurar la informaci\u00f3n para ser intercambiada entre sistemas. gRPC: framework de c\u00f3digo abierto que permite la comunicaci\u00f3n entre sistemas utilizando RPC. RPC: Remote Procedure Call, m\u00e9todo de comunicaci\u00f3n entre procesos que permite a un programa llamar a una funci\u00f3n en otro proceso. HTTP: Hypertext Transfer Protocol, protocolo de comunicaci\u00f3n utilizado en la web. XML: Extensible Markup Language, lenguaje de marcado utilizado para estructurar datos. JSON: JavaScript Object Notation, formato de intercambio de datos ligero y f\u00e1cil de leer. API p\u00fablica: interfaz que permite a cualquier desarrollador acceder a sus funciones o datos. API privada: interfaz que requiere autorizaci\u00f3n para ser utilizada y solo est\u00e1 disponible para ciertos desarrolladores o aplicaciones.","title":"Palabras clave y definiciones"},{"location":"go/mid/web_services_y_apis/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es un web service y para qu\u00e9 se utiliza? \u00bfCu\u00e1les son los tipos de web services m\u00e1s comunes? \u00bfQu\u00e9 es una API y cu\u00e1l es su funci\u00f3n? \u00bfCu\u00e1l es la diferencia entre REST y SOAP? \u00bfQu\u00e9 es gRPC y cu\u00e1les son sus ventajas?","title":"Preguntas de repaso"},{"location":"go/mid/web_services_y_apis/#ejemplos-de-codigo","text":"","title":"Ejemplos de c\u00f3digo"},{"location":"go/mid/web_services_y_apis/#creacion-de-un-servidor-rest-utilizando-el-framework-gin","text":"package main import ( \"github.com/gin-gonic/gin\" ) func main () { // Creamos un router utilizando el framework Gin router := gin . Default () // Definimos una ruta GET con el endpoint \"/saludo\" router . GET ( \"/saludo\" , func ( c * gin . Context ) { // Enviamos un mensaje de saludo como respuesta c . JSON ( 200 , gin . H { \"mensaje\" : \"\u00a1Hola desde mi servidor REST!\" , }) }) // Iniciamos el servidor en el puerto 8080 router . Run ( \":8080\" ) }","title":"Creaci\u00f3n de un servidor REST utilizando el framework Gin"},{"location":"go/mid/web_services_y_apis/#consumo-de-una-api-utilizando-la-libreria-nethttp","text":"package main import ( \"encoding/json\" \"fmt\" \"net/http\" ) func main () { // Realizamos una petici\u00f3n GET a la API response , err := http . Get ( \"https://jsonplaceholder.typicode.com/posts/1\" ) if err != nil { fmt . Println ( err ) } // Creamos una estructura para almacenar la respuesta var post struct { UserID int `json:\"userId\"` ID int `json:\"id\"` Title string `json:\"title\"` Body string `json:\"body\"` } // Decodificamos la respuesta en formato JSON y la almacenamos en la estructura err = json . NewDecoder ( response . Body ). Decode ( & post ) if err != nil { fmt . Println ( err ) } // Imprimimos el t\u00edtulo y el cuerpo del post fmt . Println ( post . Title ) fmt . Println ( post . Body ) }","title":"Consumo de una API utilizando la librer\u00eda net/http"},{"location":"go/mid/web_services_y_apis/#creacion-de-un-servidor-grpc","text":"package main import ( \"context\" \"fmt\" \"log\" \"net\" \"google.golang.org/grpc\" \"example.com/server/proto\" ) // Implementamos la interfaz generada por gRPC type server struct {} // Definimos un m\u00e9todo para saludar al cliente func ( s * server ) Saludar ( ctx context . Context , req * proto . SaludoRequest ) ( * proto . SaludoResponse , error ) { // Obtenemos el nombre del cliente desde la petici\u00f3n nombre := req . GetNombre () // Creamos un mensaje de saludo y lo enviamos como respuesta mensaje := fmt . Sprintf ( \"\u00a1Hola %s desde mi servidor gRPC!\" , nombre ) return & proto . SaludoResponse { Mensaje : mensaje }, nil } func main () { // Creamos un servidor gRPC y lo registramos en el puerto 50051 servidor := grpc . NewServer () proto . RegisterSaludoServiceServer ( servidor , & server {}) direccion , err := net . Listen ( \"tcp\" , \":50051\" ) if err != nil { log . Fatalf ( \"Error al iniciar el servidor: %v\" , err ) } // Iniciamos el servidor if err := servidor . Serve ( direccion ); err != nil { log . Fatalf ( \"Error al iniciar el servidor: %v\" , err ) } }","title":"Creaci\u00f3n de un servidor gRPC"},{"location":"go/mid/web_services_y_apis/#consumo-de-un-servicio-grpc","text":"package main import ( \"context\" \"fmt\" \"log\" \"google.golang.org/grpc\" \"example.com/client/proto\" ) func main () { // Creamos una conexi\u00f3n con el servidor gRPC conn , err := grpc . Dial ( \":50051\" , grpc . WithInsecure ()) if err != nil { log . Fatalf ( \"Error al conectar con el servidor: %v\" , err ) } defer conn . Close () // Creamos un cliente utilizando la conexi\u00f3n cliente := proto . NewSaludoServiceClient ( conn ) // Realizamos una petici\u00f3n al servidor respuesta , err := cliente . Saludar ( context . Background (), & proto . SaludoRequest { Nombre : \"Juan\" }) if err != nil { log . Fatalf ( \"Error al llamar al servidor: %v\" , err ) } // Imprimimos el mensaje de respuesta fmt . Println ( respuesta . GetMensaje ()) }","title":"Consumo de un servicio gRPC"},{"location":"go/mid/web_services_y_apis/#ejercicios-practicos","text":"Crea un servidor REST utilizando el framework Gin que permita realizar operaciones CRUD (Create, Read, Update, Delete) sobre una lista de tareas. Consuma la API p\u00fablica de OpenWeatherMap para obtener la informaci\u00f3n del clima de una ciudad espec\u00edfica y la muestre por consola. Crea un servidor gRPC que permita realizar la operaci\u00f3n de suma de dos n\u00fameros y devuelve el resultado como respuesta.","title":"Ejercicios pr\u00e1cticos"},{"location":"go/mid/web_services_y_apis/#consejos-y-mejores-practicas","text":"Utiliza el framework o librer\u00eda que mejor se adapte a tus necesidades, ya sea para crear o consumir servicios web y APIs. Documenta tus servicios y APIs de manera clara y concisa, incluyendo la estructura de los datos que se env\u00edan y reciben. Valida siempre los datos que se env\u00edan y reciben para evitar errores y posibles vulnerabilidades. Utiliza HTTPS para proteger la comunicaci\u00f3n entre sistemas y asegurarte de que los datos no sean interceptados por terceros. Realiza pruebas exhaustivas para garantizar el correcto funcionamiento de tus servicios y APIs antes de ponerlos en producci\u00f3n. Sigue las mejores pr\u00e1cticas y est\u00e1ndares establecidos para asegurar la interoperabilidad y la compatibilidad con otros sistemas.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"go/sr/contribuci%C3%B3n_a_la_comunidad_de_go/","text":"Contribuci\u00f3n a la comunidad de Go \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 Go es un lenguaje de programaci\u00f3n de c\u00f3digo abierto creado por Google en el a\u00f1o 2009. Desde entonces, ha ganado gran popularidad gracias a su eficiencia, simplicidad y capacidad para manejar aplicaciones de alto rendimiento. Adem\u00e1s, cuenta con una comunidad activa y comprometida que trabaja constantemente en la mejora y evoluci\u00f3n del lenguaje. En este m\u00f3dulo, nos enfocaremos en la importancia de contribuir a la comunidad de Go y c\u00f3mo podemos hacerlo. Tambi\u00e9n veremos c\u00f3mo estar al d\u00eda con las \u00faltimas novedades y avances del lenguaje. Explicaci\u00f3n te\u00f3rica \u00b6 La comunidad de Go es un grupo diverso de desarrolladores, usuarios y entusiastas que comparten un inter\u00e9s com\u00fan: el lenguaje de programaci\u00f3n Go. Contribuir a esta comunidad no solo es una forma de agradecer y devolver a la comunidad por el uso del lenguaje, sino que tambi\u00e9n nos permite mejorar nuestras habilidades, aprender de otros y ser parte de una comunidad en constante crecimiento. Existen diversas formas de contribuir a la comunidad de Go, como por ejemplo: Reportando errores y problemas en el lenguaje o en sus herramientas. Participando en discusiones y debates en foros y comunidades en l\u00ednea. Compartiendo conocimientos y experiencias a trav\u00e9s de blogs, tutoriales y videos. Contribuyendo con c\u00f3digo en proyectos de c\u00f3digo abierto relacionados con Go. Organizando o asistiendo a eventos y conferencias de Go. Ayudando a otros miembros de la comunidad con sus dudas y preguntas. Es importante tener en cuenta que no es necesario ser un experto en Go para contribuir a la comunidad. Cualquier aporte, por peque\u00f1o que sea, es valioso y puede marcar la diferencia. Palabras clave y su definici\u00f3n \u00b6 Comunidad de Go: grupo de desarrolladores, usuarios y entusiastas del lenguaje de programaci\u00f3n Go. Contribuci\u00f3n: aporte o ayuda a la comunidad de Go. C\u00f3digo abierto: software cuyo c\u00f3digo fuente es accesible y modificable por cualquier persona. Proyecto de c\u00f3digo abierto: proyecto de software en el cual el c\u00f3digo fuente es accesible y modificable por cualquier persona. Eventos y conferencias de Go: reuniones y charlas enfocadas en el lenguaje de programaci\u00f3n Go. Preguntas de repaso \u00b6 \u00bfPor qu\u00e9 es importante contribuir a la comunidad de Go? \u00bfCu\u00e1les son algunas formas de contribuir a la comunidad de Go? \u00bfEs necesario ser un experto en Go para contribuir a la comunidad? \u00bfQu\u00e9 es un proyecto de c\u00f3digo abierto? \u00bfCu\u00e1les son algunos eventos y conferencias de Go populares? Ejemplos de c\u00f3digo en Go lang \u00b6 Reportando un error en el lenguaje: package main import \"fmt\" func main () { // c\u00f3digo con un error fmt . Println ( \"Hola, mundo!\" ) } Contribuyendo con c\u00f3digo en un proyecto de c\u00f3digo abierto: package main import \"fmt\" func main () { // c\u00f3digo para calcular el \u00e1rea de un c\u00edrculo radius := 5.0 area := calculateArea ( radius ) fmt . Println ( \"El \u00e1rea del c\u00edrculo es:\" , area ) } func calculateArea ( r float64 ) float64 { return 3.14 * r * r } Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Busca un error en el c\u00f3digo de alg\u00fan proyecto de Go y rep\u00f3rtalo en el foro de discusi\u00f3n correspondiente. Escribe un blog o tutorial sobre alg\u00fan tema relacionado con Go que consideres interesante y comp\u00e1rtelo en la comunidad. Participa en un proyecto de c\u00f3digo abierto de Go y contribuye con alguna mejora o correcci\u00f3n de errores. Organiza un evento o charla sobre Go en tu comunidad local o asiste a uno ya organizado. Ayuda a otros miembros de la comunidad respondiendo preguntas y dudas en foros y comunidades en l\u00ednea. Consejos o mejores pr\u00e1cticas \u00b6 Siempre respeta el c\u00f3digo de conducta de la comunidad de Go al contribuir. Aseg\u00farate de tener un buen entendimiento del problema o tarea antes de iniciar cualquier contribuci\u00f3n. Comunica y colabora con otros miembros de la comunidad para obtener un mejor resultado. Mantente actualizado con las \u00faltimas novedades y avances del lenguaje. No tengas miedo de preguntar o pedir ayuda si tienes alguna duda o problema. \u00a1Divi\u00e9rtete y disfruta de ser parte de la comunidad de Go!","title":"Contribuci\u00f3n a la comunidad de Go"},{"location":"go/sr/contribuci%C3%B3n_a_la_comunidad_de_go/#contribucion-a-la-comunidad-de-go","text":"","title":"Contribuci\u00f3n a la comunidad de Go"},{"location":"go/sr/contribuci%C3%B3n_a_la_comunidad_de_go/#descripcion-del-modulo","text":"Go es un lenguaje de programaci\u00f3n de c\u00f3digo abierto creado por Google en el a\u00f1o 2009. Desde entonces, ha ganado gran popularidad gracias a su eficiencia, simplicidad y capacidad para manejar aplicaciones de alto rendimiento. Adem\u00e1s, cuenta con una comunidad activa y comprometida que trabaja constantemente en la mejora y evoluci\u00f3n del lenguaje. En este m\u00f3dulo, nos enfocaremos en la importancia de contribuir a la comunidad de Go y c\u00f3mo podemos hacerlo. Tambi\u00e9n veremos c\u00f3mo estar al d\u00eda con las \u00faltimas novedades y avances del lenguaje.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"go/sr/contribuci%C3%B3n_a_la_comunidad_de_go/#explicacion-teorica","text":"La comunidad de Go es un grupo diverso de desarrolladores, usuarios y entusiastas que comparten un inter\u00e9s com\u00fan: el lenguaje de programaci\u00f3n Go. Contribuir a esta comunidad no solo es una forma de agradecer y devolver a la comunidad por el uso del lenguaje, sino que tambi\u00e9n nos permite mejorar nuestras habilidades, aprender de otros y ser parte de una comunidad en constante crecimiento. Existen diversas formas de contribuir a la comunidad de Go, como por ejemplo: Reportando errores y problemas en el lenguaje o en sus herramientas. Participando en discusiones y debates en foros y comunidades en l\u00ednea. Compartiendo conocimientos y experiencias a trav\u00e9s de blogs, tutoriales y videos. Contribuyendo con c\u00f3digo en proyectos de c\u00f3digo abierto relacionados con Go. Organizando o asistiendo a eventos y conferencias de Go. Ayudando a otros miembros de la comunidad con sus dudas y preguntas. Es importante tener en cuenta que no es necesario ser un experto en Go para contribuir a la comunidad. Cualquier aporte, por peque\u00f1o que sea, es valioso y puede marcar la diferencia.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"go/sr/contribuci%C3%B3n_a_la_comunidad_de_go/#palabras-clave-y-su-definicion","text":"Comunidad de Go: grupo de desarrolladores, usuarios y entusiastas del lenguaje de programaci\u00f3n Go. Contribuci\u00f3n: aporte o ayuda a la comunidad de Go. C\u00f3digo abierto: software cuyo c\u00f3digo fuente es accesible y modificable por cualquier persona. Proyecto de c\u00f3digo abierto: proyecto de software en el cual el c\u00f3digo fuente es accesible y modificable por cualquier persona. Eventos y conferencias de Go: reuniones y charlas enfocadas en el lenguaje de programaci\u00f3n Go.","title":"Palabras clave y su definici\u00f3n"},{"location":"go/sr/contribuci%C3%B3n_a_la_comunidad_de_go/#preguntas-de-repaso","text":"\u00bfPor qu\u00e9 es importante contribuir a la comunidad de Go? \u00bfCu\u00e1les son algunas formas de contribuir a la comunidad de Go? \u00bfEs necesario ser un experto en Go para contribuir a la comunidad? \u00bfQu\u00e9 es un proyecto de c\u00f3digo abierto? \u00bfCu\u00e1les son algunos eventos y conferencias de Go populares?","title":"Preguntas de repaso"},{"location":"go/sr/contribuci%C3%B3n_a_la_comunidad_de_go/#ejemplos-de-codigo-en-go-lang","text":"Reportando un error en el lenguaje: package main import \"fmt\" func main () { // c\u00f3digo con un error fmt . Println ( \"Hola, mundo!\" ) } Contribuyendo con c\u00f3digo en un proyecto de c\u00f3digo abierto: package main import \"fmt\" func main () { // c\u00f3digo para calcular el \u00e1rea de un c\u00edrculo radius := 5.0 area := calculateArea ( radius ) fmt . Println ( \"El \u00e1rea del c\u00edrculo es:\" , area ) } func calculateArea ( r float64 ) float64 { return 3.14 * r * r }","title":"Ejemplos de c\u00f3digo en Go lang"},{"location":"go/sr/contribuci%C3%B3n_a_la_comunidad_de_go/#ejercicios-practicos-con-instrucciones-claras","text":"Busca un error en el c\u00f3digo de alg\u00fan proyecto de Go y rep\u00f3rtalo en el foro de discusi\u00f3n correspondiente. Escribe un blog o tutorial sobre alg\u00fan tema relacionado con Go que consideres interesante y comp\u00e1rtelo en la comunidad. Participa en un proyecto de c\u00f3digo abierto de Go y contribuye con alguna mejora o correcci\u00f3n de errores. Organiza un evento o charla sobre Go en tu comunidad local o asiste a uno ya organizado. Ayuda a otros miembros de la comunidad respondiendo preguntas y dudas en foros y comunidades en l\u00ednea.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"go/sr/contribuci%C3%B3n_a_la_comunidad_de_go/#consejos-o-mejores-practicas","text":"Siempre respeta el c\u00f3digo de conducta de la comunidad de Go al contribuir. Aseg\u00farate de tener un buen entendimiento del problema o tarea antes de iniciar cualquier contribuci\u00f3n. Comunica y colabora con otros miembros de la comunidad para obtener un mejor resultado. Mantente actualizado con las \u00faltimas novedades y avances del lenguaje. No tengas miedo de preguntar o pedir ayuda si tienes alguna duda o problema. \u00a1Divi\u00e9rtete y disfruta de ser parte de la comunidad de Go!","title":"Consejos o mejores pr\u00e1cticas"},{"location":"go/sr/desarrollo_de_aplicaciones_de_alto_tr%C3%A1fico/","text":"Desarrollo de aplicaciones de alto tr\u00e1fico \u00b6 El desarrollo de aplicaciones de alto tr\u00e1fico es un proceso complejo que requiere de t\u00e9cnicas y herramientas espec\u00edficas para garantizar la alta disponibilidad y rendimiento de la aplicaci\u00f3n. En este m\u00f3dulo, aprenderemos sobre las mejores pr\u00e1cticas para desarrollar aplicaciones de alto tr\u00e1fico en el lenguaje de programaci\u00f3n Go. Teor\u00eda \u00b6 Las aplicaciones de alto tr\u00e1fico son aquellas que reciben una gran cantidad de solicitudes de usuarios simult\u00e1neamente. Esto puede ser debido a una gran base de usuarios, una campa\u00f1a de marketing exitosa o un evento en particular. Para garantizar que la aplicaci\u00f3n pueda manejar este alto volumen de tr\u00e1fico, es necesario implementar t\u00e9cnicas y utilizar herramientas adecuadas. Una de las caracter\u00edsticas principales de Go es su capacidad para manejar concurrencia de manera eficiente. Esto significa que puede ejecutar m\u00faltiples tareas simult\u00e1neamente y manejar grandes cantidades de tr\u00e1fico de manera efectiva. Adem\u00e1s, Go es un lenguaje de programaci\u00f3n compilado, lo que significa que el c\u00f3digo se traduce a lenguaje de m\u00e1quina antes de la ejecuci\u00f3n, lo que aumenta el rendimiento de la aplicaci\u00f3n. Para desarrollar aplicaciones de alto tr\u00e1fico en Go, es importante tener en cuenta las siguientes consideraciones: Dise\u00f1o escalable: el dise\u00f1o de la aplicaci\u00f3n debe ser escalable para poder manejar un aumento repentino en el tr\u00e1fico sin afectar su rendimiento. Gesti\u00f3n de recursos: es esencial optimizar el uso de recursos como memoria, CPU y almacenamiento para garantizar que la aplicaci\u00f3n pueda manejar el alto tr\u00e1fico sin problemas. Monitoreo y detecci\u00f3n de errores: es importante tener un sistema de monitoreo en su lugar para detectar y solucionar r\u00e1pidamente cualquier problema que pueda surgir debido al alto tr\u00e1fico. Pruebas exhaustivas: antes de lanzar la aplicaci\u00f3n, es necesario realizar pruebas exhaustivas para garantizar su estabilidad y rendimiento bajo diferentes condiciones de tr\u00e1fico. Palabras clave y definiciones \u00b6 Alto tr\u00e1fico: una gran cantidad de solicitudes simult\u00e1neas recibidas por una aplicaci\u00f3n. Alta disponibilidad: la capacidad de una aplicaci\u00f3n para estar en funcionamiento y accesible para los usuarios en todo momento. Concurrencia: la capacidad de ejecutar m\u00faltiples tareas simult\u00e1neamente. Compilado: un lenguaje de programaci\u00f3n compilado se traduce a lenguaje de m\u00e1quina antes de la ejecuci\u00f3n, lo que aumenta la eficiencia y el rendimiento del c\u00f3digo. Escalabilidad: la capacidad de una aplicaci\u00f3n para manejar un aumento en el tr\u00e1fico sin afectar su rendimiento. Gesti\u00f3n de recursos: la optimizaci\u00f3n del uso de recursos como memoria, CPU y almacenamiento para garantizar un rendimiento \u00f3ptimo de la aplicaci\u00f3n. Monitoreo: el seguimiento constante del estado y rendimiento de la aplicaci\u00f3n. Pruebas: la evaluaci\u00f3n y validaci\u00f3n del rendimiento y estabilidad de la aplicaci\u00f3n bajo diferentes condiciones. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es una aplicaci\u00f3n de alto tr\u00e1fico? \u00bfPor qu\u00e9 es importante tener un dise\u00f1o escalable al desarrollar aplicaciones de alto tr\u00e1fico? \u00bfQu\u00e9 ventajas ofrece Go para manejar concurrencia? \u00bfPor qu\u00e9 es necesario tener un sistema de monitoreo en su lugar para aplicaciones de alto tr\u00e1fico? \u00bfCu\u00e1l es la diferencia entre un lenguaje compilado y un lenguaje interpretado? Ejemplos de c\u00f3digo en Go lang \u00b6 Concurrencia \u00b6 package main import ( \"fmt\" \"time\" ) func printNumbers () { for i := 1 ; i <= 10 ; i ++ { fmt . Println ( i ) time . Sleep ( time . Second ) } } func printLetters () { for i := 'a' ; i <= 'j' ; i ++ { fmt . Printf ( \"%c\\n\" , i ) time . Sleep ( time . Second ) } } func main () { go printNumbers () go printLetters () time . Sleep ( 12 * time . Second ) } En este ejemplo, utilizamos goroutines (funciones que se ejecutan de manera concurrente) para imprimir n\u00fameros y letras al mismo tiempo. El uso de la funci\u00f3n time.Sleep() nos permite controlar el tiempo de ejecuci\u00f3n de cada goroutine. Gesti\u00f3n de recursos \u00b6 package main import ( \"fmt\" \"runtime\" ) func main () { fmt . Println ( \"N\u00famero de CPUs: \" , runtime . NumCPU ()) fmt . Println ( \"Uso de la memoria:\" , runtime . MemStats . Alloc ) } Este ejemplo muestra c\u00f3mo obtener informaci\u00f3n sobre el uso de recursos de la aplicaci\u00f3n, en este caso, el n\u00famero de CPUs y el uso de memoria. Ejercicios pr\u00e1cticos \u00b6 Crea una aplicaci\u00f3n en Go que imprima la tabla de multiplicar del 2. Utiliza goroutines para imprimir una lista de nombres de forma concurrente. Realiza pruebas de rendimiento en tu aplicaci\u00f3n y optimiza la gesti\u00f3n de recursos en caso de ser necesario. Consejos y mejores pr\u00e1cticas \u00b6 Utiliza goroutines y canales para manejar la concurrencia de manera eficiente. Dise\u00f1a tu aplicaci\u00f3n con la escalabilidad en mente para manejar futuros aumentos en el tr\u00e1fico. Implementa un sistema de monitoreo para detectar y solucionar r\u00e1pidamente problemas de rendimiento. Realiza pruebas exhaustivas antes de lanzar la aplicaci\u00f3n para garantizar su estabilidad y rendimiento bajo diferentes condiciones de tr\u00e1fico. Utiliza herramientas de profiling para identificar posibles cuellos de botella en el c\u00f3digo y optimizar su rendimiento. En resumen, el desarrollo de aplicaciones de alto tr\u00e1fico en Go requiere de una combinaci\u00f3n de t\u00e9cnicas y herramientas adecuadas para garantizar la alta disponibilidad y rendimiento de la aplicaci\u00f3n. Con el uso adecuado de goroutines y canales, dise\u00f1o escalable, gesti\u00f3n de recursos y pruebas exhaustivas, se puede desarrollar una aplicaci\u00f3n robusta y capaz de manejar grandes cantidades de tr\u00e1fico sin problemas.","title":"Desarrollo de aplicaciones de alto tr\u00e1fico"},{"location":"go/sr/desarrollo_de_aplicaciones_de_alto_tr%C3%A1fico/#desarrollo-de-aplicaciones-de-alto-trafico","text":"El desarrollo de aplicaciones de alto tr\u00e1fico es un proceso complejo que requiere de t\u00e9cnicas y herramientas espec\u00edficas para garantizar la alta disponibilidad y rendimiento de la aplicaci\u00f3n. En este m\u00f3dulo, aprenderemos sobre las mejores pr\u00e1cticas para desarrollar aplicaciones de alto tr\u00e1fico en el lenguaje de programaci\u00f3n Go.","title":"Desarrollo de aplicaciones de alto tr\u00e1fico"},{"location":"go/sr/desarrollo_de_aplicaciones_de_alto_tr%C3%A1fico/#teoria","text":"Las aplicaciones de alto tr\u00e1fico son aquellas que reciben una gran cantidad de solicitudes de usuarios simult\u00e1neamente. Esto puede ser debido a una gran base de usuarios, una campa\u00f1a de marketing exitosa o un evento en particular. Para garantizar que la aplicaci\u00f3n pueda manejar este alto volumen de tr\u00e1fico, es necesario implementar t\u00e9cnicas y utilizar herramientas adecuadas. Una de las caracter\u00edsticas principales de Go es su capacidad para manejar concurrencia de manera eficiente. Esto significa que puede ejecutar m\u00faltiples tareas simult\u00e1neamente y manejar grandes cantidades de tr\u00e1fico de manera efectiva. Adem\u00e1s, Go es un lenguaje de programaci\u00f3n compilado, lo que significa que el c\u00f3digo se traduce a lenguaje de m\u00e1quina antes de la ejecuci\u00f3n, lo que aumenta el rendimiento de la aplicaci\u00f3n. Para desarrollar aplicaciones de alto tr\u00e1fico en Go, es importante tener en cuenta las siguientes consideraciones: Dise\u00f1o escalable: el dise\u00f1o de la aplicaci\u00f3n debe ser escalable para poder manejar un aumento repentino en el tr\u00e1fico sin afectar su rendimiento. Gesti\u00f3n de recursos: es esencial optimizar el uso de recursos como memoria, CPU y almacenamiento para garantizar que la aplicaci\u00f3n pueda manejar el alto tr\u00e1fico sin problemas. Monitoreo y detecci\u00f3n de errores: es importante tener un sistema de monitoreo en su lugar para detectar y solucionar r\u00e1pidamente cualquier problema que pueda surgir debido al alto tr\u00e1fico. Pruebas exhaustivas: antes de lanzar la aplicaci\u00f3n, es necesario realizar pruebas exhaustivas para garantizar su estabilidad y rendimiento bajo diferentes condiciones de tr\u00e1fico.","title":"Teor\u00eda"},{"location":"go/sr/desarrollo_de_aplicaciones_de_alto_tr%C3%A1fico/#palabras-clave-y-definiciones","text":"Alto tr\u00e1fico: una gran cantidad de solicitudes simult\u00e1neas recibidas por una aplicaci\u00f3n. Alta disponibilidad: la capacidad de una aplicaci\u00f3n para estar en funcionamiento y accesible para los usuarios en todo momento. Concurrencia: la capacidad de ejecutar m\u00faltiples tareas simult\u00e1neamente. Compilado: un lenguaje de programaci\u00f3n compilado se traduce a lenguaje de m\u00e1quina antes de la ejecuci\u00f3n, lo que aumenta la eficiencia y el rendimiento del c\u00f3digo. Escalabilidad: la capacidad de una aplicaci\u00f3n para manejar un aumento en el tr\u00e1fico sin afectar su rendimiento. Gesti\u00f3n de recursos: la optimizaci\u00f3n del uso de recursos como memoria, CPU y almacenamiento para garantizar un rendimiento \u00f3ptimo de la aplicaci\u00f3n. Monitoreo: el seguimiento constante del estado y rendimiento de la aplicaci\u00f3n. Pruebas: la evaluaci\u00f3n y validaci\u00f3n del rendimiento y estabilidad de la aplicaci\u00f3n bajo diferentes condiciones.","title":"Palabras clave y definiciones"},{"location":"go/sr/desarrollo_de_aplicaciones_de_alto_tr%C3%A1fico/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es una aplicaci\u00f3n de alto tr\u00e1fico? \u00bfPor qu\u00e9 es importante tener un dise\u00f1o escalable al desarrollar aplicaciones de alto tr\u00e1fico? \u00bfQu\u00e9 ventajas ofrece Go para manejar concurrencia? \u00bfPor qu\u00e9 es necesario tener un sistema de monitoreo en su lugar para aplicaciones de alto tr\u00e1fico? \u00bfCu\u00e1l es la diferencia entre un lenguaje compilado y un lenguaje interpretado?","title":"Preguntas de repaso"},{"location":"go/sr/desarrollo_de_aplicaciones_de_alto_tr%C3%A1fico/#ejemplos-de-codigo-en-go-lang","text":"","title":"Ejemplos de c\u00f3digo en Go lang"},{"location":"go/sr/desarrollo_de_aplicaciones_de_alto_tr%C3%A1fico/#concurrencia","text":"package main import ( \"fmt\" \"time\" ) func printNumbers () { for i := 1 ; i <= 10 ; i ++ { fmt . Println ( i ) time . Sleep ( time . Second ) } } func printLetters () { for i := 'a' ; i <= 'j' ; i ++ { fmt . Printf ( \"%c\\n\" , i ) time . Sleep ( time . Second ) } } func main () { go printNumbers () go printLetters () time . Sleep ( 12 * time . Second ) } En este ejemplo, utilizamos goroutines (funciones que se ejecutan de manera concurrente) para imprimir n\u00fameros y letras al mismo tiempo. El uso de la funci\u00f3n time.Sleep() nos permite controlar el tiempo de ejecuci\u00f3n de cada goroutine.","title":"Concurrencia"},{"location":"go/sr/desarrollo_de_aplicaciones_de_alto_tr%C3%A1fico/#gestion-de-recursos","text":"package main import ( \"fmt\" \"runtime\" ) func main () { fmt . Println ( \"N\u00famero de CPUs: \" , runtime . NumCPU ()) fmt . Println ( \"Uso de la memoria:\" , runtime . MemStats . Alloc ) } Este ejemplo muestra c\u00f3mo obtener informaci\u00f3n sobre el uso de recursos de la aplicaci\u00f3n, en este caso, el n\u00famero de CPUs y el uso de memoria.","title":"Gesti\u00f3n de recursos"},{"location":"go/sr/desarrollo_de_aplicaciones_de_alto_tr%C3%A1fico/#ejercicios-practicos","text":"Crea una aplicaci\u00f3n en Go que imprima la tabla de multiplicar del 2. Utiliza goroutines para imprimir una lista de nombres de forma concurrente. Realiza pruebas de rendimiento en tu aplicaci\u00f3n y optimiza la gesti\u00f3n de recursos en caso de ser necesario.","title":"Ejercicios pr\u00e1cticos"},{"location":"go/sr/desarrollo_de_aplicaciones_de_alto_tr%C3%A1fico/#consejos-y-mejores-practicas","text":"Utiliza goroutines y canales para manejar la concurrencia de manera eficiente. Dise\u00f1a tu aplicaci\u00f3n con la escalabilidad en mente para manejar futuros aumentos en el tr\u00e1fico. Implementa un sistema de monitoreo para detectar y solucionar r\u00e1pidamente problemas de rendimiento. Realiza pruebas exhaustivas antes de lanzar la aplicaci\u00f3n para garantizar su estabilidad y rendimiento bajo diferentes condiciones de tr\u00e1fico. Utiliza herramientas de profiling para identificar posibles cuellos de botella en el c\u00f3digo y optimizar su rendimiento. En resumen, el desarrollo de aplicaciones de alto tr\u00e1fico en Go requiere de una combinaci\u00f3n de t\u00e9cnicas y herramientas adecuadas para garantizar la alta disponibilidad y rendimiento de la aplicaci\u00f3n. Con el uso adecuado de goroutines y canales, dise\u00f1o escalable, gesti\u00f3n de recursos y pruebas exhaustivas, se puede desarrollar una aplicaci\u00f3n robusta y capaz de manejar grandes cantidades de tr\u00e1fico sin problemas.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"go/sr/desarrollo_de_aplicaciones_multiplataforma/","text":"Desarrollo de aplicaciones multiplataforma \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 El desarrollo de aplicaciones multiplataforma se refiere al proceso de crear aplicaciones que pueden ser utilizadas en diferentes sistemas operativos y dispositivos. En el caso de Go lang, esto implica utilizar herramientas y t\u00e9cnicas que nos permitan compilar y ejecutar nuestro c\u00f3digo en diferentes plataformas, como Windows, macOS, Linux, entre otros. Palabras clave y su definici\u00f3n \u00b6 Multiplataforma: Se refiere a la capacidad de un programa o aplicaci\u00f3n de ser ejecutado en diferentes plataformas. Compilaci\u00f3n: Proceso de traducir el c\u00f3digo fuente a un formato ejecutable. Lenguaje de programaci\u00f3n: Un conjunto de reglas y s\u00edmbolos utilizados para escribir programas de computadora. Sistemas operativos: Software que administra los recursos de hardware y software de un ordenador. Biblioteca est\u00e1ndar: Conjunto de paquetes y funciones que vienen incluidos en Go lang y que proporcionan funcionalidades b\u00e1sicas para el desarrollo de aplicaciones. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es el desarrollo de aplicaciones multiplataforma? \u00bfPor qu\u00e9 es importante tener aplicaciones compatibles con diferentes plataformas? \u00bfQu\u00e9 es la compilaci\u00f3n en el contexto de desarrollo de aplicaciones? Menciona algunos sistemas operativos compatibles con Go lang. \u00bfQu\u00e9 es una biblioteca est\u00e1ndar en Go lang? Ejemplos de c\u00f3digo en Go lang \u00b6 package main import \"fmt\" func main () { fmt . Println ( \"\u00a1Hola Mundo!\" ) } Este es un ejemplo b\u00e1sico de un programa en Go lang que imprime \"\u00a1Hola Mundo!\" en la consola. package main import ( \"fmt\" \"runtime\" ) func main () { fmt . Println ( \"Este programa se est\u00e1 ejecutando en\" , runtime . GOOS ) } Este ejemplo utiliza la biblioteca est\u00e1ndar \"runtime\" para imprimir el sistema operativo en el que se est\u00e1 ejecutando el programa. Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea un programa en Go lang que muestre la fecha y hora actual del sistema. Modifica el programa anterior para que tambi\u00e9n imprima el nombre del sistema operativo en el que se est\u00e1 ejecutando. Crea un programa que calcule el \u00e1rea de un c\u00edrculo dado su radio (puedes utilizar la constante math.Pi de la biblioteca est\u00e1ndar). Consejos o mejores pr\u00e1cticas \u00b6 Utilizar la biblioteca est\u00e1ndar de Go lang siempre que sea posible para asegurar la compatibilidad con diferentes sistemas operativos. Evitar el uso de librer\u00edas externas que pueden no ser compatibles con todas las plataformas. Realizar pruebas exhaustivas en diferentes sistemas operativos antes de lanzar una aplicaci\u00f3n multiplataforma. Mantenerse actualizado sobre las \u00faltimas versiones de Go lang para aprovechar las mejoras en la compatibilidad con diferentes plataformas.","title":"Desarrollo de aplicaciones multiplataforma"},{"location":"go/sr/desarrollo_de_aplicaciones_multiplataforma/#desarrollo-de-aplicaciones-multiplataforma","text":"","title":"Desarrollo de aplicaciones multiplataforma"},{"location":"go/sr/desarrollo_de_aplicaciones_multiplataforma/#explicacion-teorica","text":"El desarrollo de aplicaciones multiplataforma se refiere al proceso de crear aplicaciones que pueden ser utilizadas en diferentes sistemas operativos y dispositivos. En el caso de Go lang, esto implica utilizar herramientas y t\u00e9cnicas que nos permitan compilar y ejecutar nuestro c\u00f3digo en diferentes plataformas, como Windows, macOS, Linux, entre otros.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"go/sr/desarrollo_de_aplicaciones_multiplataforma/#palabras-clave-y-su-definicion","text":"Multiplataforma: Se refiere a la capacidad de un programa o aplicaci\u00f3n de ser ejecutado en diferentes plataformas. Compilaci\u00f3n: Proceso de traducir el c\u00f3digo fuente a un formato ejecutable. Lenguaje de programaci\u00f3n: Un conjunto de reglas y s\u00edmbolos utilizados para escribir programas de computadora. Sistemas operativos: Software que administra los recursos de hardware y software de un ordenador. Biblioteca est\u00e1ndar: Conjunto de paquetes y funciones que vienen incluidos en Go lang y que proporcionan funcionalidades b\u00e1sicas para el desarrollo de aplicaciones.","title":"Palabras clave y su definici\u00f3n"},{"location":"go/sr/desarrollo_de_aplicaciones_multiplataforma/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es el desarrollo de aplicaciones multiplataforma? \u00bfPor qu\u00e9 es importante tener aplicaciones compatibles con diferentes plataformas? \u00bfQu\u00e9 es la compilaci\u00f3n en el contexto de desarrollo de aplicaciones? Menciona algunos sistemas operativos compatibles con Go lang. \u00bfQu\u00e9 es una biblioteca est\u00e1ndar en Go lang?","title":"Preguntas de repaso"},{"location":"go/sr/desarrollo_de_aplicaciones_multiplataforma/#ejemplos-de-codigo-en-go-lang","text":"package main import \"fmt\" func main () { fmt . Println ( \"\u00a1Hola Mundo!\" ) } Este es un ejemplo b\u00e1sico de un programa en Go lang que imprime \"\u00a1Hola Mundo!\" en la consola. package main import ( \"fmt\" \"runtime\" ) func main () { fmt . Println ( \"Este programa se est\u00e1 ejecutando en\" , runtime . GOOS ) } Este ejemplo utiliza la biblioteca est\u00e1ndar \"runtime\" para imprimir el sistema operativo en el que se est\u00e1 ejecutando el programa.","title":"Ejemplos de c\u00f3digo en Go lang"},{"location":"go/sr/desarrollo_de_aplicaciones_multiplataforma/#ejercicios-practicos-con-instrucciones-claras","text":"Crea un programa en Go lang que muestre la fecha y hora actual del sistema. Modifica el programa anterior para que tambi\u00e9n imprima el nombre del sistema operativo en el que se est\u00e1 ejecutando. Crea un programa que calcule el \u00e1rea de un c\u00edrculo dado su radio (puedes utilizar la constante math.Pi de la biblioteca est\u00e1ndar).","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"go/sr/desarrollo_de_aplicaciones_multiplataforma/#consejos-o-mejores-practicas","text":"Utilizar la biblioteca est\u00e1ndar de Go lang siempre que sea posible para asegurar la compatibilidad con diferentes sistemas operativos. Evitar el uso de librer\u00edas externas que pueden no ser compatibles con todas las plataformas. Realizar pruebas exhaustivas en diferentes sistemas operativos antes de lanzar una aplicaci\u00f3n multiplataforma. Mantenerse actualizado sobre las \u00faltimas versiones de Go lang para aprovechar las mejoras en la compatibilidad con diferentes plataformas.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"go/sr/integraci%C3%B3n_con_tecnolog%C3%ADas_emergentes/","text":"Integraci\u00f3n con tecnolog\u00edas emergentes \u00b6 En el mundo actual de la tecnolog\u00eda, es cada vez m\u00e1s com\u00fan encontrar aplicaciones que utilizan tecnolog\u00edas emergentes como Blockchain, Internet de las cosas y aprendizaje autom\u00e1tico. Estas tecnolog\u00edas tienen el potencial de revolucionar la forma en que interactuamos con la tecnolog\u00eda y c\u00f3mo se desarrollan las aplicaciones. En esta lecci\u00f3n, exploraremos c\u00f3mo podemos integrar estas tecnolog\u00edas emergentes en nuestras aplicaciones escritas en Go. Teor\u00eda de integraci\u00f3n con tecnolog\u00edas emergentes \u00b6 La integraci\u00f3n de tecnolog\u00edas emergentes en nuestras aplicaciones escritas en Go puede ser un proceso complejo y desafiante, pero tambi\u00e9n es una oportunidad para mejorar y potenciar nuestras aplicaciones. Al integrar estas tecnolog\u00edas, podemos ofrecer caracter\u00edsticas \u00fanicas y mejorar la experiencia del usuario. A continuaci\u00f3n, se explica c\u00f3mo se pueden integrar cada una de estas tecnolog\u00edas en nuestras aplicaciones: Blockchain \u00b6 Blockchain es una tecnolog\u00eda de registro distribuido que permite la creaci\u00f3n de registros inmutables y transparentes. Se ha utilizado principalmente en el mundo de las criptomonedas, pero su potencial se extiende a muchos otros campos, como el almacenamiento de datos, la gesti\u00f3n de identidad y la trazabilidad de productos. La integraci\u00f3n de Blockchain en nuestras aplicaciones Go puede realizarse a trav\u00e9s de bibliotecas y APIs que proporcionan acceso a las redes Blockchain. Algunos ejemplos de bibliotecas son go-ethereum y hyperledger/fabric-sdk-go. Tambi\u00e9n podemos crear nuestra propia implementaci\u00f3n utilizando el paquete crypto de Go. Internet de las cosas (IoT) \u00b6 El Internet de las cosas es una red de dispositivos conectados que pueden intercambiar datos entre s\u00ed. Estos dispositivos pueden ser desde sensores hasta electrodom\u00e9sticos inteligentes. La integraci\u00f3n de IoT en nuestras aplicaciones Go se puede realizar a trav\u00e9s de bibliotecas y APIs que proporcionan acceso a los dispositivos IoT. Algunas de las bibliotecas populares son adafruit-io-go y go-kit/kit. Aprendizaje autom\u00e1tico (ML) \u00b6 El aprendizaje autom\u00e1tico es una t\u00e9cnica de inteligencia artificial que permite a las computadoras aprender y mejorar autom\u00e1ticamente a trav\u00e9s de la experiencia. Puede ser utilizado para analizar grandes cantidades de datos y hacer predicciones precisas. La integraci\u00f3n de ML en nuestras aplicaciones Go se puede realizar a trav\u00e9s de bibliotecas y APIs que proporcionan herramientas para el aprendizaje autom\u00e1tico, como TensorFlow y Gorgonia. Palabras clave \u00b6 Blockchain: tecnolog\u00eda de registro distribuido utilizada para crear registros inmutables y transparentes. Internet de las cosas (IoT): red de dispositivos conectados que pueden intercambiar datos entre s\u00ed. Aprendizaje autom\u00e1tico (ML): t\u00e9cnica de inteligencia artificial que permite a las computadoras aprender y mejorar autom\u00e1ticamente a trav\u00e9s de la experiencia. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es Blockchain y c\u00f3mo se puede integrar en aplicaciones Go? \u00bfQu\u00e9 es el Internet de las cosas y c\u00f3mo se puede integrar en aplicaciones Go? \u00bfQu\u00e9 es el aprendizaje autom\u00e1tico y c\u00f3mo se puede integrar en aplicaciones Go? Ejemplos de c\u00f3digo en Go \u00b6 Integraci\u00f3n con Blockchain \u00b6 // Importar la biblioteca go - ethereum import ( \"github.com/ethereum/go-ethereum/ethclient\" ) // Crear una conexi\u00f3n con una red Ethereum client , err := ethclient . Dial ( \"https://mainnet.infura.io\" ) if err != nil { log . Fatal ( err ) } // Obtener el \u00faltimo bloque de la red Ethereum header , err := client . HeaderByNumber ( context . Background (), nil ) if err != nil { log . Fatal ( err ) } fmt . Println ( header . Number . String ()) // 5671744 Integraci\u00f3n con IoT \u00b6 // Importar la biblioteca adafruit - io - go import ( \"github.com/adafruit/io-client-go/io\" ) // Crear una conexi\u00f3n con Adafruit IO aio := io . NewClient ( \"YOUR_AIO_KEY\" ) // Publicar un valor en un feed err := aio . Publish ( \"test-feed\" , 42 ) if err != nil { log . Fatal ( err ) } // Leer el valor m\u00e1s reciente de un feed data , err := aio . Receive ( \"test-feed\" ) if err != nil { log . Fatal ( err ) } fmt . Println ( data . Value ) // 42 Integraci\u00f3n con ML \u00b6 // Importar la biblioteca TensorFlow import ( tf \"github.com/tensorflow/tensorflow/tensorflow/go\" ) // Crear un modelo de red neuronal simple model := tf . NewGraph () // A\u00f1adir nodos al modelo input := tf . NewTensor ([] float32 { 1 , 2 , 3 , 4 }) output := tf . Add ( input , tf . NewTensor ([] float32 { 1 , 1 , 1 , 1 })) // Ejecutar el modelo session , err := tf . NewSession ( model , nil ) if err != nil { log . Fatal ( err ) } defer session . Close () result , err := session . Run ( output , nil , nil ) if err != nil { log . Fatal ( err ) } fmt . Println ( result . Value ()) // [ 2 3 4 5 ] Ejercicios pr\u00e1cticos \u00b6 Integrar una biblioteca Blockchain en una aplicaci\u00f3n Go para almacenar datos de forma segura. Crear una aplicaci\u00f3n Go que se comunique con dispositivos IoT y muestre datos en tiempo real. Desarrollar un algoritmo de aprendizaje autom\u00e1tico en Go para predecir el precio de una criptomoneda. Consejos y mejores pr\u00e1cticas \u00b6 Antes de integrar cualquier tecnolog\u00eda emergente en una aplicaci\u00f3n Go, aseg\u00farate de comprender su funcionamiento y c\u00f3mo se puede utilizar de manera efectiva. Utiliza bibliotecas y APIs de confianza para integrar estas tecnolog\u00edas en tus aplicaciones Go. Aseg\u00farate de tener una buena documentaci\u00f3n y pruebas en tu aplicaci\u00f3n despu\u00e9s de la integraci\u00f3n para garantizar su funcionamiento correcto. Mantente actualizado sobre las nuevas tecnolog\u00edas emergentes y c\u00f3mo se pueden utilizar en aplicaciones Go para mejorar su funcionalidad y experiencia del usuario.","title":"Integraci\u00f3n con tecnolog\u00edas emergentes"},{"location":"go/sr/integraci%C3%B3n_con_tecnolog%C3%ADas_emergentes/#integracion-con-tecnologias-emergentes","text":"En el mundo actual de la tecnolog\u00eda, es cada vez m\u00e1s com\u00fan encontrar aplicaciones que utilizan tecnolog\u00edas emergentes como Blockchain, Internet de las cosas y aprendizaje autom\u00e1tico. Estas tecnolog\u00edas tienen el potencial de revolucionar la forma en que interactuamos con la tecnolog\u00eda y c\u00f3mo se desarrollan las aplicaciones. En esta lecci\u00f3n, exploraremos c\u00f3mo podemos integrar estas tecnolog\u00edas emergentes en nuestras aplicaciones escritas en Go.","title":"Integraci\u00f3n con tecnolog\u00edas emergentes"},{"location":"go/sr/integraci%C3%B3n_con_tecnolog%C3%ADas_emergentes/#teoria-de-integracion-con-tecnologias-emergentes","text":"La integraci\u00f3n de tecnolog\u00edas emergentes en nuestras aplicaciones escritas en Go puede ser un proceso complejo y desafiante, pero tambi\u00e9n es una oportunidad para mejorar y potenciar nuestras aplicaciones. Al integrar estas tecnolog\u00edas, podemos ofrecer caracter\u00edsticas \u00fanicas y mejorar la experiencia del usuario. A continuaci\u00f3n, se explica c\u00f3mo se pueden integrar cada una de estas tecnolog\u00edas en nuestras aplicaciones:","title":"Teor\u00eda de integraci\u00f3n con tecnolog\u00edas emergentes"},{"location":"go/sr/integraci%C3%B3n_con_tecnolog%C3%ADas_emergentes/#blockchain","text":"Blockchain es una tecnolog\u00eda de registro distribuido que permite la creaci\u00f3n de registros inmutables y transparentes. Se ha utilizado principalmente en el mundo de las criptomonedas, pero su potencial se extiende a muchos otros campos, como el almacenamiento de datos, la gesti\u00f3n de identidad y la trazabilidad de productos. La integraci\u00f3n de Blockchain en nuestras aplicaciones Go puede realizarse a trav\u00e9s de bibliotecas y APIs que proporcionan acceso a las redes Blockchain. Algunos ejemplos de bibliotecas son go-ethereum y hyperledger/fabric-sdk-go. Tambi\u00e9n podemos crear nuestra propia implementaci\u00f3n utilizando el paquete crypto de Go.","title":"Blockchain"},{"location":"go/sr/integraci%C3%B3n_con_tecnolog%C3%ADas_emergentes/#internet-de-las-cosas-iot","text":"El Internet de las cosas es una red de dispositivos conectados que pueden intercambiar datos entre s\u00ed. Estos dispositivos pueden ser desde sensores hasta electrodom\u00e9sticos inteligentes. La integraci\u00f3n de IoT en nuestras aplicaciones Go se puede realizar a trav\u00e9s de bibliotecas y APIs que proporcionan acceso a los dispositivos IoT. Algunas de las bibliotecas populares son adafruit-io-go y go-kit/kit.","title":"Internet de las cosas (IoT)"},{"location":"go/sr/integraci%C3%B3n_con_tecnolog%C3%ADas_emergentes/#aprendizaje-automatico-ml","text":"El aprendizaje autom\u00e1tico es una t\u00e9cnica de inteligencia artificial que permite a las computadoras aprender y mejorar autom\u00e1ticamente a trav\u00e9s de la experiencia. Puede ser utilizado para analizar grandes cantidades de datos y hacer predicciones precisas. La integraci\u00f3n de ML en nuestras aplicaciones Go se puede realizar a trav\u00e9s de bibliotecas y APIs que proporcionan herramientas para el aprendizaje autom\u00e1tico, como TensorFlow y Gorgonia.","title":"Aprendizaje autom\u00e1tico (ML)"},{"location":"go/sr/integraci%C3%B3n_con_tecnolog%C3%ADas_emergentes/#palabras-clave","text":"Blockchain: tecnolog\u00eda de registro distribuido utilizada para crear registros inmutables y transparentes. Internet de las cosas (IoT): red de dispositivos conectados que pueden intercambiar datos entre s\u00ed. Aprendizaje autom\u00e1tico (ML): t\u00e9cnica de inteligencia artificial que permite a las computadoras aprender y mejorar autom\u00e1ticamente a trav\u00e9s de la experiencia.","title":"Palabras clave"},{"location":"go/sr/integraci%C3%B3n_con_tecnolog%C3%ADas_emergentes/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Blockchain y c\u00f3mo se puede integrar en aplicaciones Go? \u00bfQu\u00e9 es el Internet de las cosas y c\u00f3mo se puede integrar en aplicaciones Go? \u00bfQu\u00e9 es el aprendizaje autom\u00e1tico y c\u00f3mo se puede integrar en aplicaciones Go?","title":"Preguntas de repaso"},{"location":"go/sr/integraci%C3%B3n_con_tecnolog%C3%ADas_emergentes/#ejemplos-de-codigo-en-go","text":"","title":"Ejemplos de c\u00f3digo en Go"},{"location":"go/sr/integraci%C3%B3n_con_tecnolog%C3%ADas_emergentes/#integracion-con-blockchain","text":"// Importar la biblioteca go - ethereum import ( \"github.com/ethereum/go-ethereum/ethclient\" ) // Crear una conexi\u00f3n con una red Ethereum client , err := ethclient . Dial ( \"https://mainnet.infura.io\" ) if err != nil { log . Fatal ( err ) } // Obtener el \u00faltimo bloque de la red Ethereum header , err := client . HeaderByNumber ( context . Background (), nil ) if err != nil { log . Fatal ( err ) } fmt . Println ( header . Number . String ()) // 5671744","title":"Integraci\u00f3n con Blockchain"},{"location":"go/sr/integraci%C3%B3n_con_tecnolog%C3%ADas_emergentes/#integracion-con-iot","text":"// Importar la biblioteca adafruit - io - go import ( \"github.com/adafruit/io-client-go/io\" ) // Crear una conexi\u00f3n con Adafruit IO aio := io . NewClient ( \"YOUR_AIO_KEY\" ) // Publicar un valor en un feed err := aio . Publish ( \"test-feed\" , 42 ) if err != nil { log . Fatal ( err ) } // Leer el valor m\u00e1s reciente de un feed data , err := aio . Receive ( \"test-feed\" ) if err != nil { log . Fatal ( err ) } fmt . Println ( data . Value ) // 42","title":"Integraci\u00f3n con IoT"},{"location":"go/sr/integraci%C3%B3n_con_tecnolog%C3%ADas_emergentes/#integracion-con-ml","text":"// Importar la biblioteca TensorFlow import ( tf \"github.com/tensorflow/tensorflow/tensorflow/go\" ) // Crear un modelo de red neuronal simple model := tf . NewGraph () // A\u00f1adir nodos al modelo input := tf . NewTensor ([] float32 { 1 , 2 , 3 , 4 }) output := tf . Add ( input , tf . NewTensor ([] float32 { 1 , 1 , 1 , 1 })) // Ejecutar el modelo session , err := tf . NewSession ( model , nil ) if err != nil { log . Fatal ( err ) } defer session . Close () result , err := session . Run ( output , nil , nil ) if err != nil { log . Fatal ( err ) } fmt . Println ( result . Value ()) // [ 2 3 4 5 ]","title":"Integraci\u00f3n con ML"},{"location":"go/sr/integraci%C3%B3n_con_tecnolog%C3%ADas_emergentes/#ejercicios-practicos","text":"Integrar una biblioteca Blockchain en una aplicaci\u00f3n Go para almacenar datos de forma segura. Crear una aplicaci\u00f3n Go que se comunique con dispositivos IoT y muestre datos en tiempo real. Desarrollar un algoritmo de aprendizaje autom\u00e1tico en Go para predecir el precio de una criptomoneda.","title":"Ejercicios pr\u00e1cticos"},{"location":"go/sr/integraci%C3%B3n_con_tecnolog%C3%ADas_emergentes/#consejos-y-mejores-practicas","text":"Antes de integrar cualquier tecnolog\u00eda emergente en una aplicaci\u00f3n Go, aseg\u00farate de comprender su funcionamiento y c\u00f3mo se puede utilizar de manera efectiva. Utiliza bibliotecas y APIs de confianza para integrar estas tecnolog\u00edas en tus aplicaciones Go. Aseg\u00farate de tener una buena documentaci\u00f3n y pruebas en tu aplicaci\u00f3n despu\u00e9s de la integraci\u00f3n para garantizar su funcionamiento correcto. Mantente actualizado sobre las nuevas tecnolog\u00edas emergentes y c\u00f3mo se pueden utilizar en aplicaciones Go para mejorar su funcionalidad y experiencia del usuario.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"go/sr/mejores_pr%C3%A1cticas_y_patrones_de_dise%C3%B1o/","text":"Lecci\u00f3n: Mejores pr\u00e1cticas y patrones de dise\u00f1o en Go lang \u00b6 En esta lecci\u00f3n, aprender\u00e1s sobre las mejores pr\u00e1cticas y patrones de dise\u00f1o que se pueden utilizar en aplicaciones en Go para mejorar su calidad y mantenibilidad. 1. Explicaci\u00f3n te\u00f3rica \u00b6 Las mejores pr\u00e1cticas y patrones de dise\u00f1o son t\u00e9cnicas y principios que se utilizan para desarrollar aplicaciones de alta calidad, f\u00e1ciles de mantener y escalables. En Go lang, estas pr\u00e1cticas y patrones se enfocan en promover la simplicidad, la eficiencia y la legibilidad del c\u00f3digo. Algunas de las mejores pr\u00e1cticas en Go lang incluyen: Utilizar nombres de variables y funciones descriptivos y concisos. Mantener el c\u00f3digo limpio y f\u00e1cil de entender. Evitar el uso de variables globales. Utilizar interfaces en lugar de tipos concretos. Manejar errores de manera adecuada utilizando la sintaxis if err != nil . Utilizar pruebas unitarias para garantizar la funcionalidad del c\u00f3digo. Por otro lado, los patrones de dise\u00f1o son soluciones probadas y com\u00fanmente utilizadas para problemas de dise\u00f1o recurrentes en el desarrollo de software. En Go lang, algunos de los patrones de dise\u00f1o m\u00e1s utilizados son: Patr\u00f3n de dise\u00f1o Singleton: garantiza que solo haya una instancia de una estructura en todo el programa. Patr\u00f3n de dise\u00f1o Factory: permite la creaci\u00f3n de objetos sin especificar la clase exacta del objeto que se crear\u00e1. Patr\u00f3n de dise\u00f1o Observer: establece una relaci\u00f3n de uno a muchos entre objetos, de modo que cuando un objeto cambia, se notifica a todos los objetos que dependen de \u00e9l. Patr\u00f3n de dise\u00f1o Strategy: permite cambiar el comportamiento de un objeto en tiempo de ejecuci\u00f3n. 2. Palabras clave y su definici\u00f3n \u00b6 Mejores pr\u00e1cticas: t\u00e9cnicas y principios utilizados para desarrollar aplicaciones de alta calidad y mantenibles. Patrones de dise\u00f1o: soluciones probadas y com\u00fanmente utilizadas para problemas de dise\u00f1o recurrentes en el desarrollo de software. Simplicidad: principio de dise\u00f1o que promueve la claridad y la simplicidad en el c\u00f3digo. Eficiencia: principio de dise\u00f1o que se enfoca en la optimizaci\u00f3n del rendimiento y el uso adecuado de recursos. Legibilidad: principio de dise\u00f1o que se refiere a la facilidad de entender el c\u00f3digo por otros desarrolladores. Variables globales: variables que pueden ser accedidas y modificadas desde cualquier parte del programa. Interfaces: tipos abstractos que definen un conjunto de m\u00e9todos que deben ser implementados por una estructura para cumplir con la interfaz. Pruebas unitarias: pruebas que se encargan de verificar la funcionalidad de una unidad de c\u00f3digo, como una funci\u00f3n o un m\u00e9todo. Singleton: patr\u00f3n de dise\u00f1o que garantiza la existencia de una \u00fanica instancia de una estructura en todo el programa. Factory: patr\u00f3n de dise\u00f1o que permite la creaci\u00f3n de objetos sin especificar la clase exacta del objeto que se crear\u00e1. Observer: patr\u00f3n de dise\u00f1o que establece una relaci\u00f3n de uno a muchos entre objetos, de modo que cuando un objeto cambia, se notifica a todos los objetos que dependen de \u00e9l. Strategy: patr\u00f3n de dise\u00f1o que permite cambiar el comportamiento de un objeto en tiempo de ejecuci\u00f3n. 3. Preguntas de repaso \u00b6 \u00bfQu\u00e9 son las mejores pr\u00e1cticas y por qu\u00e9 son importantes en el desarrollo de aplicaciones en Go lang? Menciona dos patrones de dise\u00f1o com\u00fanmente utilizados en Go lang. \u00bfQu\u00e9 es una interfaz y c\u00f3mo se utiliza en Go lang? \u00bfPor qu\u00e9 es importante manejar adecuadamente los errores en Go lang? \u00bfQu\u00e9 son las pruebas unitarias y por qu\u00e9 son importantes en el desarrollo de aplicaciones en Go lang? 4. Ejemplos de c\u00f3digo en Go lang \u00b6 Mejores pr\u00e1cticas \u00b6 // Utilizar nombres descriptivos para variables y funciones func calcularArea ( base , altura float64 ) float64 { return base * altura } // Utilizar interfaces en lugar de tipos concretos type Animal interface { Sonido () string } func HacerSonido ( animal Animal ) { fmt . Println ( animal . Sonido ()) } // Manejar errores utilizando if err != nil archivo , err := os . Open ( \"archivo.txt\" ) if err != nil { log . Fatal ( err ) } Patr\u00f3n de dise\u00f1o Singleton \u00b6 // Implementaci\u00f3n del patr\u00f3n de dise\u00f1o Singleton en Go lang type Database struct { connection string } var instance * Database func GetInstance () * Database { if instance == nil { instance = & Database { connection : \"localhost\" } } return instance } Patr\u00f3n de dise\u00f1o Factory \u00b6 // Implementaci\u00f3n del patr\u00f3n de dise\u00f1o Factory en Go lang type Shape interface { Area () float64 } type Rectangle struct { base , altura float64 } func ( r Rectangle ) Area () float64 { return r . base * r . altura } type Circle struct { radio float64 } func ( c Circle ) Area () float64 { return math . Pi * c . radio * c . radio } func CrearShape ( tipo string ) Shape { if tipo == \"rectangulo\" { return Rectangle { base : 5 , altura : 3 } } else if tipo == \"circulo\" { return Circle { radio : 2 } } else { return nil } } 5. Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una funci\u00f3n en Go lang que tome como par\u00e1metros dos n\u00fameros enteros y devuelva el resultado de la multiplicaci\u00f3n de ambos. Utiliza nombres descriptivos para la funci\u00f3n y los par\u00e1metros. Implementa una interfaz en Go lang que contenga un m\u00e9todo para calcular el per\u00edmetro de una figura geom\u00e9trica. Crea dos estructuras que implementen esta interfaz, una para un tri\u00e1ngulo y otra para un cuadrado. Crea una funci\u00f3n en Go lang que lea un archivo de texto y devuelva su contenido. Maneja adecuadamente los errores utilizando la sintaxis if err != nil . Implementa el patr\u00f3n de dise\u00f1o Singleton en un programa en Go lang que simule la conexi\u00f3n a una base de datos. Utiliza el patr\u00f3n de dise\u00f1o Factory para crear un programa en Go lang que permita al usuario elegir entre dos figuras geom\u00e9tricas (tri\u00e1ngulo o cuadrado) y calcular su \u00e1rea. 6. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza nombres descriptivos para variables y funciones para que el c\u00f3digo sea m\u00e1s f\u00e1cil de entender. Mant\u00e9n el c\u00f3digo limpio y bien estructurado para facilitar su mantenimiento. Evita el uso de variables globales, ya que pueden causar problemas de concurrencia. Utiliza interfaces en lugar de tipos concretos para lograr un c\u00f3digo m\u00e1s flexible y f\u00e1cil de extender. Maneja adecuadamente los errores utilizando la sintaxis if err != nil para evitar problemas en tiempo de ejecuci\u00f3n. Realiza pruebas unitarias para garantizar la funcionalidad del c\u00f3digo. Utiliza patrones de dise\u00f1o cuando sea necesario para resolver problemas de dise\u00f1o recurrentes. Documenta tu c\u00f3digo para que otros desarrolladores puedan entenderlo f\u00e1cilmente.","title":"Lecci\u00f3n: Mejores pr\u00e1cticas y patrones de dise\u00f1o en Go lang"},{"location":"go/sr/mejores_pr%C3%A1cticas_y_patrones_de_dise%C3%B1o/#leccion-mejores-practicas-y-patrones-de-diseno-en-go-lang","text":"En esta lecci\u00f3n, aprender\u00e1s sobre las mejores pr\u00e1cticas y patrones de dise\u00f1o que se pueden utilizar en aplicaciones en Go para mejorar su calidad y mantenibilidad.","title":"Lecci\u00f3n: Mejores pr\u00e1cticas y patrones de dise\u00f1o en Go lang"},{"location":"go/sr/mejores_pr%C3%A1cticas_y_patrones_de_dise%C3%B1o/#1-explicacion-teorica","text":"Las mejores pr\u00e1cticas y patrones de dise\u00f1o son t\u00e9cnicas y principios que se utilizan para desarrollar aplicaciones de alta calidad, f\u00e1ciles de mantener y escalables. En Go lang, estas pr\u00e1cticas y patrones se enfocan en promover la simplicidad, la eficiencia y la legibilidad del c\u00f3digo. Algunas de las mejores pr\u00e1cticas en Go lang incluyen: Utilizar nombres de variables y funciones descriptivos y concisos. Mantener el c\u00f3digo limpio y f\u00e1cil de entender. Evitar el uso de variables globales. Utilizar interfaces en lugar de tipos concretos. Manejar errores de manera adecuada utilizando la sintaxis if err != nil . Utilizar pruebas unitarias para garantizar la funcionalidad del c\u00f3digo. Por otro lado, los patrones de dise\u00f1o son soluciones probadas y com\u00fanmente utilizadas para problemas de dise\u00f1o recurrentes en el desarrollo de software. En Go lang, algunos de los patrones de dise\u00f1o m\u00e1s utilizados son: Patr\u00f3n de dise\u00f1o Singleton: garantiza que solo haya una instancia de una estructura en todo el programa. Patr\u00f3n de dise\u00f1o Factory: permite la creaci\u00f3n de objetos sin especificar la clase exacta del objeto que se crear\u00e1. Patr\u00f3n de dise\u00f1o Observer: establece una relaci\u00f3n de uno a muchos entre objetos, de modo que cuando un objeto cambia, se notifica a todos los objetos que dependen de \u00e9l. Patr\u00f3n de dise\u00f1o Strategy: permite cambiar el comportamiento de un objeto en tiempo de ejecuci\u00f3n.","title":"1. Explicaci\u00f3n te\u00f3rica"},{"location":"go/sr/mejores_pr%C3%A1cticas_y_patrones_de_dise%C3%B1o/#2-palabras-clave-y-su-definicion","text":"Mejores pr\u00e1cticas: t\u00e9cnicas y principios utilizados para desarrollar aplicaciones de alta calidad y mantenibles. Patrones de dise\u00f1o: soluciones probadas y com\u00fanmente utilizadas para problemas de dise\u00f1o recurrentes en el desarrollo de software. Simplicidad: principio de dise\u00f1o que promueve la claridad y la simplicidad en el c\u00f3digo. Eficiencia: principio de dise\u00f1o que se enfoca en la optimizaci\u00f3n del rendimiento y el uso adecuado de recursos. Legibilidad: principio de dise\u00f1o que se refiere a la facilidad de entender el c\u00f3digo por otros desarrolladores. Variables globales: variables que pueden ser accedidas y modificadas desde cualquier parte del programa. Interfaces: tipos abstractos que definen un conjunto de m\u00e9todos que deben ser implementados por una estructura para cumplir con la interfaz. Pruebas unitarias: pruebas que se encargan de verificar la funcionalidad de una unidad de c\u00f3digo, como una funci\u00f3n o un m\u00e9todo. Singleton: patr\u00f3n de dise\u00f1o que garantiza la existencia de una \u00fanica instancia de una estructura en todo el programa. Factory: patr\u00f3n de dise\u00f1o que permite la creaci\u00f3n de objetos sin especificar la clase exacta del objeto que se crear\u00e1. Observer: patr\u00f3n de dise\u00f1o que establece una relaci\u00f3n de uno a muchos entre objetos, de modo que cuando un objeto cambia, se notifica a todos los objetos que dependen de \u00e9l. Strategy: patr\u00f3n de dise\u00f1o que permite cambiar el comportamiento de un objeto en tiempo de ejecuci\u00f3n.","title":"2. Palabras clave y su definici\u00f3n"},{"location":"go/sr/mejores_pr%C3%A1cticas_y_patrones_de_dise%C3%B1o/#3-preguntas-de-repaso","text":"\u00bfQu\u00e9 son las mejores pr\u00e1cticas y por qu\u00e9 son importantes en el desarrollo de aplicaciones en Go lang? Menciona dos patrones de dise\u00f1o com\u00fanmente utilizados en Go lang. \u00bfQu\u00e9 es una interfaz y c\u00f3mo se utiliza en Go lang? \u00bfPor qu\u00e9 es importante manejar adecuadamente los errores en Go lang? \u00bfQu\u00e9 son las pruebas unitarias y por qu\u00e9 son importantes en el desarrollo de aplicaciones en Go lang?","title":"3. Preguntas de repaso"},{"location":"go/sr/mejores_pr%C3%A1cticas_y_patrones_de_dise%C3%B1o/#4-ejemplos-de-codigo-en-go-lang","text":"","title":"4. Ejemplos de c\u00f3digo en Go lang"},{"location":"go/sr/mejores_pr%C3%A1cticas_y_patrones_de_dise%C3%B1o/#mejores-practicas","text":"// Utilizar nombres descriptivos para variables y funciones func calcularArea ( base , altura float64 ) float64 { return base * altura } // Utilizar interfaces en lugar de tipos concretos type Animal interface { Sonido () string } func HacerSonido ( animal Animal ) { fmt . Println ( animal . Sonido ()) } // Manejar errores utilizando if err != nil archivo , err := os . Open ( \"archivo.txt\" ) if err != nil { log . Fatal ( err ) }","title":"Mejores pr\u00e1cticas"},{"location":"go/sr/mejores_pr%C3%A1cticas_y_patrones_de_dise%C3%B1o/#patron-de-diseno-singleton","text":"// Implementaci\u00f3n del patr\u00f3n de dise\u00f1o Singleton en Go lang type Database struct { connection string } var instance * Database func GetInstance () * Database { if instance == nil { instance = & Database { connection : \"localhost\" } } return instance }","title":"Patr\u00f3n de dise\u00f1o Singleton"},{"location":"go/sr/mejores_pr%C3%A1cticas_y_patrones_de_dise%C3%B1o/#patron-de-diseno-factory","text":"// Implementaci\u00f3n del patr\u00f3n de dise\u00f1o Factory en Go lang type Shape interface { Area () float64 } type Rectangle struct { base , altura float64 } func ( r Rectangle ) Area () float64 { return r . base * r . altura } type Circle struct { radio float64 } func ( c Circle ) Area () float64 { return math . Pi * c . radio * c . radio } func CrearShape ( tipo string ) Shape { if tipo == \"rectangulo\" { return Rectangle { base : 5 , altura : 3 } } else if tipo == \"circulo\" { return Circle { radio : 2 } } else { return nil } }","title":"Patr\u00f3n de dise\u00f1o Factory"},{"location":"go/sr/mejores_pr%C3%A1cticas_y_patrones_de_dise%C3%B1o/#5-ejercicios-practicos-con-instrucciones-claras","text":"Crea una funci\u00f3n en Go lang que tome como par\u00e1metros dos n\u00fameros enteros y devuelva el resultado de la multiplicaci\u00f3n de ambos. Utiliza nombres descriptivos para la funci\u00f3n y los par\u00e1metros. Implementa una interfaz en Go lang que contenga un m\u00e9todo para calcular el per\u00edmetro de una figura geom\u00e9trica. Crea dos estructuras que implementen esta interfaz, una para un tri\u00e1ngulo y otra para un cuadrado. Crea una funci\u00f3n en Go lang que lea un archivo de texto y devuelva su contenido. Maneja adecuadamente los errores utilizando la sintaxis if err != nil . Implementa el patr\u00f3n de dise\u00f1o Singleton en un programa en Go lang que simule la conexi\u00f3n a una base de datos. Utiliza el patr\u00f3n de dise\u00f1o Factory para crear un programa en Go lang que permita al usuario elegir entre dos figuras geom\u00e9tricas (tri\u00e1ngulo o cuadrado) y calcular su \u00e1rea.","title":"5. Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"go/sr/mejores_pr%C3%A1cticas_y_patrones_de_dise%C3%B1o/#6-consejos-o-mejores-practicas","text":"Utiliza nombres descriptivos para variables y funciones para que el c\u00f3digo sea m\u00e1s f\u00e1cil de entender. Mant\u00e9n el c\u00f3digo limpio y bien estructurado para facilitar su mantenimiento. Evita el uso de variables globales, ya que pueden causar problemas de concurrencia. Utiliza interfaces en lugar de tipos concretos para lograr un c\u00f3digo m\u00e1s flexible y f\u00e1cil de extender. Maneja adecuadamente los errores utilizando la sintaxis if err != nil para evitar problemas en tiempo de ejecuci\u00f3n. Realiza pruebas unitarias para garantizar la funcionalidad del c\u00f3digo. Utiliza patrones de dise\u00f1o cuando sea necesario para resolver problemas de dise\u00f1o recurrentes. Documenta tu c\u00f3digo para que otros desarrolladores puedan entenderlo f\u00e1cilmente.","title":"6. Consejos o mejores pr\u00e1cticas"},{"location":"go/sr/migraci%C3%B3n_de_aplicaciones_existentes_a_go/","text":"Migraci\u00f3n de aplicaciones existentes a Go \u00b6 Introducci\u00f3n \u00b6 Go es un lenguaje de programaci\u00f3n de c\u00f3digo abierto, creado por Google en 2009, que se ha vuelto cada vez m\u00e1s popular en la comunidad de desarrolladores debido a su eficiencia, simplicidad y facilidad de uso. A medida que las aplicaciones existentes crecen y evolucionan, puede ser necesario migrarlas a un lenguaje m\u00e1s moderno y eficiente como Go. En este m\u00f3dulo, aprender\u00e1s los pasos y consideraciones para migrar aplicaciones existentes a Go. Palabras clave \u00b6 Migraci\u00f3n: proceso de trasladar una aplicaci\u00f3n existente de un lenguaje de programaci\u00f3n a otro. Eficiencia: capacidad de realizar tareas de manera r\u00e1pida y con la menor cantidad de recursos posibles. Simplicidad: cualidad de ser f\u00e1cil de entender y utilizar. Facilidad de uso: capacidad de utilizar un lenguaje de programaci\u00f3n de manera intuitiva y sin complicaciones. Modernizaci\u00f3n: proceso de actualizar una aplicaci\u00f3n existente a un lenguaje o tecnolog\u00eda m\u00e1s reciente. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la migraci\u00f3n de aplicaciones? \u00bfPor qu\u00e9 se puede considerar la migraci\u00f3n a Go? \u00bfCu\u00e1les son las principales caracter\u00edsticas de Go? \u00bfQu\u00e9 es la modernizaci\u00f3n de una aplicaci\u00f3n? \u00bfCu\u00e1les son los beneficios de migrar una aplicaci\u00f3n a Go? Pasos para migrar aplicaciones existentes a Go \u00b6 1. Evaluar la viabilidad de la migraci\u00f3n \u00b6 Antes de comenzar el proceso de migraci\u00f3n, es importante evaluar si realmente es necesario migrar la aplicaci\u00f3n existente a Go. Algunos factores a considerar son: La complejidad de la aplicaci\u00f3n: si la aplicaci\u00f3n es muy compleja, puede ser m\u00e1s dif\u00edcil y costoso migrarla a un lenguaje diferente. El tiempo y recursos disponibles: la migraci\u00f3n puede ser un proceso largo y requerir una inversi\u00f3n de tiempo y recursos significativa. La compatibilidad de las aplicaciones: algunas aplicaciones pueden tener dependencias o integraciones con otras tecnolog\u00edas que pueden no ser compatibles con Go. 2. Familiarizarse con Go \u00b6 Antes de comenzar a migrar, es importante tener un conocimiento b\u00e1sico de Go y sus caracter\u00edsticas principales. Algunos conceptos importantes a conocer son: Tipos de datos y estructuras de control: Go tiene tipos de datos fuertes y estructuras de control similares a otros lenguajes de programaci\u00f3n. Funciones y m\u00e9todos: en Go, las funciones y m\u00e9todos son fundamentales y se utilizan para realizar tareas espec\u00edficas. Paquetes y m\u00f3dulos: Go utiliza un sistema de paquetes y m\u00f3dulos para organizar y compartir c\u00f3digo. 3. Analizar el c\u00f3digo existente \u00b6 Antes de comenzar a escribir c\u00f3digo en Go, es importante analizar el c\u00f3digo existente y determinar qu\u00e9 partes pueden ser reutilizadas y cu\u00e1les deben ser reescritas. Tambi\u00e9n es importante identificar las dependencias y librer\u00edas utilizadas en la aplicaci\u00f3n actual y buscar alternativas en Go. 4. Convertir el c\u00f3digo a Go \u00b6 Una vez que se ha analizado el c\u00f3digo existente, se puede comenzar a convertirlo a Go. Esto puede requerir la reescritura de algunas partes del c\u00f3digo, pero tambi\u00e9n se pueden reutilizar algunas secciones. Es importante seguir las mejores pr\u00e1cticas de Go al escribir nuevo c\u00f3digo y asegurarse de que el c\u00f3digo sea eficiente y f\u00e1cil de entender. 5. Realizar pruebas exhaustivas \u00b6 Despu\u00e9s de convertir el c\u00f3digo a Go, es esencial realizar pruebas exhaustivas para asegurarse de que la aplicaci\u00f3n funcione correctamente y no haya errores o problemas de rendimiento. Se pueden utilizar herramientas de prueba como pruebas unitarias, pruebas de integraci\u00f3n y pruebas de rendimiento. 6. Implementar la aplicaci\u00f3n en producci\u00f3n \u00b6 Una vez que se han realizado las pruebas y se ha asegurado que la aplicaci\u00f3n funciona correctamente, se puede implementar en producci\u00f3n. Es importante monitorear la aplicaci\u00f3n y realizar ajustes si es necesario. Ejemplos de c\u00f3digo en Go \u00b6 A continuaci\u00f3n, se muestra un ejemplo de una funci\u00f3n en Go que suma dos n\u00fameros enteros y devuelve el resultado: func suma ( a , b int ) int { return a + b } Ejercicios pr\u00e1cticos \u00b6 Escribe una funci\u00f3n en Go que tome un n\u00famero entero como par\u00e1metro y devuelva su doble. Convierte el siguiente c\u00f3digo de Python a Go: def es_par ( num ): if num % 2 == 0 : return True else : return False Consejos y mejores pr\u00e1cticas \u00b6 Comienza con peque\u00f1as partes de la aplicaci\u00f3n y ve migr\u00e1ndolas gradualmente a Go. Utiliza herramientas de conversi\u00f3n de c\u00f3digo si es posible, pero aseg\u00farate de revisar y ajustar el c\u00f3digo manualmente. Aprovecha las caracter\u00edsticas \u00fanicas de Go, como las rutinas y canales, para mejorar la eficiencia y el rendimiento de la aplicaci\u00f3n. Realiza pruebas y ajustes constantes para asegurarte de que la aplicaci\u00f3n funcione correctamente y sea eficiente. Conclusi\u00f3n \u00b6 La migraci\u00f3n de aplicaciones existentes a Go puede ser un proceso desafiante, pero tambi\u00e9n puede traer muchos beneficios en t\u00e9rminos de eficiencia y rendimiento. Al seguir los pasos y consideraciones mencionados en este m\u00f3dulo, podr\u00e1s realizar una migraci\u00f3n exitosa y aprovechar al m\u00e1ximo las caracter\u00edsticas de Go. Recuerda siempre evaluar la viabilidad de la migraci\u00f3n y familiarizarte con Go antes de comenzar a escribir c\u00f3digo. \u00a1Buena suerte!","title":"Migraci\u00f3n de aplicaciones existentes a Go"},{"location":"go/sr/migraci%C3%B3n_de_aplicaciones_existentes_a_go/#migracion-de-aplicaciones-existentes-a-go","text":"","title":"Migraci\u00f3n de aplicaciones existentes a Go"},{"location":"go/sr/migraci%C3%B3n_de_aplicaciones_existentes_a_go/#introduccion","text":"Go es un lenguaje de programaci\u00f3n de c\u00f3digo abierto, creado por Google en 2009, que se ha vuelto cada vez m\u00e1s popular en la comunidad de desarrolladores debido a su eficiencia, simplicidad y facilidad de uso. A medida que las aplicaciones existentes crecen y evolucionan, puede ser necesario migrarlas a un lenguaje m\u00e1s moderno y eficiente como Go. En este m\u00f3dulo, aprender\u00e1s los pasos y consideraciones para migrar aplicaciones existentes a Go.","title":"Introducci\u00f3n"},{"location":"go/sr/migraci%C3%B3n_de_aplicaciones_existentes_a_go/#palabras-clave","text":"Migraci\u00f3n: proceso de trasladar una aplicaci\u00f3n existente de un lenguaje de programaci\u00f3n a otro. Eficiencia: capacidad de realizar tareas de manera r\u00e1pida y con la menor cantidad de recursos posibles. Simplicidad: cualidad de ser f\u00e1cil de entender y utilizar. Facilidad de uso: capacidad de utilizar un lenguaje de programaci\u00f3n de manera intuitiva y sin complicaciones. Modernizaci\u00f3n: proceso de actualizar una aplicaci\u00f3n existente a un lenguaje o tecnolog\u00eda m\u00e1s reciente.","title":"Palabras clave"},{"location":"go/sr/migraci%C3%B3n_de_aplicaciones_existentes_a_go/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la migraci\u00f3n de aplicaciones? \u00bfPor qu\u00e9 se puede considerar la migraci\u00f3n a Go? \u00bfCu\u00e1les son las principales caracter\u00edsticas de Go? \u00bfQu\u00e9 es la modernizaci\u00f3n de una aplicaci\u00f3n? \u00bfCu\u00e1les son los beneficios de migrar una aplicaci\u00f3n a Go?","title":"Preguntas de repaso"},{"location":"go/sr/migraci%C3%B3n_de_aplicaciones_existentes_a_go/#pasos-para-migrar-aplicaciones-existentes-a-go","text":"","title":"Pasos para migrar aplicaciones existentes a Go"},{"location":"go/sr/migraci%C3%B3n_de_aplicaciones_existentes_a_go/#1-evaluar-la-viabilidad-de-la-migracion","text":"Antes de comenzar el proceso de migraci\u00f3n, es importante evaluar si realmente es necesario migrar la aplicaci\u00f3n existente a Go. Algunos factores a considerar son: La complejidad de la aplicaci\u00f3n: si la aplicaci\u00f3n es muy compleja, puede ser m\u00e1s dif\u00edcil y costoso migrarla a un lenguaje diferente. El tiempo y recursos disponibles: la migraci\u00f3n puede ser un proceso largo y requerir una inversi\u00f3n de tiempo y recursos significativa. La compatibilidad de las aplicaciones: algunas aplicaciones pueden tener dependencias o integraciones con otras tecnolog\u00edas que pueden no ser compatibles con Go.","title":"1. Evaluar la viabilidad de la migraci\u00f3n"},{"location":"go/sr/migraci%C3%B3n_de_aplicaciones_existentes_a_go/#2-familiarizarse-con-go","text":"Antes de comenzar a migrar, es importante tener un conocimiento b\u00e1sico de Go y sus caracter\u00edsticas principales. Algunos conceptos importantes a conocer son: Tipos de datos y estructuras de control: Go tiene tipos de datos fuertes y estructuras de control similares a otros lenguajes de programaci\u00f3n. Funciones y m\u00e9todos: en Go, las funciones y m\u00e9todos son fundamentales y se utilizan para realizar tareas espec\u00edficas. Paquetes y m\u00f3dulos: Go utiliza un sistema de paquetes y m\u00f3dulos para organizar y compartir c\u00f3digo.","title":"2. Familiarizarse con Go"},{"location":"go/sr/migraci%C3%B3n_de_aplicaciones_existentes_a_go/#3-analizar-el-codigo-existente","text":"Antes de comenzar a escribir c\u00f3digo en Go, es importante analizar el c\u00f3digo existente y determinar qu\u00e9 partes pueden ser reutilizadas y cu\u00e1les deben ser reescritas. Tambi\u00e9n es importante identificar las dependencias y librer\u00edas utilizadas en la aplicaci\u00f3n actual y buscar alternativas en Go.","title":"3. Analizar el c\u00f3digo existente"},{"location":"go/sr/migraci%C3%B3n_de_aplicaciones_existentes_a_go/#4-convertir-el-codigo-a-go","text":"Una vez que se ha analizado el c\u00f3digo existente, se puede comenzar a convertirlo a Go. Esto puede requerir la reescritura de algunas partes del c\u00f3digo, pero tambi\u00e9n se pueden reutilizar algunas secciones. Es importante seguir las mejores pr\u00e1cticas de Go al escribir nuevo c\u00f3digo y asegurarse de que el c\u00f3digo sea eficiente y f\u00e1cil de entender.","title":"4. Convertir el c\u00f3digo a Go"},{"location":"go/sr/migraci%C3%B3n_de_aplicaciones_existentes_a_go/#5-realizar-pruebas-exhaustivas","text":"Despu\u00e9s de convertir el c\u00f3digo a Go, es esencial realizar pruebas exhaustivas para asegurarse de que la aplicaci\u00f3n funcione correctamente y no haya errores o problemas de rendimiento. Se pueden utilizar herramientas de prueba como pruebas unitarias, pruebas de integraci\u00f3n y pruebas de rendimiento.","title":"5. Realizar pruebas exhaustivas"},{"location":"go/sr/migraci%C3%B3n_de_aplicaciones_existentes_a_go/#6-implementar-la-aplicacion-en-produccion","text":"Una vez que se han realizado las pruebas y se ha asegurado que la aplicaci\u00f3n funciona correctamente, se puede implementar en producci\u00f3n. Es importante monitorear la aplicaci\u00f3n y realizar ajustes si es necesario.","title":"6. Implementar la aplicaci\u00f3n en producci\u00f3n"},{"location":"go/sr/migraci%C3%B3n_de_aplicaciones_existentes_a_go/#ejemplos-de-codigo-en-go","text":"A continuaci\u00f3n, se muestra un ejemplo de una funci\u00f3n en Go que suma dos n\u00fameros enteros y devuelve el resultado: func suma ( a , b int ) int { return a + b }","title":"Ejemplos de c\u00f3digo en Go"},{"location":"go/sr/migraci%C3%B3n_de_aplicaciones_existentes_a_go/#ejercicios-practicos","text":"Escribe una funci\u00f3n en Go que tome un n\u00famero entero como par\u00e1metro y devuelva su doble. Convierte el siguiente c\u00f3digo de Python a Go: def es_par ( num ): if num % 2 == 0 : return True else : return False","title":"Ejercicios pr\u00e1cticos"},{"location":"go/sr/migraci%C3%B3n_de_aplicaciones_existentes_a_go/#consejos-y-mejores-practicas","text":"Comienza con peque\u00f1as partes de la aplicaci\u00f3n y ve migr\u00e1ndolas gradualmente a Go. Utiliza herramientas de conversi\u00f3n de c\u00f3digo si es posible, pero aseg\u00farate de revisar y ajustar el c\u00f3digo manualmente. Aprovecha las caracter\u00edsticas \u00fanicas de Go, como las rutinas y canales, para mejorar la eficiencia y el rendimiento de la aplicaci\u00f3n. Realiza pruebas y ajustes constantes para asegurarte de que la aplicaci\u00f3n funcione correctamente y sea eficiente.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"go/sr/migraci%C3%B3n_de_aplicaciones_existentes_a_go/#conclusion","text":"La migraci\u00f3n de aplicaciones existentes a Go puede ser un proceso desafiante, pero tambi\u00e9n puede traer muchos beneficios en t\u00e9rminos de eficiencia y rendimiento. Al seguir los pasos y consideraciones mencionados en este m\u00f3dulo, podr\u00e1s realizar una migraci\u00f3n exitosa y aprovechar al m\u00e1ximo las caracter\u00edsticas de Go. Recuerda siempre evaluar la viabilidad de la migraci\u00f3n y familiarizarte con Go antes de comenzar a escribir c\u00f3digo. \u00a1Buena suerte!","title":"Conclusi\u00f3n"},{"location":"go/sr/optimizaci%C3%B3n_de_recursos_y_costos/","text":"Optimizaci\u00f3n de recursos y costos en Go \u00b6 En el desarrollo de aplicaciones en Go, es importante tener en cuenta la optimizaci\u00f3n de recursos y costos para mejorar la eficiencia y reducir los gastos asociados. En esta lecci\u00f3n, aprenderemos algunas estrategias para lograrlo. Explicaci\u00f3n te\u00f3rica \u00b6 La optimizaci\u00f3n de recursos y costos se trata de utilizar los recursos disponibles de la manera m\u00e1s eficiente posible para reducir los gastos relacionados con el desarrollo y despliegue de una aplicaci\u00f3n. Esto incluye tanto los recursos de hardware (como la memoria y la capacidad de procesamiento) como los recursos de software (como el uso de librer\u00edas y herramientas). En el caso de aplicaciones en Go, se pueden implementar diversas t\u00e9cnicas para lograr una optimizaci\u00f3n eficiente. Algunas de ellas son: Uso de concurrencia: Go es un lenguaje que ofrece soporte nativo para la concurrencia, lo que permite aprovechar al m\u00e1ximo los recursos de hardware al ejecutar varias tareas de manera simult\u00e1nea. Uso de canales: Los canales en Go son una forma de comunicaci\u00f3n entre goroutines (las unidades de ejecuci\u00f3n en Go). Estos pueden ser utilizados para coordinar y sincronizar el uso de recursos compartidos, evitando problemas de concurrencia. Minimizaci\u00f3n del uso de memoria: Go cuenta con un recolector de basura (garbage collector) que se encarga de liberar la memoria utilizada por variables y objetos que ya no est\u00e1n en uso. Sin embargo, es importante tener en cuenta el uso de recursos en la implementaci\u00f3n de algoritmos y estructuras de datos. Uso de librer\u00edas eficientes: Al elegir librer\u00edas y paquetes para el desarrollo de una aplicaci\u00f3n en Go, es importante considerar su eficiencia en t\u00e9rminos de uso de memoria y procesamiento. Esto puede impactar en el rendimiento y en los costos asociados al consumo de recursos. Implementaci\u00f3n de pruebas y monitoreo: La optimizaci\u00f3n de recursos y costos no se limita al desarrollo, tambi\u00e9n es importante realizar pruebas y monitorear la aplicaci\u00f3n en producci\u00f3n para detectar posibles problemas y realizar ajustes para mejorar la eficiencia. Palabras clave y su definici\u00f3n \u00b6 Optimizaci\u00f3n: Proceso de mejorar la eficiencia y reducir los gastos asociados a una actividad. Recursos: Elementos utilizados en el desarrollo y despliegue de una aplicaci\u00f3n, como hardware, software, tiempo y esfuerzo. Costos: Gastos asociados al desarrollo y despliegue de una aplicaci\u00f3n. Concurrencia: Capacidad de ejecutar varias tareas simult\u00e1neamente. Goroutine: Unidad de ejecuci\u00f3n en Go. Canal: Mecanismo de comunicaci\u00f3n entre goroutines. Recolector de basura (garbage collector): Componente en Go encargado de liberar la memoria utilizada por variables y objetos que ya no est\u00e1n en uso. Librer\u00edas: Conjunto de funciones y estructuras de datos que pueden ser utilizadas en una aplicaci\u00f3n. Pruebas y monitoreo: Procesos para detectar y corregir posibles problemas en una aplicaci\u00f3n. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la optimizaci\u00f3n de recursos y costos en el contexto de desarrollo de aplicaciones en Go? \u00bfCu\u00e1l es una de las t\u00e9cnicas m\u00e1s utilizadas en Go para aprovechar al m\u00e1ximo los recursos de hardware? \u00bfQu\u00e9 son los canales en Go y para qu\u00e9 se utilizan? \u00bfPor qu\u00e9 es importante tener en cuenta el uso de memoria en la implementaci\u00f3n de una aplicaci\u00f3n en Go? \u00bfQu\u00e9 se debe considerar al elegir librer\u00edas y paquetes para el desarrollo de una aplicaci\u00f3n en Go? \u00bfPor qu\u00e9 es importante implementar pruebas y monitoreo en una aplicaci\u00f3n en producci\u00f3n? Ejemplos de c\u00f3digo en Go \u00b6 Uso de concurrencia \u00b6 package main import ( \"fmt\" \"time\" ) func main () { // Lanzar una goroutine para imprimir un mensaje go printMessage ( \"Hola\" ) // Imprimir un mensaje desde la goroutine principal fmt . Println ( \"Mundo\" ) // Esperar un segundo para que la goroutine termine de ejecutarse time . Sleep ( 1 * time . Second ) } func printMessage ( message string ) { // Imprimir el mensaje fmt . Println ( message ) } Uso de canales \u00b6 package main import \"fmt\" func main () { // Crear un canal de tipo string message := make ( chan string ) // Lanzar una goroutine para enviar un mensaje al canal go sendMessage ( message , \"Hola\" ) // Imprimir el mensaje recibido del canal fmt . Println ( <- message ) } func sendMessage ( ch chan string , message string ) { // Enviar el mensaje al canal ch <- message } Ejercicios pr\u00e1cticos \u00b6 Implementa una funci\u00f3n que reciba un slice de n\u00fameros enteros y retorne la suma de todos ellos utilizando concurrencia. Crea un programa que utilice canales para comunicar dos goroutines que impriman un mensaje cada una, asegurando que la impresi\u00f3n del segundo mensaje se realice despu\u00e9s de la impresi\u00f3n del primero. Realiza pruebas de rendimiento en tu aplicaci\u00f3n en Go y utiliza los resultados para identificar posibles mejoras en t\u00e9rminos de uso de recursos. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza la concurrencia y los canales de manera adecuada para aprovechar al m\u00e1ximo los recursos de hardware. Ten en cuenta el uso de memoria en la implementaci\u00f3n de algoritmos y estructuras de datos. Elige librer\u00edas y paquetes eficientes para lograr una mejor optimizaci\u00f3n de recursos y costos. Realiza pruebas y monitoreo en tu aplicaci\u00f3n para identificar posibles problemas y mejorar su eficiencia. Mantente actualizado en las mejores pr\u00e1cticas de optimizaci\u00f3n en Go para seguir mejorando tus habilidades en el desarrollo de aplicaciones eficientes.","title":"Optimizaci\u00f3n de recursos y costos en Go"},{"location":"go/sr/optimizaci%C3%B3n_de_recursos_y_costos/#optimizacion-de-recursos-y-costos-en-go","text":"En el desarrollo de aplicaciones en Go, es importante tener en cuenta la optimizaci\u00f3n de recursos y costos para mejorar la eficiencia y reducir los gastos asociados. En esta lecci\u00f3n, aprenderemos algunas estrategias para lograrlo.","title":"Optimizaci\u00f3n de recursos y costos en Go"},{"location":"go/sr/optimizaci%C3%B3n_de_recursos_y_costos/#explicacion-teorica","text":"La optimizaci\u00f3n de recursos y costos se trata de utilizar los recursos disponibles de la manera m\u00e1s eficiente posible para reducir los gastos relacionados con el desarrollo y despliegue de una aplicaci\u00f3n. Esto incluye tanto los recursos de hardware (como la memoria y la capacidad de procesamiento) como los recursos de software (como el uso de librer\u00edas y herramientas). En el caso de aplicaciones en Go, se pueden implementar diversas t\u00e9cnicas para lograr una optimizaci\u00f3n eficiente. Algunas de ellas son: Uso de concurrencia: Go es un lenguaje que ofrece soporte nativo para la concurrencia, lo que permite aprovechar al m\u00e1ximo los recursos de hardware al ejecutar varias tareas de manera simult\u00e1nea. Uso de canales: Los canales en Go son una forma de comunicaci\u00f3n entre goroutines (las unidades de ejecuci\u00f3n en Go). Estos pueden ser utilizados para coordinar y sincronizar el uso de recursos compartidos, evitando problemas de concurrencia. Minimizaci\u00f3n del uso de memoria: Go cuenta con un recolector de basura (garbage collector) que se encarga de liberar la memoria utilizada por variables y objetos que ya no est\u00e1n en uso. Sin embargo, es importante tener en cuenta el uso de recursos en la implementaci\u00f3n de algoritmos y estructuras de datos. Uso de librer\u00edas eficientes: Al elegir librer\u00edas y paquetes para el desarrollo de una aplicaci\u00f3n en Go, es importante considerar su eficiencia en t\u00e9rminos de uso de memoria y procesamiento. Esto puede impactar en el rendimiento y en los costos asociados al consumo de recursos. Implementaci\u00f3n de pruebas y monitoreo: La optimizaci\u00f3n de recursos y costos no se limita al desarrollo, tambi\u00e9n es importante realizar pruebas y monitorear la aplicaci\u00f3n en producci\u00f3n para detectar posibles problemas y realizar ajustes para mejorar la eficiencia.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"go/sr/optimizaci%C3%B3n_de_recursos_y_costos/#palabras-clave-y-su-definicion","text":"Optimizaci\u00f3n: Proceso de mejorar la eficiencia y reducir los gastos asociados a una actividad. Recursos: Elementos utilizados en el desarrollo y despliegue de una aplicaci\u00f3n, como hardware, software, tiempo y esfuerzo. Costos: Gastos asociados al desarrollo y despliegue de una aplicaci\u00f3n. Concurrencia: Capacidad de ejecutar varias tareas simult\u00e1neamente. Goroutine: Unidad de ejecuci\u00f3n en Go. Canal: Mecanismo de comunicaci\u00f3n entre goroutines. Recolector de basura (garbage collector): Componente en Go encargado de liberar la memoria utilizada por variables y objetos que ya no est\u00e1n en uso. Librer\u00edas: Conjunto de funciones y estructuras de datos que pueden ser utilizadas en una aplicaci\u00f3n. Pruebas y monitoreo: Procesos para detectar y corregir posibles problemas en una aplicaci\u00f3n.","title":"Palabras clave y su definici\u00f3n"},{"location":"go/sr/optimizaci%C3%B3n_de_recursos_y_costos/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la optimizaci\u00f3n de recursos y costos en el contexto de desarrollo de aplicaciones en Go? \u00bfCu\u00e1l es una de las t\u00e9cnicas m\u00e1s utilizadas en Go para aprovechar al m\u00e1ximo los recursos de hardware? \u00bfQu\u00e9 son los canales en Go y para qu\u00e9 se utilizan? \u00bfPor qu\u00e9 es importante tener en cuenta el uso de memoria en la implementaci\u00f3n de una aplicaci\u00f3n en Go? \u00bfQu\u00e9 se debe considerar al elegir librer\u00edas y paquetes para el desarrollo de una aplicaci\u00f3n en Go? \u00bfPor qu\u00e9 es importante implementar pruebas y monitoreo en una aplicaci\u00f3n en producci\u00f3n?","title":"Preguntas de repaso"},{"location":"go/sr/optimizaci%C3%B3n_de_recursos_y_costos/#ejemplos-de-codigo-en-go","text":"","title":"Ejemplos de c\u00f3digo en Go"},{"location":"go/sr/optimizaci%C3%B3n_de_recursos_y_costos/#uso-de-concurrencia","text":"package main import ( \"fmt\" \"time\" ) func main () { // Lanzar una goroutine para imprimir un mensaje go printMessage ( \"Hola\" ) // Imprimir un mensaje desde la goroutine principal fmt . Println ( \"Mundo\" ) // Esperar un segundo para que la goroutine termine de ejecutarse time . Sleep ( 1 * time . Second ) } func printMessage ( message string ) { // Imprimir el mensaje fmt . Println ( message ) }","title":"Uso de concurrencia"},{"location":"go/sr/optimizaci%C3%B3n_de_recursos_y_costos/#uso-de-canales","text":"package main import \"fmt\" func main () { // Crear un canal de tipo string message := make ( chan string ) // Lanzar una goroutine para enviar un mensaje al canal go sendMessage ( message , \"Hola\" ) // Imprimir el mensaje recibido del canal fmt . Println ( <- message ) } func sendMessage ( ch chan string , message string ) { // Enviar el mensaje al canal ch <- message }","title":"Uso de canales"},{"location":"go/sr/optimizaci%C3%B3n_de_recursos_y_costos/#ejercicios-practicos","text":"Implementa una funci\u00f3n que reciba un slice de n\u00fameros enteros y retorne la suma de todos ellos utilizando concurrencia. Crea un programa que utilice canales para comunicar dos goroutines que impriman un mensaje cada una, asegurando que la impresi\u00f3n del segundo mensaje se realice despu\u00e9s de la impresi\u00f3n del primero. Realiza pruebas de rendimiento en tu aplicaci\u00f3n en Go y utiliza los resultados para identificar posibles mejoras en t\u00e9rminos de uso de recursos.","title":"Ejercicios pr\u00e1cticos"},{"location":"go/sr/optimizaci%C3%B3n_de_recursos_y_costos/#consejos-o-mejores-practicas","text":"Utiliza la concurrencia y los canales de manera adecuada para aprovechar al m\u00e1ximo los recursos de hardware. Ten en cuenta el uso de memoria en la implementaci\u00f3n de algoritmos y estructuras de datos. Elige librer\u00edas y paquetes eficientes para lograr una mejor optimizaci\u00f3n de recursos y costos. Realiza pruebas y monitoreo en tu aplicaci\u00f3n para identificar posibles problemas y mejorar su eficiencia. Mantente actualizado en las mejores pr\u00e1cticas de optimizaci\u00f3n en Go para seguir mejorando tus habilidades en el desarrollo de aplicaciones eficientes.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"go/sr/resoluci%C3%B3n_de_problemas_avanzados/","text":"Resoluci\u00f3n de problemas avanzados \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En este m\u00f3dulo, aprender\u00e1s t\u00e9cnicas avanzadas para resolver problemas complejos en aplicaciones en Go. Aprender\u00e1s c\u00f3mo abordar problemas de manera eficiente y efectiva, utilizando herramientas y conceptos espec\u00edficos de Go. Explicaci\u00f3n te\u00f3rica \u00b6 Cuando se trata de resolver problemas en aplicaciones en Go, es importante tener una comprensi\u00f3n s\u00f3lida de los conceptos b\u00e1sicos del lenguaje, como variables, tipos de datos, estructuras de control y funciones. Sin embargo, a medida que los problemas se vuelven m\u00e1s complejos, tambi\u00e9n necesitar\u00e1s utilizar t\u00e9cnicas y herramientas m\u00e1s avanzadas. Una de las t\u00e9cnicas m\u00e1s importantes en la resoluci\u00f3n de problemas avanzados es la descomposici\u00f3n del problema. Esto implica dividir un problema grande y complejo en problemas m\u00e1s peque\u00f1os y manejables. Esto te permitir\u00e1 abordar cada problema de manera individual y luego combinar las soluciones para resolver el problema general. Otra t\u00e9cnica \u00fatil es la abstracci\u00f3n, que implica separar los detalles irrelevantes del problema y enfocarse en los conceptos clave. Esto te ayudar\u00e1 a reducir la complejidad del problema y a encontrar una soluci\u00f3n m\u00e1s clara y concisa. Adem\u00e1s, es importante tener una comprensi\u00f3n profunda de los tipos de datos en Go y c\u00f3mo se pueden manipular y transformar. Esto te permitir\u00e1 utilizar las estructuras de datos adecuadas para cada problema y optimizar el rendimiento de tu aplicaci\u00f3n. Por \u00faltimo, es importante ser paciente y persistente al resolver problemas avanzados. A menudo, estos problemas requieren un enfoque iterativo y pueden llevar tiempo para encontrar la soluci\u00f3n \u00f3ptima. Palabras clave y su definici\u00f3n \u00b6 Descomposici\u00f3n del problema: t\u00e9cnica que implica dividir un problema grande en problemas m\u00e1s peque\u00f1os y manejables. Abstracci\u00f3n: t\u00e9cnica que implica separar los detalles irrelevantes de un problema y enfocarse en los conceptos clave. Tipos de datos: categor\u00edas de valores que pueden ser utilizados en un programa. Estructuras de datos: formas de organizar y almacenar datos en una aplicaci\u00f3n. Iterativo: proceso que se repite varias veces hasta que se alcanza una soluci\u00f3n. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la descomposici\u00f3n del problema y c\u00f3mo puede ayudarte a resolver problemas complejos en aplicaciones en Go? \u00bfQu\u00e9 es la abstracci\u00f3n y por qu\u00e9 es importante en la resoluci\u00f3n de problemas avanzados? \u00bfPor qu\u00e9 es importante tener una comprensi\u00f3n profunda de los tipos de datos en Go al resolver problemas avanzados? \u00bfQu\u00e9 es una estructura de datos y c\u00f3mo puede optimizar el rendimiento de una aplicaci\u00f3n? \u00bfPor qu\u00e9 es importante ser paciente y persistente al resolver problemas avanzados en aplicaciones en Go? Ejemplos de c\u00f3digo en Go lang \u00b6 // Ejemplo de descomposici\u00f3n del problema package main import \"fmt\" func main () { // Problema : obtener la suma de los n\u00fameros pares entre 1 y 10 // Descomposici\u00f3n : dividir el problema en 2 partes : obtener los n\u00fameros pares y luego sumarlos numerosPares := obtenerNumerosPares ( 1 , 10 ) suma := sumarNumeros ( numerosPares ) fmt . Println ( suma ) // Output : 30 } func obtenerNumerosPares ( inicio , fin int ) [] int { var pares [] int for i := inicio ; i <= fin ; i ++ { if i % 2 == 0 { pares = append ( pares , i ) } } return pares } func sumarNumeros ( numeros [] int ) int { suma := 0 for _ , numero := range numeros { suma += numero } return suma } // Ejemplo de abstracci\u00f3n package main import \"fmt\" func main () { // Problema : dado un slice de n\u00fameros , obtener la suma de los n\u00fameros mayores a 10 numeros := [] int { 5 , 3 , 12 , 8 , 20 } suma := obtenerSuma ( numeros ) fmt . Println ( suma ) // Output : 32 } func obtenerSuma ( numeros [] int ) int { suma := 0 for _ , numero := range numeros { if numero > 10 { suma += numero } } return suma } Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Escribe una funci\u00f3n en Go que tome como par\u00e1metro un slice de strings y devuelva un nuevo slice con los strings en orden inverso. Crea una estructura de datos en Go que pueda almacenar los datos de un estudiante, incluyendo nombre, edad, y lista de materias y sus respectivas notas. Escribe una funci\u00f3n en Go que tome como par\u00e1metros un n\u00famero entero y una funci\u00f3n, y llame a la funci\u00f3n el n\u00famero de veces especificado por el par\u00e1metro. Utiliza la t\u00e9cnica de abstracci\u00f3n para escribir una funci\u00f3n en Go que tome como par\u00e1metro un slice de n\u00fameros y devuelva la media de los n\u00fameros mayores a 50. Utiliza la t\u00e9cnica de descomposici\u00f3n del problema para escribir una funci\u00f3n en Go que tome como par\u00e1metro un n\u00famero y devuelva el resultado de la secuencia de Fibonacci hasta ese n\u00famero. Consejos o mejores pr\u00e1cticas \u00b6 Practica la descomposici\u00f3n del problema y la abstracci\u00f3n para resolver problemas complejos de manera m\u00e1s eficiente. Familiar\u00edzate con los tipos de datos y estructuras de datos en Go para poder seleccionar la mejor opci\u00f3n para cada problema. Utiliza comentarios y nombres de variables descriptivos en tu c\u00f3digo para facilitar la comprensi\u00f3n y el mantenimiento. No tengas miedo de buscar ayuda en la documentaci\u00f3n o en foros en l\u00ednea si te encuentras con problemas complejos. A menudo, otros desarrolladores pueden ofrecer una perspectiva fresca y ayudarte a encontrar soluciones creativas. Practica la resoluci\u00f3n de problemas avanzados de manera regular para mejorar tus habilidades y confianza en Go.","title":"Resoluci\u00f3n de problemas avanzados"},{"location":"go/sr/resoluci%C3%B3n_de_problemas_avanzados/#resolucion-de-problemas-avanzados","text":"","title":"Resoluci\u00f3n de problemas avanzados"},{"location":"go/sr/resoluci%C3%B3n_de_problemas_avanzados/#descripcion-del-modulo","text":"En este m\u00f3dulo, aprender\u00e1s t\u00e9cnicas avanzadas para resolver problemas complejos en aplicaciones en Go. Aprender\u00e1s c\u00f3mo abordar problemas de manera eficiente y efectiva, utilizando herramientas y conceptos espec\u00edficos de Go.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"go/sr/resoluci%C3%B3n_de_problemas_avanzados/#explicacion-teorica","text":"Cuando se trata de resolver problemas en aplicaciones en Go, es importante tener una comprensi\u00f3n s\u00f3lida de los conceptos b\u00e1sicos del lenguaje, como variables, tipos de datos, estructuras de control y funciones. Sin embargo, a medida que los problemas se vuelven m\u00e1s complejos, tambi\u00e9n necesitar\u00e1s utilizar t\u00e9cnicas y herramientas m\u00e1s avanzadas. Una de las t\u00e9cnicas m\u00e1s importantes en la resoluci\u00f3n de problemas avanzados es la descomposici\u00f3n del problema. Esto implica dividir un problema grande y complejo en problemas m\u00e1s peque\u00f1os y manejables. Esto te permitir\u00e1 abordar cada problema de manera individual y luego combinar las soluciones para resolver el problema general. Otra t\u00e9cnica \u00fatil es la abstracci\u00f3n, que implica separar los detalles irrelevantes del problema y enfocarse en los conceptos clave. Esto te ayudar\u00e1 a reducir la complejidad del problema y a encontrar una soluci\u00f3n m\u00e1s clara y concisa. Adem\u00e1s, es importante tener una comprensi\u00f3n profunda de los tipos de datos en Go y c\u00f3mo se pueden manipular y transformar. Esto te permitir\u00e1 utilizar las estructuras de datos adecuadas para cada problema y optimizar el rendimiento de tu aplicaci\u00f3n. Por \u00faltimo, es importante ser paciente y persistente al resolver problemas avanzados. A menudo, estos problemas requieren un enfoque iterativo y pueden llevar tiempo para encontrar la soluci\u00f3n \u00f3ptima.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"go/sr/resoluci%C3%B3n_de_problemas_avanzados/#palabras-clave-y-su-definicion","text":"Descomposici\u00f3n del problema: t\u00e9cnica que implica dividir un problema grande en problemas m\u00e1s peque\u00f1os y manejables. Abstracci\u00f3n: t\u00e9cnica que implica separar los detalles irrelevantes de un problema y enfocarse en los conceptos clave. Tipos de datos: categor\u00edas de valores que pueden ser utilizados en un programa. Estructuras de datos: formas de organizar y almacenar datos en una aplicaci\u00f3n. Iterativo: proceso que se repite varias veces hasta que se alcanza una soluci\u00f3n.","title":"Palabras clave y su definici\u00f3n"},{"location":"go/sr/resoluci%C3%B3n_de_problemas_avanzados/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la descomposici\u00f3n del problema y c\u00f3mo puede ayudarte a resolver problemas complejos en aplicaciones en Go? \u00bfQu\u00e9 es la abstracci\u00f3n y por qu\u00e9 es importante en la resoluci\u00f3n de problemas avanzados? \u00bfPor qu\u00e9 es importante tener una comprensi\u00f3n profunda de los tipos de datos en Go al resolver problemas avanzados? \u00bfQu\u00e9 es una estructura de datos y c\u00f3mo puede optimizar el rendimiento de una aplicaci\u00f3n? \u00bfPor qu\u00e9 es importante ser paciente y persistente al resolver problemas avanzados en aplicaciones en Go?","title":"Preguntas de repaso"},{"location":"go/sr/resoluci%C3%B3n_de_problemas_avanzados/#ejemplos-de-codigo-en-go-lang","text":"// Ejemplo de descomposici\u00f3n del problema package main import \"fmt\" func main () { // Problema : obtener la suma de los n\u00fameros pares entre 1 y 10 // Descomposici\u00f3n : dividir el problema en 2 partes : obtener los n\u00fameros pares y luego sumarlos numerosPares := obtenerNumerosPares ( 1 , 10 ) suma := sumarNumeros ( numerosPares ) fmt . Println ( suma ) // Output : 30 } func obtenerNumerosPares ( inicio , fin int ) [] int { var pares [] int for i := inicio ; i <= fin ; i ++ { if i % 2 == 0 { pares = append ( pares , i ) } } return pares } func sumarNumeros ( numeros [] int ) int { suma := 0 for _ , numero := range numeros { suma += numero } return suma } // Ejemplo de abstracci\u00f3n package main import \"fmt\" func main () { // Problema : dado un slice de n\u00fameros , obtener la suma de los n\u00fameros mayores a 10 numeros := [] int { 5 , 3 , 12 , 8 , 20 } suma := obtenerSuma ( numeros ) fmt . Println ( suma ) // Output : 32 } func obtenerSuma ( numeros [] int ) int { suma := 0 for _ , numero := range numeros { if numero > 10 { suma += numero } } return suma }","title":"Ejemplos de c\u00f3digo en Go lang"},{"location":"go/sr/resoluci%C3%B3n_de_problemas_avanzados/#ejercicios-practicos-con-instrucciones-claras","text":"Escribe una funci\u00f3n en Go que tome como par\u00e1metro un slice de strings y devuelva un nuevo slice con los strings en orden inverso. Crea una estructura de datos en Go que pueda almacenar los datos de un estudiante, incluyendo nombre, edad, y lista de materias y sus respectivas notas. Escribe una funci\u00f3n en Go que tome como par\u00e1metros un n\u00famero entero y una funci\u00f3n, y llame a la funci\u00f3n el n\u00famero de veces especificado por el par\u00e1metro. Utiliza la t\u00e9cnica de abstracci\u00f3n para escribir una funci\u00f3n en Go que tome como par\u00e1metro un slice de n\u00fameros y devuelva la media de los n\u00fameros mayores a 50. Utiliza la t\u00e9cnica de descomposici\u00f3n del problema para escribir una funci\u00f3n en Go que tome como par\u00e1metro un n\u00famero y devuelva el resultado de la secuencia de Fibonacci hasta ese n\u00famero.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"go/sr/resoluci%C3%B3n_de_problemas_avanzados/#consejos-o-mejores-practicas","text":"Practica la descomposici\u00f3n del problema y la abstracci\u00f3n para resolver problemas complejos de manera m\u00e1s eficiente. Familiar\u00edzate con los tipos de datos y estructuras de datos en Go para poder seleccionar la mejor opci\u00f3n para cada problema. Utiliza comentarios y nombres de variables descriptivos en tu c\u00f3digo para facilitar la comprensi\u00f3n y el mantenimiento. No tengas miedo de buscar ayuda en la documentaci\u00f3n o en foros en l\u00ednea si te encuentras con problemas complejos. A menudo, otros desarrolladores pueden ofrecer una perspectiva fresca y ayudarte a encontrar soluciones creativas. Practica la resoluci\u00f3n de problemas avanzados de manera regular para mejorar tus habilidades y confianza en Go.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"haskel/jr/funciones_y_expresiones/","text":"Funciones y Expresiones \u00b6 Introducci\u00f3n \u00b6 En Haskell, las funciones y expresiones son elementos fundamentales en la programaci\u00f3n funcional. Una funci\u00f3n es un bloque de c\u00f3digo que toma uno o m\u00e1s valores de entrada, realiza una operaci\u00f3n y devuelve un resultado. Una expresi\u00f3n, por otro lado, es una combinaci\u00f3n de valores, operadores y funciones que se eval\u00faa para obtener un resultado. En este m\u00f3dulo, aprender\u00e1s c\u00f3mo utilizar funciones y expresiones en Haskell para resolver problemas de manera eficiente. Palabras clave y Definiciones \u00b6 Funci\u00f3n : Una funci\u00f3n es un bloque de c\u00f3digo que toma uno o m\u00e1s valores de entrada, realiza una operaci\u00f3n y devuelve un resultado. Expresi\u00f3n : Una expresi\u00f3n es una combinaci\u00f3n de valores, operadores y funciones que se eval\u00faa para obtener un resultado. Par\u00e1metro : Un par\u00e1metro es un valor que se pasa a una funci\u00f3n para que pueda ser utilizado en su operaci\u00f3n. Argumento : Un argumento es un valor espec\u00edfico que se pasa a una funci\u00f3n cuando se llama, para ser utilizado como un par\u00e1metro. Tipo de datos : Un tipo de datos es una categor\u00eda para clasificar los valores en Haskell, como enteros, cadenas o booleanos. Funciones de orden superior : Son funciones que toman otras funciones como argumentos o devuelven una funci\u00f3n como resultado. Composici\u00f3n de funciones : Es la combinaci\u00f3n de dos o m\u00e1s funciones para formar una nueva funci\u00f3n. Preguntas de Repaso \u00b6 \u00bfQu\u00e9 es una funci\u00f3n en Haskell? \u00bfQu\u00e9 es una expresi\u00f3n? \u00bfCu\u00e1l es la diferencia entre un par\u00e1metro y un argumento? \u00bfQu\u00e9 son las funciones de orden superior? \u00bfQu\u00e9 es la composici\u00f3n de funciones? Ejemplos de C\u00f3digo en Haskell \u00b6 Definici\u00f3n de una funci\u00f3n \u00b6 -- Funci\u00f3n que suma dos n\u00fameros suma :: Int -> Int -> Int suma x y = x + y Llamada a una funci\u00f3n \u00b6 -- Llamada a la funci\u00f3n suma con 2 y 3 como argumentos suma 2 3 -- Resultado: 5 Definici\u00f3n de una expresi\u00f3n \u00b6 -- Expresi\u00f3n que calcula el \u00e1rea de un c\u00edrculo area :: Float -> Float area r = pi * r ^ 2 Llamada a una expresi\u00f3n \u00b6 -- Llamada a la expresi\u00f3n area con 5 como argumento area 5 -- Resultado: 78.53982 Funciones de Orden Superior \u00b6 -- Funci\u00f3n que aplica una funci\u00f3n a cada elemento de una lista map :: ( a -> b ) -> [ a ] -> [ b ] map f [] = [] map f ( x : xs ) = f x : map f xs Ejercicios Pr\u00e1cticos \u00b6 Define una funci\u00f3n que calcule el \u00e1rea de un tri\u00e1ngulo. Crea una expresi\u00f3n que convierta una temperatura en grados Celsius a grados Fahrenheit. Utiliza la funci\u00f3n map para incrementar en 1 cada elemento de una lista de n\u00fameros. Crea una funci\u00f3n que calcule el factorial de un n\u00famero. Utiliza la composici\u00f3n de funciones para crear una funci\u00f3n que calcule el doble del cuadrado de un n\u00famero. Consejos y Mejores Pr\u00e1cticas \u00b6 Utiliza nombres descriptivos para tus funciones y expresiones. Evita crear funciones y expresiones demasiado largas o complejas, es mejor dividirlas en funciones m\u00e1s peque\u00f1as y reutilizables. Aprovecha las funciones de orden superior para escribir c\u00f3digo m\u00e1s conciso y elegante. Utiliza la composici\u00f3n de funciones en lugar de anidar m\u00faltiples funciones en una sola expresi\u00f3n. Prueba tus funciones y expresiones con distintos valores de entrada para asegurarte de que funcionan correctamente.","title":"Funciones y Expresiones"},{"location":"haskel/jr/funciones_y_expresiones/#funciones-y-expresiones","text":"","title":"Funciones y Expresiones"},{"location":"haskel/jr/funciones_y_expresiones/#introduccion","text":"En Haskell, las funciones y expresiones son elementos fundamentales en la programaci\u00f3n funcional. Una funci\u00f3n es un bloque de c\u00f3digo que toma uno o m\u00e1s valores de entrada, realiza una operaci\u00f3n y devuelve un resultado. Una expresi\u00f3n, por otro lado, es una combinaci\u00f3n de valores, operadores y funciones que se eval\u00faa para obtener un resultado. En este m\u00f3dulo, aprender\u00e1s c\u00f3mo utilizar funciones y expresiones en Haskell para resolver problemas de manera eficiente.","title":"Introducci\u00f3n"},{"location":"haskel/jr/funciones_y_expresiones/#palabras-clave-y-definiciones","text":"Funci\u00f3n : Una funci\u00f3n es un bloque de c\u00f3digo que toma uno o m\u00e1s valores de entrada, realiza una operaci\u00f3n y devuelve un resultado. Expresi\u00f3n : Una expresi\u00f3n es una combinaci\u00f3n de valores, operadores y funciones que se eval\u00faa para obtener un resultado. Par\u00e1metro : Un par\u00e1metro es un valor que se pasa a una funci\u00f3n para que pueda ser utilizado en su operaci\u00f3n. Argumento : Un argumento es un valor espec\u00edfico que se pasa a una funci\u00f3n cuando se llama, para ser utilizado como un par\u00e1metro. Tipo de datos : Un tipo de datos es una categor\u00eda para clasificar los valores en Haskell, como enteros, cadenas o booleanos. Funciones de orden superior : Son funciones que toman otras funciones como argumentos o devuelven una funci\u00f3n como resultado. Composici\u00f3n de funciones : Es la combinaci\u00f3n de dos o m\u00e1s funciones para formar una nueva funci\u00f3n.","title":"Palabras clave y Definiciones"},{"location":"haskel/jr/funciones_y_expresiones/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es una funci\u00f3n en Haskell? \u00bfQu\u00e9 es una expresi\u00f3n? \u00bfCu\u00e1l es la diferencia entre un par\u00e1metro y un argumento? \u00bfQu\u00e9 son las funciones de orden superior? \u00bfQu\u00e9 es la composici\u00f3n de funciones?","title":"Preguntas de Repaso"},{"location":"haskel/jr/funciones_y_expresiones/#ejemplos-de-codigo-en-haskell","text":"","title":"Ejemplos de C\u00f3digo en Haskell"},{"location":"haskel/jr/funciones_y_expresiones/#definicion-de-una-funcion","text":"-- Funci\u00f3n que suma dos n\u00fameros suma :: Int -> Int -> Int suma x y = x + y","title":"Definici\u00f3n de una funci\u00f3n"},{"location":"haskel/jr/funciones_y_expresiones/#llamada-a-una-funcion","text":"-- Llamada a la funci\u00f3n suma con 2 y 3 como argumentos suma 2 3 -- Resultado: 5","title":"Llamada a una funci\u00f3n"},{"location":"haskel/jr/funciones_y_expresiones/#definicion-de-una-expresion","text":"-- Expresi\u00f3n que calcula el \u00e1rea de un c\u00edrculo area :: Float -> Float area r = pi * r ^ 2","title":"Definici\u00f3n de una expresi\u00f3n"},{"location":"haskel/jr/funciones_y_expresiones/#llamada-a-una-expresion","text":"-- Llamada a la expresi\u00f3n area con 5 como argumento area 5 -- Resultado: 78.53982","title":"Llamada a una expresi\u00f3n"},{"location":"haskel/jr/funciones_y_expresiones/#funciones-de-orden-superior","text":"-- Funci\u00f3n que aplica una funci\u00f3n a cada elemento de una lista map :: ( a -> b ) -> [ a ] -> [ b ] map f [] = [] map f ( x : xs ) = f x : map f xs","title":"Funciones de Orden Superior"},{"location":"haskel/jr/funciones_y_expresiones/#ejercicios-practicos","text":"Define una funci\u00f3n que calcule el \u00e1rea de un tri\u00e1ngulo. Crea una expresi\u00f3n que convierta una temperatura en grados Celsius a grados Fahrenheit. Utiliza la funci\u00f3n map para incrementar en 1 cada elemento de una lista de n\u00fameros. Crea una funci\u00f3n que calcule el factorial de un n\u00famero. Utiliza la composici\u00f3n de funciones para crear una funci\u00f3n que calcule el doble del cuadrado de un n\u00famero.","title":"Ejercicios Pr\u00e1cticos"},{"location":"haskel/jr/funciones_y_expresiones/#consejos-y-mejores-practicas","text":"Utiliza nombres descriptivos para tus funciones y expresiones. Evita crear funciones y expresiones demasiado largas o complejas, es mejor dividirlas en funciones m\u00e1s peque\u00f1as y reutilizables. Aprovecha las funciones de orden superior para escribir c\u00f3digo m\u00e1s conciso y elegante. Utiliza la composici\u00f3n de funciones en lugar de anidar m\u00faltiples funciones en una sola expresi\u00f3n. Prueba tus funciones y expresiones con distintos valores de entrada para asegurarte de que funcionan correctamente.","title":"Consejos y Mejores Pr\u00e1cticas"},{"location":"haskel/jr/introducci%C3%B3n_a_haskell/","text":"Introducci\u00f3n a Haskell \u00b6 Haskell es un lenguaje de programaci\u00f3n funcional, creado en 1990 por un grupo de investigadores liderado por el matem\u00e1tico Haskell Curry. Se basa en el c\u00e1lculo lambda, lo que lo convierte en un lenguaje elegante y poderoso para resolver problemas matem\u00e1ticos y l\u00f3gicos. Teor\u00eda \u00b6 Haskell se caracteriza por su sistema de tipado est\u00e1tico, lo que significa que todos los tipos de datos son verificados en tiempo de compilaci\u00f3n, lo que ayuda a evitar errores comunes en tiempo de ejecuci\u00f3n. Adem\u00e1s, su paradigma funcional se basa en la evaluaci\u00f3n de expresiones y la aplicaci\u00f3n de funciones, en lugar de la ejecuci\u00f3n de instrucciones secuenciales. En Haskell, todo es una expresi\u00f3n, incluso las funciones. Esto significa que las funciones pueden ser tratadas como cualquier otro valor, pudiendo ser pasadas como argumentos a otras funciones o ser devueltas como resultado de una funci\u00f3n. Otra caracter\u00edstica importante de Haskell es que es un lenguaje puro, lo que significa que no permite efectos secundarios. Esto significa que una funci\u00f3n siempre devolver\u00e1 el mismo resultado para los mismos argumentos, lo que facilita la comprensi\u00f3n y el razonamiento sobre el c\u00f3digo. Palabras clave y definiciones \u00b6 Tipado est\u00e1tico: sistema de verificaci\u00f3n de tipos en tiempo de compilaci\u00f3n. C\u00e1lculo lambda: modelo matem\u00e1tico utilizado en la programaci\u00f3n funcional. Expresi\u00f3n: cualquier valor o combinaci\u00f3n de valores que puede ser evaluado. Funci\u00f3n: bloque de c\u00f3digo que acepta uno o m\u00e1s argumentos y devuelve un resultado. Lenguaje puro: aquel que no permite efectos secundarios. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es el sistema de tipado est\u00e1tico en Haskell? \u00bfQu\u00e9 es una expresi\u00f3n en Haskell? \u00bfQu\u00e9 significa que Haskell sea un lenguaje puro? Ejemplos de c\u00f3digo en Haskell \u00b6 Funci\u00f3n que devuelve el cuadrado de un n\u00famero \u00b6 square :: Int -> Int square x = x * x Funci\u00f3n que devuelve el factorial de un n\u00famero \u00b6 factorial :: Int -> Int factorial 0 = 1 factorial n = n * factorial ( n - 1 ) Ejercicios pr\u00e1cticos \u00b6 Crea una funci\u00f3n en Haskell que calcule el \u00e1rea de un c\u00edrculo, dado su radio como argumento. Crea una funci\u00f3n en Haskell que devuelva la suma de los primeros n n\u00fameros naturales. Crea una funci\u00f3n en Haskell que determine si un n\u00famero es par o impar. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza nombres de funciones y variables descriptivos. Intenta utilizar funciones de orden superior (aquellas que aceptan funciones como argumentos) en lugar de escribir c\u00f3digo repetitivo. Utiliza la recursividad en lugar de bucles para resolver problemas. Prueba tu c\u00f3digo con diferentes valores para asegurarte de que funciona correctamente.","title":"Introducci\u00f3n a Haskell"},{"location":"haskel/jr/introducci%C3%B3n_a_haskell/#introduccion-a-haskell","text":"Haskell es un lenguaje de programaci\u00f3n funcional, creado en 1990 por un grupo de investigadores liderado por el matem\u00e1tico Haskell Curry. Se basa en el c\u00e1lculo lambda, lo que lo convierte en un lenguaje elegante y poderoso para resolver problemas matem\u00e1ticos y l\u00f3gicos.","title":"Introducci\u00f3n a Haskell"},{"location":"haskel/jr/introducci%C3%B3n_a_haskell/#teoria","text":"Haskell se caracteriza por su sistema de tipado est\u00e1tico, lo que significa que todos los tipos de datos son verificados en tiempo de compilaci\u00f3n, lo que ayuda a evitar errores comunes en tiempo de ejecuci\u00f3n. Adem\u00e1s, su paradigma funcional se basa en la evaluaci\u00f3n de expresiones y la aplicaci\u00f3n de funciones, en lugar de la ejecuci\u00f3n de instrucciones secuenciales. En Haskell, todo es una expresi\u00f3n, incluso las funciones. Esto significa que las funciones pueden ser tratadas como cualquier otro valor, pudiendo ser pasadas como argumentos a otras funciones o ser devueltas como resultado de una funci\u00f3n. Otra caracter\u00edstica importante de Haskell es que es un lenguaje puro, lo que significa que no permite efectos secundarios. Esto significa que una funci\u00f3n siempre devolver\u00e1 el mismo resultado para los mismos argumentos, lo que facilita la comprensi\u00f3n y el razonamiento sobre el c\u00f3digo.","title":"Teor\u00eda"},{"location":"haskel/jr/introducci%C3%B3n_a_haskell/#palabras-clave-y-definiciones","text":"Tipado est\u00e1tico: sistema de verificaci\u00f3n de tipos en tiempo de compilaci\u00f3n. C\u00e1lculo lambda: modelo matem\u00e1tico utilizado en la programaci\u00f3n funcional. Expresi\u00f3n: cualquier valor o combinaci\u00f3n de valores que puede ser evaluado. Funci\u00f3n: bloque de c\u00f3digo que acepta uno o m\u00e1s argumentos y devuelve un resultado. Lenguaje puro: aquel que no permite efectos secundarios.","title":"Palabras clave y definiciones"},{"location":"haskel/jr/introducci%C3%B3n_a_haskell/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es el sistema de tipado est\u00e1tico en Haskell? \u00bfQu\u00e9 es una expresi\u00f3n en Haskell? \u00bfQu\u00e9 significa que Haskell sea un lenguaje puro?","title":"Preguntas de repaso"},{"location":"haskel/jr/introducci%C3%B3n_a_haskell/#ejemplos-de-codigo-en-haskell","text":"","title":"Ejemplos de c\u00f3digo en Haskell"},{"location":"haskel/jr/introducci%C3%B3n_a_haskell/#funcion-que-devuelve-el-cuadrado-de-un-numero","text":"square :: Int -> Int square x = x * x","title":"Funci\u00f3n que devuelve el cuadrado de un n\u00famero"},{"location":"haskel/jr/introducci%C3%B3n_a_haskell/#funcion-que-devuelve-el-factorial-de-un-numero","text":"factorial :: Int -> Int factorial 0 = 1 factorial n = n * factorial ( n - 1 )","title":"Funci\u00f3n que devuelve el factorial de un n\u00famero"},{"location":"haskel/jr/introducci%C3%B3n_a_haskell/#ejercicios-practicos","text":"Crea una funci\u00f3n en Haskell que calcule el \u00e1rea de un c\u00edrculo, dado su radio como argumento. Crea una funci\u00f3n en Haskell que devuelva la suma de los primeros n n\u00fameros naturales. Crea una funci\u00f3n en Haskell que determine si un n\u00famero es par o impar.","title":"Ejercicios pr\u00e1cticos"},{"location":"haskel/jr/introducci%C3%B3n_a_haskell/#consejos-o-mejores-practicas","text":"Utiliza nombres de funciones y variables descriptivos. Intenta utilizar funciones de orden superior (aquellas que aceptan funciones como argumentos) en lugar de escribir c\u00f3digo repetitivo. Utiliza la recursividad en lugar de bucles para resolver problemas. Prueba tu c\u00f3digo con diferentes valores para asegurarte de que funciona correctamente.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"haskel/jr/listas_y_tuplas/","text":"Listas y Tuplas \u00b6 Introducci\u00f3n \u00b6 En Haskell, al igual que en otros lenguajes de programaci\u00f3n, existen diversas estructuras de datos que nos permiten almacenar y manipular informaci\u00f3n. Entre las m\u00e1s utilizadas se encuentran las listas y las tuplas. Estas estructuras son fundamentales para el desarrollo de programas en Haskell y su correcto uso es esencial para escribir c\u00f3digo eficiente y legible. Listas \u00b6 Las listas son una estructura de datos muy vers\u00e1til que nos permite almacenar una secuencia ordenada de elementos del mismo tipo. En Haskell, las listas se representan utilizando corchetes y separando cada elemento por comas. Por ejemplo: numeros = [ 1 , 2 , 3 , 4 , 5 ] -- lista de n\u00fameros enteros letras = [ 'a' , 'b' , 'c' , 'd' ] -- lista de caracteres palabras = [ \"Hola\" , \"mundo\" ] -- lista de cadenas de texto Las listas en Haskell son homog\u00e9neas, lo que significa que todos sus elementos deben ser del mismo tipo. Adem\u00e1s, son inmutables, lo que significa que una vez creada una lista, no se pueden modificar sus elementos. Sin embargo, es posible crear una nueva lista a partir de otra modificando sus elementos. Palabras clave \u00b6 Listas: estructura de datos en Haskell que permite almacenar una secuencia ordenada de elementos del mismo tipo. Homog\u00e9neo: caracter\u00edstica de las listas en Haskell que indica que todos sus elementos deben ser del mismo tipo. Inmutable: propiedad de las listas en Haskell que indica que no se pueden modificar sus elementos una vez creada. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es una lista en Haskell? \u00bfC\u00f3mo se representan las listas en Haskell? \u00bfQu\u00e9 significa que una lista sea homog\u00e9nea? \u00bfEs posible modificar los elementos de una lista en Haskell? Ejemplos de c\u00f3digo en Haskell \u00b6 Crear una lista de n\u00fameros enteros y sumar todos sus elementos: numeros = [ 1 , 2 , 3 , 4 , 5 ] suma = sum numeros -- resultado: 15 Obtener el primer elemento de una lista: numeros = [ 1 , 2 , 3 , 4 , 5 ] primerElemento = head numeros -- resultado: 1 Crear una nueva lista a partir de otra modificando sus elementos: numeros = [ 1 , 2 , 3 , 4 , 5 ] nuevosNumeros = map ( * 2 ) numeros -- resultado: [2, 4, 6, 8, 10] Tuplas \u00b6 Las tuplas son otra estructura de datos en Haskell que nos permite almacenar una secuencia de elementos de diferentes tipos. A diferencia de las listas, las tuplas son heterog\u00e9neas, lo que significa que pueden contener elementos de distintos tipos. Adem\u00e1s, a diferencia de las listas, las tuplas son inmutables, lo que significa que una vez creada una tupla, no se pueden modificar sus elementos. Las tuplas se representan utilizando par\u00e9ntesis y separando cada elemento por comas. Por ejemplo: persona = ( \"Juan\" , 25 , True ) -- tupla con nombre, edad y estado civil Palabras clave \u00b6 Tuplas: estructura de datos en Haskell que permite almacenar una secuencia de elementos de diferentes tipos. Heterog\u00e9neo: caracter\u00edstica de las tuplas en Haskell que indica que pueden contener elementos de distintos tipos. Inmutable: propiedad de las tuplas en Haskell que indica que no se pueden modificar sus elementos una vez creada. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es una tupla en Haskell? \u00bfC\u00f3mo se representan las tuplas en Haskell? \u00bfQu\u00e9 significa que una tupla sea heterog\u00e9nea? \u00bfEs posible modificar los elementos de una tupla en Haskell? Ejemplos de c\u00f3digo en Haskell \u00b6 Crear una tupla con informaci\u00f3n de una persona y obtener su edad: persona = ( \"Juan\" , 25 , True ) edad = snd persona -- resultado: 25 Crear una lista de tuplas y obtener el primer elemento de cada una: personas = [( \"Juan\" , 25 , True ), ( \"Mar\u00eda\" , 30 , False ), ( \"Pedro\" , 20 , True )] nombres = map fst personas -- resultado: [\"Juan\", \"Mar\u00eda\", \"Pedro\"] Ejercicios pr\u00e1cticos \u00b6 Escribe una funci\u00f3n en Haskell que reciba una lista de n\u00fameros enteros y devuelva la suma de todos sus elementos. Escribe una funci\u00f3n en Haskell que reciba una lista de cadenas de texto y devuelva una nueva lista con las cadenas invertidas. Escribe una funci\u00f3n en Haskell que reciba una tupla con informaci\u00f3n de una persona (nombre, edad, estado civil) y devuelva un mensaje de saludo personalizado. Consejos y mejores pr\u00e1cticas \u00b6 Utiliza listas cuando necesites almacenar una secuencia ordenada de elementos del mismo tipo. Utiliza tuplas cuando necesites almacenar una secuencia de elementos de diferentes tipos. Aprovecha las funciones de orden superior como map y filter para manipular listas y tuplas de forma m\u00e1s eficiente. Recuerda que tanto las listas como las tuplas son inmutables, por lo que siempre se crear\u00e1 una nueva estructura al aplicar una operaci\u00f3n sobre ellas.","title":"Listas y Tuplas"},{"location":"haskel/jr/listas_y_tuplas/#listas-y-tuplas","text":"","title":"Listas y Tuplas"},{"location":"haskel/jr/listas_y_tuplas/#introduccion","text":"En Haskell, al igual que en otros lenguajes de programaci\u00f3n, existen diversas estructuras de datos que nos permiten almacenar y manipular informaci\u00f3n. Entre las m\u00e1s utilizadas se encuentran las listas y las tuplas. Estas estructuras son fundamentales para el desarrollo de programas en Haskell y su correcto uso es esencial para escribir c\u00f3digo eficiente y legible.","title":"Introducci\u00f3n"},{"location":"haskel/jr/listas_y_tuplas/#listas","text":"Las listas son una estructura de datos muy vers\u00e1til que nos permite almacenar una secuencia ordenada de elementos del mismo tipo. En Haskell, las listas se representan utilizando corchetes y separando cada elemento por comas. Por ejemplo: numeros = [ 1 , 2 , 3 , 4 , 5 ] -- lista de n\u00fameros enteros letras = [ 'a' , 'b' , 'c' , 'd' ] -- lista de caracteres palabras = [ \"Hola\" , \"mundo\" ] -- lista de cadenas de texto Las listas en Haskell son homog\u00e9neas, lo que significa que todos sus elementos deben ser del mismo tipo. Adem\u00e1s, son inmutables, lo que significa que una vez creada una lista, no se pueden modificar sus elementos. Sin embargo, es posible crear una nueva lista a partir de otra modificando sus elementos.","title":"Listas"},{"location":"haskel/jr/listas_y_tuplas/#palabras-clave","text":"Listas: estructura de datos en Haskell que permite almacenar una secuencia ordenada de elementos del mismo tipo. Homog\u00e9neo: caracter\u00edstica de las listas en Haskell que indica que todos sus elementos deben ser del mismo tipo. Inmutable: propiedad de las listas en Haskell que indica que no se pueden modificar sus elementos una vez creada.","title":"Palabras clave"},{"location":"haskel/jr/listas_y_tuplas/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es una lista en Haskell? \u00bfC\u00f3mo se representan las listas en Haskell? \u00bfQu\u00e9 significa que una lista sea homog\u00e9nea? \u00bfEs posible modificar los elementos de una lista en Haskell?","title":"Preguntas de repaso"},{"location":"haskel/jr/listas_y_tuplas/#ejemplos-de-codigo-en-haskell","text":"Crear una lista de n\u00fameros enteros y sumar todos sus elementos: numeros = [ 1 , 2 , 3 , 4 , 5 ] suma = sum numeros -- resultado: 15 Obtener el primer elemento de una lista: numeros = [ 1 , 2 , 3 , 4 , 5 ] primerElemento = head numeros -- resultado: 1 Crear una nueva lista a partir de otra modificando sus elementos: numeros = [ 1 , 2 , 3 , 4 , 5 ] nuevosNumeros = map ( * 2 ) numeros -- resultado: [2, 4, 6, 8, 10]","title":"Ejemplos de c\u00f3digo en Haskell"},{"location":"haskel/jr/listas_y_tuplas/#tuplas","text":"Las tuplas son otra estructura de datos en Haskell que nos permite almacenar una secuencia de elementos de diferentes tipos. A diferencia de las listas, las tuplas son heterog\u00e9neas, lo que significa que pueden contener elementos de distintos tipos. Adem\u00e1s, a diferencia de las listas, las tuplas son inmutables, lo que significa que una vez creada una tupla, no se pueden modificar sus elementos. Las tuplas se representan utilizando par\u00e9ntesis y separando cada elemento por comas. Por ejemplo: persona = ( \"Juan\" , 25 , True ) -- tupla con nombre, edad y estado civil","title":"Tuplas"},{"location":"haskel/jr/listas_y_tuplas/#palabras-clave_1","text":"Tuplas: estructura de datos en Haskell que permite almacenar una secuencia de elementos de diferentes tipos. Heterog\u00e9neo: caracter\u00edstica de las tuplas en Haskell que indica que pueden contener elementos de distintos tipos. Inmutable: propiedad de las tuplas en Haskell que indica que no se pueden modificar sus elementos una vez creada.","title":"Palabras clave"},{"location":"haskel/jr/listas_y_tuplas/#preguntas-de-repaso_1","text":"\u00bfQu\u00e9 es una tupla en Haskell? \u00bfC\u00f3mo se representan las tuplas en Haskell? \u00bfQu\u00e9 significa que una tupla sea heterog\u00e9nea? \u00bfEs posible modificar los elementos de una tupla en Haskell?","title":"Preguntas de repaso"},{"location":"haskel/jr/listas_y_tuplas/#ejemplos-de-codigo-en-haskell_1","text":"Crear una tupla con informaci\u00f3n de una persona y obtener su edad: persona = ( \"Juan\" , 25 , True ) edad = snd persona -- resultado: 25 Crear una lista de tuplas y obtener el primer elemento de cada una: personas = [( \"Juan\" , 25 , True ), ( \"Mar\u00eda\" , 30 , False ), ( \"Pedro\" , 20 , True )] nombres = map fst personas -- resultado: [\"Juan\", \"Mar\u00eda\", \"Pedro\"]","title":"Ejemplos de c\u00f3digo en Haskell"},{"location":"haskel/jr/listas_y_tuplas/#ejercicios-practicos","text":"Escribe una funci\u00f3n en Haskell que reciba una lista de n\u00fameros enteros y devuelva la suma de todos sus elementos. Escribe una funci\u00f3n en Haskell que reciba una lista de cadenas de texto y devuelva una nueva lista con las cadenas invertidas. Escribe una funci\u00f3n en Haskell que reciba una tupla con informaci\u00f3n de una persona (nombre, edad, estado civil) y devuelva un mensaje de saludo personalizado.","title":"Ejercicios pr\u00e1cticos"},{"location":"haskel/jr/listas_y_tuplas/#consejos-y-mejores-practicas","text":"Utiliza listas cuando necesites almacenar una secuencia ordenada de elementos del mismo tipo. Utiliza tuplas cuando necesites almacenar una secuencia de elementos de diferentes tipos. Aprovecha las funciones de orden superior como map y filter para manipular listas y tuplas de forma m\u00e1s eficiente. Recuerda que tanto las listas como las tuplas son inmutables, por lo que siempre se crear\u00e1 una nueva estructura al aplicar una operaci\u00f3n sobre ellas.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"haskel/jr/m%C3%B3dulos_y_funciones_de_orden_superior/","text":"M\u00f3dulos y Funciones de Orden Superior \u00b6 En Haskell, un m\u00f3dulo es una colecci\u00f3n de funciones y tipos de datos relacionados que se pueden utilizar en un programa. Los m\u00f3dulos permiten agrupar funciones y tipos de datos relacionados para facilitar su uso y reutilizaci\u00f3n en diferentes programas. Tambi\u00e9n ayudan a mantener un c\u00f3digo m\u00e1s organizado y modular, lo que facilita la colaboraci\u00f3n en proyectos de programaci\u00f3n. Adem\u00e1s de los m\u00f3dulos, Haskell tambi\u00e9n cuenta con funciones de orden superior, que son funciones que pueden tomar otras funciones como argumentos o devolver funciones como resultado. Esto permite una mayor flexibilidad y expresividad en la programaci\u00f3n funcional. Palabras clave y definiciones \u00b6 M\u00f3dulo: una colecci\u00f3n de funciones y tipos de datos relacionados. Funci\u00f3n de orden superior: una funci\u00f3n que toma otras funciones como argumentos o devuelve funciones como resultado. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es un m\u00f3dulo en Haskell? \u00bfQu\u00e9 ventajas ofrece el uso de m\u00f3dulos en la programaci\u00f3n? \u00bfQu\u00e9 es una funci\u00f3n de orden superior en Haskell? \u00bfPor qu\u00e9 las funciones de orden superior son \u00fatiles en la programaci\u00f3n funcional? Ejemplos de c\u00f3digo en Haskell \u00b6 M\u00f3dulo \"Calculadora\" \u00b6 module Calculadora where -- Funci\u00f3n para sumar dos n\u00fameros sumar :: Int -> Int -> Int sumar x y = x + y -- Funci\u00f3n para restar dos n\u00fameros restar :: Int -> Int -> Int restar x y = x - y -- Funci\u00f3n para multiplicar dos n\u00fameros multiplicar :: Int -> Int -> Int multiplicar x y = x * y -- Funci\u00f3n de orden superior para aplicar una operaci\u00f3n a dos n\u00fameros dados aplicarOperacion :: ( Int -> Int -> Int ) -> Int -> Int -> Int aplicarOperacion f x y = f x y Uso de funciones de orden superior \u00b6 -- Se puede utilizar la funci\u00f3n de orden superior \"aplicarOperacion\" con la funci\u00f3n \"sumar\" aplicarOperacion sumar 5 3 -- Devuelve 8 Ejercicios pr\u00e1cticos \u00b6 Crea un m\u00f3dulo que contenga funciones para calcular el \u00e1rea y el per\u00edmetro de un c\u00edrculo. Utiliza una funci\u00f3n de orden superior para aplicar una operaci\u00f3n a una lista de n\u00fameros. Crea una funci\u00f3n que tome una lista de palabras y devuelva una lista con la longitud de cada palabra. Consejos y mejores pr\u00e1cticas \u00b6 Utiliza m\u00f3dulos para agrupar funciones y tipos de datos relacionados y facilitar su uso y reutilizaci\u00f3n. Aprovecha las funciones de orden superior para escribir c\u00f3digo m\u00e1s expresivo y flexible. Al crear m\u00f3dulos, aseg\u00farate de seguir las convenciones de nomenclatura y estructura de Haskell para facilitar su importaci\u00f3n y uso en otros programas.","title":"M\u00f3dulos y Funciones de Orden Superior"},{"location":"haskel/jr/m%C3%B3dulos_y_funciones_de_orden_superior/#modulos-y-funciones-de-orden-superior","text":"En Haskell, un m\u00f3dulo es una colecci\u00f3n de funciones y tipos de datos relacionados que se pueden utilizar en un programa. Los m\u00f3dulos permiten agrupar funciones y tipos de datos relacionados para facilitar su uso y reutilizaci\u00f3n en diferentes programas. Tambi\u00e9n ayudan a mantener un c\u00f3digo m\u00e1s organizado y modular, lo que facilita la colaboraci\u00f3n en proyectos de programaci\u00f3n. Adem\u00e1s de los m\u00f3dulos, Haskell tambi\u00e9n cuenta con funciones de orden superior, que son funciones que pueden tomar otras funciones como argumentos o devolver funciones como resultado. Esto permite una mayor flexibilidad y expresividad en la programaci\u00f3n funcional.","title":"M\u00f3dulos y Funciones de Orden Superior"},{"location":"haskel/jr/m%C3%B3dulos_y_funciones_de_orden_superior/#palabras-clave-y-definiciones","text":"M\u00f3dulo: una colecci\u00f3n de funciones y tipos de datos relacionados. Funci\u00f3n de orden superior: una funci\u00f3n que toma otras funciones como argumentos o devuelve funciones como resultado.","title":"Palabras clave y definiciones"},{"location":"haskel/jr/m%C3%B3dulos_y_funciones_de_orden_superior/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es un m\u00f3dulo en Haskell? \u00bfQu\u00e9 ventajas ofrece el uso de m\u00f3dulos en la programaci\u00f3n? \u00bfQu\u00e9 es una funci\u00f3n de orden superior en Haskell? \u00bfPor qu\u00e9 las funciones de orden superior son \u00fatiles en la programaci\u00f3n funcional?","title":"Preguntas de repaso"},{"location":"haskel/jr/m%C3%B3dulos_y_funciones_de_orden_superior/#ejemplos-de-codigo-en-haskell","text":"","title":"Ejemplos de c\u00f3digo en Haskell"},{"location":"haskel/jr/m%C3%B3dulos_y_funciones_de_orden_superior/#modulo-calculadora","text":"module Calculadora where -- Funci\u00f3n para sumar dos n\u00fameros sumar :: Int -> Int -> Int sumar x y = x + y -- Funci\u00f3n para restar dos n\u00fameros restar :: Int -> Int -> Int restar x y = x - y -- Funci\u00f3n para multiplicar dos n\u00fameros multiplicar :: Int -> Int -> Int multiplicar x y = x * y -- Funci\u00f3n de orden superior para aplicar una operaci\u00f3n a dos n\u00fameros dados aplicarOperacion :: ( Int -> Int -> Int ) -> Int -> Int -> Int aplicarOperacion f x y = f x y","title":"M\u00f3dulo \"Calculadora\""},{"location":"haskel/jr/m%C3%B3dulos_y_funciones_de_orden_superior/#uso-de-funciones-de-orden-superior","text":"-- Se puede utilizar la funci\u00f3n de orden superior \"aplicarOperacion\" con la funci\u00f3n \"sumar\" aplicarOperacion sumar 5 3 -- Devuelve 8","title":"Uso de funciones de orden superior"},{"location":"haskel/jr/m%C3%B3dulos_y_funciones_de_orden_superior/#ejercicios-practicos","text":"Crea un m\u00f3dulo que contenga funciones para calcular el \u00e1rea y el per\u00edmetro de un c\u00edrculo. Utiliza una funci\u00f3n de orden superior para aplicar una operaci\u00f3n a una lista de n\u00fameros. Crea una funci\u00f3n que tome una lista de palabras y devuelva una lista con la longitud de cada palabra.","title":"Ejercicios pr\u00e1cticos"},{"location":"haskel/jr/m%C3%B3dulos_y_funciones_de_orden_superior/#consejos-y-mejores-practicas","text":"Utiliza m\u00f3dulos para agrupar funciones y tipos de datos relacionados y facilitar su uso y reutilizaci\u00f3n. Aprovecha las funciones de orden superior para escribir c\u00f3digo m\u00e1s expresivo y flexible. Al crear m\u00f3dulos, aseg\u00farate de seguir las convenciones de nomenclatura y estructura de Haskell para facilitar su importaci\u00f3n y uso en otros programas.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"haskel/jr/programaci%C3%B3n_funcional/","text":"Programaci\u00f3n Funcional \u00b6 La programaci\u00f3n funcional es un paradigma de programaci\u00f3n en el que el flujo de ejecuci\u00f3n del programa se basa en la evaluaci\u00f3n de funciones. Este enfoque se basa en el c\u00e1lculo lambda, un sistema formal que describe la computaci\u00f3n en t\u00e9rminos de funciones matem\u00e1ticas. Palabras clave y su definici\u00f3n \u00b6 Paradigma de programaci\u00f3n: Una forma de pensar sobre c\u00f3mo resolver problemas de programaci\u00f3n. Evaluaci\u00f3n de funciones: El proceso de aplicar una funci\u00f3n a sus argumentos y obtener un resultado. C\u00e1lculo lambda: Un sistema formal que describe la computaci\u00f3n en t\u00e9rminos de funciones matem\u00e1ticas. Inmutabilidad: Un concepto en programaci\u00f3n funcional en el que los datos no pueden ser modificados una vez que se han creado. Funciones de orden superior: Funciones que pueden tomar otras funciones como argumentos o devolver una funci\u00f3n como resultado. Recursi\u00f3n: Un m\u00e9todo de resoluci\u00f3n de problemas en el que una funci\u00f3n se llama a s\u00ed misma para resolver un subproblema m\u00e1s peque\u00f1o. Tipado est\u00e1tico: Un sistema en el que los tipos de datos se verifican en tiempo de compilaci\u00f3n en lugar de en tiempo de ejecuci\u00f3n. Currying: Un proceso en el que una funci\u00f3n con m\u00faltiples argumentos se convierte en una serie de funciones con un solo argumento. Composici\u00f3n de funciones: La combinaci\u00f3n de dos o m\u00e1s funciones para formar una nueva funci\u00f3n. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la programaci\u00f3n funcional y en qu\u00e9 se basa? \u00bfQu\u00e9 es el c\u00e1lculo lambda y c\u00f3mo se relaciona con la programaci\u00f3n funcional? \u00bfQu\u00e9 es la inmutabilidad y por qu\u00e9 es importante en la programaci\u00f3n funcional? \u00bfQu\u00e9 son las funciones de orden superior y c\u00f3mo se usan en la programaci\u00f3n funcional? \u00bfQu\u00e9 es la recursi\u00f3n y c\u00f3mo se aplica en la programaci\u00f3n funcional? \u00bfQu\u00e9 es el tipado est\u00e1tico y c\u00f3mo se diferencia del tipado din\u00e1mico? \u00bfQu\u00e9 es el currying y c\u00f3mo se utiliza en la programaci\u00f3n funcional? \u00bfQu\u00e9 es la composici\u00f3n de funciones y c\u00f3mo se aplica en la programaci\u00f3n funcional? Ejemplos de c\u00f3digo en Haskell \u00b6 Ejemplo 1: Funci\u00f3n de suma \u00b6 La siguiente funci\u00f3n en Haskell recibe dos n\u00fameros enteros como argumentos y devuelve su suma: suma :: Int -> Int -> Int suma x y = x + y Ejemplo 2: Funci\u00f3n de orden superior \u00b6 La funci\u00f3n map es una funci\u00f3n de orden superior en Haskell que toma una funci\u00f3n y una lista como argumentos y devuelve una nueva lista aplicando la funci\u00f3n a cada elemento de la lista: map :: ( a -> b ) -> [ a ] -> [ b ] map f [] = [] map f ( x : xs ) = f x : map f xs Ejemplo 3: Funci\u00f3n recursiva \u00b6 La siguiente funci\u00f3n en Haskell calcula el factorial de un n\u00famero utilizando recursi\u00f3n: factorial :: Int -> Int factorial 0 = 1 factorial n = n * factorial ( n - 1 ) Ejercicios pr\u00e1cticos \u00b6 Crea una funci\u00f3n en Haskell que calcule el \u00e1rea de un c\u00edrculo dado su radio. Utiliza la funci\u00f3n map para convertir una lista de n\u00fameros enteros en una lista de sus valores absolutos. Escribe una funci\u00f3n recursiva en Haskell que calcule la potencia de un n\u00famero dado su exponente. Crea una funci\u00f3n de orden superior en Haskell que filtre los elementos de una lista seg\u00fan un criterio dado. Implementa una funci\u00f3n en Haskell que calcule el promedio de una lista de n\u00fameros. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza funciones puras en lugar de funciones con efectos laterales para evitar efectos secundarios no deseados. Utiliza la recursi\u00f3n en lugar de bucles para resolver problemas en la programaci\u00f3n funcional. Aprovecha las funciones de orden superior para escribir c\u00f3digo m\u00e1s conciso y legible. Aprende a usar tipos de datos algebraicos para modelar problemas de manera elegante. Practica el uso de funciones de composici\u00f3n para crear funciones m\u00e1s complejas a partir de funciones m\u00e1s simples.","title":"Programaci\u00f3n Funcional"},{"location":"haskel/jr/programaci%C3%B3n_funcional/#programacion-funcional","text":"La programaci\u00f3n funcional es un paradigma de programaci\u00f3n en el que el flujo de ejecuci\u00f3n del programa se basa en la evaluaci\u00f3n de funciones. Este enfoque se basa en el c\u00e1lculo lambda, un sistema formal que describe la computaci\u00f3n en t\u00e9rminos de funciones matem\u00e1ticas.","title":"Programaci\u00f3n Funcional"},{"location":"haskel/jr/programaci%C3%B3n_funcional/#palabras-clave-y-su-definicion","text":"Paradigma de programaci\u00f3n: Una forma de pensar sobre c\u00f3mo resolver problemas de programaci\u00f3n. Evaluaci\u00f3n de funciones: El proceso de aplicar una funci\u00f3n a sus argumentos y obtener un resultado. C\u00e1lculo lambda: Un sistema formal que describe la computaci\u00f3n en t\u00e9rminos de funciones matem\u00e1ticas. Inmutabilidad: Un concepto en programaci\u00f3n funcional en el que los datos no pueden ser modificados una vez que se han creado. Funciones de orden superior: Funciones que pueden tomar otras funciones como argumentos o devolver una funci\u00f3n como resultado. Recursi\u00f3n: Un m\u00e9todo de resoluci\u00f3n de problemas en el que una funci\u00f3n se llama a s\u00ed misma para resolver un subproblema m\u00e1s peque\u00f1o. Tipado est\u00e1tico: Un sistema en el que los tipos de datos se verifican en tiempo de compilaci\u00f3n en lugar de en tiempo de ejecuci\u00f3n. Currying: Un proceso en el que una funci\u00f3n con m\u00faltiples argumentos se convierte en una serie de funciones con un solo argumento. Composici\u00f3n de funciones: La combinaci\u00f3n de dos o m\u00e1s funciones para formar una nueva funci\u00f3n.","title":"Palabras clave y su definici\u00f3n"},{"location":"haskel/jr/programaci%C3%B3n_funcional/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la programaci\u00f3n funcional y en qu\u00e9 se basa? \u00bfQu\u00e9 es el c\u00e1lculo lambda y c\u00f3mo se relaciona con la programaci\u00f3n funcional? \u00bfQu\u00e9 es la inmutabilidad y por qu\u00e9 es importante en la programaci\u00f3n funcional? \u00bfQu\u00e9 son las funciones de orden superior y c\u00f3mo se usan en la programaci\u00f3n funcional? \u00bfQu\u00e9 es la recursi\u00f3n y c\u00f3mo se aplica en la programaci\u00f3n funcional? \u00bfQu\u00e9 es el tipado est\u00e1tico y c\u00f3mo se diferencia del tipado din\u00e1mico? \u00bfQu\u00e9 es el currying y c\u00f3mo se utiliza en la programaci\u00f3n funcional? \u00bfQu\u00e9 es la composici\u00f3n de funciones y c\u00f3mo se aplica en la programaci\u00f3n funcional?","title":"Preguntas de repaso"},{"location":"haskel/jr/programaci%C3%B3n_funcional/#ejemplos-de-codigo-en-haskell","text":"","title":"Ejemplos de c\u00f3digo en Haskell"},{"location":"haskel/jr/programaci%C3%B3n_funcional/#ejemplo-1-funcion-de-suma","text":"La siguiente funci\u00f3n en Haskell recibe dos n\u00fameros enteros como argumentos y devuelve su suma: suma :: Int -> Int -> Int suma x y = x + y","title":"Ejemplo 1: Funci\u00f3n de suma"},{"location":"haskel/jr/programaci%C3%B3n_funcional/#ejemplo-2-funcion-de-orden-superior","text":"La funci\u00f3n map es una funci\u00f3n de orden superior en Haskell que toma una funci\u00f3n y una lista como argumentos y devuelve una nueva lista aplicando la funci\u00f3n a cada elemento de la lista: map :: ( a -> b ) -> [ a ] -> [ b ] map f [] = [] map f ( x : xs ) = f x : map f xs","title":"Ejemplo 2: Funci\u00f3n de orden superior"},{"location":"haskel/jr/programaci%C3%B3n_funcional/#ejemplo-3-funcion-recursiva","text":"La siguiente funci\u00f3n en Haskell calcula el factorial de un n\u00famero utilizando recursi\u00f3n: factorial :: Int -> Int factorial 0 = 1 factorial n = n * factorial ( n - 1 )","title":"Ejemplo 3: Funci\u00f3n recursiva"},{"location":"haskel/jr/programaci%C3%B3n_funcional/#ejercicios-practicos","text":"Crea una funci\u00f3n en Haskell que calcule el \u00e1rea de un c\u00edrculo dado su radio. Utiliza la funci\u00f3n map para convertir una lista de n\u00fameros enteros en una lista de sus valores absolutos. Escribe una funci\u00f3n recursiva en Haskell que calcule la potencia de un n\u00famero dado su exponente. Crea una funci\u00f3n de orden superior en Haskell que filtre los elementos de una lista seg\u00fan un criterio dado. Implementa una funci\u00f3n en Haskell que calcule el promedio de una lista de n\u00fameros.","title":"Ejercicios pr\u00e1cticos"},{"location":"haskel/jr/programaci%C3%B3n_funcional/#consejos-o-mejores-practicas","text":"Utiliza funciones puras en lugar de funciones con efectos laterales para evitar efectos secundarios no deseados. Utiliza la recursi\u00f3n en lugar de bucles para resolver problemas en la programaci\u00f3n funcional. Aprovecha las funciones de orden superior para escribir c\u00f3digo m\u00e1s conciso y legible. Aprende a usar tipos de datos algebraicos para modelar problemas de manera elegante. Practica el uso de funciones de composici\u00f3n para crear funciones m\u00e1s complejas a partir de funciones m\u00e1s simples.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"haskel/jr/recursi%C3%B3n/","text":"Recursi\u00f3n en Haskell \u00b6 La recursi\u00f3n es una t\u00e9cnica utilizada en programaci\u00f3n que consiste en la llamada a una funci\u00f3n desde su propia definici\u00f3n. En Haskell, al ser un lenguaje funcional, la recursi\u00f3n es una herramienta fundamental para resolver problemas m\u00e1s complejos. En esta lecci\u00f3n, aprenderemos c\u00f3mo aplicar la recursi\u00f3n en Haskell y c\u00f3mo puede ayudarnos a escribir c\u00f3digo m\u00e1s eficiente y elegante. Palabras clave y definiciones \u00b6 Recursi\u00f3n : t\u00e9cnica utilizada en programaci\u00f3n en la que una funci\u00f3n se llama a s\u00ed misma desde su propia definici\u00f3n. Funci\u00f3n recursiva : funci\u00f3n que se llama a s\u00ed misma dentro de su propio cuerpo. Caso base : condici\u00f3n que detiene la recursi\u00f3n y evita que la funci\u00f3n se llame infinitamente. Pila de llamadas : estructura de datos que almacena las llamadas a funciones en orden de ejecuci\u00f3n. Funciones de orden superior : funciones que toman otras funciones como argumentos o devuelven funciones como resultado. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la recursi\u00f3n y en qu\u00e9 consiste? \u00bfCu\u00e1l es la diferencia entre una funci\u00f3n recursiva y una funci\u00f3n iterativa? \u00bfQu\u00e9 es un caso base y por qu\u00e9 es importante en la recursi\u00f3n? \u00bfC\u00f3mo se evita un bucle infinito en una funci\u00f3n recursiva? \u00bfQu\u00e9 es una pila de llamadas y c\u00f3mo se relaciona con la recursi\u00f3n? \u00bfPueden las funciones recursivas ser optimizadas para mejorar su rendimiento? \u00bfQu\u00e9 son las funciones de orden superior y c\u00f3mo pueden ser \u00fatiles en la recursi\u00f3n? Ejemplos de c\u00f3digo \u00b6 Factorial \u00b6 El factorial de un n\u00famero es la multiplicaci\u00f3n de todos los n\u00fameros enteros positivos desde 1 hasta el n\u00famero en s\u00ed. Por ejemplo, el factorial de 5 es 5 * 4 * 3 * 2 * 1 = 120. En Haskell, podemos escribir una funci\u00f3n recursiva para calcular el factorial de un n\u00famero de la siguiente manera: factorial :: Int -> Int factorial 0 = 1 -- caso base factorial n = n * factorial ( n - 1 ) -- llamada recursiva La funci\u00f3n toma un n\u00famero entero como argumento y devuelve su factorial. El caso base es cuando el n\u00famero es 0, ya que el factorial de 0 es 1. La llamada recursiva se realiza restando 1 al n\u00famero y multiplicando el resultado con la llamada recursiva de ese n\u00famero. Fibonacci \u00b6 La secuencia de Fibonacci es una serie num\u00e9rica en la que cada n\u00famero es igual a la suma de los dos n\u00fameros anteriores. Por ejemplo, la secuencia comienza con 0, 1, 1, 2, 3, 5, 8, 13, ... En Haskell, podemos escribir una funci\u00f3n recursiva para generar la secuencia de Fibonacci de la siguiente manera: fibonacci :: Int -> Int fibonacci 0 = 0 -- caso base fibonacci 1 = 1 -- caso base fibonacci n = fibonacci ( n - 1 ) + fibonacci ( n - 2 ) -- llamada recursiva El caso base es cuando el n\u00famero es 0 o 1, ya que en esos casos, el n\u00famero en la secuencia es igual al mismo n\u00famero. La llamada recursiva se realiza sumando los dos n\u00fameros anteriores en la secuencia. Ejercicios pr\u00e1cticos \u00b6 Escribe una funci\u00f3n recursiva para calcular la suma de los primeros n n\u00fameros naturales. Escribe una funci\u00f3n recursiva para calcular el n\u00famero de d\u00edgitos de un n\u00famero entero. Escribe una funci\u00f3n recursiva para encontrar el m\u00e1ximo elemento en una lista de n\u00fameros. Escribe una funci\u00f3n recursiva para calcular el en\u00e9simo t\u00e9rmino en la secuencia de Fibonacci. Escribe una funci\u00f3n recursiva que compruebe si una palabra es un pal\u00edndromo (se lee igual de izquierda a derecha y de derecha a izquierda). Consejos y mejores pr\u00e1cticas \u00b6 Siempre aseg\u00farate de tener un caso base en tus funciones recursivas para evitar un bucle infinito. Utiliza patrones de coincidencia para manejar diferentes casos en una funci\u00f3n recursiva. Aseg\u00farate de que la llamada recursiva se acerca al caso base en cada iteraci\u00f3n para evitar un stack overflow. Utiliza funciones de orden superior para abstraer la recursi\u00f3n y hacer que tu c\u00f3digo sea m\u00e1s legible y reusable. Practica la recursi\u00f3n resolviendo diferentes problemas y retos para mejorar tus habilidades en esta t\u00e9cnica.","title":"Recursi\u00f3n en Haskell"},{"location":"haskel/jr/recursi%C3%B3n/#recursion-en-haskell","text":"La recursi\u00f3n es una t\u00e9cnica utilizada en programaci\u00f3n que consiste en la llamada a una funci\u00f3n desde su propia definici\u00f3n. En Haskell, al ser un lenguaje funcional, la recursi\u00f3n es una herramienta fundamental para resolver problemas m\u00e1s complejos. En esta lecci\u00f3n, aprenderemos c\u00f3mo aplicar la recursi\u00f3n en Haskell y c\u00f3mo puede ayudarnos a escribir c\u00f3digo m\u00e1s eficiente y elegante.","title":"Recursi\u00f3n en Haskell"},{"location":"haskel/jr/recursi%C3%B3n/#palabras-clave-y-definiciones","text":"Recursi\u00f3n : t\u00e9cnica utilizada en programaci\u00f3n en la que una funci\u00f3n se llama a s\u00ed misma desde su propia definici\u00f3n. Funci\u00f3n recursiva : funci\u00f3n que se llama a s\u00ed misma dentro de su propio cuerpo. Caso base : condici\u00f3n que detiene la recursi\u00f3n y evita que la funci\u00f3n se llame infinitamente. Pila de llamadas : estructura de datos que almacena las llamadas a funciones en orden de ejecuci\u00f3n. Funciones de orden superior : funciones que toman otras funciones como argumentos o devuelven funciones como resultado.","title":"Palabras clave y definiciones"},{"location":"haskel/jr/recursi%C3%B3n/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la recursi\u00f3n y en qu\u00e9 consiste? \u00bfCu\u00e1l es la diferencia entre una funci\u00f3n recursiva y una funci\u00f3n iterativa? \u00bfQu\u00e9 es un caso base y por qu\u00e9 es importante en la recursi\u00f3n? \u00bfC\u00f3mo se evita un bucle infinito en una funci\u00f3n recursiva? \u00bfQu\u00e9 es una pila de llamadas y c\u00f3mo se relaciona con la recursi\u00f3n? \u00bfPueden las funciones recursivas ser optimizadas para mejorar su rendimiento? \u00bfQu\u00e9 son las funciones de orden superior y c\u00f3mo pueden ser \u00fatiles en la recursi\u00f3n?","title":"Preguntas de repaso"},{"location":"haskel/jr/recursi%C3%B3n/#ejemplos-de-codigo","text":"","title":"Ejemplos de c\u00f3digo"},{"location":"haskel/jr/recursi%C3%B3n/#factorial","text":"El factorial de un n\u00famero es la multiplicaci\u00f3n de todos los n\u00fameros enteros positivos desde 1 hasta el n\u00famero en s\u00ed. Por ejemplo, el factorial de 5 es 5 * 4 * 3 * 2 * 1 = 120. En Haskell, podemos escribir una funci\u00f3n recursiva para calcular el factorial de un n\u00famero de la siguiente manera: factorial :: Int -> Int factorial 0 = 1 -- caso base factorial n = n * factorial ( n - 1 ) -- llamada recursiva La funci\u00f3n toma un n\u00famero entero como argumento y devuelve su factorial. El caso base es cuando el n\u00famero es 0, ya que el factorial de 0 es 1. La llamada recursiva se realiza restando 1 al n\u00famero y multiplicando el resultado con la llamada recursiva de ese n\u00famero.","title":"Factorial"},{"location":"haskel/jr/recursi%C3%B3n/#fibonacci","text":"La secuencia de Fibonacci es una serie num\u00e9rica en la que cada n\u00famero es igual a la suma de los dos n\u00fameros anteriores. Por ejemplo, la secuencia comienza con 0, 1, 1, 2, 3, 5, 8, 13, ... En Haskell, podemos escribir una funci\u00f3n recursiva para generar la secuencia de Fibonacci de la siguiente manera: fibonacci :: Int -> Int fibonacci 0 = 0 -- caso base fibonacci 1 = 1 -- caso base fibonacci n = fibonacci ( n - 1 ) + fibonacci ( n - 2 ) -- llamada recursiva El caso base es cuando el n\u00famero es 0 o 1, ya que en esos casos, el n\u00famero en la secuencia es igual al mismo n\u00famero. La llamada recursiva se realiza sumando los dos n\u00fameros anteriores en la secuencia.","title":"Fibonacci"},{"location":"haskel/jr/recursi%C3%B3n/#ejercicios-practicos","text":"Escribe una funci\u00f3n recursiva para calcular la suma de los primeros n n\u00fameros naturales. Escribe una funci\u00f3n recursiva para calcular el n\u00famero de d\u00edgitos de un n\u00famero entero. Escribe una funci\u00f3n recursiva para encontrar el m\u00e1ximo elemento en una lista de n\u00fameros. Escribe una funci\u00f3n recursiva para calcular el en\u00e9simo t\u00e9rmino en la secuencia de Fibonacci. Escribe una funci\u00f3n recursiva que compruebe si una palabra es un pal\u00edndromo (se lee igual de izquierda a derecha y de derecha a izquierda).","title":"Ejercicios pr\u00e1cticos"},{"location":"haskel/jr/recursi%C3%B3n/#consejos-y-mejores-practicas","text":"Siempre aseg\u00farate de tener un caso base en tus funciones recursivas para evitar un bucle infinito. Utiliza patrones de coincidencia para manejar diferentes casos en una funci\u00f3n recursiva. Aseg\u00farate de que la llamada recursiva se acerca al caso base en cada iteraci\u00f3n para evitar un stack overflow. Utiliza funciones de orden superior para abstraer la recursi\u00f3n y hacer que tu c\u00f3digo sea m\u00e1s legible y reusable. Practica la recursi\u00f3n resolviendo diferentes problemas y retos para mejorar tus habilidades en esta t\u00e9cnica.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"haskel/jr/tipos_de_datos_algebraicos/","text":"Tipos de Datos Algebraicos en Haskell \u00b6 En Haskell, un tipo de datos algebraico es una forma de definir una estructura de datos personalizada, basada en la teor\u00eda de tipos algebraicos. Estos tipos de datos son una herramienta poderosa para crear estructuras de datos complejas que se adaptan a las necesidades espec\u00edficas de un programa. En esta lecci\u00f3n, exploraremos los tipos de datos algebraicos en Haskell y c\u00f3mo se pueden utilizar en la programaci\u00f3n funcional. Teor\u00eda de tipos algebraicos \u00b6 La teor\u00eda de tipos algebraicos es una rama de las matem\u00e1ticas que se centra en la construcci\u00f3n y manipulaci\u00f3n de tipos de datos. En Haskell, los tipos de datos algebraicos se basan en la teor\u00eda de tipos algebraicos, lo que significa que siguen ciertas reglas y propiedades matem\u00e1ticas. Un tipo de datos algebraico se puede pensar como una estructura de datos que consta de uno o m\u00e1s constructores de datos. Cada constructor de datos define una forma diferente de crear una instancia de ese tipo de datos. Por ejemplo, podemos tener un tipo de datos \"Persona\" con dos constructores de datos: \"Hombre\" y \"Mujer\". Cada uno de estos constructores puede tomar diferentes par\u00e1metros, como el nombre y la edad, para crear una persona espec\u00edfica. Los tipos de datos algebraicos tambi\u00e9n pueden ser recursivos, lo que significa que pueden contener instancias de s\u00ed mismos. Esto permite la creaci\u00f3n de estructuras de datos complejas, como \u00e1rboles o listas enlazadas. Palabras clave y definiciones \u00b6 Tipo de datos algebraico: una estructura de datos personalizada definida por uno o m\u00e1s constructores de datos. Constructor de datos: una funci\u00f3n que crea una instancia de un tipo de datos algebraico. Recursi\u00f3n: la capacidad de un tipo de datos de contener instancias de s\u00ed mismo. Suma de tipos: un tipo de datos algebraico que consta de dos o m\u00e1s tipos de datos. Producto de tipos: un tipo de datos algebraico que combina dos o m\u00e1s tipos de datos para crear una estructura m\u00e1s compleja. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es un tipo de datos algebraico en Haskell? \u00bfQu\u00e9 es un constructor de datos? \u00bfQu\u00e9 significa que un tipo de datos sea recursivo? \u00bfQu\u00e9 es una suma de tipos? \u00bfQu\u00e9 es un producto de tipos? Ejemplos de c\u00f3digo en Haskell \u00b6 Definici\u00f3n de un tipo de datos algebraico \u00b6 data Persona = Hombre String Int | Mujer String Int En este ejemplo, hemos definido un tipo de datos \"Persona\" con dos constructores de datos: \"Hombre\" y \"Mujer\". Cada uno de ellos toma dos par\u00e1metros: el nombre y la edad de la persona. Uso de un tipo de datos algebraico \u00b6 persona1 = Hombre \"Juan\" 30 persona2 = Mujer \"Mar\u00eda\" 25 Aqu\u00ed, hemos creado dos instancias del tipo de datos \"Persona\", utilizando los constructores de datos \"Hombre\" y \"Mujer\". Tipo de datos recursivo \u00b6 data Lista = Vacio | Cons Int Lista En este ejemplo, hemos definido un tipo de datos \"Lista\" que puede ser recursivo. El constructor de datos \"Cons\" toma un entero y otra instancia de \"Lista\" como par\u00e1metros, lo que nos permite crear una lista enlazada de enteros. Ejercicios pr\u00e1cticos \u00b6 Define un tipo de datos algebraico llamado \"Animal\" con los constructores de datos \"Perro\", \"Gato\" y \"P\u00e1jaro\". Cada uno de ellos debe tomar un par\u00e1metro para el nombre del animal. Crea una instancia del tipo de datos \"Animal\" utilizando el constructor \"Gato\" con el nombre \"Mittens\". Define un tipo de datos algebraico recursivo llamado \"Arbol\" que tenga dos constructores de datos: \"Nodo\" que tome un valor y dos instancias de \"Arbol\" como par\u00e1metros, y \"Hoja\" que no tome par\u00e1metros. Utiliza el tipo de datos \"Arbol\" para crear un \u00e1rbol binario con los valores 1, 2 y 3 como nodos. Consejos y mejores pr\u00e1cticas \u00b6 Utiliza tipos de datos algebraicos para crear estructuras de datos personalizadas que se adapten a las necesidades de tu programa. Piensa en c\u00f3mo las propiedades matem\u00e1ticas de los tipos de datos algebraicos pueden ayudarte a resolver problemas de programaci\u00f3n. Utiliza la recursi\u00f3n con cuidado, ya que puede llevar a estructuras de datos complejas y potencialmente ineficientes.","title":"Tipos de Datos Algebraicos en Haskell"},{"location":"haskel/jr/tipos_de_datos_algebraicos/#tipos-de-datos-algebraicos-en-haskell","text":"En Haskell, un tipo de datos algebraico es una forma de definir una estructura de datos personalizada, basada en la teor\u00eda de tipos algebraicos. Estos tipos de datos son una herramienta poderosa para crear estructuras de datos complejas que se adaptan a las necesidades espec\u00edficas de un programa. En esta lecci\u00f3n, exploraremos los tipos de datos algebraicos en Haskell y c\u00f3mo se pueden utilizar en la programaci\u00f3n funcional.","title":"Tipos de Datos Algebraicos en Haskell"},{"location":"haskel/jr/tipos_de_datos_algebraicos/#teoria-de-tipos-algebraicos","text":"La teor\u00eda de tipos algebraicos es una rama de las matem\u00e1ticas que se centra en la construcci\u00f3n y manipulaci\u00f3n de tipos de datos. En Haskell, los tipos de datos algebraicos se basan en la teor\u00eda de tipos algebraicos, lo que significa que siguen ciertas reglas y propiedades matem\u00e1ticas. Un tipo de datos algebraico se puede pensar como una estructura de datos que consta de uno o m\u00e1s constructores de datos. Cada constructor de datos define una forma diferente de crear una instancia de ese tipo de datos. Por ejemplo, podemos tener un tipo de datos \"Persona\" con dos constructores de datos: \"Hombre\" y \"Mujer\". Cada uno de estos constructores puede tomar diferentes par\u00e1metros, como el nombre y la edad, para crear una persona espec\u00edfica. Los tipos de datos algebraicos tambi\u00e9n pueden ser recursivos, lo que significa que pueden contener instancias de s\u00ed mismos. Esto permite la creaci\u00f3n de estructuras de datos complejas, como \u00e1rboles o listas enlazadas.","title":"Teor\u00eda de tipos algebraicos"},{"location":"haskel/jr/tipos_de_datos_algebraicos/#palabras-clave-y-definiciones","text":"Tipo de datos algebraico: una estructura de datos personalizada definida por uno o m\u00e1s constructores de datos. Constructor de datos: una funci\u00f3n que crea una instancia de un tipo de datos algebraico. Recursi\u00f3n: la capacidad de un tipo de datos de contener instancias de s\u00ed mismo. Suma de tipos: un tipo de datos algebraico que consta de dos o m\u00e1s tipos de datos. Producto de tipos: un tipo de datos algebraico que combina dos o m\u00e1s tipos de datos para crear una estructura m\u00e1s compleja.","title":"Palabras clave y definiciones"},{"location":"haskel/jr/tipos_de_datos_algebraicos/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es un tipo de datos algebraico en Haskell? \u00bfQu\u00e9 es un constructor de datos? \u00bfQu\u00e9 significa que un tipo de datos sea recursivo? \u00bfQu\u00e9 es una suma de tipos? \u00bfQu\u00e9 es un producto de tipos?","title":"Preguntas de repaso"},{"location":"haskel/jr/tipos_de_datos_algebraicos/#ejemplos-de-codigo-en-haskell","text":"","title":"Ejemplos de c\u00f3digo en Haskell"},{"location":"haskel/jr/tipos_de_datos_algebraicos/#definicion-de-un-tipo-de-datos-algebraico","text":"data Persona = Hombre String Int | Mujer String Int En este ejemplo, hemos definido un tipo de datos \"Persona\" con dos constructores de datos: \"Hombre\" y \"Mujer\". Cada uno de ellos toma dos par\u00e1metros: el nombre y la edad de la persona.","title":"Definici\u00f3n de un tipo de datos algebraico"},{"location":"haskel/jr/tipos_de_datos_algebraicos/#uso-de-un-tipo-de-datos-algebraico","text":"persona1 = Hombre \"Juan\" 30 persona2 = Mujer \"Mar\u00eda\" 25 Aqu\u00ed, hemos creado dos instancias del tipo de datos \"Persona\", utilizando los constructores de datos \"Hombre\" y \"Mujer\".","title":"Uso de un tipo de datos algebraico"},{"location":"haskel/jr/tipos_de_datos_algebraicos/#tipo-de-datos-recursivo","text":"data Lista = Vacio | Cons Int Lista En este ejemplo, hemos definido un tipo de datos \"Lista\" que puede ser recursivo. El constructor de datos \"Cons\" toma un entero y otra instancia de \"Lista\" como par\u00e1metros, lo que nos permite crear una lista enlazada de enteros.","title":"Tipo de datos recursivo"},{"location":"haskel/jr/tipos_de_datos_algebraicos/#ejercicios-practicos","text":"Define un tipo de datos algebraico llamado \"Animal\" con los constructores de datos \"Perro\", \"Gato\" y \"P\u00e1jaro\". Cada uno de ellos debe tomar un par\u00e1metro para el nombre del animal. Crea una instancia del tipo de datos \"Animal\" utilizando el constructor \"Gato\" con el nombre \"Mittens\". Define un tipo de datos algebraico recursivo llamado \"Arbol\" que tenga dos constructores de datos: \"Nodo\" que tome un valor y dos instancias de \"Arbol\" como par\u00e1metros, y \"Hoja\" que no tome par\u00e1metros. Utiliza el tipo de datos \"Arbol\" para crear un \u00e1rbol binario con los valores 1, 2 y 3 como nodos.","title":"Ejercicios pr\u00e1cticos"},{"location":"haskel/jr/tipos_de_datos_algebraicos/#consejos-y-mejores-practicas","text":"Utiliza tipos de datos algebraicos para crear estructuras de datos personalizadas que se adapten a las necesidades de tu programa. Piensa en c\u00f3mo las propiedades matem\u00e1ticas de los tipos de datos algebraicos pueden ayudarte a resolver problemas de programaci\u00f3n. Utiliza la recursi\u00f3n con cuidado, ya que puede llevar a estructuras de datos complejas y potencialmente ineficientes.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"haskel/mid/manipulaci%C3%B3n_de_archivos/","text":"Manipulaci\u00f3n de Archivos en Haskell \u00b6 La manipulaci\u00f3n de archivos es una tarea com\u00fan en la programaci\u00f3n, ya que permite leer y escribir datos en archivos externos, lo que facilita el almacenamiento y procesamiento de grandes cantidades de informaci\u00f3n. En Haskell, esta tarea se puede realizar de manera eficiente y elegante gracias a sus funciones y tipos de datos espec\u00edficos para manejar archivos. Palabras clave y su definici\u00f3n \u00b6 Archivo: es una colecci\u00f3n de datos almacenados en un medio de almacenamiento secundario, como un disco duro o una unidad USB. Manipulaci\u00f3n: se refiere a las acciones realizadas sobre un archivo, como leer, escribir, modificar o eliminar datos. Excepci\u00f3n: es un evento inesperado que puede ocurrir durante la ejecuci\u00f3n de un programa y que puede interrumpir su flujo normal. I/O (Input/Output): se refiere a las operaciones de entrada y salida de datos de un programa, que en el caso de la manipulaci\u00f3n de archivos incluyen la lectura y escritura de datos. Explicaci\u00f3n te\u00f3rica \u00b6 En Haskell, los archivos se manipulan a trav\u00e9s de un tipo de dato llamado Handle , que representa un canal de comunicaci\u00f3n entre el programa y el archivo. Este tipo de dato es una abstracci\u00f3n que nos permite realizar operaciones de entrada y salida de datos en un archivo de manera segura y eficiente. Para abrir un archivo, se utiliza la funci\u00f3n openFile , que recibe como argumentos el nombre del archivo y el modo en el que se desea abrirlo. Los modos disponibles son ReadMode para leer datos del archivo, WriteMode para escribir datos en el archivo (borrando su contenido previo), AppendMode para escribir datos al final del archivo y ReadWriteMode para leer y escribir datos en el archivo. Una vez abierto el archivo, se pueden realizar operaciones de entrada y salida de datos utilizando las funciones hGetLine y hPutStrLn respectivamente. La primera recibe un Handle como argumento y devuelve una l\u00ednea de texto del archivo, mientras que la segunda recibe un Handle y una cadena de texto y escribe dicha cadena en el archivo. Es importante mencionar que todas las operaciones de entrada/salida en Haskell son puras, lo que significa que no tienen efectos secundarios y siempre devuelven el mismo resultado para los mismos argumentos. Esto se logra utilizando el tipo de dato IO y las funciones de la librer\u00eda est\u00e1ndar do y return , que permiten secuenciar y combinar operaciones de I/O de manera segura. En caso de que ocurra una excepci\u00f3n durante la manipulaci\u00f3n de un archivo, como por ejemplo que el archivo no exista o que se quiera leer m\u00e1s all\u00e1 del final del archivo, Haskell nos ofrece una manera elegante de manejar dichas excepciones utilizando tipos de datos como Maybe y Either y funciones como catch y try . Preguntas de repaso \u00b6 \u00bfQu\u00e9 es una excepci\u00f3n y c\u00f3mo se manejan en Haskell? \u00bfCu\u00e1l es el tipo de dato utilizado para representar un archivo en Haskell? \u00bfCu\u00e1les son los modos disponibles para abrir un archivo? \u00bfC\u00f3mo se realiza la lectura de datos desde un archivo en Haskell? Ejemplos de c\u00f3digo en Haskell \u00b6 Lectura de un archivo l\u00ednea por l\u00ednea \u00b6 main :: IO () main = do -- Abrir el archivo en modo lectura file <- openFile \"archivo.txt\" ReadMode -- Realizar la lectura l\u00ednea por l\u00ednea contents <- hGetLine file putStrLn contents -- Cerrar el archivo hClose file Escritura de un archivo \u00b6 main :: IO () main = do -- Abrir el archivo en modo escritura file <- openFile \"archivo.txt\" WriteMode -- Escribir una cadena de texto en el archivo hPutStrLn file \"Hola mundo!\" -- Cerrar el archivo hClose file Manejo de excepciones \u00b6 main :: IO () main = do -- Intentar abrir el archivo en modo lectura result <- try ( openFile \"archivo.txt\" ReadMode ) :: IO ( Either SomeException Handle ) case result of -- Si se pudo abrir el archivo, leer su contenido l\u00ednea por l\u00ednea y mostrarlo en pantalla Right handle -> do contents <- hGetLine handle putStrLn contents hClose handle -- Si ocurre una excepci\u00f3n, mostrar un mensaje de error Left ex -> putStrLn $ \"Error al abrir el archivo: \" ++ show ex Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea un programa en Haskell que abra el archivo numeros.txt en modo lectura y muestre en pantalla el resultado de sumar los n\u00fameros que se encuentran en cada l\u00ednea del archivo. Modifica el programa anterior para que pueda manejar excepciones en caso de que el archivo no exista o contenga datos no num\u00e9ricos. Consejos o mejores pr\u00e1cticas \u00b6 Es importante siempre cerrar el archivo una vez que se ha terminado de manipularlo, para evitar problemas de memoria y asegurar que los cambios realizados se guarden correctamente. Utiliza funciones como try y catch para manejar excepciones de manera elegante y evitar interrupciones inesperadas en tu programa. Recuerda que todas las operaciones de entrada/salida en Haskell son puras, por lo que es importante utilizar el tipo de dato IO y las funciones do y return para secuenciar y combinar dichas operaciones de manera segura.","title":"Manipulaci\u00f3n de Archivos en Haskell"},{"location":"haskel/mid/manipulaci%C3%B3n_de_archivos/#manipulacion-de-archivos-en-haskell","text":"La manipulaci\u00f3n de archivos es una tarea com\u00fan en la programaci\u00f3n, ya que permite leer y escribir datos en archivos externos, lo que facilita el almacenamiento y procesamiento de grandes cantidades de informaci\u00f3n. En Haskell, esta tarea se puede realizar de manera eficiente y elegante gracias a sus funciones y tipos de datos espec\u00edficos para manejar archivos.","title":"Manipulaci\u00f3n de Archivos en Haskell"},{"location":"haskel/mid/manipulaci%C3%B3n_de_archivos/#palabras-clave-y-su-definicion","text":"Archivo: es una colecci\u00f3n de datos almacenados en un medio de almacenamiento secundario, como un disco duro o una unidad USB. Manipulaci\u00f3n: se refiere a las acciones realizadas sobre un archivo, como leer, escribir, modificar o eliminar datos. Excepci\u00f3n: es un evento inesperado que puede ocurrir durante la ejecuci\u00f3n de un programa y que puede interrumpir su flujo normal. I/O (Input/Output): se refiere a las operaciones de entrada y salida de datos de un programa, que en el caso de la manipulaci\u00f3n de archivos incluyen la lectura y escritura de datos.","title":"Palabras clave y su definici\u00f3n"},{"location":"haskel/mid/manipulaci%C3%B3n_de_archivos/#explicacion-teorica","text":"En Haskell, los archivos se manipulan a trav\u00e9s de un tipo de dato llamado Handle , que representa un canal de comunicaci\u00f3n entre el programa y el archivo. Este tipo de dato es una abstracci\u00f3n que nos permite realizar operaciones de entrada y salida de datos en un archivo de manera segura y eficiente. Para abrir un archivo, se utiliza la funci\u00f3n openFile , que recibe como argumentos el nombre del archivo y el modo en el que se desea abrirlo. Los modos disponibles son ReadMode para leer datos del archivo, WriteMode para escribir datos en el archivo (borrando su contenido previo), AppendMode para escribir datos al final del archivo y ReadWriteMode para leer y escribir datos en el archivo. Una vez abierto el archivo, se pueden realizar operaciones de entrada y salida de datos utilizando las funciones hGetLine y hPutStrLn respectivamente. La primera recibe un Handle como argumento y devuelve una l\u00ednea de texto del archivo, mientras que la segunda recibe un Handle y una cadena de texto y escribe dicha cadena en el archivo. Es importante mencionar que todas las operaciones de entrada/salida en Haskell son puras, lo que significa que no tienen efectos secundarios y siempre devuelven el mismo resultado para los mismos argumentos. Esto se logra utilizando el tipo de dato IO y las funciones de la librer\u00eda est\u00e1ndar do y return , que permiten secuenciar y combinar operaciones de I/O de manera segura. En caso de que ocurra una excepci\u00f3n durante la manipulaci\u00f3n de un archivo, como por ejemplo que el archivo no exista o que se quiera leer m\u00e1s all\u00e1 del final del archivo, Haskell nos ofrece una manera elegante de manejar dichas excepciones utilizando tipos de datos como Maybe y Either y funciones como catch y try .","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"haskel/mid/manipulaci%C3%B3n_de_archivos/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es una excepci\u00f3n y c\u00f3mo se manejan en Haskell? \u00bfCu\u00e1l es el tipo de dato utilizado para representar un archivo en Haskell? \u00bfCu\u00e1les son los modos disponibles para abrir un archivo? \u00bfC\u00f3mo se realiza la lectura de datos desde un archivo en Haskell?","title":"Preguntas de repaso"},{"location":"haskel/mid/manipulaci%C3%B3n_de_archivos/#ejemplos-de-codigo-en-haskell","text":"","title":"Ejemplos de c\u00f3digo en Haskell"},{"location":"haskel/mid/manipulaci%C3%B3n_de_archivos/#lectura-de-un-archivo-linea-por-linea","text":"main :: IO () main = do -- Abrir el archivo en modo lectura file <- openFile \"archivo.txt\" ReadMode -- Realizar la lectura l\u00ednea por l\u00ednea contents <- hGetLine file putStrLn contents -- Cerrar el archivo hClose file","title":"Lectura de un archivo l\u00ednea por l\u00ednea"},{"location":"haskel/mid/manipulaci%C3%B3n_de_archivos/#escritura-de-un-archivo","text":"main :: IO () main = do -- Abrir el archivo en modo escritura file <- openFile \"archivo.txt\" WriteMode -- Escribir una cadena de texto en el archivo hPutStrLn file \"Hola mundo!\" -- Cerrar el archivo hClose file","title":"Escritura de un archivo"},{"location":"haskel/mid/manipulaci%C3%B3n_de_archivos/#manejo-de-excepciones","text":"main :: IO () main = do -- Intentar abrir el archivo en modo lectura result <- try ( openFile \"archivo.txt\" ReadMode ) :: IO ( Either SomeException Handle ) case result of -- Si se pudo abrir el archivo, leer su contenido l\u00ednea por l\u00ednea y mostrarlo en pantalla Right handle -> do contents <- hGetLine handle putStrLn contents hClose handle -- Si ocurre una excepci\u00f3n, mostrar un mensaje de error Left ex -> putStrLn $ \"Error al abrir el archivo: \" ++ show ex","title":"Manejo de excepciones"},{"location":"haskel/mid/manipulaci%C3%B3n_de_archivos/#ejercicios-practicos-con-instrucciones-claras","text":"Crea un programa en Haskell que abra el archivo numeros.txt en modo lectura y muestre en pantalla el resultado de sumar los n\u00fameros que se encuentran en cada l\u00ednea del archivo. Modifica el programa anterior para que pueda manejar excepciones en caso de que el archivo no exista o contenga datos no num\u00e9ricos.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"haskel/mid/manipulaci%C3%B3n_de_archivos/#consejos-o-mejores-practicas","text":"Es importante siempre cerrar el archivo una vez que se ha terminado de manipularlo, para evitar problemas de memoria y asegurar que los cambios realizados se guarden correctamente. Utiliza funciones como try y catch para manejar excepciones de manera elegante y evitar interrupciones inesperadas en tu programa. Recuerda que todas las operaciones de entrada/salida en Haskell son puras, por lo que es importante utilizar el tipo de dato IO y las funciones do y return para secuenciar y combinar dichas operaciones de manera segura.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"haskel/mid/monads/","text":"Monads \u00b6 Introducci\u00f3n \u00b6 Los monads son una de las caracter\u00edsticas m\u00e1s importantes y poderosas de Haskell. Permiten manejar efectos secundarios en un lenguaje puramente funcional y asegurar la inmutabilidad de los datos. En t\u00e9rminos simples, un monad es una estructura de datos que representa una computaci\u00f3n con efectos secundarios. Esto significa que pueden realizar operaciones que produzcan un cambio en el estado del programa o interactuar con el mundo exterior, como leer o escribir en archivos, hacer solicitudes de red, entre otros. Los monads proporcionan una forma segura y controlada de trabajar con efectos secundarios en Haskell. Al utilizarlos, se puede mantener la pureza y transparencia referencial del lenguaje, lo que lo hace m\u00e1s robusto y f\u00e1cil de razonar. Palabras clave y su definici\u00f3n \u00b6 Monad: Es una estructura de datos que representa una computaci\u00f3n con efectos secundarios. En Haskell, se implementa mediante el tipo de dato Monad y tiene dos funciones principales: return y >>= . Efecto secundario: Es cualquier operaci\u00f3n que cause un cambio en el estado del programa o interact\u00fae con el mundo exterior. Transparencia referencial: Se refiere a la propiedad de que una funci\u00f3n siempre devuelve el mismo resultado para los mismos argumentos, sin importar cu\u00e1ntas veces se llame. Pureza: Es la propiedad de que una funci\u00f3n no tiene efectos secundarios y siempre produce el mismo resultado para los mismos argumentos. Do notation: Es una sintaxis especial en Haskell que permite escribir c\u00f3digo imperativo en un contexto de monad de manera m\u00e1s legible y familiar. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es un monad en Haskell? \u00bfCu\u00e1l es la funci\u00f3n principal de un monad? \u00bfPor qu\u00e9 son importantes los monads en un lenguaje puramente funcional? \u00bfQu\u00e9 es un efecto secundario y c\u00f3mo se maneja en Haskell? \u00bfQu\u00e9 significa que una funci\u00f3n sea pura y transparente referencialmente? \u00bfQu\u00e9 es la do notation y en qu\u00e9 contexto se utiliza en Haskell? Ejemplos de c\u00f3digo en Haskell \u00b6 Ejemplo 1: Monad Maybe \u00b6 El monad Maybe se utiliza para manejar valores que pueden o no estar presentes. Se implementa mediante el tipo de dato Maybe y tiene dos constructores: Just para valores presentes y Nothing para valores ausentes. -- Funci\u00f3n que divide dos n\u00fameros y devuelve un resultado Maybe safeDiv :: Double -> Double -> Maybe Double safeDiv x 0 = Nothing -- Si el divisor es cero, devuelve Nothing safeDiv x y = Just ( x / y ) -- De lo contrario, devuelve Just el resultado -- Ejemplo de uso de la funci\u00f3n divide10by :: Double -> Maybe Double divide10by x = do y <- safeDiv 10 x return y -- Devuelve el resultado de la divisi\u00f3n -- Ejemplo de llamada con un divisor v\u00e1lido divide10by 2 -- Devuelve Just 5.0 -- Ejemplo de llamada con un divisor inv\u00e1lido divide10by 0 -- Devuelve Nothing Ejemplo 2: Monad IO \u00b6 El monad IO se utiliza para manejar efectos secundarios en Haskell. Se implementa mediante el tipo de dato IO y tiene dos constructores: return para valores puros y >>= para encadenar acciones con efectos secundarios. -- Funci\u00f3n que imprime un mensaje en pantalla y devuelve un valor puro greet :: String -> IO String greet name = do putStrLn ( \"Hello \" ++ name ) return \"Nice to meet you!\" -- Ejemplo de uso de la funci\u00f3n main :: IO () main = do putStrLn \"What's your name?\" name <- getLine message <- greet name putStrLn message Ejercicios pr\u00e1cticos \u00b6 Crea una funci\u00f3n que reciba una lista de n\u00fameros y devuelva la suma de los cuadrados de los n\u00fameros pares utilizando un monad. Utiliza el monad IO para crear un programa que pregunte al usuario su edad y le diga si es mayor de edad o no. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza monads solo cuando sea necesario para manejar efectos secundarios. En la mayor\u00eda de los casos, se pueden evitar mediante el uso de funciones puras y tipos de datos inmutables. Aprende a trabajar con diferentes tipos de monads y c\u00f3mo se implementan en Haskell, como Maybe , IO , List , entre otros. Utiliza la do notation para escribir c\u00f3digo imperativo en un contexto de monad de manera m\u00e1s legible y familiar. Practica la resoluci\u00f3n de problemas utilizando monads para mejorar tu comprensi\u00f3n y habilidades en Haskell.","title":"Monads"},{"location":"haskel/mid/monads/#monads","text":"","title":"Monads"},{"location":"haskel/mid/monads/#introduccion","text":"Los monads son una de las caracter\u00edsticas m\u00e1s importantes y poderosas de Haskell. Permiten manejar efectos secundarios en un lenguaje puramente funcional y asegurar la inmutabilidad de los datos. En t\u00e9rminos simples, un monad es una estructura de datos que representa una computaci\u00f3n con efectos secundarios. Esto significa que pueden realizar operaciones que produzcan un cambio en el estado del programa o interactuar con el mundo exterior, como leer o escribir en archivos, hacer solicitudes de red, entre otros. Los monads proporcionan una forma segura y controlada de trabajar con efectos secundarios en Haskell. Al utilizarlos, se puede mantener la pureza y transparencia referencial del lenguaje, lo que lo hace m\u00e1s robusto y f\u00e1cil de razonar.","title":"Introducci\u00f3n"},{"location":"haskel/mid/monads/#palabras-clave-y-su-definicion","text":"Monad: Es una estructura de datos que representa una computaci\u00f3n con efectos secundarios. En Haskell, se implementa mediante el tipo de dato Monad y tiene dos funciones principales: return y >>= . Efecto secundario: Es cualquier operaci\u00f3n que cause un cambio en el estado del programa o interact\u00fae con el mundo exterior. Transparencia referencial: Se refiere a la propiedad de que una funci\u00f3n siempre devuelve el mismo resultado para los mismos argumentos, sin importar cu\u00e1ntas veces se llame. Pureza: Es la propiedad de que una funci\u00f3n no tiene efectos secundarios y siempre produce el mismo resultado para los mismos argumentos. Do notation: Es una sintaxis especial en Haskell que permite escribir c\u00f3digo imperativo en un contexto de monad de manera m\u00e1s legible y familiar.","title":"Palabras clave y su definici\u00f3n"},{"location":"haskel/mid/monads/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es un monad en Haskell? \u00bfCu\u00e1l es la funci\u00f3n principal de un monad? \u00bfPor qu\u00e9 son importantes los monads en un lenguaje puramente funcional? \u00bfQu\u00e9 es un efecto secundario y c\u00f3mo se maneja en Haskell? \u00bfQu\u00e9 significa que una funci\u00f3n sea pura y transparente referencialmente? \u00bfQu\u00e9 es la do notation y en qu\u00e9 contexto se utiliza en Haskell?","title":"Preguntas de repaso"},{"location":"haskel/mid/monads/#ejemplos-de-codigo-en-haskell","text":"","title":"Ejemplos de c\u00f3digo en Haskell"},{"location":"haskel/mid/monads/#ejemplo-1-monad-maybe","text":"El monad Maybe se utiliza para manejar valores que pueden o no estar presentes. Se implementa mediante el tipo de dato Maybe y tiene dos constructores: Just para valores presentes y Nothing para valores ausentes. -- Funci\u00f3n que divide dos n\u00fameros y devuelve un resultado Maybe safeDiv :: Double -> Double -> Maybe Double safeDiv x 0 = Nothing -- Si el divisor es cero, devuelve Nothing safeDiv x y = Just ( x / y ) -- De lo contrario, devuelve Just el resultado -- Ejemplo de uso de la funci\u00f3n divide10by :: Double -> Maybe Double divide10by x = do y <- safeDiv 10 x return y -- Devuelve el resultado de la divisi\u00f3n -- Ejemplo de llamada con un divisor v\u00e1lido divide10by 2 -- Devuelve Just 5.0 -- Ejemplo de llamada con un divisor inv\u00e1lido divide10by 0 -- Devuelve Nothing","title":"Ejemplo 1: Monad Maybe"},{"location":"haskel/mid/monads/#ejemplo-2-monad-io","text":"El monad IO se utiliza para manejar efectos secundarios en Haskell. Se implementa mediante el tipo de dato IO y tiene dos constructores: return para valores puros y >>= para encadenar acciones con efectos secundarios. -- Funci\u00f3n que imprime un mensaje en pantalla y devuelve un valor puro greet :: String -> IO String greet name = do putStrLn ( \"Hello \" ++ name ) return \"Nice to meet you!\" -- Ejemplo de uso de la funci\u00f3n main :: IO () main = do putStrLn \"What's your name?\" name <- getLine message <- greet name putStrLn message","title":"Ejemplo 2: Monad IO"},{"location":"haskel/mid/monads/#ejercicios-practicos","text":"Crea una funci\u00f3n que reciba una lista de n\u00fameros y devuelva la suma de los cuadrados de los n\u00fameros pares utilizando un monad. Utiliza el monad IO para crear un programa que pregunte al usuario su edad y le diga si es mayor de edad o no.","title":"Ejercicios pr\u00e1cticos"},{"location":"haskel/mid/monads/#consejos-o-mejores-practicas","text":"Utiliza monads solo cuando sea necesario para manejar efectos secundarios. En la mayor\u00eda de los casos, se pueden evitar mediante el uso de funciones puras y tipos de datos inmutables. Aprende a trabajar con diferentes tipos de monads y c\u00f3mo se implementan en Haskell, como Maybe , IO , List , entre otros. Utiliza la do notation para escribir c\u00f3digo imperativo en un contexto de monad de manera m\u00e1s legible y familiar. Practica la resoluci\u00f3n de problemas utilizando monads para mejorar tu comprensi\u00f3n y habilidades en Haskell.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"haskel/mid/patrones_de_dise%C3%B1o_en_haskell/","text":"Patrones de Dise\u00f1o en Haskell \u00b6 Introducci\u00f3n \u00b6 En la programaci\u00f3n funcional, los patrones de dise\u00f1o son t\u00e9cnicas que permiten resolver problemas comunes de forma elegante y eficiente. A diferencia de la programaci\u00f3n orientada a objetos, donde los patrones de dise\u00f1o se basan en la manipulaci\u00f3n de objetos, en Haskell se basan en la manipulaci\u00f3n de funciones. Esto permite una mayor flexibilidad y expresividad en el dise\u00f1o de programas. Palabras clave y su definici\u00f3n \u00b6 Patr\u00f3n de dise\u00f1o: Es una soluci\u00f3n general y reutilizable para un problema com\u00fan en el dise\u00f1o de software. Funciones de alto orden: Son funciones que toman como argumento otras funciones o devuelven funciones como resultado. Composici\u00f3n de funciones: Es una t\u00e9cnica que permite combinar dos o m\u00e1s funciones para crear una nueva funci\u00f3n. Recursi\u00f3n: Es una t\u00e9cnica de programaci\u00f3n que consiste en la llamada a una funci\u00f3n dentro de su propia definici\u00f3n. Tipos de datos algebraicos: Son una forma de definir tipos de datos estructurados en Haskell. Preguntas de repaso \u00b6 \u00bfQu\u00e9 son los patrones de dise\u00f1o y por qu\u00e9 son \u00fatiles en la programaci\u00f3n funcional? \u00bfEn qu\u00e9 se diferencian los patrones de dise\u00f1o en Haskell de los patrones en la programaci\u00f3n orientada a objetos? \u00bfQu\u00e9 son las funciones de alto orden y c\u00f3mo se utilizan en Haskell? \u00bfQu\u00e9 es la composici\u00f3n de funciones y c\u00f3mo se implementa en Haskell? \u00bfEn qu\u00e9 consiste la recursi\u00f3n y cu\u00e1l es su importancia en la programaci\u00f3n funcional? \u00bfQu\u00e9 son los tipos de datos algebraicos y c\u00f3mo se definen en Haskell? Ejemplos de c\u00f3digo en Haskell \u00b6 Funciones de alto orden \u00b6 Las funciones de alto orden son un concepto importante en Haskell y se utilizan ampliamente en la implementaci\u00f3n de patrones de dise\u00f1o. Un ejemplo de una funci\u00f3n de alto orden es map , que toma una funci\u00f3n y una lista como argumentos y aplica la funci\u00f3n a cada elemento de la lista, devolviendo una nueva lista con los resultados. -- Funci\u00f3n que suma 1 a cada elemento de la lista sumarUno :: [ Int ] -> [ Int ] sumarUno lista = map ( \\ x -> x + 1 ) lista -- Uso de la funci\u00f3n sumarUno sumarUno [ 1 , 2 , 3 ] -- [2, 3, 4] Composici\u00f3n de funciones \u00b6 La composici\u00f3n de funciones es una t\u00e9cnica \u00fatil para combinar dos o m\u00e1s funciones y crear una nueva funci\u00f3n. En Haskell, se utiliza el operador . para componer funciones. -- Funci\u00f3n que devuelve el doble de un n\u00famero doble :: Int -> Int doble x = x * 2 -- Funci\u00f3n que suma 1 al doble de un n\u00famero sumaUnoAlDoble :: Int -> Int sumaUnoAlDoble = doble . ( + 1 ) -- Uso de la funci\u00f3n sumaUnoAlDoble sumaUnoAlDoble 5 -- 12 Recursi\u00f3n \u00b6 La recursi\u00f3n es una t\u00e9cnica fundamental en la programaci\u00f3n funcional y se utiliza en muchos patrones de dise\u00f1o. Un ejemplo de recursi\u00f3n es la implementaci\u00f3n de la funci\u00f3n factorial , que calcula el factorial de un n\u00famero. -- Funci\u00f3n que calcula el factorial de un n\u00famero factorial :: Int -> Int factorial 0 = 1 factorial n = n * factorial ( n - 1 ) -- Uso de la funci\u00f3n factorial factorial 5 -- 120 Tipos de datos algebraicos \u00b6 Los tipos de datos algebraicos son una forma de definir tipos de datos estructurados en Haskell. Un ejemplo com\u00fan es la definici\u00f3n de un tipo Maybe , que puede ser Just con un valor o Nothing . -- Definici\u00f3n del tipo Maybe data Maybe a = Just a | Nothing -- Funci\u00f3n que devuelve el elemento de una lista en la posici\u00f3n indicada elementoEnPosicion :: [ a ] -> Int -> Maybe a elementoEnPosicion [] _ = Nothing elementoEnPosicion ( x : xs ) pos | pos == 0 = Just x | otherwise = elementoEnPosicion xs ( pos - 1 ) -- Uso de la funci\u00f3n elementoEnPosicion elementoEnPosicion [ 1 , 2 , 3 ] 1 -- Just 2 elementoEnPosicion [ 1 , 2 , 3 ] 5 -- Nothing Ejercicios pr\u00e1cticos \u00b6 Implementar una funci\u00f3n filter' que tome una lista y una funci\u00f3n como argumentos y devuelva una lista con los elementos que cumplan la condici\u00f3n de la funci\u00f3n. Implementar una funci\u00f3n foldr' que tome una funci\u00f3n, un elemento inicial y una lista como argumentos, y aplique la funci\u00f3n a cada elemento de la lista de forma recursiva. Definir un tipo de datos Tree que represente un \u00e1rbol binario y una funci\u00f3n mapTree que tome una funci\u00f3n y un Tree como argumentos y aplique la funci\u00f3n a cada elemento del \u00e1rbol. Implementar una funci\u00f3n maybeLast que tome una lista y devuelva el \u00faltimo elemento si existe, o Nothing en caso contrario. Consejos y mejores pr\u00e1cticas \u00b6 Utilizar funciones de alto orden y composici\u00f3n de funciones para crear c\u00f3digo m\u00e1s modular y reutilizable. Utilizar la recursi\u00f3n para resolver problemas que involucren estructuras de datos recursivas. Definir tipos de datos algebraicos para representar estructuras de datos complejas. Practicar la implementaci\u00f3n de patrones de dise\u00f1o en Haskell para familiarizarse con su uso y aplicaciones.","title":"Patrones de Dise\u00f1o en Haskell"},{"location":"haskel/mid/patrones_de_dise%C3%B1o_en_haskell/#patrones-de-diseno-en-haskell","text":"","title":"Patrones de Dise\u00f1o en Haskell"},{"location":"haskel/mid/patrones_de_dise%C3%B1o_en_haskell/#introduccion","text":"En la programaci\u00f3n funcional, los patrones de dise\u00f1o son t\u00e9cnicas que permiten resolver problemas comunes de forma elegante y eficiente. A diferencia de la programaci\u00f3n orientada a objetos, donde los patrones de dise\u00f1o se basan en la manipulaci\u00f3n de objetos, en Haskell se basan en la manipulaci\u00f3n de funciones. Esto permite una mayor flexibilidad y expresividad en el dise\u00f1o de programas.","title":"Introducci\u00f3n"},{"location":"haskel/mid/patrones_de_dise%C3%B1o_en_haskell/#palabras-clave-y-su-definicion","text":"Patr\u00f3n de dise\u00f1o: Es una soluci\u00f3n general y reutilizable para un problema com\u00fan en el dise\u00f1o de software. Funciones de alto orden: Son funciones que toman como argumento otras funciones o devuelven funciones como resultado. Composici\u00f3n de funciones: Es una t\u00e9cnica que permite combinar dos o m\u00e1s funciones para crear una nueva funci\u00f3n. Recursi\u00f3n: Es una t\u00e9cnica de programaci\u00f3n que consiste en la llamada a una funci\u00f3n dentro de su propia definici\u00f3n. Tipos de datos algebraicos: Son una forma de definir tipos de datos estructurados en Haskell.","title":"Palabras clave y su definici\u00f3n"},{"location":"haskel/mid/patrones_de_dise%C3%B1o_en_haskell/#preguntas-de-repaso","text":"\u00bfQu\u00e9 son los patrones de dise\u00f1o y por qu\u00e9 son \u00fatiles en la programaci\u00f3n funcional? \u00bfEn qu\u00e9 se diferencian los patrones de dise\u00f1o en Haskell de los patrones en la programaci\u00f3n orientada a objetos? \u00bfQu\u00e9 son las funciones de alto orden y c\u00f3mo se utilizan en Haskell? \u00bfQu\u00e9 es la composici\u00f3n de funciones y c\u00f3mo se implementa en Haskell? \u00bfEn qu\u00e9 consiste la recursi\u00f3n y cu\u00e1l es su importancia en la programaci\u00f3n funcional? \u00bfQu\u00e9 son los tipos de datos algebraicos y c\u00f3mo se definen en Haskell?","title":"Preguntas de repaso"},{"location":"haskel/mid/patrones_de_dise%C3%B1o_en_haskell/#ejemplos-de-codigo-en-haskell","text":"","title":"Ejemplos de c\u00f3digo en Haskell"},{"location":"haskel/mid/patrones_de_dise%C3%B1o_en_haskell/#funciones-de-alto-orden","text":"Las funciones de alto orden son un concepto importante en Haskell y se utilizan ampliamente en la implementaci\u00f3n de patrones de dise\u00f1o. Un ejemplo de una funci\u00f3n de alto orden es map , que toma una funci\u00f3n y una lista como argumentos y aplica la funci\u00f3n a cada elemento de la lista, devolviendo una nueva lista con los resultados. -- Funci\u00f3n que suma 1 a cada elemento de la lista sumarUno :: [ Int ] -> [ Int ] sumarUno lista = map ( \\ x -> x + 1 ) lista -- Uso de la funci\u00f3n sumarUno sumarUno [ 1 , 2 , 3 ] -- [2, 3, 4]","title":"Funciones de alto orden"},{"location":"haskel/mid/patrones_de_dise%C3%B1o_en_haskell/#composicion-de-funciones","text":"La composici\u00f3n de funciones es una t\u00e9cnica \u00fatil para combinar dos o m\u00e1s funciones y crear una nueva funci\u00f3n. En Haskell, se utiliza el operador . para componer funciones. -- Funci\u00f3n que devuelve el doble de un n\u00famero doble :: Int -> Int doble x = x * 2 -- Funci\u00f3n que suma 1 al doble de un n\u00famero sumaUnoAlDoble :: Int -> Int sumaUnoAlDoble = doble . ( + 1 ) -- Uso de la funci\u00f3n sumaUnoAlDoble sumaUnoAlDoble 5 -- 12","title":"Composici\u00f3n de funciones"},{"location":"haskel/mid/patrones_de_dise%C3%B1o_en_haskell/#recursion","text":"La recursi\u00f3n es una t\u00e9cnica fundamental en la programaci\u00f3n funcional y se utiliza en muchos patrones de dise\u00f1o. Un ejemplo de recursi\u00f3n es la implementaci\u00f3n de la funci\u00f3n factorial , que calcula el factorial de un n\u00famero. -- Funci\u00f3n que calcula el factorial de un n\u00famero factorial :: Int -> Int factorial 0 = 1 factorial n = n * factorial ( n - 1 ) -- Uso de la funci\u00f3n factorial factorial 5 -- 120","title":"Recursi\u00f3n"},{"location":"haskel/mid/patrones_de_dise%C3%B1o_en_haskell/#tipos-de-datos-algebraicos","text":"Los tipos de datos algebraicos son una forma de definir tipos de datos estructurados en Haskell. Un ejemplo com\u00fan es la definici\u00f3n de un tipo Maybe , que puede ser Just con un valor o Nothing . -- Definici\u00f3n del tipo Maybe data Maybe a = Just a | Nothing -- Funci\u00f3n que devuelve el elemento de una lista en la posici\u00f3n indicada elementoEnPosicion :: [ a ] -> Int -> Maybe a elementoEnPosicion [] _ = Nothing elementoEnPosicion ( x : xs ) pos | pos == 0 = Just x | otherwise = elementoEnPosicion xs ( pos - 1 ) -- Uso de la funci\u00f3n elementoEnPosicion elementoEnPosicion [ 1 , 2 , 3 ] 1 -- Just 2 elementoEnPosicion [ 1 , 2 , 3 ] 5 -- Nothing","title":"Tipos de datos algebraicos"},{"location":"haskel/mid/patrones_de_dise%C3%B1o_en_haskell/#ejercicios-practicos","text":"Implementar una funci\u00f3n filter' que tome una lista y una funci\u00f3n como argumentos y devuelva una lista con los elementos que cumplan la condici\u00f3n de la funci\u00f3n. Implementar una funci\u00f3n foldr' que tome una funci\u00f3n, un elemento inicial y una lista como argumentos, y aplique la funci\u00f3n a cada elemento de la lista de forma recursiva. Definir un tipo de datos Tree que represente un \u00e1rbol binario y una funci\u00f3n mapTree que tome una funci\u00f3n y un Tree como argumentos y aplique la funci\u00f3n a cada elemento del \u00e1rbol. Implementar una funci\u00f3n maybeLast que tome una lista y devuelva el \u00faltimo elemento si existe, o Nothing en caso contrario.","title":"Ejercicios pr\u00e1cticos"},{"location":"haskel/mid/patrones_de_dise%C3%B1o_en_haskell/#consejos-y-mejores-practicas","text":"Utilizar funciones de alto orden y composici\u00f3n de funciones para crear c\u00f3digo m\u00e1s modular y reutilizable. Utilizar la recursi\u00f3n para resolver problemas que involucren estructuras de datos recursivas. Definir tipos de datos algebraicos para representar estructuras de datos complejas. Practicar la implementaci\u00f3n de patrones de dise\u00f1o en Haskell para familiarizarse con su uso y aplicaciones.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"haskel/mid/programaci%C3%B3n_concurrente/","text":"Programaci\u00f3n Concurrente \u00b6 Descripci\u00f3n del M\u00f3dulo \u00b6 En este m\u00f3dulo, aprender\u00e1s a utilizar la programaci\u00f3n concurrente en Haskell, un lenguaje funcional puro que ofrece soporte para la ejecuci\u00f3n de tareas concurrentes de manera eficiente y segura. Conocer\u00e1s las herramientas y t\u00e9cnicas necesarias para trabajar con m\u00faltiples procesos y hilos de ejecuci\u00f3n, as\u00ed como tambi\u00e9n la biblioteca de concurrencia proporcionada por Haskell. 1. Explicaci\u00f3n te\u00f3rica \u00b6 La programaci\u00f3n concurrente se refiere a la ejecuci\u00f3n simult\u00e1nea de m\u00faltiples tareas dentro de un programa. En Haskell, esto se logra a trav\u00e9s de la creaci\u00f3n de procesos y hilos de ejecuci\u00f3n, los cuales pueden ejecutarse de forma paralela o en concurrencia. La diferencia entre estos dos t\u00e9rminos radica en c\u00f3mo se gestionan los recursos del sistema y c\u00f3mo se coordinan las tareas. En la programaci\u00f3n paralela, los procesos o hilos se ejecutan de forma simult\u00e1nea en diferentes n\u00facleos de procesamiento, lo que permite un aumento en el rendimiento y la velocidad de ejecuci\u00f3n. En cambio, en la programaci\u00f3n en concurrencia, los procesos o hilos se ejecutan de forma intercalada en un solo n\u00facleo de procesamiento, compartiendo recursos y coordin\u00e1ndose a trav\u00e9s de mecanismos de sincronizaci\u00f3n. Haskell ofrece soporte para ambas formas de programaci\u00f3n concurrente, lo que permite al programador elegir la mejor opci\u00f3n seg\u00fan las necesidades de su aplicaci\u00f3n. 2. Palabras clave y su definici\u00f3n \u00b6 Proceso: Es una instancia de un programa en ejecuci\u00f3n, que tiene su propio espacio de memoria y recursos asignados. Hilo (Thread): Es una unidad de ejecuci\u00f3n ligera dentro de un proceso, que comparte recursos con otros hilos en el mismo proceso. Paralelismo: Se refiere a la ejecuci\u00f3n simult\u00e1nea de tareas en diferentes n\u00facleos de procesamiento. Concurrencia: Se refiere a la ejecuci\u00f3n intercalada de tareas en un solo n\u00facleo de procesamiento. Sincronizaci\u00f3n: Es el mecanismo utilizado para coordinar la ejecuci\u00f3n de m\u00faltiples procesos o hilos, evitando conflictos y garantizando la consistencia de datos. Biblioteca de concurrencia (Concurrent Haskell): Es una biblioteca de funciones y tipos proporcionada por Haskell para trabajar con procesos y hilos de ejecuci\u00f3n. 3. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la programaci\u00f3n concurrente? \u00bfCu\u00e1l es la diferencia entre programaci\u00f3n paralela y programaci\u00f3n en concurrencia? \u00bfQu\u00e9 ventajas ofrece Haskell en cuanto a la programaci\u00f3n concurrente? \u00bfQu\u00e9 es un proceso en Haskell? \u00bfQu\u00e9 es un hilo de ejecuci\u00f3n en Haskell? \u00bfQu\u00e9 es la sincronizaci\u00f3n y por qu\u00e9 es importante en la programaci\u00f3n concurrente? \u00bfQu\u00e9 es la biblioteca de concurrencia en Haskell? 4. Ejemplos de c\u00f3digo en Haskell \u00b6 Creaci\u00f3n de un proceso \u00b6 import Control.Concurrent ( forkIO ) main = do putStrLn \"Iniciando el proceso principal\" forkIO $ do putStrLn \"Ejecutando proceso en segundo plano\" putStrLn \"Finalizando el proceso principal\" Creaci\u00f3n de un hilo \u00b6 import Control.Concurrent ( forkIO ) import Control.Concurrent.MVar ( newEmptyMVar , takeMVar , putMVar ) main = do putStrLn \"Iniciando el proceso principal\" mvar <- newEmptyMVar forkIO $ do putStrLn \"Ejecutando proceso en segundo plano\" putMVar mvar \"Resultado del proceso\" result <- takeMVar mvar putStrLn result putStrLn \"Finalizando el proceso principal\" 5. Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea un programa en Haskell que ejecute dos procesos en paralelo, donde uno imprima \"\u00a1Hola!\" y el otro imprima \"\u00a1Mundo!\". Modifica el programa anterior para que los procesos se ejecuten en concurrencia en lugar de paralelo. Crea un programa en Haskell que simule una carrera entre dos hilos, donde cada uno avance un paso en cada iteraci\u00f3n. El hilo que primero alcance un total de 10 pasos gana la carrera. Modifica el programa anterior para que los hilos compartan una variable que represente la posici\u00f3n actual en la carrera y se sincronicen para evitar conflictos. 6. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza la programaci\u00f3n paralela cuando necesites un aumento en el rendimiento y la velocidad de ejecuci\u00f3n. Utiliza la programaci\u00f3n en concurrencia cuando necesites coordinar tareas y evitar conflictos en el acceso a recursos compartidos. Utiliza la biblioteca de concurrencia de Haskell para aprovechar al m\u00e1ximo las herramientas y funciones disponibles. Utiliza mecanismos de sincronizaci\u00f3n adecuados para garantizar la consistencia de datos y evitar errores en la ejecuci\u00f3n de procesos y hilos.","title":"Programaci\u00f3n Concurrente"},{"location":"haskel/mid/programaci%C3%B3n_concurrente/#programacion-concurrente","text":"","title":"Programaci\u00f3n Concurrente"},{"location":"haskel/mid/programaci%C3%B3n_concurrente/#descripcion-del-modulo","text":"En este m\u00f3dulo, aprender\u00e1s a utilizar la programaci\u00f3n concurrente en Haskell, un lenguaje funcional puro que ofrece soporte para la ejecuci\u00f3n de tareas concurrentes de manera eficiente y segura. Conocer\u00e1s las herramientas y t\u00e9cnicas necesarias para trabajar con m\u00faltiples procesos y hilos de ejecuci\u00f3n, as\u00ed como tambi\u00e9n la biblioteca de concurrencia proporcionada por Haskell.","title":"Descripci\u00f3n del M\u00f3dulo"},{"location":"haskel/mid/programaci%C3%B3n_concurrente/#1-explicacion-teorica","text":"La programaci\u00f3n concurrente se refiere a la ejecuci\u00f3n simult\u00e1nea de m\u00faltiples tareas dentro de un programa. En Haskell, esto se logra a trav\u00e9s de la creaci\u00f3n de procesos y hilos de ejecuci\u00f3n, los cuales pueden ejecutarse de forma paralela o en concurrencia. La diferencia entre estos dos t\u00e9rminos radica en c\u00f3mo se gestionan los recursos del sistema y c\u00f3mo se coordinan las tareas. En la programaci\u00f3n paralela, los procesos o hilos se ejecutan de forma simult\u00e1nea en diferentes n\u00facleos de procesamiento, lo que permite un aumento en el rendimiento y la velocidad de ejecuci\u00f3n. En cambio, en la programaci\u00f3n en concurrencia, los procesos o hilos se ejecutan de forma intercalada en un solo n\u00facleo de procesamiento, compartiendo recursos y coordin\u00e1ndose a trav\u00e9s de mecanismos de sincronizaci\u00f3n. Haskell ofrece soporte para ambas formas de programaci\u00f3n concurrente, lo que permite al programador elegir la mejor opci\u00f3n seg\u00fan las necesidades de su aplicaci\u00f3n.","title":"1. Explicaci\u00f3n te\u00f3rica"},{"location":"haskel/mid/programaci%C3%B3n_concurrente/#2-palabras-clave-y-su-definicion","text":"Proceso: Es una instancia de un programa en ejecuci\u00f3n, que tiene su propio espacio de memoria y recursos asignados. Hilo (Thread): Es una unidad de ejecuci\u00f3n ligera dentro de un proceso, que comparte recursos con otros hilos en el mismo proceso. Paralelismo: Se refiere a la ejecuci\u00f3n simult\u00e1nea de tareas en diferentes n\u00facleos de procesamiento. Concurrencia: Se refiere a la ejecuci\u00f3n intercalada de tareas en un solo n\u00facleo de procesamiento. Sincronizaci\u00f3n: Es el mecanismo utilizado para coordinar la ejecuci\u00f3n de m\u00faltiples procesos o hilos, evitando conflictos y garantizando la consistencia de datos. Biblioteca de concurrencia (Concurrent Haskell): Es una biblioteca de funciones y tipos proporcionada por Haskell para trabajar con procesos y hilos de ejecuci\u00f3n.","title":"2. Palabras clave y su definici\u00f3n"},{"location":"haskel/mid/programaci%C3%B3n_concurrente/#3-preguntas-de-repaso","text":"\u00bfQu\u00e9 es la programaci\u00f3n concurrente? \u00bfCu\u00e1l es la diferencia entre programaci\u00f3n paralela y programaci\u00f3n en concurrencia? \u00bfQu\u00e9 ventajas ofrece Haskell en cuanto a la programaci\u00f3n concurrente? \u00bfQu\u00e9 es un proceso en Haskell? \u00bfQu\u00e9 es un hilo de ejecuci\u00f3n en Haskell? \u00bfQu\u00e9 es la sincronizaci\u00f3n y por qu\u00e9 es importante en la programaci\u00f3n concurrente? \u00bfQu\u00e9 es la biblioteca de concurrencia en Haskell?","title":"3. Preguntas de repaso"},{"location":"haskel/mid/programaci%C3%B3n_concurrente/#4-ejemplos-de-codigo-en-haskell","text":"","title":"4. Ejemplos de c\u00f3digo en Haskell"},{"location":"haskel/mid/programaci%C3%B3n_concurrente/#creacion-de-un-proceso","text":"import Control.Concurrent ( forkIO ) main = do putStrLn \"Iniciando el proceso principal\" forkIO $ do putStrLn \"Ejecutando proceso en segundo plano\" putStrLn \"Finalizando el proceso principal\"","title":"Creaci\u00f3n de un proceso"},{"location":"haskel/mid/programaci%C3%B3n_concurrente/#creacion-de-un-hilo","text":"import Control.Concurrent ( forkIO ) import Control.Concurrent.MVar ( newEmptyMVar , takeMVar , putMVar ) main = do putStrLn \"Iniciando el proceso principal\" mvar <- newEmptyMVar forkIO $ do putStrLn \"Ejecutando proceso en segundo plano\" putMVar mvar \"Resultado del proceso\" result <- takeMVar mvar putStrLn result putStrLn \"Finalizando el proceso principal\"","title":"Creaci\u00f3n de un hilo"},{"location":"haskel/mid/programaci%C3%B3n_concurrente/#5-ejercicios-practicos-con-instrucciones-claras","text":"Crea un programa en Haskell que ejecute dos procesos en paralelo, donde uno imprima \"\u00a1Hola!\" y el otro imprima \"\u00a1Mundo!\". Modifica el programa anterior para que los procesos se ejecuten en concurrencia en lugar de paralelo. Crea un programa en Haskell que simule una carrera entre dos hilos, donde cada uno avance un paso en cada iteraci\u00f3n. El hilo que primero alcance un total de 10 pasos gana la carrera. Modifica el programa anterior para que los hilos compartan una variable que represente la posici\u00f3n actual en la carrera y se sincronicen para evitar conflictos.","title":"5. Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"haskel/mid/programaci%C3%B3n_concurrente/#6-consejos-o-mejores-practicas","text":"Utiliza la programaci\u00f3n paralela cuando necesites un aumento en el rendimiento y la velocidad de ejecuci\u00f3n. Utiliza la programaci\u00f3n en concurrencia cuando necesites coordinar tareas y evitar conflictos en el acceso a recursos compartidos. Utiliza la biblioteca de concurrencia de Haskell para aprovechar al m\u00e1ximo las herramientas y funciones disponibles. Utiliza mecanismos de sincronizaci\u00f3n adecuados para garantizar la consistencia de datos y evitar errores en la ejecuci\u00f3n de procesos y hilos.","title":"6. Consejos o mejores pr\u00e1cticas"},{"location":"haskel/mid/programaci%C3%B3n_orientada_a_objetos/","text":"Programaci\u00f3n Orientada a Objetos \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 La Programaci\u00f3n Orientada a Objetos (POO) es un paradigma de programaci\u00f3n en el que se modelan los programas como una colecci\u00f3n de objetos que interact\u00faan entre s\u00ed. Estos objetos tienen caracter\u00edsticas (atributos) y comportamientos (m\u00e9todos) que definen su estado y c\u00f3mo se relacionan con otros objetos. En POO, el c\u00f3digo se organiza en clases, que son plantillas para crear objetos. Cada objeto es una instancia de una clase y puede tener sus propios valores para los atributos y comportamientos definidos por la clase. La POO se basa en cuatro conceptos fundamentales: abstracci\u00f3n, encapsulamiento, herencia y polimorfismo. La abstracci\u00f3n se refiere a la capacidad de modelar objetos en t\u00e9rminos de sus caracter\u00edsticas y comportamientos esenciales, mientras que el encapsulamiento se encarga de ocultar los detalles internos de un objeto y solo permitir el acceso a trav\u00e9s de m\u00e9todos definidos. La herencia permite crear nuevas clases a partir de clases existentes, heredando sus caracter\u00edsticas y comportamientos. Por \u00faltimo, el polimorfismo hace posible que un objeto pueda tener diferentes formas y comportamientos dependiendo del contexto en el que se use. Palabras clave y su definici\u00f3n \u00b6 Objeto: Es una instancia de una clase en POO, que tiene atributos y m\u00e9todos. Clase: Es una plantilla para crear objetos que define sus atributos y m\u00e9todos. Atributo: Es una caracter\u00edstica de un objeto que define su estado. M\u00e9todo: Es un comportamiento de un objeto que define c\u00f3mo interact\u00faa con otros objetos. Abstracci\u00f3n: Es el proceso de modelar objetos en t\u00e9rminos de sus caracter\u00edsticas y comportamientos esenciales. Encapsulamiento: Es la t\u00e9cnica de ocultar los detalles internos de un objeto y solo permitir el acceso a trav\u00e9s de m\u00e9todos definidos. Herencia: Es la capacidad de crear nuevas clases a partir de clases existentes, heredando sus caracter\u00edsticas y comportamientos. Polimorfismo: Es la capacidad de un objeto de tener diferentes formas y comportamientos dependiendo del contexto en el que se use. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es un objeto en POO? \u00bfQu\u00e9 es una clase y para qu\u00e9 se utiliza? \u00bfQu\u00e9 son los atributos y m\u00e9todos en POO? \u00bfCu\u00e1les son los cuatro conceptos fundamentales de POO? \u00bfQu\u00e9 es el polimorfismo en POO y para qu\u00e9 se utiliza? Ejemplos de c\u00f3digo en Haskell \u00b6 En Haskell, se pueden utilizar la extensi\u00f3n de tipos de datos para implementar POO. A continuaci\u00f3n, se muestra un ejemplo de una clase \"Persona\" con atributos \"nombre\" y \"edad\" y un m\u00e9todo \"saludar\": {-# LANGUAGE ExistentialQuantification #-} data Persona = Persona { nombre :: String , edad :: Int } saludar :: Persona -> String saludar ( Persona nombre _ ) = \"Hola, mi nombre es \" ++ nombre Para crear una instancia de la clase \"Persona\" y llamar al m\u00e9todo \"saludar\", se puede hacer lo siguiente: main = do let p = Persona \"Juan\" 25 putStrLn ( saludar p ) -- imprimir\u00e1 \"Hola, mi nombre es Juan\" Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una clase \"CuentaBancaria\" con los atributos \"titular\", \"saldo\" y \"tipoCuenta\" (ahorro o corriente). Implementa un m\u00e9todo \"depositar\" que reciba un valor y lo sume al saldo de la cuenta. Crea una instancia de la clase \"CuentaBancaria\" y realiza una serie de dep\u00f3sitos y retiros utilizando el m\u00e9todo \"depositar\" y otro m\u00e9todo \"retirar\" que reste un valor del saldo. Crea una subclase \"CuentaAhorro\" que herede de \"CuentaBancaria\" y tenga un atributo adicional \"interes\" y un m\u00e9todo \"calcularInteres\" que calcule el inter\u00e9s a partir del saldo y lo sume al mismo. Crea una instancia de la subclase \"CuentaAhorro\" y realiza una serie de dep\u00f3sitos y retiros, adem\u00e1s de llamar al m\u00e9todo \"calcularInteres\" para ver c\u00f3mo afecta al saldo. Consejos o mejores pr\u00e1cticas \u00b6 Utilizar la abstracci\u00f3n y encapsulamiento para mantener el c\u00f3digo modular y f\u00e1cil de mantener. Utilizar la herencia y el polimorfismo para reutilizar c\u00f3digo y tener una estructura m\u00e1s escalable. Definir nombres claros y descriptivos para las clases, atributos y m\u00e9todos. Utilizar la extensi\u00f3n de tipos de datos en Haskell para implementar POO de forma m\u00e1s eficiente.","title":"Programaci\u00f3n Orientada a Objetos"},{"location":"haskel/mid/programaci%C3%B3n_orientada_a_objetos/#programacion-orientada-a-objetos","text":"","title":"Programaci\u00f3n Orientada a Objetos"},{"location":"haskel/mid/programaci%C3%B3n_orientada_a_objetos/#explicacion-teorica","text":"La Programaci\u00f3n Orientada a Objetos (POO) es un paradigma de programaci\u00f3n en el que se modelan los programas como una colecci\u00f3n de objetos que interact\u00faan entre s\u00ed. Estos objetos tienen caracter\u00edsticas (atributos) y comportamientos (m\u00e9todos) que definen su estado y c\u00f3mo se relacionan con otros objetos. En POO, el c\u00f3digo se organiza en clases, que son plantillas para crear objetos. Cada objeto es una instancia de una clase y puede tener sus propios valores para los atributos y comportamientos definidos por la clase. La POO se basa en cuatro conceptos fundamentales: abstracci\u00f3n, encapsulamiento, herencia y polimorfismo. La abstracci\u00f3n se refiere a la capacidad de modelar objetos en t\u00e9rminos de sus caracter\u00edsticas y comportamientos esenciales, mientras que el encapsulamiento se encarga de ocultar los detalles internos de un objeto y solo permitir el acceso a trav\u00e9s de m\u00e9todos definidos. La herencia permite crear nuevas clases a partir de clases existentes, heredando sus caracter\u00edsticas y comportamientos. Por \u00faltimo, el polimorfismo hace posible que un objeto pueda tener diferentes formas y comportamientos dependiendo del contexto en el que se use.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"haskel/mid/programaci%C3%B3n_orientada_a_objetos/#palabras-clave-y-su-definicion","text":"Objeto: Es una instancia de una clase en POO, que tiene atributos y m\u00e9todos. Clase: Es una plantilla para crear objetos que define sus atributos y m\u00e9todos. Atributo: Es una caracter\u00edstica de un objeto que define su estado. M\u00e9todo: Es un comportamiento de un objeto que define c\u00f3mo interact\u00faa con otros objetos. Abstracci\u00f3n: Es el proceso de modelar objetos en t\u00e9rminos de sus caracter\u00edsticas y comportamientos esenciales. Encapsulamiento: Es la t\u00e9cnica de ocultar los detalles internos de un objeto y solo permitir el acceso a trav\u00e9s de m\u00e9todos definidos. Herencia: Es la capacidad de crear nuevas clases a partir de clases existentes, heredando sus caracter\u00edsticas y comportamientos. Polimorfismo: Es la capacidad de un objeto de tener diferentes formas y comportamientos dependiendo del contexto en el que se use.","title":"Palabras clave y su definici\u00f3n"},{"location":"haskel/mid/programaci%C3%B3n_orientada_a_objetos/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es un objeto en POO? \u00bfQu\u00e9 es una clase y para qu\u00e9 se utiliza? \u00bfQu\u00e9 son los atributos y m\u00e9todos en POO? \u00bfCu\u00e1les son los cuatro conceptos fundamentales de POO? \u00bfQu\u00e9 es el polimorfismo en POO y para qu\u00e9 se utiliza?","title":"Preguntas de repaso"},{"location":"haskel/mid/programaci%C3%B3n_orientada_a_objetos/#ejemplos-de-codigo-en-haskell","text":"En Haskell, se pueden utilizar la extensi\u00f3n de tipos de datos para implementar POO. A continuaci\u00f3n, se muestra un ejemplo de una clase \"Persona\" con atributos \"nombre\" y \"edad\" y un m\u00e9todo \"saludar\": {-# LANGUAGE ExistentialQuantification #-} data Persona = Persona { nombre :: String , edad :: Int } saludar :: Persona -> String saludar ( Persona nombre _ ) = \"Hola, mi nombre es \" ++ nombre Para crear una instancia de la clase \"Persona\" y llamar al m\u00e9todo \"saludar\", se puede hacer lo siguiente: main = do let p = Persona \"Juan\" 25 putStrLn ( saludar p ) -- imprimir\u00e1 \"Hola, mi nombre es Juan\"","title":"Ejemplos de c\u00f3digo en Haskell"},{"location":"haskel/mid/programaci%C3%B3n_orientada_a_objetos/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una clase \"CuentaBancaria\" con los atributos \"titular\", \"saldo\" y \"tipoCuenta\" (ahorro o corriente). Implementa un m\u00e9todo \"depositar\" que reciba un valor y lo sume al saldo de la cuenta. Crea una instancia de la clase \"CuentaBancaria\" y realiza una serie de dep\u00f3sitos y retiros utilizando el m\u00e9todo \"depositar\" y otro m\u00e9todo \"retirar\" que reste un valor del saldo. Crea una subclase \"CuentaAhorro\" que herede de \"CuentaBancaria\" y tenga un atributo adicional \"interes\" y un m\u00e9todo \"calcularInteres\" que calcule el inter\u00e9s a partir del saldo y lo sume al mismo. Crea una instancia de la subclase \"CuentaAhorro\" y realiza una serie de dep\u00f3sitos y retiros, adem\u00e1s de llamar al m\u00e9todo \"calcularInteres\" para ver c\u00f3mo afecta al saldo.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"haskel/mid/programaci%C3%B3n_orientada_a_objetos/#consejos-o-mejores-practicas","text":"Utilizar la abstracci\u00f3n y encapsulamiento para mantener el c\u00f3digo modular y f\u00e1cil de mantener. Utilizar la herencia y el polimorfismo para reutilizar c\u00f3digo y tener una estructura m\u00e1s escalable. Definir nombres claros y descriptivos para las clases, atributos y m\u00e9todos. Utilizar la extensi\u00f3n de tipos de datos en Haskell para implementar POO de forma m\u00e1s eficiente.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"haskel/mid/testing_y_debugging/","text":"Testing y Debugging \u00b6 En el desarrollo de software, es importante asegurar la calidad del c\u00f3digo para evitar errores y fallos en la aplicaci\u00f3n. Para lograr esto, existen diversas t\u00e9cnicas y herramientas, entre las cuales se encuentran el testing y el debugging. Explicaci\u00f3n te\u00f3rica \u00b6 El testing consiste en probar el c\u00f3digo de una aplicaci\u00f3n para verificar que cumpla con los requerimientos y funcione correctamente. Esto se logra mediante la creaci\u00f3n de casos de prueba que cubran todas las posibles situaciones que puedan ocurrir en la aplicaci\u00f3n. El objetivo del testing es detectar errores y fallos en el c\u00f3digo antes de que llegue a producci\u00f3n. Por otro lado, el debugging es el proceso de encontrar y corregir errores en el c\u00f3digo. Esto se logra utilizando herramientas de depuraci\u00f3n que permiten examinar el estado del programa en tiempo de ejecuci\u00f3n, identificar el origen del error y solucionarlo. Palabras clave y su definici\u00f3n \u00b6 Testing: proceso de probar el c\u00f3digo de una aplicaci\u00f3n para verificar su correcto funcionamiento. Caso de prueba: conjunto de condiciones y datos de entrada que se utilizan para probar una funcionalidad espec\u00edfica del c\u00f3digo. Depuraci\u00f3n (debugging): proceso de encontrar y solucionar errores en el c\u00f3digo. Herramientas de depuraci\u00f3n: programas o utilidades que permiten examinar el estado del programa en tiempo de ejecuci\u00f3n para encontrar errores. Pruebas unitarias: pruebas individuales que se realizan en cada componente o unidad de c\u00f3digo. Pruebas de integraci\u00f3n: pruebas que se realizan en la interacci\u00f3n entre diferentes componentes del c\u00f3digo. Pruebas de aceptaci\u00f3n: pruebas que se realizan para verificar que la aplicaci\u00f3n cumpla con los requerimientos del usuario. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es el testing y cu\u00e1l es su objetivo? \u00bfCu\u00e1l es la diferencia entre testing y debugging? \u00bfQu\u00e9 son las herramientas de depuraci\u00f3n y para qu\u00e9 se utilizan? \u00bfCu\u00e1les son los tipos de pruebas m\u00e1s comunes en el desarrollo de software? \u00bfQu\u00e9 es un caso de prueba y para qu\u00e9 se utiliza? Ejemplos de c\u00f3digo en Haskell \u00b6 Ejemplo de una prueba unitaria en Haskell: -- Funci\u00f3n que suma dos n\u00fameros sumar :: Int -> Int -> Int sumar x y = x + y -- Prueba unitaria main = do if sumar 2 3 == 5 then putStrLn \"Prueba aprobada\" else putStrLn \"Prueba fallida\" Ejemplo de una prueba de integraci\u00f3n en Haskell: -- Funci\u00f3n que devuelve la suma de los elementos de una lista sumarLista :: [ Int ] -> Int sumarLista [] = 0 sumarLista ( x : xs ) = x + sumarLista xs -- Prueba de integraci\u00f3n main = do let lista = [ 1, 2, 3, 4, 5 ] if sumarLista lista == 15 then putStrLn \"Prueba aprobada\" else putStrLn \"Prueba fallida\" Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una funci\u00f3n en Haskell que calcule el factorial de un n\u00famero. Realiza pruebas unitarias para comprobar que la funci\u00f3n anterior funciona correctamente. Crea una funci\u00f3n que reciba una lista de n\u00fameros y devuelva el n\u00famero m\u00e1s grande de la lista. Realiza una prueba de integraci\u00f3n para comprobar que la funci\u00f3n anterior devuelve el resultado correcto. Crea una funci\u00f3n en Haskell que determine si un n\u00famero es primo o no. Realiza una prueba de aceptaci\u00f3n para verificar que la funci\u00f3n anterior devuelve el resultado correcto para diferentes n\u00fameros. Consejos o mejores pr\u00e1cticas \u00b6 Realizar pruebas de forma regular durante el desarrollo del c\u00f3digo. Utilizar herramientas de depuraci\u00f3n para encontrar y solucionar errores de forma eficiente. Utilizar diferentes tipos de pruebas para asegurar la calidad del c\u00f3digo. Incluir casos de prueba para situaciones extremas y casos l\u00edmite. Automatizar las pruebas para facilitar su ejecuci\u00f3n y detecci\u00f3n de errores. Utilizar comentarios y mensajes de error claros en el c\u00f3digo para facilitar el debugging. Realizar pruebas en diferentes entornos y condiciones para asegurar la estabilidad y compatibilidad del c\u00f3digo.","title":"Testing y Debugging"},{"location":"haskel/mid/testing_y_debugging/#testing-y-debugging","text":"En el desarrollo de software, es importante asegurar la calidad del c\u00f3digo para evitar errores y fallos en la aplicaci\u00f3n. Para lograr esto, existen diversas t\u00e9cnicas y herramientas, entre las cuales se encuentran el testing y el debugging.","title":"Testing y Debugging"},{"location":"haskel/mid/testing_y_debugging/#explicacion-teorica","text":"El testing consiste en probar el c\u00f3digo de una aplicaci\u00f3n para verificar que cumpla con los requerimientos y funcione correctamente. Esto se logra mediante la creaci\u00f3n de casos de prueba que cubran todas las posibles situaciones que puedan ocurrir en la aplicaci\u00f3n. El objetivo del testing es detectar errores y fallos en el c\u00f3digo antes de que llegue a producci\u00f3n. Por otro lado, el debugging es el proceso de encontrar y corregir errores en el c\u00f3digo. Esto se logra utilizando herramientas de depuraci\u00f3n que permiten examinar el estado del programa en tiempo de ejecuci\u00f3n, identificar el origen del error y solucionarlo.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"haskel/mid/testing_y_debugging/#palabras-clave-y-su-definicion","text":"Testing: proceso de probar el c\u00f3digo de una aplicaci\u00f3n para verificar su correcto funcionamiento. Caso de prueba: conjunto de condiciones y datos de entrada que se utilizan para probar una funcionalidad espec\u00edfica del c\u00f3digo. Depuraci\u00f3n (debugging): proceso de encontrar y solucionar errores en el c\u00f3digo. Herramientas de depuraci\u00f3n: programas o utilidades que permiten examinar el estado del programa en tiempo de ejecuci\u00f3n para encontrar errores. Pruebas unitarias: pruebas individuales que se realizan en cada componente o unidad de c\u00f3digo. Pruebas de integraci\u00f3n: pruebas que se realizan en la interacci\u00f3n entre diferentes componentes del c\u00f3digo. Pruebas de aceptaci\u00f3n: pruebas que se realizan para verificar que la aplicaci\u00f3n cumpla con los requerimientos del usuario.","title":"Palabras clave y su definici\u00f3n"},{"location":"haskel/mid/testing_y_debugging/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es el testing y cu\u00e1l es su objetivo? \u00bfCu\u00e1l es la diferencia entre testing y debugging? \u00bfQu\u00e9 son las herramientas de depuraci\u00f3n y para qu\u00e9 se utilizan? \u00bfCu\u00e1les son los tipos de pruebas m\u00e1s comunes en el desarrollo de software? \u00bfQu\u00e9 es un caso de prueba y para qu\u00e9 se utiliza?","title":"Preguntas de repaso"},{"location":"haskel/mid/testing_y_debugging/#ejemplos-de-codigo-en-haskell","text":"Ejemplo de una prueba unitaria en Haskell: -- Funci\u00f3n que suma dos n\u00fameros sumar :: Int -> Int -> Int sumar x y = x + y -- Prueba unitaria main = do if sumar 2 3 == 5 then putStrLn \"Prueba aprobada\" else putStrLn \"Prueba fallida\" Ejemplo de una prueba de integraci\u00f3n en Haskell: -- Funci\u00f3n que devuelve la suma de los elementos de una lista sumarLista :: [ Int ] -> Int sumarLista [] = 0 sumarLista ( x : xs ) = x + sumarLista xs -- Prueba de integraci\u00f3n main = do let lista = [ 1, 2, 3, 4, 5 ] if sumarLista lista == 15 then putStrLn \"Prueba aprobada\" else putStrLn \"Prueba fallida\"","title":"Ejemplos de c\u00f3digo en Haskell"},{"location":"haskel/mid/testing_y_debugging/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una funci\u00f3n en Haskell que calcule el factorial de un n\u00famero. Realiza pruebas unitarias para comprobar que la funci\u00f3n anterior funciona correctamente. Crea una funci\u00f3n que reciba una lista de n\u00fameros y devuelva el n\u00famero m\u00e1s grande de la lista. Realiza una prueba de integraci\u00f3n para comprobar que la funci\u00f3n anterior devuelve el resultado correcto. Crea una funci\u00f3n en Haskell que determine si un n\u00famero es primo o no. Realiza una prueba de aceptaci\u00f3n para verificar que la funci\u00f3n anterior devuelve el resultado correcto para diferentes n\u00fameros.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"haskel/mid/testing_y_debugging/#consejos-o-mejores-practicas","text":"Realizar pruebas de forma regular durante el desarrollo del c\u00f3digo. Utilizar herramientas de depuraci\u00f3n para encontrar y solucionar errores de forma eficiente. Utilizar diferentes tipos de pruebas para asegurar la calidad del c\u00f3digo. Incluir casos de prueba para situaciones extremas y casos l\u00edmite. Automatizar las pruebas para facilitar su ejecuci\u00f3n y detecci\u00f3n de errores. Utilizar comentarios y mensajes de error claros en el c\u00f3digo para facilitar el debugging. Realizar pruebas en diferentes entornos y condiciones para asegurar la estabilidad y compatibilidad del c\u00f3digo.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"haskel/mid/tipos_de_datos_parametrizados/","text":"Tipos de Datos Parametrizados \u00b6 En Haskell, los tipos de datos parametrizados nos permiten crear estructuras de datos flexibles que pueden almacenar diferentes tipos de datos. Esto es posible gracias a los par\u00e1metros que se pueden especificar al crear el tipo de dato, permiti\u00e9ndonos definir estructuras gen\u00e9ricas que puedan ser utilizadas con diferentes tipos de datos. Explicaci\u00f3n te\u00f3rica \u00b6 Los tipos de datos parametrizados se definen mediante el uso de variables de tipo, que son indicadas con una letra min\u00fascula en su nombre. Al crear una estructura de datos parametrizada, estas variables de tipo se utilizan en lugar de un tipo de dato espec\u00edfico, permitiendo as\u00ed que la estructura pueda trabajar con diferentes tipos de datos. Los tipos de datos parametrizados se pueden utilizar en diferentes estructuras de datos, como listas, \u00e1rboles, tuplas, entre otras. Esto nos permite crear estructuras m\u00e1s flexibles y modulares, ya que podemos definir una estructura una vez y luego utilizarla con diferentes tipos de datos. Palabras clave y su definici\u00f3n \u00b6 Tipo de dato parametrizado: es un tipo de dato que utiliza variables de tipo en su definici\u00f3n, permitiendo su uso con diferentes tipos de datos. Variable de tipo: es una letra min\u00fascula utilizada en la definici\u00f3n de un tipo de dato parametrizado, que representa un tipo de dato desconocido. Polimorfismo: es la capacidad de una funci\u00f3n o estructura de datos para trabajar con diferentes tipos de datos. Inferencia de tipos: es un proceso en Haskell que permite deducir el tipo de una expresi\u00f3n sin necesidad de ser especificado expl\u00edcitamente. Preguntas de repaso \u00b6 \u00bfQu\u00e9 son los tipos de datos parametrizados en Haskell? \u00bfC\u00f3mo se definen los tipos de datos parametrizados? \u00bfQu\u00e9 es una variable de tipo? \u00bfEn qu\u00e9 estructuras de datos se pueden utilizar los tipos de datos parametrizados? \u00bfQu\u00e9 es el polimorfismo en Haskell? \u00bfCu\u00e1l es la ventaja de utilizar tipos de datos parametrizados en la creaci\u00f3n de estructuras de datos? Ejemplos de c\u00f3digo en Haskell \u00b6 Lista parametrizada \u00b6 data Lista a = Vacio | Cons a ( Lista a ) En este ejemplo, hemos creado una estructura de datos llamada \"Lista\" que es parametrizada por una variable de tipo \"a\". Esto significa que podemos crear una lista de cualquier tipo de datos, como por ejemplo una lista de enteros: \"Lista Int\", o una lista de cadenas: \"Lista String\". Funci\u00f3n polim\u00f3rfica \u00b6 suma :: Num a => a -> a -> a suma x y = x + y La funci\u00f3n \"suma\" es polim\u00f3rfica ya que puede trabajar con diferentes tipos de datos num\u00e9ricos, como enteros, flotantes o incluso n\u00fameros complejos. Esto es posible gracias al uso de la clase de tipo \"Num\", que proporciona las operaciones num\u00e9ricas b\u00e1sicas. Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una estructura de datos parametrizada llamada \"Arbol\" que pueda almacenar cualquier tipo de dato. Define una funci\u00f3n polim\u00f3rfica llamada \"maximo\" que reciba una lista de elementos y retorne el elemento de mayor valor. Crea una funci\u00f3n llamada \"longitud\" que reciba una lista y retorne su longitud, utilizando la inferencia de tipos. Crea una estructura de datos parametrizada llamada \"Pareja\" que almacene dos elementos de cualquier tipo. Define una funci\u00f3n llamada \"concatenar\" que reciba dos listas y retorne una lista con todos los elementos de ambas listas, utilizando la inferencia de tipos. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza nombres de variables de tipo descriptivos para facilitar la comprensi\u00f3n de la estructura de datos. Aseg\u00farate de que la funci\u00f3n o estructura de datos sea realmente polim\u00f3rfica, es decir, que pueda trabajar con diferentes tipos de datos sin necesidad de hacer cambios en su definici\u00f3n. Aprovecha la inferencia de tipos para evitar tener que especificar los tipos de datos en cada llamada a la funci\u00f3n. Practica la creaci\u00f3n de estructuras de datos parametrizadas y su uso en diferentes tipos de problemas para familiarizarte con su funcionamiento.","title":"Tipos de Datos Parametrizados"},{"location":"haskel/mid/tipos_de_datos_parametrizados/#tipos-de-datos-parametrizados","text":"En Haskell, los tipos de datos parametrizados nos permiten crear estructuras de datos flexibles que pueden almacenar diferentes tipos de datos. Esto es posible gracias a los par\u00e1metros que se pueden especificar al crear el tipo de dato, permiti\u00e9ndonos definir estructuras gen\u00e9ricas que puedan ser utilizadas con diferentes tipos de datos.","title":"Tipos de Datos Parametrizados"},{"location":"haskel/mid/tipos_de_datos_parametrizados/#explicacion-teorica","text":"Los tipos de datos parametrizados se definen mediante el uso de variables de tipo, que son indicadas con una letra min\u00fascula en su nombre. Al crear una estructura de datos parametrizada, estas variables de tipo se utilizan en lugar de un tipo de dato espec\u00edfico, permitiendo as\u00ed que la estructura pueda trabajar con diferentes tipos de datos. Los tipos de datos parametrizados se pueden utilizar en diferentes estructuras de datos, como listas, \u00e1rboles, tuplas, entre otras. Esto nos permite crear estructuras m\u00e1s flexibles y modulares, ya que podemos definir una estructura una vez y luego utilizarla con diferentes tipos de datos.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"haskel/mid/tipos_de_datos_parametrizados/#palabras-clave-y-su-definicion","text":"Tipo de dato parametrizado: es un tipo de dato que utiliza variables de tipo en su definici\u00f3n, permitiendo su uso con diferentes tipos de datos. Variable de tipo: es una letra min\u00fascula utilizada en la definici\u00f3n de un tipo de dato parametrizado, que representa un tipo de dato desconocido. Polimorfismo: es la capacidad de una funci\u00f3n o estructura de datos para trabajar con diferentes tipos de datos. Inferencia de tipos: es un proceso en Haskell que permite deducir el tipo de una expresi\u00f3n sin necesidad de ser especificado expl\u00edcitamente.","title":"Palabras clave y su definici\u00f3n"},{"location":"haskel/mid/tipos_de_datos_parametrizados/#preguntas-de-repaso","text":"\u00bfQu\u00e9 son los tipos de datos parametrizados en Haskell? \u00bfC\u00f3mo se definen los tipos de datos parametrizados? \u00bfQu\u00e9 es una variable de tipo? \u00bfEn qu\u00e9 estructuras de datos se pueden utilizar los tipos de datos parametrizados? \u00bfQu\u00e9 es el polimorfismo en Haskell? \u00bfCu\u00e1l es la ventaja de utilizar tipos de datos parametrizados en la creaci\u00f3n de estructuras de datos?","title":"Preguntas de repaso"},{"location":"haskel/mid/tipos_de_datos_parametrizados/#ejemplos-de-codigo-en-haskell","text":"","title":"Ejemplos de c\u00f3digo en Haskell"},{"location":"haskel/mid/tipos_de_datos_parametrizados/#lista-parametrizada","text":"data Lista a = Vacio | Cons a ( Lista a ) En este ejemplo, hemos creado una estructura de datos llamada \"Lista\" que es parametrizada por una variable de tipo \"a\". Esto significa que podemos crear una lista de cualquier tipo de datos, como por ejemplo una lista de enteros: \"Lista Int\", o una lista de cadenas: \"Lista String\".","title":"Lista parametrizada"},{"location":"haskel/mid/tipos_de_datos_parametrizados/#funcion-polimorfica","text":"suma :: Num a => a -> a -> a suma x y = x + y La funci\u00f3n \"suma\" es polim\u00f3rfica ya que puede trabajar con diferentes tipos de datos num\u00e9ricos, como enteros, flotantes o incluso n\u00fameros complejos. Esto es posible gracias al uso de la clase de tipo \"Num\", que proporciona las operaciones num\u00e9ricas b\u00e1sicas.","title":"Funci\u00f3n polim\u00f3rfica"},{"location":"haskel/mid/tipos_de_datos_parametrizados/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una estructura de datos parametrizada llamada \"Arbol\" que pueda almacenar cualquier tipo de dato. Define una funci\u00f3n polim\u00f3rfica llamada \"maximo\" que reciba una lista de elementos y retorne el elemento de mayor valor. Crea una funci\u00f3n llamada \"longitud\" que reciba una lista y retorne su longitud, utilizando la inferencia de tipos. Crea una estructura de datos parametrizada llamada \"Pareja\" que almacene dos elementos de cualquier tipo. Define una funci\u00f3n llamada \"concatenar\" que reciba dos listas y retorne una lista con todos los elementos de ambas listas, utilizando la inferencia de tipos.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"haskel/mid/tipos_de_datos_parametrizados/#consejos-o-mejores-practicas","text":"Utiliza nombres de variables de tipo descriptivos para facilitar la comprensi\u00f3n de la estructura de datos. Aseg\u00farate de que la funci\u00f3n o estructura de datos sea realmente polim\u00f3rfica, es decir, que pueda trabajar con diferentes tipos de datos sin necesidad de hacer cambios en su definici\u00f3n. Aprovecha la inferencia de tipos para evitar tener que especificar los tipos de datos en cada llamada a la funci\u00f3n. Practica la creaci\u00f3n de estructuras de datos parametrizadas y su uso en diferentes tipos de problemas para familiarizarte con su funcionamiento.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"haskel/sr/desarrollo_de_aplicaciones_web/","text":"Desarrollo de Aplicaciones Web en Haskell \u00b6 En la era digital actual, el desarrollo de aplicaciones web se ha convertido en una parte fundamental de la industria tecnol\u00f3gica. El uso de lenguajes de programaci\u00f3n funcionales como Haskell para crear aplicaciones web ofrece una serie de ventajas, como una mayor seguridad y escalabilidad. En este m\u00f3dulo, aprender\u00e1s c\u00f3mo utilizar Haskell para desarrollar aplicaciones web modernas y robustas. Teor\u00eda \u00b6 Haskell es un lenguaje de programaci\u00f3n funcional puro, lo que significa que se basa en la evaluaci\u00f3n de expresiones para realizar operaciones y no utiliza variables mutables. Esto lo hace ideal para el desarrollo de aplicaciones web, ya que permite una mejor gesti\u00f3n de los datos y reduce la posibilidad de errores. Algunos de los frameworks m\u00e1s populares para el desarrollo web en Haskell son Yesod y Snap. Estos frameworks proporcionan una estructura para crear aplicaciones web de forma r\u00e1pida y eficiente, utilizando los principios de la programaci\u00f3n funcional. Adem\u00e1s de los frameworks, Haskell tambi\u00e9n cuenta con una amplia gama de bibliotecas y herramientas que facilitan el desarrollo de aplicaciones web, como Servant, que permite crear APIs de forma sencilla y segura, y BlazeHTML, para generar c\u00f3digo HTML de manera eficiente. Palabras clave \u00b6 Haskell: Lenguaje de programaci\u00f3n funcional puro utilizado para el desarrollo de aplicaciones web. Yesod: Framework de Haskell para la creaci\u00f3n de aplicaciones web. Snap: Otro framework de Haskell para el desarrollo web. Servant: Biblioteca para la creaci\u00f3n de APIs en Haskell. BlazeHTML: Biblioteca para la generaci\u00f3n de c\u00f3digo HTML en Haskell. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es Haskell y por qu\u00e9 es adecuado para el desarrollo de aplicaciones web? \u00bfCu\u00e1les son algunos de los frameworks y bibliotecas m\u00e1s populares para el desarrollo web en Haskell? \u00bfQu\u00e9 es Servant y para qu\u00e9 se utiliza? \u00bfC\u00f3mo funciona la evaluaci\u00f3n de expresiones en Haskell? Ejemplos de c\u00f3digo \u00b6 Creaci\u00f3n de una aplicaci\u00f3n web simple con Yesod: \u00b6 {-# LANGUAGE OverloadedStrings #-} import Yesod data HelloWorld = HelloWorld instance Yesod HelloWorld getHomeR :: Handler Html getHomeR = defaultLayout [ whamlet | Hello World !| ] main :: IO () main = warp 3000 HelloWorld Creaci\u00f3n de una API con Servant: \u00b6 {-# LANGUAGE DataKinds #-} {-# LANGUAGE TypeOperators #-} import Servant type API = \"hello\" :> Get '[PlainText] String server :: Server API server = return \"Hello World!\" app :: Application app = serve ( Proxy :: Proxy API ) server Ejercicios pr\u00e1cticos \u00b6 Crea una aplicaci\u00f3n web utilizando el framework Snap que muestre una lista de nombres y edades. Utiliza Servant para crear una API que reciba dos n\u00fameros como par\u00e1metros y devuelva su suma. Implementa una funci\u00f3n en Haskell que convierta una lista de n\u00fameros en una lista de HTML con etiquetas . Consejos y mejores pr\u00e1cticas \u00b6 Utiliza los tipos de datos de Haskell para asegurar la integridad de tus datos. Aprovecha las ventajas de la evaluaci\u00f3n perezosa para mejorar el rendimiento de tus aplicaciones web. Utiliza los frameworks y bibliotecas de Haskell para facilitar el desarrollo y asegurar la calidad de tu c\u00f3digo. Mant\u00e9n tu c\u00f3digo limpio y modular para facilitar su mantenimiento y escalabilidad.","title":"Desarrollo de Aplicaciones Web en Haskell"},{"location":"haskel/sr/desarrollo_de_aplicaciones_web/#desarrollo-de-aplicaciones-web-en-haskell","text":"En la era digital actual, el desarrollo de aplicaciones web se ha convertido en una parte fundamental de la industria tecnol\u00f3gica. El uso de lenguajes de programaci\u00f3n funcionales como Haskell para crear aplicaciones web ofrece una serie de ventajas, como una mayor seguridad y escalabilidad. En este m\u00f3dulo, aprender\u00e1s c\u00f3mo utilizar Haskell para desarrollar aplicaciones web modernas y robustas.","title":"Desarrollo de Aplicaciones Web en Haskell"},{"location":"haskel/sr/desarrollo_de_aplicaciones_web/#teoria","text":"Haskell es un lenguaje de programaci\u00f3n funcional puro, lo que significa que se basa en la evaluaci\u00f3n de expresiones para realizar operaciones y no utiliza variables mutables. Esto lo hace ideal para el desarrollo de aplicaciones web, ya que permite una mejor gesti\u00f3n de los datos y reduce la posibilidad de errores. Algunos de los frameworks m\u00e1s populares para el desarrollo web en Haskell son Yesod y Snap. Estos frameworks proporcionan una estructura para crear aplicaciones web de forma r\u00e1pida y eficiente, utilizando los principios de la programaci\u00f3n funcional. Adem\u00e1s de los frameworks, Haskell tambi\u00e9n cuenta con una amplia gama de bibliotecas y herramientas que facilitan el desarrollo de aplicaciones web, como Servant, que permite crear APIs de forma sencilla y segura, y BlazeHTML, para generar c\u00f3digo HTML de manera eficiente.","title":"Teor\u00eda"},{"location":"haskel/sr/desarrollo_de_aplicaciones_web/#palabras-clave","text":"Haskell: Lenguaje de programaci\u00f3n funcional puro utilizado para el desarrollo de aplicaciones web. Yesod: Framework de Haskell para la creaci\u00f3n de aplicaciones web. Snap: Otro framework de Haskell para el desarrollo web. Servant: Biblioteca para la creaci\u00f3n de APIs en Haskell. BlazeHTML: Biblioteca para la generaci\u00f3n de c\u00f3digo HTML en Haskell.","title":"Palabras clave"},{"location":"haskel/sr/desarrollo_de_aplicaciones_web/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Haskell y por qu\u00e9 es adecuado para el desarrollo de aplicaciones web? \u00bfCu\u00e1les son algunos de los frameworks y bibliotecas m\u00e1s populares para el desarrollo web en Haskell? \u00bfQu\u00e9 es Servant y para qu\u00e9 se utiliza? \u00bfC\u00f3mo funciona la evaluaci\u00f3n de expresiones en Haskell?","title":"Preguntas de repaso"},{"location":"haskel/sr/desarrollo_de_aplicaciones_web/#ejemplos-de-codigo","text":"","title":"Ejemplos de c\u00f3digo"},{"location":"haskel/sr/desarrollo_de_aplicaciones_web/#creacion-de-una-aplicacion-web-simple-con-yesod","text":"{-# LANGUAGE OverloadedStrings #-} import Yesod data HelloWorld = HelloWorld instance Yesod HelloWorld getHomeR :: Handler Html getHomeR = defaultLayout [ whamlet | Hello World !| ] main :: IO () main = warp 3000 HelloWorld","title":"Creaci\u00f3n de una aplicaci\u00f3n web simple con Yesod:"},{"location":"haskel/sr/desarrollo_de_aplicaciones_web/#creacion-de-una-api-con-servant","text":"{-# LANGUAGE DataKinds #-} {-# LANGUAGE TypeOperators #-} import Servant type API = \"hello\" :> Get '[PlainText] String server :: Server API server = return \"Hello World!\" app :: Application app = serve ( Proxy :: Proxy API ) server","title":"Creaci\u00f3n de una API con Servant:"},{"location":"haskel/sr/desarrollo_de_aplicaciones_web/#ejercicios-practicos","text":"Crea una aplicaci\u00f3n web utilizando el framework Snap que muestre una lista de nombres y edades. Utiliza Servant para crear una API que reciba dos n\u00fameros como par\u00e1metros y devuelva su suma. Implementa una funci\u00f3n en Haskell que convierta una lista de n\u00fameros en una lista de HTML con etiquetas .","title":"Ejercicios pr\u00e1cticos"},{"location":"haskel/sr/desarrollo_de_aplicaciones_web/#consejos-y-mejores-practicas","text":"Utiliza los tipos de datos de Haskell para asegurar la integridad de tus datos. Aprovecha las ventajas de la evaluaci\u00f3n perezosa para mejorar el rendimiento de tus aplicaciones web. Utiliza los frameworks y bibliotecas de Haskell para facilitar el desarrollo y asegurar la calidad de tu c\u00f3digo. Mant\u00e9n tu c\u00f3digo limpio y modular para facilitar su mantenimiento y escalabilidad.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"haskel/sr/expresiones_lambda/","text":"Expresiones Lambda \u00b6 Teor\u00eda \u00b6 Las expresiones lambda son una caracter\u00edstica clave de Haskell que permite escribir funciones de forma concisa y elegante. Una expresi\u00f3n lambda es una funci\u00f3n an\u00f3nima que no tiene un nombre definido y se utiliza para realizar c\u00e1lculos o transformaciones en los datos. En Haskell, las expresiones lambda se crean utilizando la sintaxis \\argumentos -> cuerpo de la funci\u00f3n , donde los argumentos son los par\u00e1metros de la funci\u00f3n y el cuerpo es la expresi\u00f3n que se debe evaluar. Las expresiones lambda se utilizan principalmente para crear funciones de orden superior, es decir, funciones que toman otras funciones como argumentos o devuelven funciones como resultado. Esto permite una programaci\u00f3n m\u00e1s funcional y modular, ya que se pueden crear funciones gen\u00e9ricas que se pueden aplicar a diferentes tipos de datos. Palabras clave y definiciones \u00b6 Lambda: un s\u00edmbolo ( \\ ) utilizado en Haskell para definir una expresi\u00f3n lambda. Funci\u00f3n de orden superior: una funci\u00f3n que toma otras funciones como argumentos o devuelve funciones como resultado. Par\u00e1metros: valores que se pasan a una funci\u00f3n para que pueda realizar su c\u00e1lculo. Expresi\u00f3n: una combinaci\u00f3n de valores, operadores y funciones que se eval\u00faa para producir un resultado. Cuerpo: la parte de una funci\u00f3n que contiene la expresi\u00f3n que se debe evaluar. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es una expresi\u00f3n lambda en Haskell? \u00bfPara qu\u00e9 se utilizan principalmente las expresiones lambda? \u00bfC\u00f3mo se crea una expresi\u00f3n lambda en Haskell? \u00bfQu\u00e9 es una funci\u00f3n de orden superior? \u00bfQu\u00e9 es un par\u00e1metro en una funci\u00f3n? \u00bfQu\u00e9 es el cuerpo de una funci\u00f3n? \u00bfQu\u00e9 es una expresi\u00f3n en Haskell? Ejemplos de c\u00f3digo \u00b6 Una funci\u00f3n que suma dos n\u00fameros utilizando una expresi\u00f3n lambda: sumar = \\ x y -> x + y Una funci\u00f3n de orden superior que toma una funci\u00f3n y un valor y devuelve el resultado de aplicar la funci\u00f3n al valor: aplicar :: ( a -> b ) -> a -> b aplicar f x = f x doble = aplicar ( \\ x -> x * 2 ) 5 -- devuelve 10 Ejercicios pr\u00e1cticos \u00b6 Escribe una funci\u00f3n lambda que multiplique dos n\u00fameros. Crea una funci\u00f3n de orden superior que tome una lista de n\u00fameros y una funci\u00f3n y aplique la funci\u00f3n a cada elemento de la lista. Escribe una expresi\u00f3n lambda que devuelva el cuadrado de un n\u00famero. Utiliza la funci\u00f3n map y una expresi\u00f3n lambda para transformar una lista de n\u00fameros en su valor absoluto. Crea una funci\u00f3n de orden superior que tome una lista de cadenas y una funci\u00f3n y aplique la funci\u00f3n a cada cadena de la lista. Consejos y mejores pr\u00e1cticas \u00b6 Utiliza expresiones lambda en lugar de funciones definidas cuando necesites una funci\u00f3n simple y no quieras definir un nombre para ella. Aseg\u00farate de que los argumentos y el cuerpo de la funci\u00f3n est\u00e9n separados por un espacio en blanco despu\u00e9s del s\u00edmbolo \\ . Utiliza par\u00e9ntesis para agrupar argumentos y expresiones si es necesario. Por ejemplo: (\\x -> (x * x)) . Evita usar expresiones lambda demasiado complejas, ya que pueden dificultar la lectura y el mantenimiento del c\u00f3digo.","title":"Expresiones Lambda"},{"location":"haskel/sr/expresiones_lambda/#expresiones-lambda","text":"","title":"Expresiones Lambda"},{"location":"haskel/sr/expresiones_lambda/#teoria","text":"Las expresiones lambda son una caracter\u00edstica clave de Haskell que permite escribir funciones de forma concisa y elegante. Una expresi\u00f3n lambda es una funci\u00f3n an\u00f3nima que no tiene un nombre definido y se utiliza para realizar c\u00e1lculos o transformaciones en los datos. En Haskell, las expresiones lambda se crean utilizando la sintaxis \\argumentos -> cuerpo de la funci\u00f3n , donde los argumentos son los par\u00e1metros de la funci\u00f3n y el cuerpo es la expresi\u00f3n que se debe evaluar. Las expresiones lambda se utilizan principalmente para crear funciones de orden superior, es decir, funciones que toman otras funciones como argumentos o devuelven funciones como resultado. Esto permite una programaci\u00f3n m\u00e1s funcional y modular, ya que se pueden crear funciones gen\u00e9ricas que se pueden aplicar a diferentes tipos de datos.","title":"Teor\u00eda"},{"location":"haskel/sr/expresiones_lambda/#palabras-clave-y-definiciones","text":"Lambda: un s\u00edmbolo ( \\ ) utilizado en Haskell para definir una expresi\u00f3n lambda. Funci\u00f3n de orden superior: una funci\u00f3n que toma otras funciones como argumentos o devuelve funciones como resultado. Par\u00e1metros: valores que se pasan a una funci\u00f3n para que pueda realizar su c\u00e1lculo. Expresi\u00f3n: una combinaci\u00f3n de valores, operadores y funciones que se eval\u00faa para producir un resultado. Cuerpo: la parte de una funci\u00f3n que contiene la expresi\u00f3n que se debe evaluar.","title":"Palabras clave y definiciones"},{"location":"haskel/sr/expresiones_lambda/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es una expresi\u00f3n lambda en Haskell? \u00bfPara qu\u00e9 se utilizan principalmente las expresiones lambda? \u00bfC\u00f3mo se crea una expresi\u00f3n lambda en Haskell? \u00bfQu\u00e9 es una funci\u00f3n de orden superior? \u00bfQu\u00e9 es un par\u00e1metro en una funci\u00f3n? \u00bfQu\u00e9 es el cuerpo de una funci\u00f3n? \u00bfQu\u00e9 es una expresi\u00f3n en Haskell?","title":"Preguntas de repaso"},{"location":"haskel/sr/expresiones_lambda/#ejemplos-de-codigo","text":"Una funci\u00f3n que suma dos n\u00fameros utilizando una expresi\u00f3n lambda: sumar = \\ x y -> x + y Una funci\u00f3n de orden superior que toma una funci\u00f3n y un valor y devuelve el resultado de aplicar la funci\u00f3n al valor: aplicar :: ( a -> b ) -> a -> b aplicar f x = f x doble = aplicar ( \\ x -> x * 2 ) 5 -- devuelve 10","title":"Ejemplos de c\u00f3digo"},{"location":"haskel/sr/expresiones_lambda/#ejercicios-practicos","text":"Escribe una funci\u00f3n lambda que multiplique dos n\u00fameros. Crea una funci\u00f3n de orden superior que tome una lista de n\u00fameros y una funci\u00f3n y aplique la funci\u00f3n a cada elemento de la lista. Escribe una expresi\u00f3n lambda que devuelva el cuadrado de un n\u00famero. Utiliza la funci\u00f3n map y una expresi\u00f3n lambda para transformar una lista de n\u00fameros en su valor absoluto. Crea una funci\u00f3n de orden superior que tome una lista de cadenas y una funci\u00f3n y aplique la funci\u00f3n a cada cadena de la lista.","title":"Ejercicios pr\u00e1cticos"},{"location":"haskel/sr/expresiones_lambda/#consejos-y-mejores-practicas","text":"Utiliza expresiones lambda en lugar de funciones definidas cuando necesites una funci\u00f3n simple y no quieras definir un nombre para ella. Aseg\u00farate de que los argumentos y el cuerpo de la funci\u00f3n est\u00e9n separados por un espacio en blanco despu\u00e9s del s\u00edmbolo \\ . Utiliza par\u00e9ntesis para agrupar argumentos y expresiones si es necesario. Por ejemplo: (\\x -> (x * x)) . Evita usar expresiones lambda demasiado complejas, ya que pueden dificultar la lectura y el mantenimiento del c\u00f3digo.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"haskel/sr/optimizaci%C3%B3n_de_c%C3%B3digo/","text":"Optimizaci\u00f3n de C\u00f3digo en Haskell \u00b6 En este m\u00f3dulo, aprender\u00e1s t\u00e9cnicas avanzadas para optimizar el rendimiento de tu c\u00f3digo en Haskell. La optimizaci\u00f3n de c\u00f3digo es un proceso importante en la programaci\u00f3n, ya que puede mejorar significativamente la velocidad y eficiencia de tus programas. En Haskell, la optimizaci\u00f3n se centra en reducir el tiempo de ejecuci\u00f3n y el uso de recursos de memoria, sin sacrificar la legibilidad y mantenibilidad del c\u00f3digo. Explicaci\u00f3n te\u00f3rica \u00b6 La optimizaci\u00f3n de c\u00f3digo en Haskell se basa en dos principios fundamentales: la evaluaci\u00f3n perezosa y la inmutabilidad. La evaluaci\u00f3n perezosa significa que Haskell solo eval\u00faa expresiones cuando es necesario, lo que permite evitar c\u00e1lculos innecesarios. La inmutabilidad, por otro lado, garantiza que los valores nunca cambien, lo que simplifica la optimizaci\u00f3n del c\u00f3digo. Adem\u00e1s de estos principios, existen diversas t\u00e9cnicas y herramientas que pueden utilizarse para optimizar el c\u00f3digo en Haskell. Entre las m\u00e1s comunes se encuentran: Uso adecuado de estructuras de datos: elegir la estructura de datos m\u00e1s eficiente para cada problema es clave en la optimizaci\u00f3n de c\u00f3digo. Algunas estructuras, como las listas, son m\u00e1s lentas que otras, como los vectores o los conjuntos. Uso de funciones de orden superior: las funciones de orden superior, como map y fold, pueden ser m\u00e1s eficientes que los bucles tradicionales. Uso de tipado estricto: en Haskell, el tipado por defecto es perezoso, lo que significa que los argumentos se eval\u00faan solo cuando son necesarios. Sin embargo, en algunos casos puede ser beneficioso utilizar el tipado estricto para evitar c\u00e1lculos innecesarios. Uso de optimizaciones del compilador: el compilador de Haskell, GHC, ofrece diversas opciones de optimizaci\u00f3n que pueden mejorar el rendimiento del c\u00f3digo. Algunas de ellas son la eliminaci\u00f3n de c\u00f3digo muerto, el desenrollado de bucles y la especializaci\u00f3n de funciones. Palabras clave y su definici\u00f3n \u00b6 Evaluaci\u00f3n perezosa: estrategia de evaluaci\u00f3n en la que las expresiones se eval\u00faan solo cuando es necesario. Inmutabilidad: propiedad de los valores en Haskell que garantiza que no pueden ser modificados despu\u00e9s de su creaci\u00f3n. Estructuras de datos: organizaciones de datos en memoria que permiten almacenar y acceder a ellos de manera eficiente. Funciones de orden superior: funciones que toman otras funciones como argumentos o devuelven funciones como resultado. Tipado estricto: estrategia de evaluaci\u00f3n en la que los argumentos se eval\u00faan inmediatamente. Compilador: programa que traduce el c\u00f3digo fuente a un programa ejecutable. Preguntas de repaso \u00b6 \u00bfQu\u00e9 significa que Haskell tenga una evaluaci\u00f3n perezosa? \u00bfPor qu\u00e9 la inmutabilidad es importante en la optimizaci\u00f3n de c\u00f3digo en Haskell? \u00bfC\u00f3mo podemos elegir la estructura de datos m\u00e1s eficiente para un problema en particular? \u00bfQu\u00e9 son las funciones de orden superior y c\u00f3mo pueden ayudar en la optimizaci\u00f3n de c\u00f3digo? \u00bfEn qu\u00e9 casos puede ser beneficioso utilizar el tipado estricto en Haskell? \u00bfQu\u00e9 herramientas ofrece el compilador GHC para optimizar el c\u00f3digo en Haskell? Ejemplos de c\u00f3digo en Haskell \u00b6 Uso de estructuras de datos eficientes \u00b6 Las listas son una estructura de datos com\u00fan en Haskell, pero pueden ser ineficientes en ciertos casos. Por ejemplo, si queremos obtener el \u00faltimo elemento de una lista, podemos utilizar la funci\u00f3n predefinida last , pero su tiempo de ejecuci\u00f3n es lineal en la longitud de la lista. En cambio, si utilizamos un vector, podemos acceder al \u00faltimo elemento de forma constante. -- Utilizando listas (ineficiente) last [ 1 , 2 , 3 , 4 , 5 ] -- 5 -- Utilizando vectores (eficiente) import qualified Data.Vector as V V . last $ V . fromList [ 1 , 2 , 3 , 4 , 5 ] -- 5 Uso de funciones de orden superior \u00b6 Las funciones de orden superior pueden ser m\u00e1s eficientes que los bucles tradicionales, ya que el compilador puede realizar optimizaciones en ellas. Por ejemplo, si queremos sumar los cuadrados de los primeros 100 n\u00fameros naturales, podemos utilizar un bucle for o la funci\u00f3n sum junto con map . -- Utilizando un bucle for (ineficiente) let sum = 0 forM_ [ 1 .. 100 ] $ \\ n -> sum += n ^ 2 sum -- 338350 -- Utilizando funciones de orden superior (m\u00e1s eficiente) sum $ map ( ^ 2 ) [ 1 .. 100 ] -- 338350 Uso de tipado estricto \u00b6 En algunos casos, puede ser beneficioso utilizar el tipado estricto en Haskell para evitar c\u00e1lculos innecesarios. Por ejemplo, si queremos obtener el primer elemento de una lista, podemos utilizar la funci\u00f3n head . Sin embargo, al ser perezosa, Haskell evaluar\u00e1 toda la lista aunque solo necesitamos el primer elemento. Si utilizamos el tipado estricto, podemos evitar esta evaluaci\u00f3n innecesaria. -- Utilizando tipado perezoso (ineficiente) head [ 1 , 2 , 3 ] -- 1 -- Utilizando tipado estricto (m\u00e1s eficiente) import qualified Data.List as L L . head' [ 1 , 2 , 3 ] -- 1 Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Utiliza una estructura de datos adecuada para almacenar los n\u00fameros del 1 al 100 y calcula la suma de los cuadrados de estos n\u00fameros. Escribe una funci\u00f3n utilizando funciones de orden superior que devuelva la lista de los primeros 50 n\u00fameros pares. Crea una funci\u00f3n que devuelva el primer elemento de una lista utilizando tipado estricto. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza la estructura de datos m\u00e1s eficiente para cada problema. Utiliza funciones de orden superior en lugar de bucles tradicionales. Utiliza el tipado estricto en casos espec\u00edficos para evitar c\u00e1lculos innecesarios. Experimenta con las opciones de optimizaci\u00f3n del compilador GHC. Realiza pruebas de rendimiento para comparar diferentes implementaciones y elegir la m\u00e1s eficiente.","title":"Optimizaci\u00f3n de C\u00f3digo en Haskell"},{"location":"haskel/sr/optimizaci%C3%B3n_de_c%C3%B3digo/#optimizacion-de-codigo-en-haskell","text":"En este m\u00f3dulo, aprender\u00e1s t\u00e9cnicas avanzadas para optimizar el rendimiento de tu c\u00f3digo en Haskell. La optimizaci\u00f3n de c\u00f3digo es un proceso importante en la programaci\u00f3n, ya que puede mejorar significativamente la velocidad y eficiencia de tus programas. En Haskell, la optimizaci\u00f3n se centra en reducir el tiempo de ejecuci\u00f3n y el uso de recursos de memoria, sin sacrificar la legibilidad y mantenibilidad del c\u00f3digo.","title":"Optimizaci\u00f3n de C\u00f3digo en Haskell"},{"location":"haskel/sr/optimizaci%C3%B3n_de_c%C3%B3digo/#explicacion-teorica","text":"La optimizaci\u00f3n de c\u00f3digo en Haskell se basa en dos principios fundamentales: la evaluaci\u00f3n perezosa y la inmutabilidad. La evaluaci\u00f3n perezosa significa que Haskell solo eval\u00faa expresiones cuando es necesario, lo que permite evitar c\u00e1lculos innecesarios. La inmutabilidad, por otro lado, garantiza que los valores nunca cambien, lo que simplifica la optimizaci\u00f3n del c\u00f3digo. Adem\u00e1s de estos principios, existen diversas t\u00e9cnicas y herramientas que pueden utilizarse para optimizar el c\u00f3digo en Haskell. Entre las m\u00e1s comunes se encuentran: Uso adecuado de estructuras de datos: elegir la estructura de datos m\u00e1s eficiente para cada problema es clave en la optimizaci\u00f3n de c\u00f3digo. Algunas estructuras, como las listas, son m\u00e1s lentas que otras, como los vectores o los conjuntos. Uso de funciones de orden superior: las funciones de orden superior, como map y fold, pueden ser m\u00e1s eficientes que los bucles tradicionales. Uso de tipado estricto: en Haskell, el tipado por defecto es perezoso, lo que significa que los argumentos se eval\u00faan solo cuando son necesarios. Sin embargo, en algunos casos puede ser beneficioso utilizar el tipado estricto para evitar c\u00e1lculos innecesarios. Uso de optimizaciones del compilador: el compilador de Haskell, GHC, ofrece diversas opciones de optimizaci\u00f3n que pueden mejorar el rendimiento del c\u00f3digo. Algunas de ellas son la eliminaci\u00f3n de c\u00f3digo muerto, el desenrollado de bucles y la especializaci\u00f3n de funciones.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"haskel/sr/optimizaci%C3%B3n_de_c%C3%B3digo/#palabras-clave-y-su-definicion","text":"Evaluaci\u00f3n perezosa: estrategia de evaluaci\u00f3n en la que las expresiones se eval\u00faan solo cuando es necesario. Inmutabilidad: propiedad de los valores en Haskell que garantiza que no pueden ser modificados despu\u00e9s de su creaci\u00f3n. Estructuras de datos: organizaciones de datos en memoria que permiten almacenar y acceder a ellos de manera eficiente. Funciones de orden superior: funciones que toman otras funciones como argumentos o devuelven funciones como resultado. Tipado estricto: estrategia de evaluaci\u00f3n en la que los argumentos se eval\u00faan inmediatamente. Compilador: programa que traduce el c\u00f3digo fuente a un programa ejecutable.","title":"Palabras clave y su definici\u00f3n"},{"location":"haskel/sr/optimizaci%C3%B3n_de_c%C3%B3digo/#preguntas-de-repaso","text":"\u00bfQu\u00e9 significa que Haskell tenga una evaluaci\u00f3n perezosa? \u00bfPor qu\u00e9 la inmutabilidad es importante en la optimizaci\u00f3n de c\u00f3digo en Haskell? \u00bfC\u00f3mo podemos elegir la estructura de datos m\u00e1s eficiente para un problema en particular? \u00bfQu\u00e9 son las funciones de orden superior y c\u00f3mo pueden ayudar en la optimizaci\u00f3n de c\u00f3digo? \u00bfEn qu\u00e9 casos puede ser beneficioso utilizar el tipado estricto en Haskell? \u00bfQu\u00e9 herramientas ofrece el compilador GHC para optimizar el c\u00f3digo en Haskell?","title":"Preguntas de repaso"},{"location":"haskel/sr/optimizaci%C3%B3n_de_c%C3%B3digo/#ejemplos-de-codigo-en-haskell","text":"","title":"Ejemplos de c\u00f3digo en Haskell"},{"location":"haskel/sr/optimizaci%C3%B3n_de_c%C3%B3digo/#uso-de-estructuras-de-datos-eficientes","text":"Las listas son una estructura de datos com\u00fan en Haskell, pero pueden ser ineficientes en ciertos casos. Por ejemplo, si queremos obtener el \u00faltimo elemento de una lista, podemos utilizar la funci\u00f3n predefinida last , pero su tiempo de ejecuci\u00f3n es lineal en la longitud de la lista. En cambio, si utilizamos un vector, podemos acceder al \u00faltimo elemento de forma constante. -- Utilizando listas (ineficiente) last [ 1 , 2 , 3 , 4 , 5 ] -- 5 -- Utilizando vectores (eficiente) import qualified Data.Vector as V V . last $ V . fromList [ 1 , 2 , 3 , 4 , 5 ] -- 5","title":"Uso de estructuras de datos eficientes"},{"location":"haskel/sr/optimizaci%C3%B3n_de_c%C3%B3digo/#uso-de-funciones-de-orden-superior","text":"Las funciones de orden superior pueden ser m\u00e1s eficientes que los bucles tradicionales, ya que el compilador puede realizar optimizaciones en ellas. Por ejemplo, si queremos sumar los cuadrados de los primeros 100 n\u00fameros naturales, podemos utilizar un bucle for o la funci\u00f3n sum junto con map . -- Utilizando un bucle for (ineficiente) let sum = 0 forM_ [ 1 .. 100 ] $ \\ n -> sum += n ^ 2 sum -- 338350 -- Utilizando funciones de orden superior (m\u00e1s eficiente) sum $ map ( ^ 2 ) [ 1 .. 100 ] -- 338350","title":"Uso de funciones de orden superior"},{"location":"haskel/sr/optimizaci%C3%B3n_de_c%C3%B3digo/#uso-de-tipado-estricto","text":"En algunos casos, puede ser beneficioso utilizar el tipado estricto en Haskell para evitar c\u00e1lculos innecesarios. Por ejemplo, si queremos obtener el primer elemento de una lista, podemos utilizar la funci\u00f3n head . Sin embargo, al ser perezosa, Haskell evaluar\u00e1 toda la lista aunque solo necesitamos el primer elemento. Si utilizamos el tipado estricto, podemos evitar esta evaluaci\u00f3n innecesaria. -- Utilizando tipado perezoso (ineficiente) head [ 1 , 2 , 3 ] -- 1 -- Utilizando tipado estricto (m\u00e1s eficiente) import qualified Data.List as L L . head' [ 1 , 2 , 3 ] -- 1","title":"Uso de tipado estricto"},{"location":"haskel/sr/optimizaci%C3%B3n_de_c%C3%B3digo/#ejercicios-practicos-con-instrucciones-claras","text":"Utiliza una estructura de datos adecuada para almacenar los n\u00fameros del 1 al 100 y calcula la suma de los cuadrados de estos n\u00fameros. Escribe una funci\u00f3n utilizando funciones de orden superior que devuelva la lista de los primeros 50 n\u00fameros pares. Crea una funci\u00f3n que devuelva el primer elemento de una lista utilizando tipado estricto.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"haskel/sr/optimizaci%C3%B3n_de_c%C3%B3digo/#consejos-o-mejores-practicas","text":"Utiliza la estructura de datos m\u00e1s eficiente para cada problema. Utiliza funciones de orden superior en lugar de bucles tradicionales. Utiliza el tipado estricto en casos espec\u00edficos para evitar c\u00e1lculos innecesarios. Experimenta con las opciones de optimizaci\u00f3n del compilador GHC. Realiza pruebas de rendimiento para comparar diferentes implementaciones y elegir la m\u00e1s eficiente.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"haskel/sr/programaci%C3%B3n_con_monads_avanzada/","text":"Programaci\u00f3n con Monads Avanzada \u00b6 En esta lecci\u00f3n, aprender\u00e1s t\u00e9cnicas avanzadas de programaci\u00f3n con monads en Haskell. Los monads son una herramienta poderosa para trabajar con efectos secundarios en lenguajes funcionales y su uso es esencial para crear programas robustos y modulares. Teor\u00eda \u00b6 Los monads son una abstracci\u00f3n que permite encapsular acciones con efectos secundarios en una estructura de datos. Esto permite que estas acciones sean tratadas como valores y puedan ser combinadas y secuenciadas de manera segura y predecible. En Haskell, los monads se implementan como tipos de datos que se adhieren a ciertas reglas y proporcionan funciones para trabajar con ellos de manera gen\u00e9rica. Una de las caracter\u00edsticas m\u00e1s poderosas de los monads es su capacidad para ser anidados. Esto significa que podemos tener un monad dentro de otro monad, lo que nos permite trabajar con efectos secundarios m\u00e1s complejos y combinar diferentes tipos de monads en una sola acci\u00f3n. Adem\u00e1s, Haskell tambi\u00e9n tiene una herramienta llamada \"transformers\" que nos permite trabajar con monads anidados de manera m\u00e1s eficiente. Palabras clave \u00b6 Monad: Una estructura de datos que encapsula acciones con efectos secundarios. Efectos secundarios: Cualquier acci\u00f3n que afecte al estado del programa fuera de la funci\u00f3n en la que se encuentra. Anidamiento de monads: La capacidad de tener un monad dentro de otro monad. Transformers: Una herramienta que nos permite trabajar con monads anidados de manera m\u00e1s eficiente. Preguntas de repaso \u00b6 \u00bfQu\u00e9 son los monads en Haskell? \u00bfQu\u00e9 ventaja tiene el anidamiento de monads? \u00bfQu\u00e9 son los transformers y para qu\u00e9 se utilizan? Ejemplos de c\u00f3digo \u00b6 Monad Maybe \u00b6 El monad Maybe se utiliza para manejar valores que pueden ser nulos. Su implementaci\u00f3n en Haskell es la siguiente: data Maybe a = Nothing | Just a Podemos utilizarlo para encapsular acciones que podr\u00edan devolver un valor nulo y manejar este caso de manera segura. safeDiv :: Int -> Int -> Maybe Int safeDiv _ 0 = Nothing safeDiv x y = Just ( x `div` y ) main = do putStrLn \"Ingrese dos n\u00fameros:\" num1 <- getLine num2 <- getLine let resultado = do x <- readMaybe num1 y <- readMaybe num2 safeDiv x y case resultado of Just r -> putStrLn ( \"El resultado es: \" ++ show r ) Nothing -> putStrLn \"No se puede dividir por cero.\" Monad IO \u00b6 El monad IO se utiliza para encapsular acciones con efectos secundarios, como leer o escribir en la consola o en archivos. Su implementaci\u00f3n en Haskell es la siguiente: data IO a = RealWorld -> ( a , RealWorld ) Podemos utilizarlo para realizar acciones con efectos secundarios de manera segura y controlada. main = do putStrLn \"Ingrese su nombre:\" nombre <- getLine writeFile \"mensaje.txt\" ( \"Hola \" ++ nombre ++ \", bienvenido a Haskell!\" ) Ejercicios pr\u00e1cticos \u00b6 Crea un programa que le pregunte al usuario su edad y le indique si es mayor de edad o no utilizando el monad Maybe. Crea un programa que lea un archivo y convierta su contenido a may\u00fasculas utilizando el monad IO. Consejos \u00b6 Utiliza los monads de manera eficiente para encapsular acciones con efectos secundarios y trabajar con ellas de manera segura. Aprende a utilizar los transformers para trabajar con monads anidados de manera m\u00e1s eficiente. Practica con ejercicios y programas sencillos para familiarizarte con el uso de los monads y sus caracter\u00edsticas avanzadas.","title":"Programaci\u00f3n con Monads Avanzada"},{"location":"haskel/sr/programaci%C3%B3n_con_monads_avanzada/#programacion-con-monads-avanzada","text":"En esta lecci\u00f3n, aprender\u00e1s t\u00e9cnicas avanzadas de programaci\u00f3n con monads en Haskell. Los monads son una herramienta poderosa para trabajar con efectos secundarios en lenguajes funcionales y su uso es esencial para crear programas robustos y modulares.","title":"Programaci\u00f3n con Monads Avanzada"},{"location":"haskel/sr/programaci%C3%B3n_con_monads_avanzada/#teoria","text":"Los monads son una abstracci\u00f3n que permite encapsular acciones con efectos secundarios en una estructura de datos. Esto permite que estas acciones sean tratadas como valores y puedan ser combinadas y secuenciadas de manera segura y predecible. En Haskell, los monads se implementan como tipos de datos que se adhieren a ciertas reglas y proporcionan funciones para trabajar con ellos de manera gen\u00e9rica. Una de las caracter\u00edsticas m\u00e1s poderosas de los monads es su capacidad para ser anidados. Esto significa que podemos tener un monad dentro de otro monad, lo que nos permite trabajar con efectos secundarios m\u00e1s complejos y combinar diferentes tipos de monads en una sola acci\u00f3n. Adem\u00e1s, Haskell tambi\u00e9n tiene una herramienta llamada \"transformers\" que nos permite trabajar con monads anidados de manera m\u00e1s eficiente.","title":"Teor\u00eda"},{"location":"haskel/sr/programaci%C3%B3n_con_monads_avanzada/#palabras-clave","text":"Monad: Una estructura de datos que encapsula acciones con efectos secundarios. Efectos secundarios: Cualquier acci\u00f3n que afecte al estado del programa fuera de la funci\u00f3n en la que se encuentra. Anidamiento de monads: La capacidad de tener un monad dentro de otro monad. Transformers: Una herramienta que nos permite trabajar con monads anidados de manera m\u00e1s eficiente.","title":"Palabras clave"},{"location":"haskel/sr/programaci%C3%B3n_con_monads_avanzada/#preguntas-de-repaso","text":"\u00bfQu\u00e9 son los monads en Haskell? \u00bfQu\u00e9 ventaja tiene el anidamiento de monads? \u00bfQu\u00e9 son los transformers y para qu\u00e9 se utilizan?","title":"Preguntas de repaso"},{"location":"haskel/sr/programaci%C3%B3n_con_monads_avanzada/#ejemplos-de-codigo","text":"","title":"Ejemplos de c\u00f3digo"},{"location":"haskel/sr/programaci%C3%B3n_con_monads_avanzada/#monad-maybe","text":"El monad Maybe se utiliza para manejar valores que pueden ser nulos. Su implementaci\u00f3n en Haskell es la siguiente: data Maybe a = Nothing | Just a Podemos utilizarlo para encapsular acciones que podr\u00edan devolver un valor nulo y manejar este caso de manera segura. safeDiv :: Int -> Int -> Maybe Int safeDiv _ 0 = Nothing safeDiv x y = Just ( x `div` y ) main = do putStrLn \"Ingrese dos n\u00fameros:\" num1 <- getLine num2 <- getLine let resultado = do x <- readMaybe num1 y <- readMaybe num2 safeDiv x y case resultado of Just r -> putStrLn ( \"El resultado es: \" ++ show r ) Nothing -> putStrLn \"No se puede dividir por cero.\"","title":"Monad Maybe"},{"location":"haskel/sr/programaci%C3%B3n_con_monads_avanzada/#monad-io","text":"El monad IO se utiliza para encapsular acciones con efectos secundarios, como leer o escribir en la consola o en archivos. Su implementaci\u00f3n en Haskell es la siguiente: data IO a = RealWorld -> ( a , RealWorld ) Podemos utilizarlo para realizar acciones con efectos secundarios de manera segura y controlada. main = do putStrLn \"Ingrese su nombre:\" nombre <- getLine writeFile \"mensaje.txt\" ( \"Hola \" ++ nombre ++ \", bienvenido a Haskell!\" )","title":"Monad IO"},{"location":"haskel/sr/programaci%C3%B3n_con_monads_avanzada/#ejercicios-practicos","text":"Crea un programa que le pregunte al usuario su edad y le indique si es mayor de edad o no utilizando el monad Maybe. Crea un programa que lea un archivo y convierta su contenido a may\u00fasculas utilizando el monad IO.","title":"Ejercicios pr\u00e1cticos"},{"location":"haskel/sr/programaci%C3%B3n_con_monads_avanzada/#consejos","text":"Utiliza los monads de manera eficiente para encapsular acciones con efectos secundarios y trabajar con ellas de manera segura. Aprende a utilizar los transformers para trabajar con monads anidados de manera m\u00e1s eficiente. Practica con ejercicios y programas sencillos para familiarizarte con el uso de los monads y sus caracter\u00edsticas avanzadas.","title":"Consejos"},{"location":"haskel/sr/programaci%C3%B3n_funcional_avanzada/","text":"Programaci\u00f3n Funcional Avanzada \u00b6 En este m\u00f3dulo, profundizaremos en las t\u00e9cnicas avanzadas de programaci\u00f3n funcional en Haskell. Aprender\u00e1s sobre conceptos como programaci\u00f3n con continuaciones y currying, que te permitir\u00e1n escribir c\u00f3digo m\u00e1s elegante y eficiente en tus proyectos. Teor\u00eda \u00b6 La programaci\u00f3n funcional se basa en el uso de funciones como bloques de construcci\u00f3n fundamentales para crear programas. Esto implica que las funciones son tratadas como valores de primera clase, lo que significa que pueden ser pasadas como argumentos, retornadas como resultados y almacenadas en variables. Adem\u00e1s, las funciones puras, que no tienen efectos secundarios y siempre producen el mismo resultado para los mismos argumentos, son altamente valoradas en la programaci\u00f3n funcional. Programaci\u00f3n con continuaciones \u00b6 La programaci\u00f3n con continuaciones es una t\u00e9cnica avanzada que consiste en pasar una funci\u00f3n como argumento a otra funci\u00f3n. Esta funci\u00f3n, conocida como continuaci\u00f3n, se encarga de manejar el resultado de la funci\u00f3n a la que se le pas\u00f3 como argumento. Esto permite escribir c\u00f3digo de manera m\u00e1s flexible y expresiva, ya que podemos definir diferentes continuaciones para diferentes situaciones. Currying \u00b6 Currying es una t\u00e9cnica que consiste en transformar una funci\u00f3n que toma m\u00faltiples argumentos en una serie de funciones que toman un solo argumento. Esto permite una mayor flexibilidad en la aplicaci\u00f3n de funciones y nos permite construir nuevas funciones a partir de otras de manera m\u00e1s sencilla. Palabras clave \u00b6 Programaci\u00f3n funcional: Paradigma de programaci\u00f3n que se basa en el uso de funciones como bloques de construcci\u00f3n fundamentales para crear programas. Funciones puras: Funciones que no tienen efectos secundarios y siempre producen el mismo resultado para los mismos argumentos. Continuaciones: Funciones que se pasan como argumento a otras funciones para manejar su resultado. Currying: T\u00e9cnica que consiste en transformar una funci\u00f3n que toma m\u00faltiples argumentos en una serie de funciones que toman un solo argumento. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la programaci\u00f3n funcional? \u00bfQu\u00e9 son las funciones puras y por qu\u00e9 son valoradas en la programaci\u00f3n funcional? \u00bfEn qu\u00e9 consiste la programaci\u00f3n con continuaciones? \u00bfQu\u00e9 es el currying y para qu\u00e9 se utiliza en la programaci\u00f3n funcional? Ejemplos de c\u00f3digo en Haskell \u00b6 Programaci\u00f3n con continuaciones \u00b6 -- Funci\u00f3n que suma dos n\u00fameros y pasa el resultado a una continuaci\u00f3n suma :: Int -> Int -> ( Int -> r ) -> r suma x y cont = cont ( x + y ) -- Continuaci\u00f3n que imprime el resultado imprimir :: Int -> IO () imprimir x = putStrLn ( \"El resultado es: \" ++ show x ) -- Llamada a la funci\u00f3n suma con una continuaci\u00f3n main :: IO () main = suma 5 3 imprimir -- Imprime \"El resultado es: 8\" Currying \u00b6 -- Funci\u00f3n que suma dos n\u00fameros suma :: Int -> Int -> Int suma x y = x + y -- Funci\u00f3n que aplica un n\u00famero a la funci\u00f3n suma para obtener una nueva funci\u00f3n sumarCinco :: Int -> Int sumarCinco = suma 5 -- Equivalente a sumarCinco x = suma 5 x -- Llamada a la funci\u00f3n sumarCinco main :: IO () main = print ( sumarCinco 3 ) -- Imprime 8 Ejercicios pr\u00e1cticos \u00b6 Crea una funci\u00f3n multiplicar que tome dos n\u00fameros y los multiplique. Luego, crea una continuaci\u00f3n que imprima el resultado y llama a la funci\u00f3n con los n\u00fameros 4 y 5. Define una funci\u00f3n esPar que tome un n\u00famero y retorne True si es par y False si es impar. Luego, utiliza esta funci\u00f3n en una continuaci\u00f3n para imprimir el resultado de determinar si el n\u00famero 6 es par. Utiliza currying para crear una funci\u00f3n restar que tome dos n\u00fameros y retorne la resta del segundo al primero. Luego, crea una nueva funci\u00f3n restarCinco a partir de restar y util\u00edzala para restar 5 a 10. Consejos y mejores pr\u00e1cticas \u00b6 Practica la programaci\u00f3n con continuaciones y currying para familiarizarte con estas t\u00e9cnicas. Aprende a utilizar funciones de orden superior para escribir c\u00f3digo m\u00e1s elegante y expresivo. Utiliza funciones puras siempre que sea posible para evitar efectos secundarios y hacer tu c\u00f3digo m\u00e1s predecible y f\u00e1cil de mantener.","title":"Programaci\u00f3n Funcional Avanzada"},{"location":"haskel/sr/programaci%C3%B3n_funcional_avanzada/#programacion-funcional-avanzada","text":"En este m\u00f3dulo, profundizaremos en las t\u00e9cnicas avanzadas de programaci\u00f3n funcional en Haskell. Aprender\u00e1s sobre conceptos como programaci\u00f3n con continuaciones y currying, que te permitir\u00e1n escribir c\u00f3digo m\u00e1s elegante y eficiente en tus proyectos.","title":"Programaci\u00f3n Funcional Avanzada"},{"location":"haskel/sr/programaci%C3%B3n_funcional_avanzada/#teoria","text":"La programaci\u00f3n funcional se basa en el uso de funciones como bloques de construcci\u00f3n fundamentales para crear programas. Esto implica que las funciones son tratadas como valores de primera clase, lo que significa que pueden ser pasadas como argumentos, retornadas como resultados y almacenadas en variables. Adem\u00e1s, las funciones puras, que no tienen efectos secundarios y siempre producen el mismo resultado para los mismos argumentos, son altamente valoradas en la programaci\u00f3n funcional.","title":"Teor\u00eda"},{"location":"haskel/sr/programaci%C3%B3n_funcional_avanzada/#programacion-con-continuaciones","text":"La programaci\u00f3n con continuaciones es una t\u00e9cnica avanzada que consiste en pasar una funci\u00f3n como argumento a otra funci\u00f3n. Esta funci\u00f3n, conocida como continuaci\u00f3n, se encarga de manejar el resultado de la funci\u00f3n a la que se le pas\u00f3 como argumento. Esto permite escribir c\u00f3digo de manera m\u00e1s flexible y expresiva, ya que podemos definir diferentes continuaciones para diferentes situaciones.","title":"Programaci\u00f3n con continuaciones"},{"location":"haskel/sr/programaci%C3%B3n_funcional_avanzada/#currying","text":"Currying es una t\u00e9cnica que consiste en transformar una funci\u00f3n que toma m\u00faltiples argumentos en una serie de funciones que toman un solo argumento. Esto permite una mayor flexibilidad en la aplicaci\u00f3n de funciones y nos permite construir nuevas funciones a partir de otras de manera m\u00e1s sencilla.","title":"Currying"},{"location":"haskel/sr/programaci%C3%B3n_funcional_avanzada/#palabras-clave","text":"Programaci\u00f3n funcional: Paradigma de programaci\u00f3n que se basa en el uso de funciones como bloques de construcci\u00f3n fundamentales para crear programas. Funciones puras: Funciones que no tienen efectos secundarios y siempre producen el mismo resultado para los mismos argumentos. Continuaciones: Funciones que se pasan como argumento a otras funciones para manejar su resultado. Currying: T\u00e9cnica que consiste en transformar una funci\u00f3n que toma m\u00faltiples argumentos en una serie de funciones que toman un solo argumento.","title":"Palabras clave"},{"location":"haskel/sr/programaci%C3%B3n_funcional_avanzada/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la programaci\u00f3n funcional? \u00bfQu\u00e9 son las funciones puras y por qu\u00e9 son valoradas en la programaci\u00f3n funcional? \u00bfEn qu\u00e9 consiste la programaci\u00f3n con continuaciones? \u00bfQu\u00e9 es el currying y para qu\u00e9 se utiliza en la programaci\u00f3n funcional?","title":"Preguntas de repaso"},{"location":"haskel/sr/programaci%C3%B3n_funcional_avanzada/#ejemplos-de-codigo-en-haskell","text":"","title":"Ejemplos de c\u00f3digo en Haskell"},{"location":"haskel/sr/programaci%C3%B3n_funcional_avanzada/#programacion-con-continuaciones_1","text":"-- Funci\u00f3n que suma dos n\u00fameros y pasa el resultado a una continuaci\u00f3n suma :: Int -> Int -> ( Int -> r ) -> r suma x y cont = cont ( x + y ) -- Continuaci\u00f3n que imprime el resultado imprimir :: Int -> IO () imprimir x = putStrLn ( \"El resultado es: \" ++ show x ) -- Llamada a la funci\u00f3n suma con una continuaci\u00f3n main :: IO () main = suma 5 3 imprimir -- Imprime \"El resultado es: 8\"","title":"Programaci\u00f3n con continuaciones"},{"location":"haskel/sr/programaci%C3%B3n_funcional_avanzada/#currying_1","text":"-- Funci\u00f3n que suma dos n\u00fameros suma :: Int -> Int -> Int suma x y = x + y -- Funci\u00f3n que aplica un n\u00famero a la funci\u00f3n suma para obtener una nueva funci\u00f3n sumarCinco :: Int -> Int sumarCinco = suma 5 -- Equivalente a sumarCinco x = suma 5 x -- Llamada a la funci\u00f3n sumarCinco main :: IO () main = print ( sumarCinco 3 ) -- Imprime 8","title":"Currying"},{"location":"haskel/sr/programaci%C3%B3n_funcional_avanzada/#ejercicios-practicos","text":"Crea una funci\u00f3n multiplicar que tome dos n\u00fameros y los multiplique. Luego, crea una continuaci\u00f3n que imprima el resultado y llama a la funci\u00f3n con los n\u00fameros 4 y 5. Define una funci\u00f3n esPar que tome un n\u00famero y retorne True si es par y False si es impar. Luego, utiliza esta funci\u00f3n en una continuaci\u00f3n para imprimir el resultado de determinar si el n\u00famero 6 es par. Utiliza currying para crear una funci\u00f3n restar que tome dos n\u00fameros y retorne la resta del segundo al primero. Luego, crea una nueva funci\u00f3n restarCinco a partir de restar y util\u00edzala para restar 5 a 10.","title":"Ejercicios pr\u00e1cticos"},{"location":"haskel/sr/programaci%C3%B3n_funcional_avanzada/#consejos-y-mejores-practicas","text":"Practica la programaci\u00f3n con continuaciones y currying para familiarizarte con estas t\u00e9cnicas. Aprende a utilizar funciones de orden superior para escribir c\u00f3digo m\u00e1s elegante y expresivo. Utiliza funciones puras siempre que sea posible para evitar efectos secundarios y hacer tu c\u00f3digo m\u00e1s predecible y f\u00e1cil de mantener.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"haskel/sr/programaci%C3%B3n_segura/","text":"Programaci\u00f3n Segura en Haskell \u00b6 La programaci\u00f3n segura se refiere a la aplicaci\u00f3n de t\u00e9cnicas para mejorar la seguridad y robustez de un programa. En Haskell, un lenguaje funcional puro, estas t\u00e9cnicas se enfocan en prevenir errores y garantizar la integridad de los datos. Teor\u00eda \u00b6 Haskell, al ser un lenguaje puramente funcional, se basa en la evaluaci\u00f3n de expresiones y evita los efectos secundarios, lo que lo hace m\u00e1s seguro que otros lenguajes de programaci\u00f3n. Sin embargo, a\u00fan es posible cometer errores en la implementaci\u00f3n de funciones o estructuras de datos, por lo que es importante utilizar t\u00e9cnicas de programaci\u00f3n segura para evitarlos. Una de las principales caracter\u00edsticas de Haskell es su sistema de tipos fuertemente est\u00e1tico, que permite detectar errores en tiempo de compilaci\u00f3n. Esto evita que se ejecuten programas con errores y garantiza la integridad de los datos en tiempo de ejecuci\u00f3n. Adem\u00e1s, Haskell cuenta con herramientas como la verificaci\u00f3n est\u00e1tica de propiedades y el uso de tipos algebraicos de datos para evitar errores comunes como la falta de manejo de casos o el uso de valores nulos. Palabras clave \u00b6 Haskell: lenguaje funcional puro basado en la evaluaci\u00f3n de expresiones. Seguridad: garant\u00eda de que un programa funcione correctamente y no presente errores. Robustez: capacidad de un programa para manejar errores y situaciones inesperadas. Tipos est\u00e1ticos: sistema de tipos que verifica errores en tiempo de compilaci\u00f3n. Propiedades: caracter\u00edsticas que deben cumplir los programas para ser considerados correctos. Tipos algebraicos de datos: estructuras de datos que permiten modelar de manera precisa los posibles valores de un tipo. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la programaci\u00f3n segura? \u00bfCu\u00e1les son las caracter\u00edsticas de Haskell que lo hacen m\u00e1s seguro que otros lenguajes? \u00bfC\u00f3mo ayuda el sistema de tipos est\u00e1ticos de Haskell a prevenir errores? \u00bfQu\u00e9 son las propiedades en Haskell? \u00bfQu\u00e9 son los tipos algebraicos de datos y c\u00f3mo se utilizan en Haskell? Ejemplos de c\u00f3digo en Haskell \u00b6 Verificaci\u00f3n de tipos est\u00e1ticos \u00b6 -- Funci\u00f3n que recibe un n\u00famero y devuelve su doble doble :: Int -> Int doble x = x * 2 -- Error: se espera un Int, pero se recibe un Bool doble True Uso de tipos algebraicos de datos \u00b6 -- Definici\u00f3n de un tipo de dato que representa una persona data Persona = Persona String Int -- Funci\u00f3n que recibe una persona y devuelve su nombre nombre :: Persona -> String nombre ( Persona n _ ) = n -- Uso de pattern matching para manejar todos los casos posibles nombre ( Persona \"Juan\" 25 ) -- Devuelve \"Juan\" nombre ( Persona \"Ana\" 30 ) -- Devuelve \"Ana\" nombre ( Persona \"Pedro\" 20 ) -- Devuelve \"Pedro\" Ejercicios pr\u00e1cticos \u00b6 Escribe una funci\u00f3n en Haskell que reciba una lista de n\u00fameros y devuelva la suma de todos ellos. Crea un tipo de dato que represente una canci\u00f3n, con los campos t\u00edtulo, artista y duraci\u00f3n en segundos. Escribe una funci\u00f3n que reciba una lista de canciones y devuelva la duraci\u00f3n total en minutos. Utilizando pattern matching, escribe una funci\u00f3n que reciba un n\u00famero y devuelva su cuadrado si es positivo o su valor absoluto si es negativo. Consejos y mejores pr\u00e1cticas \u00b6 Utiliza el sistema de tipos est\u00e1ticos de Haskell a tu favor para prevenir errores. Aseg\u00farate de manejar todos los casos posibles en tus funciones utilizando pattern matching. Utiliza tipos algebraicos de datos para modelar de manera precisa tus estructuras de datos. Realiza pruebas y verificaciones est\u00e1ticas de propiedades para asegurarte de que tu programa funcione correctamente. Comenta tu c\u00f3digo de manera clara y concisa para facilitar su comprensi\u00f3n y mantenimiento en el futuro.","title":"Programaci\u00f3n Segura en Haskell"},{"location":"haskel/sr/programaci%C3%B3n_segura/#programacion-segura-en-haskell","text":"La programaci\u00f3n segura se refiere a la aplicaci\u00f3n de t\u00e9cnicas para mejorar la seguridad y robustez de un programa. En Haskell, un lenguaje funcional puro, estas t\u00e9cnicas se enfocan en prevenir errores y garantizar la integridad de los datos.","title":"Programaci\u00f3n Segura en Haskell"},{"location":"haskel/sr/programaci%C3%B3n_segura/#teoria","text":"Haskell, al ser un lenguaje puramente funcional, se basa en la evaluaci\u00f3n de expresiones y evita los efectos secundarios, lo que lo hace m\u00e1s seguro que otros lenguajes de programaci\u00f3n. Sin embargo, a\u00fan es posible cometer errores en la implementaci\u00f3n de funciones o estructuras de datos, por lo que es importante utilizar t\u00e9cnicas de programaci\u00f3n segura para evitarlos. Una de las principales caracter\u00edsticas de Haskell es su sistema de tipos fuertemente est\u00e1tico, que permite detectar errores en tiempo de compilaci\u00f3n. Esto evita que se ejecuten programas con errores y garantiza la integridad de los datos en tiempo de ejecuci\u00f3n. Adem\u00e1s, Haskell cuenta con herramientas como la verificaci\u00f3n est\u00e1tica de propiedades y el uso de tipos algebraicos de datos para evitar errores comunes como la falta de manejo de casos o el uso de valores nulos.","title":"Teor\u00eda"},{"location":"haskel/sr/programaci%C3%B3n_segura/#palabras-clave","text":"Haskell: lenguaje funcional puro basado en la evaluaci\u00f3n de expresiones. Seguridad: garant\u00eda de que un programa funcione correctamente y no presente errores. Robustez: capacidad de un programa para manejar errores y situaciones inesperadas. Tipos est\u00e1ticos: sistema de tipos que verifica errores en tiempo de compilaci\u00f3n. Propiedades: caracter\u00edsticas que deben cumplir los programas para ser considerados correctos. Tipos algebraicos de datos: estructuras de datos que permiten modelar de manera precisa los posibles valores de un tipo.","title":"Palabras clave"},{"location":"haskel/sr/programaci%C3%B3n_segura/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la programaci\u00f3n segura? \u00bfCu\u00e1les son las caracter\u00edsticas de Haskell que lo hacen m\u00e1s seguro que otros lenguajes? \u00bfC\u00f3mo ayuda el sistema de tipos est\u00e1ticos de Haskell a prevenir errores? \u00bfQu\u00e9 son las propiedades en Haskell? \u00bfQu\u00e9 son los tipos algebraicos de datos y c\u00f3mo se utilizan en Haskell?","title":"Preguntas de repaso"},{"location":"haskel/sr/programaci%C3%B3n_segura/#ejemplos-de-codigo-en-haskell","text":"","title":"Ejemplos de c\u00f3digo en Haskell"},{"location":"haskel/sr/programaci%C3%B3n_segura/#verificacion-de-tipos-estaticos","text":"-- Funci\u00f3n que recibe un n\u00famero y devuelve su doble doble :: Int -> Int doble x = x * 2 -- Error: se espera un Int, pero se recibe un Bool doble True","title":"Verificaci\u00f3n de tipos est\u00e1ticos"},{"location":"haskel/sr/programaci%C3%B3n_segura/#uso-de-tipos-algebraicos-de-datos","text":"-- Definici\u00f3n de un tipo de dato que representa una persona data Persona = Persona String Int -- Funci\u00f3n que recibe una persona y devuelve su nombre nombre :: Persona -> String nombre ( Persona n _ ) = n -- Uso de pattern matching para manejar todos los casos posibles nombre ( Persona \"Juan\" 25 ) -- Devuelve \"Juan\" nombre ( Persona \"Ana\" 30 ) -- Devuelve \"Ana\" nombre ( Persona \"Pedro\" 20 ) -- Devuelve \"Pedro\"","title":"Uso de tipos algebraicos de datos"},{"location":"haskel/sr/programaci%C3%B3n_segura/#ejercicios-practicos","text":"Escribe una funci\u00f3n en Haskell que reciba una lista de n\u00fameros y devuelva la suma de todos ellos. Crea un tipo de dato que represente una canci\u00f3n, con los campos t\u00edtulo, artista y duraci\u00f3n en segundos. Escribe una funci\u00f3n que reciba una lista de canciones y devuelva la duraci\u00f3n total en minutos. Utilizando pattern matching, escribe una funci\u00f3n que reciba un n\u00famero y devuelva su cuadrado si es positivo o su valor absoluto si es negativo.","title":"Ejercicios pr\u00e1cticos"},{"location":"haskel/sr/programaci%C3%B3n_segura/#consejos-y-mejores-practicas","text":"Utiliza el sistema de tipos est\u00e1ticos de Haskell a tu favor para prevenir errores. Aseg\u00farate de manejar todos los casos posibles en tus funciones utilizando pattern matching. Utiliza tipos algebraicos de datos para modelar de manera precisa tus estructuras de datos. Realiza pruebas y verificaciones est\u00e1ticas de propiedades para asegurarte de que tu programa funcione correctamente. Comenta tu c\u00f3digo de manera clara y concisa para facilitar su comprensi\u00f3n y mantenimiento en el futuro.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"haskel/sr/tipos_de_datos_abstractos/","text":"Tipos de Datos Abstractos \u00b6 Introducci\u00f3n \u00b6 En Haskell, un tipo de dato abstracto (TDA) es una estructura de datos que encapsula tanto datos como funciones que operan sobre esos datos. Esto permite al programador ocultar la implementaci\u00f3n interna del TDA y solo exponer una interfaz p\u00fablica para su uso. Esta t\u00e9cnica de encapsulaci\u00f3n promueve la modularidad y el mantenimiento del c\u00f3digo, ya que los cambios en la implementaci\u00f3n interna no afectar\u00e1n a los usuarios del TDA. Palabras clave \u00b6 TDA: Tipo de Dato Abstracto Encapsulaci\u00f3n: t\u00e9cnica de ocultar la implementaci\u00f3n interna de una estructura de datos. Interfaz p\u00fablica: conjunto de funciones accesibles para el uso del TDA. Modularidad: capacidad de dividir un programa en m\u00f3dulos independientes y cohesivos. Mantenimiento del c\u00f3digo: proceso de actualizar y mejorar el c\u00f3digo existente para corregir errores o agregar nuevas funcionalidades. Explicaci\u00f3n te\u00f3rica \u00b6 Los TDAs se basan en el concepto de abstracci\u00f3n de datos, que se refiere a la capacidad de representar un objeto complejo mediante una estructura de datos m\u00e1s simple y f\u00e1cil de manipular. En Haskell, esto se logra a trav\u00e9s de la definici\u00f3n de tipos de datos algebraicos (TDA) y el uso de tipos de datos abstractos. Los TDAs se definen utilizando la palabra clave \"data\" seguida del nombre del TDA y una lista de constructores de datos. Estos constructores pueden ser tanto valores simples como funciones, lo que permite una gran flexibilidad en la definici\u00f3n del TDA. Adem\u00e1s, se pueden agregar restricciones de tipo a los constructores para limitar los tipos de datos que pueden ser utilizados. La interfaz p\u00fablica de un TDA se define mediante funciones que operan sobre los datos encapsulados. Estas funciones pueden ser definidas en el mismo m\u00f3dulo que el TDA o en un m\u00f3dulo separado, lo que permite una mejor organizaci\u00f3n del c\u00f3digo. Adem\u00e1s, la interfaz p\u00fablica puede ser modificada sin afectar a los usuarios del TDA, siempre y cuando se mantenga la misma funcionalidad. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es un TDA en Haskell? \u00bfCu\u00e1l es el prop\u00f3sito de la encapsulaci\u00f3n en un TDA? \u00bfQu\u00e9 es una interfaz p\u00fablica en un TDA? \u00bfC\u00f3mo se define un TDA en Haskell? \u00bfQu\u00e9 es la abstracci\u00f3n de datos? \u00bfQu\u00e9 palabra clave se utiliza para definir un TDA en Haskell? \u00bfQu\u00e9 tipos de datos se pueden utilizar como constructores en un TDA? \u00bfEs posible agregar restricciones de tipo a los constructores de un TDA? \u00bfPueden las funciones de un TDA ser definidas en un m\u00f3dulo separado? \u00bfPor qu\u00e9 es importante mantener una interfaz p\u00fablica consistente en un TDA? Ejemplos de c\u00f3digo en Haskell \u00b6 -- Definici\u00f3n de un TDA de pila data Stack a = EmptyStack | Push a ( Stack a ) -- Funci\u00f3n para agregar un elemento a la pila push :: a -> Stack a -> Stack a push x s = Push x s -- Funci\u00f3n para eliminar el elemento superior de la pila pop :: Stack a -> Stack a pop ( Push _ s ) = s pop EmptyStack = error \"La pila est\u00e1 vac\u00eda\" -- Funci\u00f3n para obtener el elemento superior de la pila top :: Stack a -> a top ( Push x _ ) = x top EmptyStack = error \"La pila est\u00e1 vac\u00eda\" Ejercicios pr\u00e1cticos \u00b6 Define un TDA de lista que solo permita agregar elementos al final de la lista. Escribe una funci\u00f3n que concatene dos listas utilizando el TDA de lista definido en el ejercicio anterior. Define un TDA de \u00e1rbol binario y escribe una funci\u00f3n para insertar un elemento en el \u00e1rbol. Escribe una funci\u00f3n que determine si un elemento pertenece a un \u00e1rbol utilizando el TDA definido en el ejercicio anterior. Crea un m\u00f3dulo separado que contenga un TDA de matriz y funciones para realizar operaciones b\u00e1sicas de matrices, como suma y multiplicaci\u00f3n. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza nombres descriptivos para los constructores de un TDA y las funciones de su interfaz p\u00fablica. Documenta adecuadamente la interfaz p\u00fablica de un TDA para facilitar su uso y comprensi\u00f3n. Evita exponer la implementaci\u00f3n interna de un TDA, ya que esto puede afectar la modularidad y el mantenimiento del c\u00f3digo. Utiliza tipos de datos algebraicos para definir los constructores de un TDA y asegurarte de que se cumplan las restricciones de tipo necesarias. Separa la definici\u00f3n del TDA y su interfaz p\u00fablica en diferentes m\u00f3dulos para una mejor organizaci\u00f3n del c\u00f3digo.","title":"Tipos de Datos Abstractos"},{"location":"haskel/sr/tipos_de_datos_abstractos/#tipos-de-datos-abstractos","text":"","title":"Tipos de Datos Abstractos"},{"location":"haskel/sr/tipos_de_datos_abstractos/#introduccion","text":"En Haskell, un tipo de dato abstracto (TDA) es una estructura de datos que encapsula tanto datos como funciones que operan sobre esos datos. Esto permite al programador ocultar la implementaci\u00f3n interna del TDA y solo exponer una interfaz p\u00fablica para su uso. Esta t\u00e9cnica de encapsulaci\u00f3n promueve la modularidad y el mantenimiento del c\u00f3digo, ya que los cambios en la implementaci\u00f3n interna no afectar\u00e1n a los usuarios del TDA.","title":"Introducci\u00f3n"},{"location":"haskel/sr/tipos_de_datos_abstractos/#palabras-clave","text":"TDA: Tipo de Dato Abstracto Encapsulaci\u00f3n: t\u00e9cnica de ocultar la implementaci\u00f3n interna de una estructura de datos. Interfaz p\u00fablica: conjunto de funciones accesibles para el uso del TDA. Modularidad: capacidad de dividir un programa en m\u00f3dulos independientes y cohesivos. Mantenimiento del c\u00f3digo: proceso de actualizar y mejorar el c\u00f3digo existente para corregir errores o agregar nuevas funcionalidades.","title":"Palabras clave"},{"location":"haskel/sr/tipos_de_datos_abstractos/#explicacion-teorica","text":"Los TDAs se basan en el concepto de abstracci\u00f3n de datos, que se refiere a la capacidad de representar un objeto complejo mediante una estructura de datos m\u00e1s simple y f\u00e1cil de manipular. En Haskell, esto se logra a trav\u00e9s de la definici\u00f3n de tipos de datos algebraicos (TDA) y el uso de tipos de datos abstractos. Los TDAs se definen utilizando la palabra clave \"data\" seguida del nombre del TDA y una lista de constructores de datos. Estos constructores pueden ser tanto valores simples como funciones, lo que permite una gran flexibilidad en la definici\u00f3n del TDA. Adem\u00e1s, se pueden agregar restricciones de tipo a los constructores para limitar los tipos de datos que pueden ser utilizados. La interfaz p\u00fablica de un TDA se define mediante funciones que operan sobre los datos encapsulados. Estas funciones pueden ser definidas en el mismo m\u00f3dulo que el TDA o en un m\u00f3dulo separado, lo que permite una mejor organizaci\u00f3n del c\u00f3digo. Adem\u00e1s, la interfaz p\u00fablica puede ser modificada sin afectar a los usuarios del TDA, siempre y cuando se mantenga la misma funcionalidad.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"haskel/sr/tipos_de_datos_abstractos/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es un TDA en Haskell? \u00bfCu\u00e1l es el prop\u00f3sito de la encapsulaci\u00f3n en un TDA? \u00bfQu\u00e9 es una interfaz p\u00fablica en un TDA? \u00bfC\u00f3mo se define un TDA en Haskell? \u00bfQu\u00e9 es la abstracci\u00f3n de datos? \u00bfQu\u00e9 palabra clave se utiliza para definir un TDA en Haskell? \u00bfQu\u00e9 tipos de datos se pueden utilizar como constructores en un TDA? \u00bfEs posible agregar restricciones de tipo a los constructores de un TDA? \u00bfPueden las funciones de un TDA ser definidas en un m\u00f3dulo separado? \u00bfPor qu\u00e9 es importante mantener una interfaz p\u00fablica consistente en un TDA?","title":"Preguntas de repaso"},{"location":"haskel/sr/tipos_de_datos_abstractos/#ejemplos-de-codigo-en-haskell","text":"-- Definici\u00f3n de un TDA de pila data Stack a = EmptyStack | Push a ( Stack a ) -- Funci\u00f3n para agregar un elemento a la pila push :: a -> Stack a -> Stack a push x s = Push x s -- Funci\u00f3n para eliminar el elemento superior de la pila pop :: Stack a -> Stack a pop ( Push _ s ) = s pop EmptyStack = error \"La pila est\u00e1 vac\u00eda\" -- Funci\u00f3n para obtener el elemento superior de la pila top :: Stack a -> a top ( Push x _ ) = x top EmptyStack = error \"La pila est\u00e1 vac\u00eda\"","title":"Ejemplos de c\u00f3digo en Haskell"},{"location":"haskel/sr/tipos_de_datos_abstractos/#ejercicios-practicos","text":"Define un TDA de lista que solo permita agregar elementos al final de la lista. Escribe una funci\u00f3n que concatene dos listas utilizando el TDA de lista definido en el ejercicio anterior. Define un TDA de \u00e1rbol binario y escribe una funci\u00f3n para insertar un elemento en el \u00e1rbol. Escribe una funci\u00f3n que determine si un elemento pertenece a un \u00e1rbol utilizando el TDA definido en el ejercicio anterior. Crea un m\u00f3dulo separado que contenga un TDA de matriz y funciones para realizar operaciones b\u00e1sicas de matrices, como suma y multiplicaci\u00f3n.","title":"Ejercicios pr\u00e1cticos"},{"location":"haskel/sr/tipos_de_datos_abstractos/#consejos-o-mejores-practicas","text":"Utiliza nombres descriptivos para los constructores de un TDA y las funciones de su interfaz p\u00fablica. Documenta adecuadamente la interfaz p\u00fablica de un TDA para facilitar su uso y comprensi\u00f3n. Evita exponer la implementaci\u00f3n interna de un TDA, ya que esto puede afectar la modularidad y el mantenimiento del c\u00f3digo. Utiliza tipos de datos algebraicos para definir los constructores de un TDA y asegurarte de que se cumplan las restricciones de tipo necesarias. Separa la definici\u00f3n del TDA y su interfaz p\u00fablica en diferentes m\u00f3dulos para una mejor organizaci\u00f3n del c\u00f3digo.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"luminus/","text":"Curso de Luminus \u00b6 \u00a1Bienvenido(a) al curso de Luminus ! En este curso aprender\u00e1s sobre el framework Luminus para Clojure, abarcando diferentes niveles: Junior Mid Senior Cada nivel te guiar\u00e1 en la instalaci\u00f3n, configuraci\u00f3n, construcci\u00f3n de proyectos web, optimizaci\u00f3n, seguridad y despliegue de aplicaciones con Luminus.","title":"Curso de Luminus"},{"location":"luminus/#curso-de-luminus","text":"\u00a1Bienvenido(a) al curso de Luminus ! En este curso aprender\u00e1s sobre el framework Luminus para Clojure, abarcando diferentes niveles: Junior Mid Senior Cada nivel te guiar\u00e1 en la instalaci\u00f3n, configuraci\u00f3n, construcci\u00f3n de proyectos web, optimizaci\u00f3n, seguridad y despliegue de aplicaciones con Luminus.","title":"Curso de Luminus"},{"location":"luminus/jr/","text":"Luminus - Nivel Junior \u00b6 \u00a1Bienvenido/a al nivel Junior de Luminus! Comienza a familiarizarte con el framework Luminus para Clojure: Introducci\u00f3n a Luminus Framework Configuraci\u00f3n de Luminus Manejo de rutas y solicitudes Creaci\u00f3n de controladores Desarrollo de vistas Administraci\u00f3n de base de datos Implementaci\u00f3n de seguridad Proyecto final Despliegue de la aplicaci\u00f3n Optimizaci\u00f3n y depuraci\u00f3n luminus_jr.json contiene un \u00edndice detallado.","title":"Luminus - Nivel Junior"},{"location":"luminus/jr/#luminus-nivel-junior","text":"\u00a1Bienvenido/a al nivel Junior de Luminus! Comienza a familiarizarte con el framework Luminus para Clojure: Introducci\u00f3n a Luminus Framework Configuraci\u00f3n de Luminus Manejo de rutas y solicitudes Creaci\u00f3n de controladores Desarrollo de vistas Administraci\u00f3n de base de datos Implementaci\u00f3n de seguridad Proyecto final Despliegue de la aplicaci\u00f3n Optimizaci\u00f3n y depuraci\u00f3n luminus_jr.json contiene un \u00edndice detallado.","title":"Luminus - Nivel Junior"},{"location":"luminus/jr/administraci%C3%B3n_de_base_de_datos/","text":"Administraci\u00f3n de base de datos en Luminus Framework \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En este m\u00f3dulo se explicar\u00e1 c\u00f3mo trabajar con la base de datos en Luminus Framework. Se ver\u00e1 c\u00f3mo configurar y conectarse a una base de datos, c\u00f3mo crear modelos y c\u00f3mo realizar consultas utilizando SQL o un ORM. Explicaci\u00f3n te\u00f3rica \u00b6 Luminus Framework utiliza una capa de persistencia basada en el framework de Java, Hibernate. Esto significa que puedes trabajar con bases de datos relacionales utilizando SQL o utilizar un ORM (Object-Relational Mapping) para interactuar con la base de datos de una manera m\u00e1s orientada a objetos. En Luminus, puedes utilizar cualquier base de datos relacional compatible con JDBC, como PostgreSQL, MySQL, Oracle, entre otros. La administraci\u00f3n de la base de datos en Luminus se divide en tres partes principales: configuraci\u00f3n y conexi\u00f3n, creaci\u00f3n de modelos y consultas. Configuraci\u00f3n y conexi\u00f3n \u00b6 Para configurar y conectarse a una base de datos en Luminus, primero debes especificar la dependencia de la base de datos en tu proyecto utilizando Leiningen o Maven. Luego, debes configurar la conexi\u00f3n en el archivo \"project.clj\" o \"pom.xml\" seg\u00fan el gestor de dependencias que est\u00e9s utilizando. Una vez configurada la conexi\u00f3n, puedes crear una instancia de la base de datos en tu aplicaci\u00f3n utilizando el archivo \"resources/config.edn\". Luminus tambi\u00e9n proporciona una funci\u00f3n llamada \"migrate\" que te permite crear autom\u00e1ticamente las tablas y relaciones en la base de datos bas\u00e1ndose en tus modelos. Creaci\u00f3n de modelos \u00b6 En Luminus, los modelos son clases que representan una tabla en la base de datos. Puedes crearlos manualmente utilizando anotaciones de Hibernate o mediante la generaci\u00f3n autom\u00e1tica de c\u00f3digo utilizando un plugin de Luminus. Los modelos tambi\u00e9n pueden tener relaciones entre s\u00ed, lo que facilita la creaci\u00f3n de consultas m\u00e1s complejas. Consultas \u00b6 Para realizar consultas a la base de datos en Luminus, puedes usar SQL directamente o utilizar un ORM como Hibernate. El uso de un ORM te permite escribir consultas de manera m\u00e1s orientada a objetos, lo que puede facilitar la lectura y el mantenimiento del c\u00f3digo. Luminus tambi\u00e9n proporciona una biblioteca llamada \"Korma\" que te permite escribir consultas en un estilo m\u00e1s declarativo. Palabras clave y su definici\u00f3n \u00b6 Base de datos: un sistema de almacenamiento de datos estructurado que permite la creaci\u00f3n, lectura, actualizaci\u00f3n y eliminaci\u00f3n de informaci\u00f3n de manera eficiente. Hibernate: un framework de mapeo objeto-relacional para Java que permite interactuar con una base de datos relacional utilizando objetos. JDBC: Java Database Connectivity, una API de Java que permite la conexi\u00f3n y ejecuci\u00f3n de consultas a bases de datos relacionales. ORM (Object-Relational Mapping): una t\u00e9cnica de programaci\u00f3n que permite mapear objetos en una base de datos relacional y viceversa. Leiningen y Maven: gestores de dependencias para proyectos en Clojure y Java, respectivamente. Plugin: una extensi\u00f3n de software que agrega funcionalidad a una aplicaci\u00f3n existente. Anotaciones: etiquetas utilizadas en el c\u00f3digo para agregar metadatos o comportamiento adicional. Korma: una biblioteca de Luminus que permite escribir consultas en un estilo m\u00e1s declarativo. Preguntas de repaso \u00b6 \u00bfQu\u00e9 framework de Java se utiliza en Luminus para interactuar con la base de datos? \u00bfQu\u00e9 es un ORM y c\u00f3mo se utiliza en Luminus? \u00bfQu\u00e9 funci\u00f3n proporciona Luminus para crear autom\u00e1ticamente tablas y relaciones en la base de datos? \u00bfQu\u00e9 biblioteca de Luminus permite escribir consultas en un estilo m\u00e1s declarativo? \u00bfQu\u00e9 gestores de dependencias se pueden utilizar en Luminus? Ejemplos de c\u00f3digo en Luminus Framework \u00b6 Configuraci\u00f3n y conexi\u00f3n a una base de datos \u00b6 ;; En project.clj :dependencies [[ org.clojure/java.jdbc \"0.7.11\" ] [ org.clojure/java.jdbc-mysql \"0.7.11\" ]] ;; En config.edn { :database-url \"jdbc:mysql://localhost:3306/mydb\" :database-options { :user \"username\" :password \"password\" }} ;; Crear instancia de la base de datos ( def db ( luminus.db.core/db )) ;; Ejecutar migraciones ( luminus.db.migration/migrate db ) Creaci\u00f3n de modelos \u00b6 ;; Definir modelo con anotaciones de Hibernate ( ns myapp.models.user ( :require [ luminus.db.core :as db ] [ org.hibernate.annotations :refer :all ])) ( defrecord User [] Object ( toString [ _ ] ( str \"User: \" ( :username this )))) ( defn user [] ( db/entity User ( id :id ) ( property :username String ) ( property :password String ))) ;; Generar modelo con plugin de Luminus ( lein generate model user ) Consultas con Korma \u00b6 ;; Consulta utilizando Korma ( require ' [ korma.db :refer [ exec-raw ]] ' [ korma.core :refer :all ]) ( defn get-users [] ( select users )) ( defn get-users-by-id [ id ] ( select users ( where { :id id }))) Ejercicios pr\u00e1cticos \u00b6 Configura y conecta tu aplicaci\u00f3n de Luminus a una base de datos PostgreSQL. Crea un modelo para una tabla \"producto\" con los campos \"nombre\", \"precio\" y \"cantidad\". Escribe una consulta utilizando Korma para obtener todos los productos con un precio mayor a $50. Agrega una nueva columna llamada \"descripcion\" a la tabla \"producto\" y actualiza tu modelo y consultas para reflejar este cambio. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza modelos y relaciones entre ellos para facilitar la creaci\u00f3n de consultas complejas. Si est\u00e1s utilizando un ORM, aseg\u00farate de comprender c\u00f3mo se traducen tus consultas a SQL para evitar posibles problemas de rendimiento. Utiliza la funci\u00f3n \"migrate\" para crear autom\u00e1ticamente tablas y relaciones en la base de datos bas\u00e1ndose en tus modelos. Utiliza la biblioteca Korma para escribir consultas de manera m\u00e1s declarativa y legible.","title":"Administraci\u00f3n de base de datos en Luminus Framework"},{"location":"luminus/jr/administraci%C3%B3n_de_base_de_datos/#administracion-de-base-de-datos-en-luminus-framework","text":"","title":"Administraci\u00f3n de base de datos en Luminus Framework"},{"location":"luminus/jr/administraci%C3%B3n_de_base_de_datos/#descripcion-del-modulo","text":"En este m\u00f3dulo se explicar\u00e1 c\u00f3mo trabajar con la base de datos en Luminus Framework. Se ver\u00e1 c\u00f3mo configurar y conectarse a una base de datos, c\u00f3mo crear modelos y c\u00f3mo realizar consultas utilizando SQL o un ORM.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"luminus/jr/administraci%C3%B3n_de_base_de_datos/#explicacion-teorica","text":"Luminus Framework utiliza una capa de persistencia basada en el framework de Java, Hibernate. Esto significa que puedes trabajar con bases de datos relacionales utilizando SQL o utilizar un ORM (Object-Relational Mapping) para interactuar con la base de datos de una manera m\u00e1s orientada a objetos. En Luminus, puedes utilizar cualquier base de datos relacional compatible con JDBC, como PostgreSQL, MySQL, Oracle, entre otros. La administraci\u00f3n de la base de datos en Luminus se divide en tres partes principales: configuraci\u00f3n y conexi\u00f3n, creaci\u00f3n de modelos y consultas.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"luminus/jr/administraci%C3%B3n_de_base_de_datos/#configuracion-y-conexion","text":"Para configurar y conectarse a una base de datos en Luminus, primero debes especificar la dependencia de la base de datos en tu proyecto utilizando Leiningen o Maven. Luego, debes configurar la conexi\u00f3n en el archivo \"project.clj\" o \"pom.xml\" seg\u00fan el gestor de dependencias que est\u00e9s utilizando. Una vez configurada la conexi\u00f3n, puedes crear una instancia de la base de datos en tu aplicaci\u00f3n utilizando el archivo \"resources/config.edn\". Luminus tambi\u00e9n proporciona una funci\u00f3n llamada \"migrate\" que te permite crear autom\u00e1ticamente las tablas y relaciones en la base de datos bas\u00e1ndose en tus modelos.","title":"Configuraci\u00f3n y conexi\u00f3n"},{"location":"luminus/jr/administraci%C3%B3n_de_base_de_datos/#creacion-de-modelos","text":"En Luminus, los modelos son clases que representan una tabla en la base de datos. Puedes crearlos manualmente utilizando anotaciones de Hibernate o mediante la generaci\u00f3n autom\u00e1tica de c\u00f3digo utilizando un plugin de Luminus. Los modelos tambi\u00e9n pueden tener relaciones entre s\u00ed, lo que facilita la creaci\u00f3n de consultas m\u00e1s complejas.","title":"Creaci\u00f3n de modelos"},{"location":"luminus/jr/administraci%C3%B3n_de_base_de_datos/#consultas","text":"Para realizar consultas a la base de datos en Luminus, puedes usar SQL directamente o utilizar un ORM como Hibernate. El uso de un ORM te permite escribir consultas de manera m\u00e1s orientada a objetos, lo que puede facilitar la lectura y el mantenimiento del c\u00f3digo. Luminus tambi\u00e9n proporciona una biblioteca llamada \"Korma\" que te permite escribir consultas en un estilo m\u00e1s declarativo.","title":"Consultas"},{"location":"luminus/jr/administraci%C3%B3n_de_base_de_datos/#palabras-clave-y-su-definicion","text":"Base de datos: un sistema de almacenamiento de datos estructurado que permite la creaci\u00f3n, lectura, actualizaci\u00f3n y eliminaci\u00f3n de informaci\u00f3n de manera eficiente. Hibernate: un framework de mapeo objeto-relacional para Java que permite interactuar con una base de datos relacional utilizando objetos. JDBC: Java Database Connectivity, una API de Java que permite la conexi\u00f3n y ejecuci\u00f3n de consultas a bases de datos relacionales. ORM (Object-Relational Mapping): una t\u00e9cnica de programaci\u00f3n que permite mapear objetos en una base de datos relacional y viceversa. Leiningen y Maven: gestores de dependencias para proyectos en Clojure y Java, respectivamente. Plugin: una extensi\u00f3n de software que agrega funcionalidad a una aplicaci\u00f3n existente. Anotaciones: etiquetas utilizadas en el c\u00f3digo para agregar metadatos o comportamiento adicional. Korma: una biblioteca de Luminus que permite escribir consultas en un estilo m\u00e1s declarativo.","title":"Palabras clave y su definici\u00f3n"},{"location":"luminus/jr/administraci%C3%B3n_de_base_de_datos/#preguntas-de-repaso","text":"\u00bfQu\u00e9 framework de Java se utiliza en Luminus para interactuar con la base de datos? \u00bfQu\u00e9 es un ORM y c\u00f3mo se utiliza en Luminus? \u00bfQu\u00e9 funci\u00f3n proporciona Luminus para crear autom\u00e1ticamente tablas y relaciones en la base de datos? \u00bfQu\u00e9 biblioteca de Luminus permite escribir consultas en un estilo m\u00e1s declarativo? \u00bfQu\u00e9 gestores de dependencias se pueden utilizar en Luminus?","title":"Preguntas de repaso"},{"location":"luminus/jr/administraci%C3%B3n_de_base_de_datos/#ejemplos-de-codigo-en-luminus-framework","text":"","title":"Ejemplos de c\u00f3digo en Luminus Framework"},{"location":"luminus/jr/administraci%C3%B3n_de_base_de_datos/#configuracion-y-conexion-a-una-base-de-datos","text":";; En project.clj :dependencies [[ org.clojure/java.jdbc \"0.7.11\" ] [ org.clojure/java.jdbc-mysql \"0.7.11\" ]] ;; En config.edn { :database-url \"jdbc:mysql://localhost:3306/mydb\" :database-options { :user \"username\" :password \"password\" }} ;; Crear instancia de la base de datos ( def db ( luminus.db.core/db )) ;; Ejecutar migraciones ( luminus.db.migration/migrate db )","title":"Configuraci\u00f3n y conexi\u00f3n a una base de datos"},{"location":"luminus/jr/administraci%C3%B3n_de_base_de_datos/#creacion-de-modelos_1","text":";; Definir modelo con anotaciones de Hibernate ( ns myapp.models.user ( :require [ luminus.db.core :as db ] [ org.hibernate.annotations :refer :all ])) ( defrecord User [] Object ( toString [ _ ] ( str \"User: \" ( :username this )))) ( defn user [] ( db/entity User ( id :id ) ( property :username String ) ( property :password String ))) ;; Generar modelo con plugin de Luminus ( lein generate model user )","title":"Creaci\u00f3n de modelos"},{"location":"luminus/jr/administraci%C3%B3n_de_base_de_datos/#consultas-con-korma","text":";; Consulta utilizando Korma ( require ' [ korma.db :refer [ exec-raw ]] ' [ korma.core :refer :all ]) ( defn get-users [] ( select users )) ( defn get-users-by-id [ id ] ( select users ( where { :id id })))","title":"Consultas con Korma"},{"location":"luminus/jr/administraci%C3%B3n_de_base_de_datos/#ejercicios-practicos","text":"Configura y conecta tu aplicaci\u00f3n de Luminus a una base de datos PostgreSQL. Crea un modelo para una tabla \"producto\" con los campos \"nombre\", \"precio\" y \"cantidad\". Escribe una consulta utilizando Korma para obtener todos los productos con un precio mayor a $50. Agrega una nueva columna llamada \"descripcion\" a la tabla \"producto\" y actualiza tu modelo y consultas para reflejar este cambio.","title":"Ejercicios pr\u00e1cticos"},{"location":"luminus/jr/administraci%C3%B3n_de_base_de_datos/#consejos-o-mejores-practicas","text":"Utiliza modelos y relaciones entre ellos para facilitar la creaci\u00f3n de consultas complejas. Si est\u00e1s utilizando un ORM, aseg\u00farate de comprender c\u00f3mo se traducen tus consultas a SQL para evitar posibles problemas de rendimiento. Utiliza la funci\u00f3n \"migrate\" para crear autom\u00e1ticamente tablas y relaciones en la base de datos bas\u00e1ndose en tus modelos. Utiliza la biblioteca Korma para escribir consultas de manera m\u00e1s declarativa y legible.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"luminus/jr/configuraci%C3%B3n_de_luminus/","text":"Configuraci\u00f3n de Luminus \u00b6 Descripci\u00f3n te\u00f3rica \u00b6 Luminus es un framework para aplicaciones web en Clojure que combina las mejores pr\u00e1cticas y herramientas de la comunidad en una estructura cohesiva y f\u00e1cil de usar. Una de las ventajas de Luminus es su configuraci\u00f3n sencilla, que permite a los desarrolladores comenzar a trabajar r\u00e1pidamente en sus proyectos sin tener que preocuparse por la configuraci\u00f3n inicial. En este m\u00f3dulo, aprender\u00e1s c\u00f3mo configurar Luminus correctamente para empezar a trabajar con \u00e9l. Se explicar\u00e1n los pasos necesarios para crear un proyecto, configurar dependencias y manejar la estructura de directorios. Palabras clave y su definici\u00f3n \u00b6 Luminus: Framework de desarrollo web en Clojure. Proyecto: Conjunto de archivos y configuraciones que conforman una aplicaci\u00f3n web. Dependencias: Bibliotecas o m\u00f3dulos externos necesarios para el funcionamiento del proyecto. Estructura de directorios: Organizaci\u00f3n de los archivos y carpetas en un proyecto. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es Luminus? \u00bfCu\u00e1les son las ventajas de Luminus? \u00bfQu\u00e9 es un proyecto en Luminus? \u00bfPara qu\u00e9 se utilizan las dependencias en un proyecto? \u00bfQu\u00e9 es la estructura de directorios en un proyecto? Ejemplos de c\u00f3digo en Luminus Framework \u00b6 ( defproject myapp \"0.1.0\" :dependencies [[ org.clojure/clojure \"1.10.1\" ] [ luminus \"3.83\" ]] :main ^ :skip-aot myapp.core :target-path \"target/%s\" :profiles { :uberjar { :aot :all }}) En este ejemplo, se muestra la configuraci\u00f3n del archivo project.clj en un proyecto Luminus. Aqu\u00ed se especifican las dependencias necesarias para el proyecto, as\u00ed como el archivo principal y la ubicaci\u00f3n del directorio de destino. Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea un proyecto Luminus llamado \"myapp\" con la versi\u00f3n \"0.1.0\". Agrega la dependencia \"luminus\" en el archivo project.clj . Abre el archivo project.clj y cambia la ubicaci\u00f3n del directorio de destino a \"target/myapp\". Verifica que la configuraci\u00f3n se haya guardado correctamente. Crea un nuevo controlador llamado \"home\" con la ruta \"/\". Agrega una vista llamada \"index\" en la carpeta \"resources/templates\". En el controlador \"home\", agrega una funci\u00f3n que renderice la vista \"index\" al acceder a la ruta \"/\". Inicia el servidor y verifica que la vista se muestre correctamente en la ruta \"/\". Crea una nueva dependencia en el archivo project.clj y verifica que se descargue correctamente al iniciar el servidor. Agrega una nueva funci\u00f3n en el controlador \"home\" que utilice la dependencia reci\u00e9n agregada. Verifica que la funci\u00f3n se ejecute correctamente al acceder a la ruta \"/\". Experimenta con la estructura de directorios y agrega nuevos archivos y carpetas en el proyecto. Reinicia el servidor y verifica que los cambios se hayan reflejado correctamente. Practica la creaci\u00f3n de nuevos controladores y rutas, as\u00ed como la utilizaci\u00f3n de dependencias en tu proyecto. Consejos o mejores pr\u00e1cticas \u00b6 Al crear un proyecto Luminus, es recomendable utilizar una versi\u00f3n espec\u00edfica para evitar problemas de compatibilidad con futuras actualizaciones. Organiza tus dependencias en grupos l\u00f3gicos en el archivo project.clj para una mejor legibilidad. Utiliza la estructura de directorios predeterminada de Luminus para una f\u00e1cil navegaci\u00f3n y mantenimiento del proyecto. Aprovecha la documentaci\u00f3n y la comunidad de Luminus para resolver dudas y aprender buenas pr\u00e1cticas en el desarrollo de aplicaciones web en Clojure.","title":"Configuraci\u00f3n de Luminus"},{"location":"luminus/jr/configuraci%C3%B3n_de_luminus/#configuracion-de-luminus","text":"","title":"Configuraci\u00f3n de Luminus"},{"location":"luminus/jr/configuraci%C3%B3n_de_luminus/#descripcion-teorica","text":"Luminus es un framework para aplicaciones web en Clojure que combina las mejores pr\u00e1cticas y herramientas de la comunidad en una estructura cohesiva y f\u00e1cil de usar. Una de las ventajas de Luminus es su configuraci\u00f3n sencilla, que permite a los desarrolladores comenzar a trabajar r\u00e1pidamente en sus proyectos sin tener que preocuparse por la configuraci\u00f3n inicial. En este m\u00f3dulo, aprender\u00e1s c\u00f3mo configurar Luminus correctamente para empezar a trabajar con \u00e9l. Se explicar\u00e1n los pasos necesarios para crear un proyecto, configurar dependencias y manejar la estructura de directorios.","title":"Descripci\u00f3n te\u00f3rica"},{"location":"luminus/jr/configuraci%C3%B3n_de_luminus/#palabras-clave-y-su-definicion","text":"Luminus: Framework de desarrollo web en Clojure. Proyecto: Conjunto de archivos y configuraciones que conforman una aplicaci\u00f3n web. Dependencias: Bibliotecas o m\u00f3dulos externos necesarios para el funcionamiento del proyecto. Estructura de directorios: Organizaci\u00f3n de los archivos y carpetas en un proyecto.","title":"Palabras clave y su definici\u00f3n"},{"location":"luminus/jr/configuraci%C3%B3n_de_luminus/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Luminus? \u00bfCu\u00e1les son las ventajas de Luminus? \u00bfQu\u00e9 es un proyecto en Luminus? \u00bfPara qu\u00e9 se utilizan las dependencias en un proyecto? \u00bfQu\u00e9 es la estructura de directorios en un proyecto?","title":"Preguntas de repaso"},{"location":"luminus/jr/configuraci%C3%B3n_de_luminus/#ejemplos-de-codigo-en-luminus-framework","text":"( defproject myapp \"0.1.0\" :dependencies [[ org.clojure/clojure \"1.10.1\" ] [ luminus \"3.83\" ]] :main ^ :skip-aot myapp.core :target-path \"target/%s\" :profiles { :uberjar { :aot :all }}) En este ejemplo, se muestra la configuraci\u00f3n del archivo project.clj en un proyecto Luminus. Aqu\u00ed se especifican las dependencias necesarias para el proyecto, as\u00ed como el archivo principal y la ubicaci\u00f3n del directorio de destino.","title":"Ejemplos de c\u00f3digo en Luminus Framework"},{"location":"luminus/jr/configuraci%C3%B3n_de_luminus/#ejercicios-practicos-con-instrucciones-claras","text":"Crea un proyecto Luminus llamado \"myapp\" con la versi\u00f3n \"0.1.0\". Agrega la dependencia \"luminus\" en el archivo project.clj . Abre el archivo project.clj y cambia la ubicaci\u00f3n del directorio de destino a \"target/myapp\". Verifica que la configuraci\u00f3n se haya guardado correctamente. Crea un nuevo controlador llamado \"home\" con la ruta \"/\". Agrega una vista llamada \"index\" en la carpeta \"resources/templates\". En el controlador \"home\", agrega una funci\u00f3n que renderice la vista \"index\" al acceder a la ruta \"/\". Inicia el servidor y verifica que la vista se muestre correctamente en la ruta \"/\". Crea una nueva dependencia en el archivo project.clj y verifica que se descargue correctamente al iniciar el servidor. Agrega una nueva funci\u00f3n en el controlador \"home\" que utilice la dependencia reci\u00e9n agregada. Verifica que la funci\u00f3n se ejecute correctamente al acceder a la ruta \"/\". Experimenta con la estructura de directorios y agrega nuevos archivos y carpetas en el proyecto. Reinicia el servidor y verifica que los cambios se hayan reflejado correctamente. Practica la creaci\u00f3n de nuevos controladores y rutas, as\u00ed como la utilizaci\u00f3n de dependencias en tu proyecto.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"luminus/jr/configuraci%C3%B3n_de_luminus/#consejos-o-mejores-practicas","text":"Al crear un proyecto Luminus, es recomendable utilizar una versi\u00f3n espec\u00edfica para evitar problemas de compatibilidad con futuras actualizaciones. Organiza tus dependencias en grupos l\u00f3gicos en el archivo project.clj para una mejor legibilidad. Utiliza la estructura de directorios predeterminada de Luminus para una f\u00e1cil navegaci\u00f3n y mantenimiento del proyecto. Aprovecha la documentaci\u00f3n y la comunidad de Luminus para resolver dudas y aprender buenas pr\u00e1cticas en el desarrollo de aplicaciones web en Clojure.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"luminus/jr/creaci%C3%B3n_de_controladores/","text":"Creaci\u00f3n de controladores en Luminus Framework \u00b6 Descripci\u00f3n te\u00f3rica \u00b6 Los controladores son una parte fundamental en el desarrollo de aplicaciones web, ya que se encargan de gestionar las solicitudes de los usuarios y devolverles una respuesta adecuada. En Luminus Framework, los controladores se basan en el patr\u00f3n MVC (Modelo-Vista-Controlador), donde el controlador act\u00faa como intermediario entre la vista y el modelo. En pocas palabras, el controlador es el encargado de recibir las solicitudes de los usuarios, procesarlas y enviar una respuesta al navegador. Esta respuesta puede ser una p\u00e1gina HTML, un archivo est\u00e1tico, un mensaje de error, entre otros. Palabras clave y su definici\u00f3n \u00b6 Controlador: Es una clase que gestiona las solicitudes de los usuarios y devuelve una respuesta. Rutas: Son las direcciones URL que se utilizan para acceder a los diferentes recursos de la aplicaci\u00f3n. M\u00e9todos HTTP: Son las acciones que se pueden realizar sobre una ruta, como GET, POST, PUT, DELETE, entre otros. Par\u00e1metros: Son valores que se env\u00edan junto con la solicitud y que se utilizan para realizar acciones espec\u00edficas en el controlador. Middleware: Son funciones que se ejecutan antes o despu\u00e9s de una solicitud, y permiten realizar tareas como autenticaci\u00f3n, manejo de errores, entre otros. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es un controlador en Luminus Framework? \u00bfCu\u00e1l es el patr\u00f3n utilizado para el desarrollo de controladores en Luminus? \u00bfQu\u00e9 es una ruta y cu\u00e1l es su funci\u00f3n en una aplicaci\u00f3n web? \u00bfQu\u00e9 son los m\u00e9todos HTTP y cu\u00e1l es su importancia en el desarrollo de controladores? \u00bfPara qu\u00e9 se utilizan los par\u00e1metros en una solicitud? \u00bfQu\u00e9 es un middleware y cu\u00e1l es su utilidad en el desarrollo de aplicaciones web? Ejemplos de c\u00f3digo en Luminus Framework \u00b6 A continuaci\u00f3n, se muestra un ejemplo de un controlador en Luminus que maneja la solicitud de la ruta \"/users\" y devuelve una lista de usuarios en formato JSON: ( ns my-app.controllers.users ( :require [ ring.util.response :as response ])) ( defn get-users [ request ] ( let [ users ( db/get-users )] ; Se obtienen los usuarios desde la base de datos ( response/json-response users ))) ; Se devuelve una respuesta en formato JSON En este ejemplo, se utiliza el m\u00e9todo GET para obtener la lista de usuarios, y se utiliza el middleware response/json-response para devolver una respuesta en formato JSON. Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea un nuevo proyecto en Luminus y configura una ruta \"/hello\" que devuelva una p\u00e1gina HTML con el mensaje \"Hola mundo\". Crea un controlador que maneje la solicitud de la ruta \"/users/:id\" y devuelva los datos del usuario con el ID especificado en formato JSON. Agrega un middleware que verifique si el usuario tiene permisos para acceder a ciertas rutas de la aplicaci\u00f3n. Crea un formulario de registro de usuarios que env\u00ede los datos al controlador correspondiente para ser almacenados en la base de datos. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza nombres descriptivos para tus controladores y m\u00e9todos, por ejemplo: users-controller y get-users . Divide tus controladores en funciones m\u00e1s peque\u00f1as para facilitar su mantenimiento. Utiliza middlewares para realizar tareas comunes como autenticaci\u00f3n, manejo de errores, entre otros. Utiliza la funci\u00f3n defroutes para definir todas las rutas de tu aplicaci\u00f3n en un solo lugar. Aprovecha al m\u00e1ximo las funcionalidades de Luminus, como la gesti\u00f3n de dependencias y la integraci\u00f3n con otras bibliotecas.","title":"Creaci\u00f3n de controladores en Luminus Framework"},{"location":"luminus/jr/creaci%C3%B3n_de_controladores/#creacion-de-controladores-en-luminus-framework","text":"","title":"Creaci\u00f3n de controladores en Luminus Framework"},{"location":"luminus/jr/creaci%C3%B3n_de_controladores/#descripcion-teorica","text":"Los controladores son una parte fundamental en el desarrollo de aplicaciones web, ya que se encargan de gestionar las solicitudes de los usuarios y devolverles una respuesta adecuada. En Luminus Framework, los controladores se basan en el patr\u00f3n MVC (Modelo-Vista-Controlador), donde el controlador act\u00faa como intermediario entre la vista y el modelo. En pocas palabras, el controlador es el encargado de recibir las solicitudes de los usuarios, procesarlas y enviar una respuesta al navegador. Esta respuesta puede ser una p\u00e1gina HTML, un archivo est\u00e1tico, un mensaje de error, entre otros.","title":"Descripci\u00f3n te\u00f3rica"},{"location":"luminus/jr/creaci%C3%B3n_de_controladores/#palabras-clave-y-su-definicion","text":"Controlador: Es una clase que gestiona las solicitudes de los usuarios y devuelve una respuesta. Rutas: Son las direcciones URL que se utilizan para acceder a los diferentes recursos de la aplicaci\u00f3n. M\u00e9todos HTTP: Son las acciones que se pueden realizar sobre una ruta, como GET, POST, PUT, DELETE, entre otros. Par\u00e1metros: Son valores que se env\u00edan junto con la solicitud y que se utilizan para realizar acciones espec\u00edficas en el controlador. Middleware: Son funciones que se ejecutan antes o despu\u00e9s de una solicitud, y permiten realizar tareas como autenticaci\u00f3n, manejo de errores, entre otros.","title":"Palabras clave y su definici\u00f3n"},{"location":"luminus/jr/creaci%C3%B3n_de_controladores/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es un controlador en Luminus Framework? \u00bfCu\u00e1l es el patr\u00f3n utilizado para el desarrollo de controladores en Luminus? \u00bfQu\u00e9 es una ruta y cu\u00e1l es su funci\u00f3n en una aplicaci\u00f3n web? \u00bfQu\u00e9 son los m\u00e9todos HTTP y cu\u00e1l es su importancia en el desarrollo de controladores? \u00bfPara qu\u00e9 se utilizan los par\u00e1metros en una solicitud? \u00bfQu\u00e9 es un middleware y cu\u00e1l es su utilidad en el desarrollo de aplicaciones web?","title":"Preguntas de repaso"},{"location":"luminus/jr/creaci%C3%B3n_de_controladores/#ejemplos-de-codigo-en-luminus-framework","text":"A continuaci\u00f3n, se muestra un ejemplo de un controlador en Luminus que maneja la solicitud de la ruta \"/users\" y devuelve una lista de usuarios en formato JSON: ( ns my-app.controllers.users ( :require [ ring.util.response :as response ])) ( defn get-users [ request ] ( let [ users ( db/get-users )] ; Se obtienen los usuarios desde la base de datos ( response/json-response users ))) ; Se devuelve una respuesta en formato JSON En este ejemplo, se utiliza el m\u00e9todo GET para obtener la lista de usuarios, y se utiliza el middleware response/json-response para devolver una respuesta en formato JSON.","title":"Ejemplos de c\u00f3digo en Luminus Framework"},{"location":"luminus/jr/creaci%C3%B3n_de_controladores/#ejercicios-practicos-con-instrucciones-claras","text":"Crea un nuevo proyecto en Luminus y configura una ruta \"/hello\" que devuelva una p\u00e1gina HTML con el mensaje \"Hola mundo\". Crea un controlador que maneje la solicitud de la ruta \"/users/:id\" y devuelva los datos del usuario con el ID especificado en formato JSON. Agrega un middleware que verifique si el usuario tiene permisos para acceder a ciertas rutas de la aplicaci\u00f3n. Crea un formulario de registro de usuarios que env\u00ede los datos al controlador correspondiente para ser almacenados en la base de datos.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"luminus/jr/creaci%C3%B3n_de_controladores/#consejos-o-mejores-practicas","text":"Utiliza nombres descriptivos para tus controladores y m\u00e9todos, por ejemplo: users-controller y get-users . Divide tus controladores en funciones m\u00e1s peque\u00f1as para facilitar su mantenimiento. Utiliza middlewares para realizar tareas comunes como autenticaci\u00f3n, manejo de errores, entre otros. Utiliza la funci\u00f3n defroutes para definir todas las rutas de tu aplicaci\u00f3n en un solo lugar. Aprovecha al m\u00e1ximo las funcionalidades de Luminus, como la gesti\u00f3n de dependencias y la integraci\u00f3n con otras bibliotecas.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"luminus/jr/desarrollo_de_vistas/","text":"Desarrollo de vistas en Luminus Framework \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En este m\u00f3dulo aprenderemos c\u00f3mo desarrollar vistas en Luminus Framework, un framework de desarrollo web basado en Clojure. Las vistas son una parte esencial de cualquier aplicaci\u00f3n web, ya que son las encargadas de mostrar la informaci\u00f3n al usuario final. En Luminus, las vistas se pueden crear utilizando diferentes plantillas y se pueden integrar con HTML, CSS y JavaScript para crear una interfaz visual atractiva. Explicaci\u00f3n te\u00f3rica \u00b6 Una vista en Luminus es una p\u00e1gina web que se muestra al usuario final. Estas vistas pueden ser est\u00e1ticas o din\u00e1micas, lo que significa que pueden mostrar contenido predefinido o contenido generado din\u00e1micamente en funci\u00f3n de la l\u00f3gica de la aplicaci\u00f3n. Las vistas se pueden crear utilizando diferentes plantillas, como hiccup, selmer o enlive, que nos permiten mezclar c\u00f3digo HTML con c\u00f3digo de Clojure. Para crear una vista en Luminus, primero debemos definir una ruta en nuestro archivo de rutas. Esta ruta estar\u00e1 asociada a una funci\u00f3n en nuestro controlador que se encargar\u00e1 de generar la vista. Dentro de esta funci\u00f3n, podemos utilizar la plantilla que hayamos elegido para crear nuestra vista, y tambi\u00e9n podemos utilizar variables y l\u00f3gica para mostrar contenido din\u00e1mico. Palabras clave y su definici\u00f3n \u00b6 Vistas: p\u00e1ginas web que se muestran al usuario final. Plantillas: archivos que nos permiten mezclar c\u00f3digo HTML con c\u00f3digo de Clojure para crear vistas. Hiccup: una de las plantillas disponibles en Luminus que utiliza una sintaxis similar a HTML para generar vistas. Selmer: otra plantilla disponible en Luminus que utiliza una sintaxis similar a Django para generar vistas. Enlive: una plantilla que nos permite utilizar CSS selectors para manipular el DOM y generar vistas din\u00e1micamente. Controlador: una parte de la arquitectura MVC que se encarga de manejar las peticiones y generar respuestas. Rutas: definiciones de URL que est\u00e1n asociadas a funciones en el controlador. Preguntas de repaso \u00b6 \u00bfQu\u00e9 son las vistas en Luminus Framework? \u00bfQu\u00e9 son las plantillas y cu\u00e1les est\u00e1n disponibles en Luminus? \u00bfQu\u00e9 es un controlador y qu\u00e9 funci\u00f3n tiene en la arquitectura MVC? \u00bfQu\u00e9 son las rutas y c\u00f3mo se relacionan con las vistas en Luminus? Ejemplos de c\u00f3digo en Luminus Framework \u00b6 Ejemplo de definici\u00f3n de una ruta en el archivo de rutas: ( GET \"/saludo/:nombre\" [] ( mi-proyecto.core/saludar )) Ejemplo de funci\u00f3n en el controlador que muestra una vista utilizando la plantilla enlive: ( defn saludar [] ( let [ nombre ( params :nombre )] ( enlive/html [ :h1 \"\u00a1Hola, \" nombre \"!\" ]))) Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una nueva ruta en el archivo de rutas que muestre una vista utilizando la plantilla selmer. En la funci\u00f3n correspondiente en el controlador, utiliza una variable y l\u00f3gica para mostrar un mensaje personalizado en la vista. Crea una nueva vista utilizando la plantilla enlive y utiliza CSS selectors para dar estilo a un elemento de la misma. Modifica una de las vistas existentes para que muestre informaci\u00f3n de una base de datos utilizando consultas a trav\u00e9s de una librer\u00eda como HoneySQL o Korma. Consejos o mejores pr\u00e1cticas \u00b6 Utilizar plantillas para generar vistas en lugar de escribir todo el c\u00f3digo HTML directamente en el controlador. Esto nos permite separar la l\u00f3gica de la presentaci\u00f3n y hace que el c\u00f3digo sea m\u00e1s legible y mantenible. Utilizar nombres descriptivos para las rutas y funciones en el controlador para facilitar la comprensi\u00f3n del c\u00f3digo. Utilizar l\u00f3gica y variables en las vistas para generar contenido din\u00e1micamente en lugar de mostrar contenido est\u00e1tico. Utilizar herramientas como Leiningen o Boot para gestionar dependencias y tareas de construcci\u00f3n de la aplicaci\u00f3n. Revisar la documentaci\u00f3n oficial de Luminus y la comunidad para aprender m\u00e1s sobre mejores pr\u00e1cticas y t\u00e9cnicas avanzadas de desarrollo de vistas.","title":"Desarrollo de vistas en Luminus Framework"},{"location":"luminus/jr/desarrollo_de_vistas/#desarrollo-de-vistas-en-luminus-framework","text":"","title":"Desarrollo de vistas en Luminus Framework"},{"location":"luminus/jr/desarrollo_de_vistas/#descripcion-del-modulo","text":"En este m\u00f3dulo aprenderemos c\u00f3mo desarrollar vistas en Luminus Framework, un framework de desarrollo web basado en Clojure. Las vistas son una parte esencial de cualquier aplicaci\u00f3n web, ya que son las encargadas de mostrar la informaci\u00f3n al usuario final. En Luminus, las vistas se pueden crear utilizando diferentes plantillas y se pueden integrar con HTML, CSS y JavaScript para crear una interfaz visual atractiva.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"luminus/jr/desarrollo_de_vistas/#explicacion-teorica","text":"Una vista en Luminus es una p\u00e1gina web que se muestra al usuario final. Estas vistas pueden ser est\u00e1ticas o din\u00e1micas, lo que significa que pueden mostrar contenido predefinido o contenido generado din\u00e1micamente en funci\u00f3n de la l\u00f3gica de la aplicaci\u00f3n. Las vistas se pueden crear utilizando diferentes plantillas, como hiccup, selmer o enlive, que nos permiten mezclar c\u00f3digo HTML con c\u00f3digo de Clojure. Para crear una vista en Luminus, primero debemos definir una ruta en nuestro archivo de rutas. Esta ruta estar\u00e1 asociada a una funci\u00f3n en nuestro controlador que se encargar\u00e1 de generar la vista. Dentro de esta funci\u00f3n, podemos utilizar la plantilla que hayamos elegido para crear nuestra vista, y tambi\u00e9n podemos utilizar variables y l\u00f3gica para mostrar contenido din\u00e1mico.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"luminus/jr/desarrollo_de_vistas/#palabras-clave-y-su-definicion","text":"Vistas: p\u00e1ginas web que se muestran al usuario final. Plantillas: archivos que nos permiten mezclar c\u00f3digo HTML con c\u00f3digo de Clojure para crear vistas. Hiccup: una de las plantillas disponibles en Luminus que utiliza una sintaxis similar a HTML para generar vistas. Selmer: otra plantilla disponible en Luminus que utiliza una sintaxis similar a Django para generar vistas. Enlive: una plantilla que nos permite utilizar CSS selectors para manipular el DOM y generar vistas din\u00e1micamente. Controlador: una parte de la arquitectura MVC que se encarga de manejar las peticiones y generar respuestas. Rutas: definiciones de URL que est\u00e1n asociadas a funciones en el controlador.","title":"Palabras clave y su definici\u00f3n"},{"location":"luminus/jr/desarrollo_de_vistas/#preguntas-de-repaso","text":"\u00bfQu\u00e9 son las vistas en Luminus Framework? \u00bfQu\u00e9 son las plantillas y cu\u00e1les est\u00e1n disponibles en Luminus? \u00bfQu\u00e9 es un controlador y qu\u00e9 funci\u00f3n tiene en la arquitectura MVC? \u00bfQu\u00e9 son las rutas y c\u00f3mo se relacionan con las vistas en Luminus?","title":"Preguntas de repaso"},{"location":"luminus/jr/desarrollo_de_vistas/#ejemplos-de-codigo-en-luminus-framework","text":"Ejemplo de definici\u00f3n de una ruta en el archivo de rutas: ( GET \"/saludo/:nombre\" [] ( mi-proyecto.core/saludar )) Ejemplo de funci\u00f3n en el controlador que muestra una vista utilizando la plantilla enlive: ( defn saludar [] ( let [ nombre ( params :nombre )] ( enlive/html [ :h1 \"\u00a1Hola, \" nombre \"!\" ])))","title":"Ejemplos de c\u00f3digo en Luminus Framework"},{"location":"luminus/jr/desarrollo_de_vistas/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una nueva ruta en el archivo de rutas que muestre una vista utilizando la plantilla selmer. En la funci\u00f3n correspondiente en el controlador, utiliza una variable y l\u00f3gica para mostrar un mensaje personalizado en la vista. Crea una nueva vista utilizando la plantilla enlive y utiliza CSS selectors para dar estilo a un elemento de la misma. Modifica una de las vistas existentes para que muestre informaci\u00f3n de una base de datos utilizando consultas a trav\u00e9s de una librer\u00eda como HoneySQL o Korma.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"luminus/jr/desarrollo_de_vistas/#consejos-o-mejores-practicas","text":"Utilizar plantillas para generar vistas en lugar de escribir todo el c\u00f3digo HTML directamente en el controlador. Esto nos permite separar la l\u00f3gica de la presentaci\u00f3n y hace que el c\u00f3digo sea m\u00e1s legible y mantenible. Utilizar nombres descriptivos para las rutas y funciones en el controlador para facilitar la comprensi\u00f3n del c\u00f3digo. Utilizar l\u00f3gica y variables en las vistas para generar contenido din\u00e1micamente en lugar de mostrar contenido est\u00e1tico. Utilizar herramientas como Leiningen o Boot para gestionar dependencias y tareas de construcci\u00f3n de la aplicaci\u00f3n. Revisar la documentaci\u00f3n oficial de Luminus y la comunidad para aprender m\u00e1s sobre mejores pr\u00e1cticas y t\u00e9cnicas avanzadas de desarrollo de vistas.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"luminus/jr/despliegue_de_la_aplicaci%C3%B3n/","text":"Despliegue de la aplicaci\u00f3n \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En este m\u00f3dulo se ense\u00f1ar\u00e1 c\u00f3mo desplegar una aplicaci\u00f3n desarrollada con Luminus en un servidor. Se ver\u00e1 c\u00f3mo configurar el entorno de producci\u00f3n, c\u00f3mo realizar actualizaciones y c\u00f3mo manejar problemas de compatibilidad. Explicaci\u00f3n te\u00f3rica \u00b6 El despliegue de una aplicaci\u00f3n es el proceso de poner en funcionamiento una aplicaci\u00f3n en un servidor para que pueda ser utilizada por los usuarios. En el caso de Luminus, una aplicaci\u00f3n puede ser desplegada en un servidor web que soporte Java, como Tomcat o Jetty. Para desplegar una aplicaci\u00f3n de Luminus, se deben seguir los siguientes pasos: Configurar el entorno de producci\u00f3n: Esto incluye configurar la base de datos, variables de entorno y cualquier otra configuraci\u00f3n espec\u00edfica para el servidor en el que se va a desplegar la aplicaci\u00f3n. Generar un archivo WAR: Luminus proporciona una tarea de Leiningen para generar un archivo WAR que contiene toda la aplicaci\u00f3n y sus dependencias. Desplegar el archivo WAR en el servidor: Una vez generado el archivo WAR, se debe copiar a la ubicaci\u00f3n adecuada en el servidor y configurar el servidor para que lo ejecute. Realizar actualizaciones: Si se realizan cambios en la aplicaci\u00f3n, se debe generar un nuevo archivo WAR y desplegarlo en el servidor nuevamente. Dependiendo del servidor, puede ser necesario reiniciarlo para que los cambios surtan efecto. Manejar problemas de compatibilidad: En ocasiones, pueden surgir problemas de compatibilidad al desplegar una aplicaci\u00f3n en un servidor diferente al que fue desarrollada. Para solucionar estos problemas, se debe revisar la configuraci\u00f3n del servidor y ajustarla seg\u00fan sea necesario. Palabras clave y su definici\u00f3n \u00b6 Despliegue: Proceso de poner en funcionamiento una aplicaci\u00f3n en un servidor. Entorno de producci\u00f3n: Configuraci\u00f3n espec\u00edfica para el servidor en el que se va a desplegar la aplicaci\u00f3n. WAR: Archivo que contiene toda la aplicaci\u00f3n y sus dependencias. Servidor web: Software que provee servicios de red para aplicaciones web. Compatibilidad: Capacidad de la aplicaci\u00f3n para funcionar correctamente en diferentes entornos. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es el despliegue de una aplicaci\u00f3n? \u00bfQu\u00e9 se debe hacer antes de desplegar una aplicaci\u00f3n de Luminus en un servidor? \u00bfC\u00f3mo se genera un archivo WAR en Luminus? \u00bfQu\u00e9 se debe hacer si se realizan cambios en la aplicaci\u00f3n? \u00bfQu\u00e9 se puede hacer para solucionar problemas de compatibilidad al desplegar una aplicaci\u00f3n en un servidor diferente? Ejemplos de c\u00f3digo en Luminus Framework \u00b6 Para generar un archivo WAR en Luminus, se utiliza la siguiente tarea en Leiningen: lein uberwar Una vez generado el archivo, se puede desplegar en el servidor web deseado. Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Configurar un entorno de producci\u00f3n para una aplicaci\u00f3n de Luminus. Generar un archivo WAR y desplegarlo en un servidor web. Realizar cambios en la aplicaci\u00f3n y actualizarla en el servidor. Solucionar un problema de compatibilidad al desplegar una aplicaci\u00f3n en un servidor diferente. Consejos o mejores pr\u00e1cticas \u00b6 Es importante tener una buena configuraci\u00f3n del entorno de producci\u00f3n para garantizar un despliegue exitoso. Se recomienda utilizar herramientas de automatizaci\u00f3n para el proceso de despliegue, como Ansible o Chef. Es importante realizar pruebas exhaustivas antes de desplegar la aplicaci\u00f3n en un entorno de producci\u00f3n. Siempre se debe tener en cuenta la compatibilidad al desarrollar una aplicaci\u00f3n para facilitar su despliegue en diferentes servidores.","title":"Despliegue de la aplicaci\u00f3n"},{"location":"luminus/jr/despliegue_de_la_aplicaci%C3%B3n/#despliegue-de-la-aplicacion","text":"","title":"Despliegue de la aplicaci\u00f3n"},{"location":"luminus/jr/despliegue_de_la_aplicaci%C3%B3n/#descripcion-del-modulo","text":"En este m\u00f3dulo se ense\u00f1ar\u00e1 c\u00f3mo desplegar una aplicaci\u00f3n desarrollada con Luminus en un servidor. Se ver\u00e1 c\u00f3mo configurar el entorno de producci\u00f3n, c\u00f3mo realizar actualizaciones y c\u00f3mo manejar problemas de compatibilidad.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"luminus/jr/despliegue_de_la_aplicaci%C3%B3n/#explicacion-teorica","text":"El despliegue de una aplicaci\u00f3n es el proceso de poner en funcionamiento una aplicaci\u00f3n en un servidor para que pueda ser utilizada por los usuarios. En el caso de Luminus, una aplicaci\u00f3n puede ser desplegada en un servidor web que soporte Java, como Tomcat o Jetty. Para desplegar una aplicaci\u00f3n de Luminus, se deben seguir los siguientes pasos: Configurar el entorno de producci\u00f3n: Esto incluye configurar la base de datos, variables de entorno y cualquier otra configuraci\u00f3n espec\u00edfica para el servidor en el que se va a desplegar la aplicaci\u00f3n. Generar un archivo WAR: Luminus proporciona una tarea de Leiningen para generar un archivo WAR que contiene toda la aplicaci\u00f3n y sus dependencias. Desplegar el archivo WAR en el servidor: Una vez generado el archivo WAR, se debe copiar a la ubicaci\u00f3n adecuada en el servidor y configurar el servidor para que lo ejecute. Realizar actualizaciones: Si se realizan cambios en la aplicaci\u00f3n, se debe generar un nuevo archivo WAR y desplegarlo en el servidor nuevamente. Dependiendo del servidor, puede ser necesario reiniciarlo para que los cambios surtan efecto. Manejar problemas de compatibilidad: En ocasiones, pueden surgir problemas de compatibilidad al desplegar una aplicaci\u00f3n en un servidor diferente al que fue desarrollada. Para solucionar estos problemas, se debe revisar la configuraci\u00f3n del servidor y ajustarla seg\u00fan sea necesario.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"luminus/jr/despliegue_de_la_aplicaci%C3%B3n/#palabras-clave-y-su-definicion","text":"Despliegue: Proceso de poner en funcionamiento una aplicaci\u00f3n en un servidor. Entorno de producci\u00f3n: Configuraci\u00f3n espec\u00edfica para el servidor en el que se va a desplegar la aplicaci\u00f3n. WAR: Archivo que contiene toda la aplicaci\u00f3n y sus dependencias. Servidor web: Software que provee servicios de red para aplicaciones web. Compatibilidad: Capacidad de la aplicaci\u00f3n para funcionar correctamente en diferentes entornos.","title":"Palabras clave y su definici\u00f3n"},{"location":"luminus/jr/despliegue_de_la_aplicaci%C3%B3n/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es el despliegue de una aplicaci\u00f3n? \u00bfQu\u00e9 se debe hacer antes de desplegar una aplicaci\u00f3n de Luminus en un servidor? \u00bfC\u00f3mo se genera un archivo WAR en Luminus? \u00bfQu\u00e9 se debe hacer si se realizan cambios en la aplicaci\u00f3n? \u00bfQu\u00e9 se puede hacer para solucionar problemas de compatibilidad al desplegar una aplicaci\u00f3n en un servidor diferente?","title":"Preguntas de repaso"},{"location":"luminus/jr/despliegue_de_la_aplicaci%C3%B3n/#ejemplos-de-codigo-en-luminus-framework","text":"Para generar un archivo WAR en Luminus, se utiliza la siguiente tarea en Leiningen: lein uberwar Una vez generado el archivo, se puede desplegar en el servidor web deseado.","title":"Ejemplos de c\u00f3digo en Luminus Framework"},{"location":"luminus/jr/despliegue_de_la_aplicaci%C3%B3n/#ejercicios-practicos-con-instrucciones-claras","text":"Configurar un entorno de producci\u00f3n para una aplicaci\u00f3n de Luminus. Generar un archivo WAR y desplegarlo en un servidor web. Realizar cambios en la aplicaci\u00f3n y actualizarla en el servidor. Solucionar un problema de compatibilidad al desplegar una aplicaci\u00f3n en un servidor diferente.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"luminus/jr/despliegue_de_la_aplicaci%C3%B3n/#consejos-o-mejores-practicas","text":"Es importante tener una buena configuraci\u00f3n del entorno de producci\u00f3n para garantizar un despliegue exitoso. Se recomienda utilizar herramientas de automatizaci\u00f3n para el proceso de despliegue, como Ansible o Chef. Es importante realizar pruebas exhaustivas antes de desplegar la aplicaci\u00f3n en un entorno de producci\u00f3n. Siempre se debe tener en cuenta la compatibilidad al desarrollar una aplicaci\u00f3n para facilitar su despliegue en diferentes servidores.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"luminus/jr/implementaci%C3%B3n_de_seguridad/","text":"Implementaci\u00f3n de seguridad en Luminus Framework \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En este m\u00f3dulo aprender\u00e1s c\u00f3mo implementar medidas de seguridad en una aplicaci\u00f3n desarrollada con Luminus Framework. Conocer\u00e1s c\u00f3mo proteger las rutas, manejar usuarios y utilizar herramientas de autenticaci\u00f3n y autorizaci\u00f3n. Estos conocimientos son fundamentales en el desarrollo de aplicaciones web, ya que la seguridad es un aspecto crucial para proteger los datos y garantizar la integridad de la aplicaci\u00f3n. Explicaci\u00f3n te\u00f3rica \u00b6 La seguridad en una aplicaci\u00f3n web se refiere a la protecci\u00f3n de los datos y recursos que maneja la aplicaci\u00f3n, as\u00ed como la prevenci\u00f3n de ataques y vulnerabilidades. Una aplicaci\u00f3n segura es aquella que implementa medidas para garantizar la confidencialidad, integridad y disponibilidad de los datos. En Luminus Framework, la seguridad se puede implementar a trav\u00e9s de diferentes herramientas y t\u00e9cnicas, como la protecci\u00f3n de rutas, la gesti\u00f3n de usuarios, la autenticaci\u00f3n y la autorizaci\u00f3n. Protecci\u00f3n de rutas \u00b6 Una de las formas m\u00e1s comunes de proteger una aplicaci\u00f3n es mediante la protecci\u00f3n de las rutas. Las rutas son las URLs que se utilizan para acceder a diferentes p\u00e1ginas o recursos de la aplicaci\u00f3n. En Luminus, se pueden definir rutas mediante el archivo routes.clj en la carpeta src/clj/ de tu proyecto. Para proteger una ruta, se puede utilizar el middleware wrap-restricted que viene incluido en Luminus. Este middleware permite restringir el acceso a una ruta a usuarios autenticados o con ciertos roles espec\u00edficos. Gesti\u00f3n de usuarios \u00b6 Otra forma de implementar seguridad en una aplicaci\u00f3n es mediante la gesti\u00f3n de usuarios. En Luminus, se puede utilizar la librer\u00eda buddy-auth para manejar la creaci\u00f3n, autenticaci\u00f3n y autorizaci\u00f3n de usuarios. Esta librer\u00eda permite definir roles y permisos para cada usuario, y tambi\u00e9n incluye funciones para el almacenamiento seguro de contrase\u00f1as. Autenticaci\u00f3n y autorizaci\u00f3n \u00b6 La autenticaci\u00f3n es el proceso de verificar la identidad de un usuario, mientras que la autorizaci\u00f3n se refiere a otorgar o denegar acceso a ciertos recursos o acciones dentro de la aplicaci\u00f3n. En Luminus, se pueden utilizar diferentes herramientas como buddy-auth o buddy-sign para implementar estos procesos de forma segura. Adem\u00e1s, tambi\u00e9n se puede utilizar la autenticaci\u00f3n basada en tokens, donde se generan tokens de acceso que permiten a los usuarios realizar acciones sin necesidad de autenticarse continuamente. Palabras clave y definiciones \u00b6 Seguridad: conjunto de medidas y t\u00e9cnicas utilizadas para proteger los datos y recursos de una aplicaci\u00f3n. Protecci\u00f3n de rutas: t\u00e9cnica que restringe el acceso a ciertas rutas o URLs en una aplicaci\u00f3n. Middleware: capa de software que act\u00faa como intermediario entre diferentes componentes de una aplicaci\u00f3n. Gesti\u00f3n de usuarios: proceso de creaci\u00f3n, autenticaci\u00f3n y autorizaci\u00f3n de usuarios en una aplicaci\u00f3n. Autenticaci\u00f3n: proceso de verificar la identidad de un usuario. Autorizaci\u00f3n: proceso de otorgar o denegar acceso a recursos o acciones en una aplicaci\u00f3n. Tokens de acceso: cadenas de caracteres que permiten a los usuarios realizar acciones sin necesidad de autenticarse continuamente. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la seguridad en una aplicaci\u00f3n web? \u00bfQu\u00e9 es la protecci\u00f3n de rutas y c\u00f3mo se puede implementar en Luminus Framework? \u00bfQu\u00e9 es la gesti\u00f3n de usuarios y c\u00f3mo se puede implementar en Luminus Framework? \u00bfCu\u00e1l es la diferencia entre autenticaci\u00f3n y autorizaci\u00f3n? \u00bfQu\u00e9 son los tokens de acceso y para qu\u00e9 se utilizan en una aplicaci\u00f3n web? Ejemplos de c\u00f3digo en Luminus Framework \u00b6 Protecci\u00f3n de rutas \u00b6 ( defroutes app-routes ( GET \"/\" [] \"P\u00e1gina de inicio\" ) ( GET \"/perfil\" [] \"P\u00e1gina de perfil\" :auth true ) ( GET \"/admin\" [] \"P\u00e1gina de administraci\u00f3n\" :auth { :role \"admin\" })) Gesti\u00f3n de usuarios \u00b6 ( ns myapp.auth ( :require [ buddy.auth :as auth ])) ( defn login-page [ req ] ( auth/login-form req )) ( defn login [ req ] ( auth/login req { :allow-anon? true })) ( defn logout [ req ] ( auth/logout req )) ( defn register-page [ req ] ( auth/register-form req )) ( defn register [ req ] ( auth/register req { :allow-anon? true })) Autenticaci\u00f3n basada en tokens \u00b6 ( ns myapp.auth ( :require [ buddy.auth :as auth ]) ( :require [ buddy.sign :as sign ])) ( defn login [ req ] ( auth/login req { :allow-anon? true :continue-uri \"/dashboard\" :credential-fn ( partial sign/validate-symmetric \"secret-key\" )})) Ejercicios pr\u00e1cticos \u00b6 Crea una aplicaci\u00f3n en Luminus Framework y agrega una protecci\u00f3n de ruta para la p\u00e1gina de perfil, de manera que solo los usuarios autenticados puedan acceder a ella. Implementa la gesti\u00f3n de usuarios en tu aplicaci\u00f3n y crea diferentes roles para los usuarios. Utiliza la autenticaci\u00f3n basada en tokens para permitir el acceso a ciertas rutas sin necesidad de autenticarse continuamente. Consejos y mejores pr\u00e1cticas \u00b6 Siempre protege las rutas que contienen informaci\u00f3n confidencial o que requieren de autenticaci\u00f3n para acceder. Utiliza una gesti\u00f3n de usuarios adecuada para garantizar que solo los usuarios autorizados puedan acceder a ciertas funcionalidades o recursos. Implementa medidas de seguridad adicionales, como el almacenamiento seguro de contrase\u00f1as y la protecci\u00f3n contra ataques de fuerza bruta. Actualiza regularmente las librer\u00edas y dependencias de tu aplicaci\u00f3n para garantizar la seguridad de la misma.","title":"Implementaci\u00f3n de seguridad en Luminus Framework"},{"location":"luminus/jr/implementaci%C3%B3n_de_seguridad/#implementacion-de-seguridad-en-luminus-framework","text":"","title":"Implementaci\u00f3n de seguridad en Luminus Framework"},{"location":"luminus/jr/implementaci%C3%B3n_de_seguridad/#descripcion-del-modulo","text":"En este m\u00f3dulo aprender\u00e1s c\u00f3mo implementar medidas de seguridad en una aplicaci\u00f3n desarrollada con Luminus Framework. Conocer\u00e1s c\u00f3mo proteger las rutas, manejar usuarios y utilizar herramientas de autenticaci\u00f3n y autorizaci\u00f3n. Estos conocimientos son fundamentales en el desarrollo de aplicaciones web, ya que la seguridad es un aspecto crucial para proteger los datos y garantizar la integridad de la aplicaci\u00f3n.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"luminus/jr/implementaci%C3%B3n_de_seguridad/#explicacion-teorica","text":"La seguridad en una aplicaci\u00f3n web se refiere a la protecci\u00f3n de los datos y recursos que maneja la aplicaci\u00f3n, as\u00ed como la prevenci\u00f3n de ataques y vulnerabilidades. Una aplicaci\u00f3n segura es aquella que implementa medidas para garantizar la confidencialidad, integridad y disponibilidad de los datos. En Luminus Framework, la seguridad se puede implementar a trav\u00e9s de diferentes herramientas y t\u00e9cnicas, como la protecci\u00f3n de rutas, la gesti\u00f3n de usuarios, la autenticaci\u00f3n y la autorizaci\u00f3n.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"luminus/jr/implementaci%C3%B3n_de_seguridad/#proteccion-de-rutas","text":"Una de las formas m\u00e1s comunes de proteger una aplicaci\u00f3n es mediante la protecci\u00f3n de las rutas. Las rutas son las URLs que se utilizan para acceder a diferentes p\u00e1ginas o recursos de la aplicaci\u00f3n. En Luminus, se pueden definir rutas mediante el archivo routes.clj en la carpeta src/clj/ de tu proyecto. Para proteger una ruta, se puede utilizar el middleware wrap-restricted que viene incluido en Luminus. Este middleware permite restringir el acceso a una ruta a usuarios autenticados o con ciertos roles espec\u00edficos.","title":"Protecci\u00f3n de rutas"},{"location":"luminus/jr/implementaci%C3%B3n_de_seguridad/#gestion-de-usuarios","text":"Otra forma de implementar seguridad en una aplicaci\u00f3n es mediante la gesti\u00f3n de usuarios. En Luminus, se puede utilizar la librer\u00eda buddy-auth para manejar la creaci\u00f3n, autenticaci\u00f3n y autorizaci\u00f3n de usuarios. Esta librer\u00eda permite definir roles y permisos para cada usuario, y tambi\u00e9n incluye funciones para el almacenamiento seguro de contrase\u00f1as.","title":"Gesti\u00f3n de usuarios"},{"location":"luminus/jr/implementaci%C3%B3n_de_seguridad/#autenticacion-y-autorizacion","text":"La autenticaci\u00f3n es el proceso de verificar la identidad de un usuario, mientras que la autorizaci\u00f3n se refiere a otorgar o denegar acceso a ciertos recursos o acciones dentro de la aplicaci\u00f3n. En Luminus, se pueden utilizar diferentes herramientas como buddy-auth o buddy-sign para implementar estos procesos de forma segura. Adem\u00e1s, tambi\u00e9n se puede utilizar la autenticaci\u00f3n basada en tokens, donde se generan tokens de acceso que permiten a los usuarios realizar acciones sin necesidad de autenticarse continuamente.","title":"Autenticaci\u00f3n y autorizaci\u00f3n"},{"location":"luminus/jr/implementaci%C3%B3n_de_seguridad/#palabras-clave-y-definiciones","text":"Seguridad: conjunto de medidas y t\u00e9cnicas utilizadas para proteger los datos y recursos de una aplicaci\u00f3n. Protecci\u00f3n de rutas: t\u00e9cnica que restringe el acceso a ciertas rutas o URLs en una aplicaci\u00f3n. Middleware: capa de software que act\u00faa como intermediario entre diferentes componentes de una aplicaci\u00f3n. Gesti\u00f3n de usuarios: proceso de creaci\u00f3n, autenticaci\u00f3n y autorizaci\u00f3n de usuarios en una aplicaci\u00f3n. Autenticaci\u00f3n: proceso de verificar la identidad de un usuario. Autorizaci\u00f3n: proceso de otorgar o denegar acceso a recursos o acciones en una aplicaci\u00f3n. Tokens de acceso: cadenas de caracteres que permiten a los usuarios realizar acciones sin necesidad de autenticarse continuamente.","title":"Palabras clave y definiciones"},{"location":"luminus/jr/implementaci%C3%B3n_de_seguridad/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la seguridad en una aplicaci\u00f3n web? \u00bfQu\u00e9 es la protecci\u00f3n de rutas y c\u00f3mo se puede implementar en Luminus Framework? \u00bfQu\u00e9 es la gesti\u00f3n de usuarios y c\u00f3mo se puede implementar en Luminus Framework? \u00bfCu\u00e1l es la diferencia entre autenticaci\u00f3n y autorizaci\u00f3n? \u00bfQu\u00e9 son los tokens de acceso y para qu\u00e9 se utilizan en una aplicaci\u00f3n web?","title":"Preguntas de repaso"},{"location":"luminus/jr/implementaci%C3%B3n_de_seguridad/#ejemplos-de-codigo-en-luminus-framework","text":"","title":"Ejemplos de c\u00f3digo en Luminus Framework"},{"location":"luminus/jr/implementaci%C3%B3n_de_seguridad/#proteccion-de-rutas_1","text":"( defroutes app-routes ( GET \"/\" [] \"P\u00e1gina de inicio\" ) ( GET \"/perfil\" [] \"P\u00e1gina de perfil\" :auth true ) ( GET \"/admin\" [] \"P\u00e1gina de administraci\u00f3n\" :auth { :role \"admin\" }))","title":"Protecci\u00f3n de rutas"},{"location":"luminus/jr/implementaci%C3%B3n_de_seguridad/#gestion-de-usuarios_1","text":"( ns myapp.auth ( :require [ buddy.auth :as auth ])) ( defn login-page [ req ] ( auth/login-form req )) ( defn login [ req ] ( auth/login req { :allow-anon? true })) ( defn logout [ req ] ( auth/logout req )) ( defn register-page [ req ] ( auth/register-form req )) ( defn register [ req ] ( auth/register req { :allow-anon? true }))","title":"Gesti\u00f3n de usuarios"},{"location":"luminus/jr/implementaci%C3%B3n_de_seguridad/#autenticacion-basada-en-tokens","text":"( ns myapp.auth ( :require [ buddy.auth :as auth ]) ( :require [ buddy.sign :as sign ])) ( defn login [ req ] ( auth/login req { :allow-anon? true :continue-uri \"/dashboard\" :credential-fn ( partial sign/validate-symmetric \"secret-key\" )}))","title":"Autenticaci\u00f3n basada en tokens"},{"location":"luminus/jr/implementaci%C3%B3n_de_seguridad/#ejercicios-practicos","text":"Crea una aplicaci\u00f3n en Luminus Framework y agrega una protecci\u00f3n de ruta para la p\u00e1gina de perfil, de manera que solo los usuarios autenticados puedan acceder a ella. Implementa la gesti\u00f3n de usuarios en tu aplicaci\u00f3n y crea diferentes roles para los usuarios. Utiliza la autenticaci\u00f3n basada en tokens para permitir el acceso a ciertas rutas sin necesidad de autenticarse continuamente.","title":"Ejercicios pr\u00e1cticos"},{"location":"luminus/jr/implementaci%C3%B3n_de_seguridad/#consejos-y-mejores-practicas","text":"Siempre protege las rutas que contienen informaci\u00f3n confidencial o que requieren de autenticaci\u00f3n para acceder. Utiliza una gesti\u00f3n de usuarios adecuada para garantizar que solo los usuarios autorizados puedan acceder a ciertas funcionalidades o recursos. Implementa medidas de seguridad adicionales, como el almacenamiento seguro de contrase\u00f1as y la protecci\u00f3n contra ataques de fuerza bruta. Actualiza regularmente las librer\u00edas y dependencias de tu aplicaci\u00f3n para garantizar la seguridad de la misma.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"luminus/jr/introducci%C3%B3n_a_luminus_framework/","text":"Introducci\u00f3n a Luminus Framework \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En este m\u00f3dulo se abordar\u00e1 el framework de desarrollo web Luminus, utilizado para crear aplicaciones en lenguaje Clojure. Se explicar\u00e1n los conceptos b\u00e1sicos de su arquitectura y se realizar\u00e1n ejemplos pr\u00e1cticos para comprender su funcionamiento. Explicaci\u00f3n te\u00f3rica \u00b6 Luminus es un framework de desarrollo web basado en Clojure, un lenguaje de programaci\u00f3n funcional. Fue creado para simplificar la creaci\u00f3n de aplicaciones web en Clojure, ya que proporciona una estructura predefinida y utilidades comunes para el desarrollo. La arquitectura de Luminus se basa en el patr\u00f3n de dise\u00f1o Modelo-Vista-Controlador (MVC), donde el modelo representa los datos de la aplicaci\u00f3n, la vista se encarga de mostrar la interfaz de usuario y el controlador maneja las interacciones entre el modelo y la vista. Adem\u00e1s, Luminus utiliza el servidor web Jetty y el sistema de plantillas Hiccup para renderizar las vistas. Palabras clave y su definici\u00f3n \u00b6 Luminus: Framework de desarrollo web basado en Clojure. Clojure: Lenguaje de programaci\u00f3n funcional utilizado para crear aplicaciones en Luminus. Arquitectura MVC: Patr\u00f3n de dise\u00f1o que divide una aplicaci\u00f3n en tres componentes: modelo, vista y controlador. Jetty: Servidor web utilizado por Luminus. Hiccup: Sistema de plantillas para renderizar las vistas en Luminus. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es Luminus Framework? \u00bfEn qu\u00e9 lenguaje est\u00e1 basado? \u00bfCu\u00e1l es la arquitectura utilizada en Luminus? \u00bfQu\u00e9 es Jetty? \u00bfPara qu\u00e9 se utiliza Hiccup en Luminus? Ejemplos de c\u00f3digo en Luminus Framework \u00b6 Crear una aplicaci\u00f3n b\u00e1sica en Luminus \u00b6 Primero, se debe instalar Leiningen, un gestor de dependencias para Clojure. Luego, ejecutar el siguiente comando en la terminal: lein new luminus mi-app Esto crear\u00e1 una carpeta llamada \"mi-app\" con la estructura b\u00e1sica de una aplicaci\u00f3n en Luminus. Definir una ruta y una vista en Luminus \u00b6 En el archivo \"mi-app/src/mi_app/handler.clj\" se pueden definir las rutas de la aplicaci\u00f3n. Por ejemplo: ( defroutes app-routes ( GET \"/\" [] \"\u00a1Hola, mundo!\" ) ( GET \"/saludo\" [] ( render \"saludo.clj\" )) En el archivo \"mi-app/resources/templates/saludo.clj\" se puede definir la vista correspondiente a la ruta \"/saludo\". Por ejemplo: ( html [ :h1 \"\u00a1Bienvenido a Luminus!\" ] [ :p \"Esta es una vista de ejemplo.\" ]) Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una aplicaci\u00f3n en Luminus y ejec\u00fatala en un servidor local. Agrega una nueva ruta a la aplicaci\u00f3n y crea una vista correspondiente. Agrega una base de datos a la aplicaci\u00f3n y realiza una consulta desde una de las rutas. Implementa un formulario en una de las vistas y guarda los datos en la base de datos. Crea una p\u00e1gina de inicio de sesi\u00f3n y valida los datos ingresados con una base de datos de usuarios. Consejos o mejores pr\u00e1cticas \u00b6 Familiarizarse con el lenguaje Clojure antes de utilizar Luminus. Seguir la convenci\u00f3n de nombres de Luminus para la estructura de carpetas y archivos. Utilizar las bibliotecas y utilidades recomendadas por Luminus para un desarrollo m\u00e1s eficiente. Aprovechar la documentaci\u00f3n y la comunidad de Luminus para resolver dudas y aprender nuevas t\u00e9cnicas.","title":"Introducci\u00f3n a Luminus Framework"},{"location":"luminus/jr/introducci%C3%B3n_a_luminus_framework/#introduccion-a-luminus-framework","text":"","title":"Introducci\u00f3n a Luminus Framework"},{"location":"luminus/jr/introducci%C3%B3n_a_luminus_framework/#descripcion-del-modulo","text":"En este m\u00f3dulo se abordar\u00e1 el framework de desarrollo web Luminus, utilizado para crear aplicaciones en lenguaje Clojure. Se explicar\u00e1n los conceptos b\u00e1sicos de su arquitectura y se realizar\u00e1n ejemplos pr\u00e1cticos para comprender su funcionamiento.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"luminus/jr/introducci%C3%B3n_a_luminus_framework/#explicacion-teorica","text":"Luminus es un framework de desarrollo web basado en Clojure, un lenguaje de programaci\u00f3n funcional. Fue creado para simplificar la creaci\u00f3n de aplicaciones web en Clojure, ya que proporciona una estructura predefinida y utilidades comunes para el desarrollo. La arquitectura de Luminus se basa en el patr\u00f3n de dise\u00f1o Modelo-Vista-Controlador (MVC), donde el modelo representa los datos de la aplicaci\u00f3n, la vista se encarga de mostrar la interfaz de usuario y el controlador maneja las interacciones entre el modelo y la vista. Adem\u00e1s, Luminus utiliza el servidor web Jetty y el sistema de plantillas Hiccup para renderizar las vistas.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"luminus/jr/introducci%C3%B3n_a_luminus_framework/#palabras-clave-y-su-definicion","text":"Luminus: Framework de desarrollo web basado en Clojure. Clojure: Lenguaje de programaci\u00f3n funcional utilizado para crear aplicaciones en Luminus. Arquitectura MVC: Patr\u00f3n de dise\u00f1o que divide una aplicaci\u00f3n en tres componentes: modelo, vista y controlador. Jetty: Servidor web utilizado por Luminus. Hiccup: Sistema de plantillas para renderizar las vistas en Luminus.","title":"Palabras clave y su definici\u00f3n"},{"location":"luminus/jr/introducci%C3%B3n_a_luminus_framework/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Luminus Framework? \u00bfEn qu\u00e9 lenguaje est\u00e1 basado? \u00bfCu\u00e1l es la arquitectura utilizada en Luminus? \u00bfQu\u00e9 es Jetty? \u00bfPara qu\u00e9 se utiliza Hiccup en Luminus?","title":"Preguntas de repaso"},{"location":"luminus/jr/introducci%C3%B3n_a_luminus_framework/#ejemplos-de-codigo-en-luminus-framework","text":"","title":"Ejemplos de c\u00f3digo en Luminus Framework"},{"location":"luminus/jr/introducci%C3%B3n_a_luminus_framework/#crear-una-aplicacion-basica-en-luminus","text":"Primero, se debe instalar Leiningen, un gestor de dependencias para Clojure. Luego, ejecutar el siguiente comando en la terminal: lein new luminus mi-app Esto crear\u00e1 una carpeta llamada \"mi-app\" con la estructura b\u00e1sica de una aplicaci\u00f3n en Luminus.","title":"Crear una aplicaci\u00f3n b\u00e1sica en Luminus"},{"location":"luminus/jr/introducci%C3%B3n_a_luminus_framework/#definir-una-ruta-y-una-vista-en-luminus","text":"En el archivo \"mi-app/src/mi_app/handler.clj\" se pueden definir las rutas de la aplicaci\u00f3n. Por ejemplo: ( defroutes app-routes ( GET \"/\" [] \"\u00a1Hola, mundo!\" ) ( GET \"/saludo\" [] ( render \"saludo.clj\" )) En el archivo \"mi-app/resources/templates/saludo.clj\" se puede definir la vista correspondiente a la ruta \"/saludo\". Por ejemplo: ( html [ :h1 \"\u00a1Bienvenido a Luminus!\" ] [ :p \"Esta es una vista de ejemplo.\" ])","title":"Definir una ruta y una vista en Luminus"},{"location":"luminus/jr/introducci%C3%B3n_a_luminus_framework/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una aplicaci\u00f3n en Luminus y ejec\u00fatala en un servidor local. Agrega una nueva ruta a la aplicaci\u00f3n y crea una vista correspondiente. Agrega una base de datos a la aplicaci\u00f3n y realiza una consulta desde una de las rutas. Implementa un formulario en una de las vistas y guarda los datos en la base de datos. Crea una p\u00e1gina de inicio de sesi\u00f3n y valida los datos ingresados con una base de datos de usuarios.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"luminus/jr/introducci%C3%B3n_a_luminus_framework/#consejos-o-mejores-practicas","text":"Familiarizarse con el lenguaje Clojure antes de utilizar Luminus. Seguir la convenci\u00f3n de nombres de Luminus para la estructura de carpetas y archivos. Utilizar las bibliotecas y utilidades recomendadas por Luminus para un desarrollo m\u00e1s eficiente. Aprovechar la documentaci\u00f3n y la comunidad de Luminus para resolver dudas y aprender nuevas t\u00e9cnicas.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"luminus/jr/manejo_de_rutas_y_solicitudes/","text":"Manejo de rutas y solicitudes en Luminus Framework \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 En Luminus Framework, las rutas son la forma en que se define la estructura de una aplicaci\u00f3n web. Una ruta es una URL que se utiliza para acceder a una p\u00e1gina o recurso espec\u00edfico dentro de la aplicaci\u00f3n. El manejo de rutas se refiere a c\u00f3mo se gestiona y se responde a las solicitudes que se realizan a trav\u00e9s de estas rutas. Luminus utiliza el enrutamiento basado en el concepto de \"composici\u00f3n de funciones\", lo que significa que cada ruta est\u00e1 asociada a una funci\u00f3n que se encarga de manejar la solicitud y generar una respuesta. Esto permite una gran flexibilidad y modularidad en el manejo de las rutas. Para manejar una solicitud, Luminus utiliza una combinaci\u00f3n de patrones de rutas y par\u00e1metros. Los patrones de rutas determinan qu\u00e9 funci\u00f3n se ejecutar\u00e1 en respuesta a una solicitud en particular, mientras que los par\u00e1metros permiten acceder a elementos espec\u00edficos de la solicitud, como por ejemplo, datos enviados a trav\u00e9s de un formulario. Palabras clave y su definici\u00f3n \u00b6 Ruta: URL que se utiliza para acceder a una p\u00e1gina o recurso en una aplicaci\u00f3n web. Enrutamiento: proceso de determinar qu\u00e9 funci\u00f3n se ejecutar\u00e1 en respuesta a una solicitud en particular. Composici\u00f3n de funciones: t\u00e9cnica de programaci\u00f3n que consiste en combinar varias funciones para construir una funcionalidad m\u00e1s compleja. Patr\u00f3n de ruta: secuencia de caracteres que se utiliza para definir una ruta en Luminus. Par\u00e1metro: elemento de una solicitud que permite acceder a datos espec\u00edficos, como por ejemplo, datos de un formulario. Controlador: funci\u00f3n que se encarga de manejar una solicitud y generar una respuesta en Luminus. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es una ruta en una aplicaci\u00f3n web? \u00bfC\u00f3mo se gestiona una solicitud en Luminus Framework? \u00bfQu\u00e9 es la composici\u00f3n de funciones y c\u00f3mo se aplica en el enrutamiento en Luminus? \u00bfQu\u00e9 es un patr\u00f3n de ruta y c\u00f3mo se utiliza en Luminus? \u00bfCu\u00e1l es la funci\u00f3n de los par\u00e1metros en el manejo de solicitudes en Luminus? \u00bfQu\u00e9 es un controlador en Luminus y cu\u00e1l es su papel en el manejo de solicitudes? Ejemplos de c\u00f3digo en Luminus Framework \u00b6 Para definir una ruta en Luminus, se utiliza la macro defroute . Esta macro toma como par\u00e1metros el patr\u00f3n de ruta y la funci\u00f3n que se encargar\u00e1 de manejar la solicitud. (defroute \"/index\" [] (index-page)) En este ejemplo, la ruta \"/index\" est\u00e1 asociada a la funci\u00f3n index-page , que se encargar\u00e1 de generar la respuesta para esta ruta en particular. Para acceder a par\u00e1metros de una solicitud, se utiliza la macro param . Esta macro toma como par\u00e1metros el nombre del par\u00e1metro y un valor por defecto en caso de que el par\u00e1metro no est\u00e9 presente en la solicitud. ( defroute \"/user/:id\" [ id ] ( user - page id )) En este caso, el par\u00e1metro id se puede acceder dentro de la funci\u00f3n user-page para utilizarlo en la generaci\u00f3n de la respuesta. Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una ruta en Luminus que responda a la URL \"/about\" y llame a la funci\u00f3n about-page para generar la respuesta. Define una ruta que permita acceder a una p\u00e1gina de perfil de usuario, utilizando el patr\u00f3n de ruta \"/user/:username\". La funci\u00f3n asociada a esta ruta debe recibir como par\u00e1metro el username y llamar a la funci\u00f3n profile-page para generar la respuesta. Crea un formulario en una p\u00e1gina y define una ruta para manejar la solicitud de env\u00edo del formulario. La ruta debe utilizar el verbo HTTP \"POST\" y llamar a la funci\u00f3n submit-form para procesar los datos enviados. Utiliza la macro param para acceder al par\u00e1metro id en una ruta y llamar a la funci\u00f3n post-page para mostrar un post espec\u00edfico en una p\u00e1gina. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza nombres descriptivos para las rutas y las funciones asociadas a ellas, esto facilitar\u00e1 la comprensi\u00f3n del c\u00f3digo. Utiliza patrones de ruta que sean f\u00e1ciles de recordar y que sigan una l\u00f3gica coherente en la estructura de la aplicaci\u00f3n. Al manejar par\u00e1metros en las rutas, valida siempre los datos recibidos para evitar errores o problemas de seguridad. Utiliza los verbos HTTP adecuados para cada tipo de solicitud (GET para obtener datos, POST para enviar datos, etc.). Utiliza la macro defroutes para agrupar varias rutas en un mismo archivo y mantener una estructura organizada en la aplicaci\u00f3n.","title":"Manejo de rutas y solicitudes en Luminus Framework"},{"location":"luminus/jr/manejo_de_rutas_y_solicitudes/#manejo-de-rutas-y-solicitudes-en-luminus-framework","text":"","title":"Manejo de rutas y solicitudes en Luminus Framework"},{"location":"luminus/jr/manejo_de_rutas_y_solicitudes/#explicacion-teorica","text":"En Luminus Framework, las rutas son la forma en que se define la estructura de una aplicaci\u00f3n web. Una ruta es una URL que se utiliza para acceder a una p\u00e1gina o recurso espec\u00edfico dentro de la aplicaci\u00f3n. El manejo de rutas se refiere a c\u00f3mo se gestiona y se responde a las solicitudes que se realizan a trav\u00e9s de estas rutas. Luminus utiliza el enrutamiento basado en el concepto de \"composici\u00f3n de funciones\", lo que significa que cada ruta est\u00e1 asociada a una funci\u00f3n que se encarga de manejar la solicitud y generar una respuesta. Esto permite una gran flexibilidad y modularidad en el manejo de las rutas. Para manejar una solicitud, Luminus utiliza una combinaci\u00f3n de patrones de rutas y par\u00e1metros. Los patrones de rutas determinan qu\u00e9 funci\u00f3n se ejecutar\u00e1 en respuesta a una solicitud en particular, mientras que los par\u00e1metros permiten acceder a elementos espec\u00edficos de la solicitud, como por ejemplo, datos enviados a trav\u00e9s de un formulario.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"luminus/jr/manejo_de_rutas_y_solicitudes/#palabras-clave-y-su-definicion","text":"Ruta: URL que se utiliza para acceder a una p\u00e1gina o recurso en una aplicaci\u00f3n web. Enrutamiento: proceso de determinar qu\u00e9 funci\u00f3n se ejecutar\u00e1 en respuesta a una solicitud en particular. Composici\u00f3n de funciones: t\u00e9cnica de programaci\u00f3n que consiste en combinar varias funciones para construir una funcionalidad m\u00e1s compleja. Patr\u00f3n de ruta: secuencia de caracteres que se utiliza para definir una ruta en Luminus. Par\u00e1metro: elemento de una solicitud que permite acceder a datos espec\u00edficos, como por ejemplo, datos de un formulario. Controlador: funci\u00f3n que se encarga de manejar una solicitud y generar una respuesta en Luminus.","title":"Palabras clave y su definici\u00f3n"},{"location":"luminus/jr/manejo_de_rutas_y_solicitudes/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es una ruta en una aplicaci\u00f3n web? \u00bfC\u00f3mo se gestiona una solicitud en Luminus Framework? \u00bfQu\u00e9 es la composici\u00f3n de funciones y c\u00f3mo se aplica en el enrutamiento en Luminus? \u00bfQu\u00e9 es un patr\u00f3n de ruta y c\u00f3mo se utiliza en Luminus? \u00bfCu\u00e1l es la funci\u00f3n de los par\u00e1metros en el manejo de solicitudes en Luminus? \u00bfQu\u00e9 es un controlador en Luminus y cu\u00e1l es su papel en el manejo de solicitudes?","title":"Preguntas de repaso"},{"location":"luminus/jr/manejo_de_rutas_y_solicitudes/#ejemplos-de-codigo-en-luminus-framework","text":"Para definir una ruta en Luminus, se utiliza la macro defroute . Esta macro toma como par\u00e1metros el patr\u00f3n de ruta y la funci\u00f3n que se encargar\u00e1 de manejar la solicitud. (defroute \"/index\" [] (index-page)) En este ejemplo, la ruta \"/index\" est\u00e1 asociada a la funci\u00f3n index-page , que se encargar\u00e1 de generar la respuesta para esta ruta en particular. Para acceder a par\u00e1metros de una solicitud, se utiliza la macro param . Esta macro toma como par\u00e1metros el nombre del par\u00e1metro y un valor por defecto en caso de que el par\u00e1metro no est\u00e9 presente en la solicitud. ( defroute \"/user/:id\" [ id ] ( user - page id )) En este caso, el par\u00e1metro id se puede acceder dentro de la funci\u00f3n user-page para utilizarlo en la generaci\u00f3n de la respuesta.","title":"Ejemplos de c\u00f3digo en Luminus Framework"},{"location":"luminus/jr/manejo_de_rutas_y_solicitudes/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una ruta en Luminus que responda a la URL \"/about\" y llame a la funci\u00f3n about-page para generar la respuesta. Define una ruta que permita acceder a una p\u00e1gina de perfil de usuario, utilizando el patr\u00f3n de ruta \"/user/:username\". La funci\u00f3n asociada a esta ruta debe recibir como par\u00e1metro el username y llamar a la funci\u00f3n profile-page para generar la respuesta. Crea un formulario en una p\u00e1gina y define una ruta para manejar la solicitud de env\u00edo del formulario. La ruta debe utilizar el verbo HTTP \"POST\" y llamar a la funci\u00f3n submit-form para procesar los datos enviados. Utiliza la macro param para acceder al par\u00e1metro id en una ruta y llamar a la funci\u00f3n post-page para mostrar un post espec\u00edfico en una p\u00e1gina.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"luminus/jr/manejo_de_rutas_y_solicitudes/#consejos-o-mejores-practicas","text":"Utiliza nombres descriptivos para las rutas y las funciones asociadas a ellas, esto facilitar\u00e1 la comprensi\u00f3n del c\u00f3digo. Utiliza patrones de ruta que sean f\u00e1ciles de recordar y que sigan una l\u00f3gica coherente en la estructura de la aplicaci\u00f3n. Al manejar par\u00e1metros en las rutas, valida siempre los datos recibidos para evitar errores o problemas de seguridad. Utiliza los verbos HTTP adecuados para cada tipo de solicitud (GET para obtener datos, POST para enviar datos, etc.). Utiliza la macro defroutes para agrupar varias rutas en un mismo archivo y mantener una estructura organizada en la aplicaci\u00f3n.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"luminus/jr/optimizaci%C3%B3n_y_depuraci%C3%B3n/","text":"M\u00f3dulo 6: Optimizaci\u00f3n y depuraci\u00f3n \u00b6 En este m\u00f3dulo, aprender\u00e1s c\u00f3mo optimizar y depurar una aplicaci\u00f3n en Luminus. La optimizaci\u00f3n es un proceso importante para mejorar el rendimiento de una aplicaci\u00f3n, mientras que la depuraci\u00f3n es esencial para encontrar y corregir errores en el c\u00f3digo. Explicaci\u00f3n te\u00f3rica \u00b6 Optimizaci\u00f3n \u00b6 La optimizaci\u00f3n en Luminus se refiere a mejorar el rendimiento de una aplicaci\u00f3n. Esto se logra mediante la identificaci\u00f3n y eliminaci\u00f3n de cuellos de botella, es decir, partes del c\u00f3digo que ralentizan la aplicaci\u00f3n. Al optimizar una aplicaci\u00f3n, se busca reducir el tiempo de respuesta y mejorar la experiencia del usuario. Para optimizar una aplicaci\u00f3n en Luminus, es importante tener en cuenta los siguientes aspectos: Carga de recursos : aseg\u00farate de que los recursos, como im\u00e1genes y archivos est\u00e1ticos, se carguen de manera eficiente para no ralentizar la aplicaci\u00f3n. Consultas a la base de datos : utiliza t\u00e9cnicas de optimizaci\u00f3n de consultas para mejorar el rendimiento de las consultas a la base de datos. Cache : utiliza la cach\u00e9 para almacenar datos que se utilizan con frecuencia y as\u00ed evitar consultas innecesarias a la base de datos. Compresi\u00f3n de archivos : comprime los archivos est\u00e1ticos para reducir su tama\u00f1o y mejorar el tiempo de carga. Uso de \u00edndices : aseg\u00farate de que la base de datos tenga \u00edndices adecuados para mejorar el rendimiento de las consultas. Depuraci\u00f3n \u00b6 La depuraci\u00f3n en Luminus se refiere a encontrar y corregir errores en el c\u00f3digo. Es importante realizar una depuraci\u00f3n adecuada para garantizar que la aplicaci\u00f3n funcione correctamente y para evitar problemas en el futuro. Para depurar una aplicaci\u00f3n en Luminus, es importante tener en cuenta los siguientes aspectos: Registro de errores : aseg\u00farate de que la aplicaci\u00f3n registre los errores para poder identificarlos y corregirlos. Utilizaci\u00f3n de herramientas de depuraci\u00f3n : utiliza herramientas como el debugger de Clojure o el REPL para inspeccionar el estado de la aplicaci\u00f3n y encontrar errores. Pruebas unitarias : es importante escribir pruebas unitarias para asegurarse de que el c\u00f3digo funcione como se espera. Manejo de excepciones : aseg\u00farate de manejar adecuadamente las excepciones para que la aplicaci\u00f3n no se bloquee en caso de que ocurra un error. Palabras clave y su definici\u00f3n \u00b6 Optimizaci\u00f3n: proceso de mejora del rendimiento de una aplicaci\u00f3n. Depuraci\u00f3n: proceso de encontrar y corregir errores en el c\u00f3digo. Cuellos de botella: partes del c\u00f3digo que ralentizan la aplicaci\u00f3n. Cache: almacenamiento temporal de datos para evitar consultas innecesarias a la base de datos. \u00cdndices: estructuras de datos que mejoran el rendimiento de las consultas a la base de datos. Registro de errores: registro de los errores que ocurren en la aplicaci\u00f3n. Debugger: herramienta que permite inspeccionar el estado de la aplicaci\u00f3n y encontrar errores. REPL: Read-Eval-Print Loop, un entorno interactivo para ejecutar c\u00f3digo y evaluar su resultado. Pruebas unitarias: pruebas que se realizan a nivel de c\u00f3digo para asegurarse de que funciona como se espera. Excepciones: errores que ocurren durante la ejecuci\u00f3n de la aplicaci\u00f3n. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la optimizaci\u00f3n en Luminus y por qu\u00e9 es importante? Menciona algunos aspectos a tener en cuenta al optimizar una aplicaci\u00f3n en Luminus. \u00bfQu\u00e9 es la depuraci\u00f3n y por qu\u00e9 es importante en una aplicaci\u00f3n? \u00bfQu\u00e9 herramientas se pueden utilizar para depurar una aplicaci\u00f3n en Luminus? \u00bfQu\u00e9 son las pruebas unitarias y por qu\u00e9 son importantes en el proceso de depuraci\u00f3n? \u00bfC\u00f3mo se pueden manejar las excepciones en una aplicaci\u00f3n en Luminus? Ejemplos de c\u00f3digo en Luminus Framework \u00b6 Carga de recursos \u00b6 En el siguiente ejemplo, se utiliza la funci\u00f3n resource para cargar un archivo est\u00e1tico en una vista. ( defn home [] ( layout/render \"home.html\" { :image ( resource \"img/logo.png\" )})) Uso de \u00edndices \u00b6 En este ejemplo, se crea un \u00edndice en una tabla de la base de datos para mejorar el rendimiento de la consulta. ( defentity user :indexes [( index :email )]) Manejo de excepciones \u00b6 En el siguiente ejemplo, se utiliza try/catch para manejar una excepci\u00f3n y mostrar un mensaje de error al usuario. ( try ( db/save-user data ) ( layout/render \"success.html\" )) ( catch Exception e ( layout/render \"error.html\" { :message ( .getMessage e )})) Ejercicios pr\u00e1cticos \u00b6 Optimiza la carga de recursos en una vista de tu aplicaci\u00f3n en Luminus. Crea un \u00edndice en una tabla de la base de datos en tu aplicaci\u00f3n. Utiliza try/catch para manejar una excepci\u00f3n en tu aplicaci\u00f3n y mostrar un mensaje de error al usuario. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza herramientas de rendimiento, como Google PageSpeed Insights, para identificar \u00e1reas de mejora en tu aplicaci\u00f3n. Realiza pruebas de rendimiento antes y despu\u00e9s de aplicar optimizaciones para medir su impacto. Utiliza un sistema de registro de errores para poder identificar y corregir problemas. Escribe pruebas unitarias para asegurarte de que el c\u00f3digo funcione como se espera. Utiliza el debugger o el REPL para encontrar errores de manera m\u00e1s eficiente. Realiza pruebas en un entorno de desarrollo antes de implementar cambios en producci\u00f3n.","title":"M\u00f3dulo 6: Optimizaci\u00f3n y depuraci\u00f3n"},{"location":"luminus/jr/optimizaci%C3%B3n_y_depuraci%C3%B3n/#modulo-6-optimizacion-y-depuracion","text":"En este m\u00f3dulo, aprender\u00e1s c\u00f3mo optimizar y depurar una aplicaci\u00f3n en Luminus. La optimizaci\u00f3n es un proceso importante para mejorar el rendimiento de una aplicaci\u00f3n, mientras que la depuraci\u00f3n es esencial para encontrar y corregir errores en el c\u00f3digo.","title":"M\u00f3dulo 6: Optimizaci\u00f3n y depuraci\u00f3n"},{"location":"luminus/jr/optimizaci%C3%B3n_y_depuraci%C3%B3n/#explicacion-teorica","text":"","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"luminus/jr/optimizaci%C3%B3n_y_depuraci%C3%B3n/#optimizacion","text":"La optimizaci\u00f3n en Luminus se refiere a mejorar el rendimiento de una aplicaci\u00f3n. Esto se logra mediante la identificaci\u00f3n y eliminaci\u00f3n de cuellos de botella, es decir, partes del c\u00f3digo que ralentizan la aplicaci\u00f3n. Al optimizar una aplicaci\u00f3n, se busca reducir el tiempo de respuesta y mejorar la experiencia del usuario. Para optimizar una aplicaci\u00f3n en Luminus, es importante tener en cuenta los siguientes aspectos: Carga de recursos : aseg\u00farate de que los recursos, como im\u00e1genes y archivos est\u00e1ticos, se carguen de manera eficiente para no ralentizar la aplicaci\u00f3n. Consultas a la base de datos : utiliza t\u00e9cnicas de optimizaci\u00f3n de consultas para mejorar el rendimiento de las consultas a la base de datos. Cache : utiliza la cach\u00e9 para almacenar datos que se utilizan con frecuencia y as\u00ed evitar consultas innecesarias a la base de datos. Compresi\u00f3n de archivos : comprime los archivos est\u00e1ticos para reducir su tama\u00f1o y mejorar el tiempo de carga. Uso de \u00edndices : aseg\u00farate de que la base de datos tenga \u00edndices adecuados para mejorar el rendimiento de las consultas.","title":"Optimizaci\u00f3n"},{"location":"luminus/jr/optimizaci%C3%B3n_y_depuraci%C3%B3n/#depuracion","text":"La depuraci\u00f3n en Luminus se refiere a encontrar y corregir errores en el c\u00f3digo. Es importante realizar una depuraci\u00f3n adecuada para garantizar que la aplicaci\u00f3n funcione correctamente y para evitar problemas en el futuro. Para depurar una aplicaci\u00f3n en Luminus, es importante tener en cuenta los siguientes aspectos: Registro de errores : aseg\u00farate de que la aplicaci\u00f3n registre los errores para poder identificarlos y corregirlos. Utilizaci\u00f3n de herramientas de depuraci\u00f3n : utiliza herramientas como el debugger de Clojure o el REPL para inspeccionar el estado de la aplicaci\u00f3n y encontrar errores. Pruebas unitarias : es importante escribir pruebas unitarias para asegurarse de que el c\u00f3digo funcione como se espera. Manejo de excepciones : aseg\u00farate de manejar adecuadamente las excepciones para que la aplicaci\u00f3n no se bloquee en caso de que ocurra un error.","title":"Depuraci\u00f3n"},{"location":"luminus/jr/optimizaci%C3%B3n_y_depuraci%C3%B3n/#palabras-clave-y-su-definicion","text":"Optimizaci\u00f3n: proceso de mejora del rendimiento de una aplicaci\u00f3n. Depuraci\u00f3n: proceso de encontrar y corregir errores en el c\u00f3digo. Cuellos de botella: partes del c\u00f3digo que ralentizan la aplicaci\u00f3n. Cache: almacenamiento temporal de datos para evitar consultas innecesarias a la base de datos. \u00cdndices: estructuras de datos que mejoran el rendimiento de las consultas a la base de datos. Registro de errores: registro de los errores que ocurren en la aplicaci\u00f3n. Debugger: herramienta que permite inspeccionar el estado de la aplicaci\u00f3n y encontrar errores. REPL: Read-Eval-Print Loop, un entorno interactivo para ejecutar c\u00f3digo y evaluar su resultado. Pruebas unitarias: pruebas que se realizan a nivel de c\u00f3digo para asegurarse de que funciona como se espera. Excepciones: errores que ocurren durante la ejecuci\u00f3n de la aplicaci\u00f3n.","title":"Palabras clave y su definici\u00f3n"},{"location":"luminus/jr/optimizaci%C3%B3n_y_depuraci%C3%B3n/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la optimizaci\u00f3n en Luminus y por qu\u00e9 es importante? Menciona algunos aspectos a tener en cuenta al optimizar una aplicaci\u00f3n en Luminus. \u00bfQu\u00e9 es la depuraci\u00f3n y por qu\u00e9 es importante en una aplicaci\u00f3n? \u00bfQu\u00e9 herramientas se pueden utilizar para depurar una aplicaci\u00f3n en Luminus? \u00bfQu\u00e9 son las pruebas unitarias y por qu\u00e9 son importantes en el proceso de depuraci\u00f3n? \u00bfC\u00f3mo se pueden manejar las excepciones en una aplicaci\u00f3n en Luminus?","title":"Preguntas de repaso"},{"location":"luminus/jr/optimizaci%C3%B3n_y_depuraci%C3%B3n/#ejemplos-de-codigo-en-luminus-framework","text":"","title":"Ejemplos de c\u00f3digo en Luminus Framework"},{"location":"luminus/jr/optimizaci%C3%B3n_y_depuraci%C3%B3n/#carga-de-recursos","text":"En el siguiente ejemplo, se utiliza la funci\u00f3n resource para cargar un archivo est\u00e1tico en una vista. ( defn home [] ( layout/render \"home.html\" { :image ( resource \"img/logo.png\" )}))","title":"Carga de recursos"},{"location":"luminus/jr/optimizaci%C3%B3n_y_depuraci%C3%B3n/#uso-de-indices","text":"En este ejemplo, se crea un \u00edndice en una tabla de la base de datos para mejorar el rendimiento de la consulta. ( defentity user :indexes [( index :email )])","title":"Uso de \u00edndices"},{"location":"luminus/jr/optimizaci%C3%B3n_y_depuraci%C3%B3n/#manejo-de-excepciones","text":"En el siguiente ejemplo, se utiliza try/catch para manejar una excepci\u00f3n y mostrar un mensaje de error al usuario. ( try ( db/save-user data ) ( layout/render \"success.html\" )) ( catch Exception e ( layout/render \"error.html\" { :message ( .getMessage e )}))","title":"Manejo de excepciones"},{"location":"luminus/jr/optimizaci%C3%B3n_y_depuraci%C3%B3n/#ejercicios-practicos","text":"Optimiza la carga de recursos en una vista de tu aplicaci\u00f3n en Luminus. Crea un \u00edndice en una tabla de la base de datos en tu aplicaci\u00f3n. Utiliza try/catch para manejar una excepci\u00f3n en tu aplicaci\u00f3n y mostrar un mensaje de error al usuario.","title":"Ejercicios pr\u00e1cticos"},{"location":"luminus/jr/optimizaci%C3%B3n_y_depuraci%C3%B3n/#consejos-o-mejores-practicas","text":"Utiliza herramientas de rendimiento, como Google PageSpeed Insights, para identificar \u00e1reas de mejora en tu aplicaci\u00f3n. Realiza pruebas de rendimiento antes y despu\u00e9s de aplicar optimizaciones para medir su impacto. Utiliza un sistema de registro de errores para poder identificar y corregir problemas. Escribe pruebas unitarias para asegurarte de que el c\u00f3digo funcione como se espera. Utiliza el debugger o el REPL para encontrar errores de manera m\u00e1s eficiente. Realiza pruebas en un entorno de desarrollo antes de implementar cambios en producci\u00f3n.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"luminus/jr/proyecto_final/","text":"Proyecto final \u00b6 En este m\u00f3dulo se llevar\u00e1 a cabo un proyecto final en el que se pondr\u00e1n en pr\u00e1ctica todos los conocimientos adquiridos sobre Luminus Framework. El objetivo es desarrollar una aplicaci\u00f3n completa utilizando esta herramienta y presentarla al final del curso. Explicaci\u00f3n te\u00f3rica \u00b6 Luminus Framework es un framework de desarrollo web basado en Clojure que permite crear aplicaciones de forma r\u00e1pida y eficiente. Est\u00e1 construido sobre otros frameworks y bibliotecas como Ring, Compojure y Hiccup, lo que lo convierte en una opci\u00f3n poderosa para el desarrollo de aplicaciones web robustas. El enfoque de Luminus se basa en la simplicidad, la modularidad y el rendimiento. Esto se logra gracias a su arquitectura basada en componentes, que permite la reutilizaci\u00f3n de c\u00f3digo y la f\u00e1cil integraci\u00f3n de nuevas funcionalidades. Para llevar a cabo el proyecto final, es importante tener en cuenta los siguientes conceptos clave: Palabras clave y su definici\u00f3n \u00b6 Clojure : es un lenguaje de programaci\u00f3n funcional din\u00e1mico que se ejecuta en la m\u00e1quina virtual de Java (JVM). Es el lenguaje en el que est\u00e1 basado Luminus Framework. Ring : es una biblioteca de manejo de peticiones HTTP para aplicaciones web en Clojure. Proporciona una interfaz simple y flexible para manejar las solicitudes y las respuestas. Compojure : es un framework de enrutamiento para aplicaciones web en Clojure. Facilita la definici\u00f3n de rutas y manejo de peticiones HTTP. Hiccup : es una biblioteca de generaci\u00f3n de HTML en Clojure, que permite definir el contenido de una p\u00e1gina web como una estructura de datos. Componentes : es el enfoque de arquitectura utilizado por Luminus, donde cada funcionalidad se divide en peque\u00f1as piezas independientes, lo que facilita su mantenimiento y reutilizaci\u00f3n. Leiningen : es un sistema de construcci\u00f3n y administraci\u00f3n de dependencias para proyectos en Clojure. Se utiliza para crear y ejecutar aplicaciones desarrolladas con Luminus. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es Luminus Framework y en qu\u00e9 lenguaje est\u00e1 basado? \u00bfCu\u00e1les son los principales componentes en los que est\u00e1 construido Luminus? \u00bfQu\u00e9 ventajas ofrece la arquitectura basada en componentes de Luminus? \u00bfQu\u00e9 es Leiningen y para qu\u00e9 se utiliza en el desarrollo con Luminus? \u00bfQu\u00e9 es Hiccup y c\u00f3mo se utiliza en el desarrollo web con Luminus? Ejemplos de c\u00f3digo en Luminus Framework \u00b6 Para comprender mejor c\u00f3mo se utiliza Luminus en el desarrollo de aplicaciones web, a continuaci\u00f3n se presentan algunos ejemplos de c\u00f3digo: Creaci\u00f3n de un proyecto con Leiningen \u00b6 Para crear un proyecto en Luminus utilizando Leiningen, se debe ejecutar el siguiente comando en la terminal: lein new luminus <nombre-proyecto> +api +h2 +reagent +sqlite +swagger Esto crear\u00e1 un proyecto con las caracter\u00edsticas especificadas (API, base de datos H2, librer\u00eda Reagent para manejo de JavaScript y base de datos SQLite) y tambi\u00e9n incluir\u00e1 la documentaci\u00f3n de Swagger para la API. Definici\u00f3n de rutas con Compojure \u00b6 Para definir una ruta en una aplicaci\u00f3n web con Luminus y Compojure, se debe utilizar la macro defroutes de la siguiente manera: ( defroutes app - routes ( GET \"/hello\" [] \"Hola mundo\" ) ( GET \"/user/:id\" [ id ] ( str \"El ID del usuario es \" id )) ( POST \"/user\" { body : params } ( str \"El nombre del usuario es \" ( : name body )))) En este ejemplo, se definen tres rutas: una para obtener un saludo, otra para obtener el ID de un usuario y otra para crear un usuario con un nombre especificado en el cuerpo de la petici\u00f3n. Uso de Hiccup para generar HTML \u00b6 Hiccup permite crear HTML utilizando una sintaxis similar a Clojure. Por ejemplo, para crear una lista de elementos, se puede utilizar la siguiente estructura de datos: [:ul [:li \"Elemento 1\"] [:li \"Elemento 2\"] [:li \"Elemento 3\"]] Esto generar\u00e1 el siguiente HTML: <ul> <li> Elemento 1 </li> <li> Elemento 2 </li> <li> Elemento 3 </li> </ul> Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crear un proyecto en Luminus utilizando Leiningen y las caracter\u00edsticas de su preferencia. Definir al menos tres rutas en el proyecto utilizando Compojure. Utilizar Hiccup para generar una p\u00e1gina de inicio con contenido HTML. Agregar una funcionalidad de base de datos utilizando la base de datos de su elecci\u00f3n (por ejemplo, PostgreSQL o MySQL). Implementar una API utilizando Swagger y probarla con una herramienta como Postman. Consejos o mejores pr\u00e1cticas \u00b6 Es recomendable seguir la convenci\u00f3n de nombres de Luminus, que utiliza el formato nombre-proyecto para el nombre del proyecto y nombre-paquete para el nombre del paquete. Utilizar componentes para dividir la funcionalidad en peque\u00f1as piezas y facilitar su reutilizaci\u00f3n. Utilizar las herramientas incluidas en el proyecto (como Swagger) para documentar y probar la API. Seguir las buenas pr\u00e1cticas de Clojure, como utilizar funciones puras y evitar mutar el estado. Utilizar la documentaci\u00f3n oficial de Luminus y su comunidad en l\u00ednea para resolver dudas y obtener ayuda en caso necesario. En resumen, el proyecto final en Luminus Framework brindar\u00e1 la oportunidad de aplicar todos los conocimientos adquiridos durante el curso y crear una aplicaci\u00f3n web completa utilizando esta herramienta poderosa. Se recomienda seguir las buenas pr\u00e1cticas y utilizar las herramientas adecuadas para obtener un desarrollo eficiente y de calidad.","title":"Proyecto final"},{"location":"luminus/jr/proyecto_final/#proyecto-final","text":"En este m\u00f3dulo se llevar\u00e1 a cabo un proyecto final en el que se pondr\u00e1n en pr\u00e1ctica todos los conocimientos adquiridos sobre Luminus Framework. El objetivo es desarrollar una aplicaci\u00f3n completa utilizando esta herramienta y presentarla al final del curso.","title":"Proyecto final"},{"location":"luminus/jr/proyecto_final/#explicacion-teorica","text":"Luminus Framework es un framework de desarrollo web basado en Clojure que permite crear aplicaciones de forma r\u00e1pida y eficiente. Est\u00e1 construido sobre otros frameworks y bibliotecas como Ring, Compojure y Hiccup, lo que lo convierte en una opci\u00f3n poderosa para el desarrollo de aplicaciones web robustas. El enfoque de Luminus se basa en la simplicidad, la modularidad y el rendimiento. Esto se logra gracias a su arquitectura basada en componentes, que permite la reutilizaci\u00f3n de c\u00f3digo y la f\u00e1cil integraci\u00f3n de nuevas funcionalidades. Para llevar a cabo el proyecto final, es importante tener en cuenta los siguientes conceptos clave:","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"luminus/jr/proyecto_final/#palabras-clave-y-su-definicion","text":"Clojure : es un lenguaje de programaci\u00f3n funcional din\u00e1mico que se ejecuta en la m\u00e1quina virtual de Java (JVM). Es el lenguaje en el que est\u00e1 basado Luminus Framework. Ring : es una biblioteca de manejo de peticiones HTTP para aplicaciones web en Clojure. Proporciona una interfaz simple y flexible para manejar las solicitudes y las respuestas. Compojure : es un framework de enrutamiento para aplicaciones web en Clojure. Facilita la definici\u00f3n de rutas y manejo de peticiones HTTP. Hiccup : es una biblioteca de generaci\u00f3n de HTML en Clojure, que permite definir el contenido de una p\u00e1gina web como una estructura de datos. Componentes : es el enfoque de arquitectura utilizado por Luminus, donde cada funcionalidad se divide en peque\u00f1as piezas independientes, lo que facilita su mantenimiento y reutilizaci\u00f3n. Leiningen : es un sistema de construcci\u00f3n y administraci\u00f3n de dependencias para proyectos en Clojure. Se utiliza para crear y ejecutar aplicaciones desarrolladas con Luminus.","title":"Palabras clave y su definici\u00f3n"},{"location":"luminus/jr/proyecto_final/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Luminus Framework y en qu\u00e9 lenguaje est\u00e1 basado? \u00bfCu\u00e1les son los principales componentes en los que est\u00e1 construido Luminus? \u00bfQu\u00e9 ventajas ofrece la arquitectura basada en componentes de Luminus? \u00bfQu\u00e9 es Leiningen y para qu\u00e9 se utiliza en el desarrollo con Luminus? \u00bfQu\u00e9 es Hiccup y c\u00f3mo se utiliza en el desarrollo web con Luminus?","title":"Preguntas de repaso"},{"location":"luminus/jr/proyecto_final/#ejemplos-de-codigo-en-luminus-framework","text":"Para comprender mejor c\u00f3mo se utiliza Luminus en el desarrollo de aplicaciones web, a continuaci\u00f3n se presentan algunos ejemplos de c\u00f3digo:","title":"Ejemplos de c\u00f3digo en Luminus Framework"},{"location":"luminus/jr/proyecto_final/#creacion-de-un-proyecto-con-leiningen","text":"Para crear un proyecto en Luminus utilizando Leiningen, se debe ejecutar el siguiente comando en la terminal: lein new luminus <nombre-proyecto> +api +h2 +reagent +sqlite +swagger Esto crear\u00e1 un proyecto con las caracter\u00edsticas especificadas (API, base de datos H2, librer\u00eda Reagent para manejo de JavaScript y base de datos SQLite) y tambi\u00e9n incluir\u00e1 la documentaci\u00f3n de Swagger para la API.","title":"Creaci\u00f3n de un proyecto con Leiningen"},{"location":"luminus/jr/proyecto_final/#definicion-de-rutas-con-compojure","text":"Para definir una ruta en una aplicaci\u00f3n web con Luminus y Compojure, se debe utilizar la macro defroutes de la siguiente manera: ( defroutes app - routes ( GET \"/hello\" [] \"Hola mundo\" ) ( GET \"/user/:id\" [ id ] ( str \"El ID del usuario es \" id )) ( POST \"/user\" { body : params } ( str \"El nombre del usuario es \" ( : name body )))) En este ejemplo, se definen tres rutas: una para obtener un saludo, otra para obtener el ID de un usuario y otra para crear un usuario con un nombre especificado en el cuerpo de la petici\u00f3n.","title":"Definici\u00f3n de rutas con Compojure"},{"location":"luminus/jr/proyecto_final/#uso-de-hiccup-para-generar-html","text":"Hiccup permite crear HTML utilizando una sintaxis similar a Clojure. Por ejemplo, para crear una lista de elementos, se puede utilizar la siguiente estructura de datos: [:ul [:li \"Elemento 1\"] [:li \"Elemento 2\"] [:li \"Elemento 3\"]] Esto generar\u00e1 el siguiente HTML: <ul> <li> Elemento 1 </li> <li> Elemento 2 </li> <li> Elemento 3 </li> </ul>","title":"Uso de Hiccup para generar HTML"},{"location":"luminus/jr/proyecto_final/#ejercicios-practicos-con-instrucciones-claras","text":"Crear un proyecto en Luminus utilizando Leiningen y las caracter\u00edsticas de su preferencia. Definir al menos tres rutas en el proyecto utilizando Compojure. Utilizar Hiccup para generar una p\u00e1gina de inicio con contenido HTML. Agregar una funcionalidad de base de datos utilizando la base de datos de su elecci\u00f3n (por ejemplo, PostgreSQL o MySQL). Implementar una API utilizando Swagger y probarla con una herramienta como Postman.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"luminus/jr/proyecto_final/#consejos-o-mejores-practicas","text":"Es recomendable seguir la convenci\u00f3n de nombres de Luminus, que utiliza el formato nombre-proyecto para el nombre del proyecto y nombre-paquete para el nombre del paquete. Utilizar componentes para dividir la funcionalidad en peque\u00f1as piezas y facilitar su reutilizaci\u00f3n. Utilizar las herramientas incluidas en el proyecto (como Swagger) para documentar y probar la API. Seguir las buenas pr\u00e1cticas de Clojure, como utilizar funciones puras y evitar mutar el estado. Utilizar la documentaci\u00f3n oficial de Luminus y su comunidad en l\u00ednea para resolver dudas y obtener ayuda en caso necesario. En resumen, el proyecto final en Luminus Framework brindar\u00e1 la oportunidad de aplicar todos los conocimientos adquiridos durante el curso y crear una aplicaci\u00f3n web completa utilizando esta herramienta poderosa. Se recomienda seguir las buenas pr\u00e1cticas y utilizar las herramientas adecuadas para obtener un desarrollo eficiente y de calidad.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"luminus/mid/","text":"Luminus - Nivel Mid \u00b6 \u00a1Bienvenido/a al nivel Mid de Luminus! Explora funcionalidades m\u00e1s avanzadas del framework: Introducci\u00f3n a Luminus Framework (repaso) Configuraci\u00f3n avanzada de Luminus Desarrollo de API REST Integraci\u00f3n con otros servicios Despliegue en la nube Seguridad avanzada Optimizaci\u00f3n y escalabilidad Desarrollo de aplicaciones en tiempo real Proyecto final El archivo luminus_mid.json describe todos los m\u00f3dulos de este nivel.","title":"Luminus - Nivel Mid"},{"location":"luminus/mid/#luminus-nivel-mid","text":"\u00a1Bienvenido/a al nivel Mid de Luminus! Explora funcionalidades m\u00e1s avanzadas del framework: Introducci\u00f3n a Luminus Framework (repaso) Configuraci\u00f3n avanzada de Luminus Desarrollo de API REST Integraci\u00f3n con otros servicios Despliegue en la nube Seguridad avanzada Optimizaci\u00f3n y escalabilidad Desarrollo de aplicaciones en tiempo real Proyecto final El archivo luminus_mid.json describe todos los m\u00f3dulos de este nivel.","title":"Luminus - Nivel Mid"},{"location":"luminus/mid/configuraci%C3%B3n_avanzada_de_luminus/","text":"Configuraci\u00f3n avanzada de Luminus \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En este m\u00f3dulo, aprenderemos c\u00f3mo configurar y trabajar con Luminus en entornos m\u00e1s complejos. Veremos c\u00f3mo utilizar herramientas de automatizaci\u00f3n y gesti\u00f3n de dependencias para optimizar nuestro proceso de desarrollo. Tambi\u00e9n exploraremos c\u00f3mo trabajar con diferentes entornos, como desarrollo, prueba y producci\u00f3n, para garantizar una aplicaci\u00f3n estable y eficiente. Explicaci\u00f3n te\u00f3rica \u00b6 Luminus es un framework web escrito en Clojure que nos permite crear aplicaciones web de manera r\u00e1pida y sencilla. Su filosof\u00eda se basa en la simplicidad y la flexibilidad, lo que lo hace ideal para proyectos de cualquier tama\u00f1o y complejidad. En este m\u00f3dulo, nos enfocaremos en la configuraci\u00f3n avanzada de Luminus, lo que implica comprender c\u00f3mo funciona el framework y c\u00f3mo podemos optimizar su uso en entornos m\u00e1s complejos. Veremos c\u00f3mo trabajar con herramientas de automatizaci\u00f3n y gesti\u00f3n de dependencias para mejorar nuestro flujo de trabajo y c\u00f3mo configurar diferentes entornos para garantizar una aplicaci\u00f3n estable y eficiente. Palabras clave y su definici\u00f3n \u00b6 Automatizaci\u00f3n: proceso de realizar tareas de manera autom\u00e1tica mediante el uso de herramientas y scripts. Gesti\u00f3n de dependencias: proceso de administrar y organizar las librer\u00edas y paquetes utilizados en un proyecto. Entorno de desarrollo: ambiente en el que se desarrolla y prueba una aplicaci\u00f3n antes de ser lanzada a producci\u00f3n. Entorno de prueba: ambiente en el que se realizan pruebas exhaustivas para garantizar el correcto funcionamiento de una aplicaci\u00f3n. Entorno de producci\u00f3n: ambiente en el que se ejecuta una aplicaci\u00f3n en vivo para su uso por parte de los usuarios finales. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es Luminus? \u00bfCu\u00e1l es la filosof\u00eda de Luminus? \u00bfPor qu\u00e9 es importante la configuraci\u00f3n avanzada de Luminus? \u00bfQu\u00e9 es la automatizaci\u00f3n y c\u00f3mo se aplica en el desarrollo de aplicaciones web? \u00bfPor qu\u00e9 es necesario trabajar con diferentes entornos en una aplicaci\u00f3n web? \u00bfQu\u00e9 es la gesti\u00f3n de dependencias y por qu\u00e9 es importante en el desarrollo de aplicaciones web? \u00bfCu\u00e1les son los entornos m\u00e1s comunes en una aplicaci\u00f3n web? Ejemplos de c\u00f3digo en Luminus Framework \u00b6 Configuraci\u00f3n de herramientas de automatizaci\u00f3n \u00b6 Para automatizar tareas en nuestro proyecto de Luminus, podemos utilizar herramientas como Leiningen o Boot. Para ello, debemos agregar las dependencias correspondientes en nuestro archivo project.clj y luego ejecutar los comandos correspondientes en la terminal. Gesti\u00f3n de dependencias con Leiningen \u00b6 Para agregar una dependencia en nuestro proyecto de Luminus utilizando Leiningen, debemos agregarla en el archivo project.clj dentro de la secci\u00f3n :dependencies . Por ejemplo: :dependencies [[org.clojure/clojure \"1.10.0\"] [compojure \"1.6.1\"]] Luego, podemos ejecutar el comando lein deps en la terminal para descargar y agregar la dependencia a nuestro proyecto. Configuraci\u00f3n de diferentes entornos \u00b6 Para configurar diferentes entornos en nuestro proyecto de Luminus, debemos agregar un archivo profiles.clj en la ra\u00edz del proyecto. En este archivo, podemos definir diferentes perfiles con sus respectivas configuraciones. Por ejemplo: {: dev {: env {: production false } : middleware [ lein - ring . middleware / wrap - reload ]} : prod {: env {: production true }} Luego, podemos ejecutar nuestro proyecto utilizando el perfil deseado mediante el comando lein with-profile <perfil> ring server . Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Utilizando Leiningen, agrega la dependencia de hiccup a tu proyecto de Luminus y crea una peque\u00f1a aplicaci\u00f3n que muestre un mensaje en una p\u00e1gina web. Crea diferentes perfiles en tu archivo profiles.clj y configura el entorno de desarrollo para que use la base de datos dev-db y el entorno de producci\u00f3n para que use la base de datos prod-db . Utilizando herramientas de automatizaci\u00f3n, crea un script que compile y empaquete tu proyecto de Luminus en un archivo jar ejecutable. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza herramientas de automatizaci\u00f3n como Leiningen o Boot para optimizar tu flujo de trabajo y evitar tareas repetitivas. Organiza y gestiona tus dependencias de manera eficiente para garantizar un proyecto limpio y bien estructurado. Configura diferentes entornos para asegurar un proceso de desarrollo y pruebas s\u00f3lido antes de lanzar tu aplicaci\u00f3n a producci\u00f3n. Siempre sigue las mejores pr\u00e1cticas de seguridad y aseg\u00farate de proteger tu aplicaci\u00f3n en entornos de producci\u00f3n.","title":"Configuraci\u00f3n avanzada de Luminus"},{"location":"luminus/mid/configuraci%C3%B3n_avanzada_de_luminus/#configuracion-avanzada-de-luminus","text":"","title":"Configuraci\u00f3n avanzada de Luminus"},{"location":"luminus/mid/configuraci%C3%B3n_avanzada_de_luminus/#descripcion-del-modulo","text":"En este m\u00f3dulo, aprenderemos c\u00f3mo configurar y trabajar con Luminus en entornos m\u00e1s complejos. Veremos c\u00f3mo utilizar herramientas de automatizaci\u00f3n y gesti\u00f3n de dependencias para optimizar nuestro proceso de desarrollo. Tambi\u00e9n exploraremos c\u00f3mo trabajar con diferentes entornos, como desarrollo, prueba y producci\u00f3n, para garantizar una aplicaci\u00f3n estable y eficiente.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"luminus/mid/configuraci%C3%B3n_avanzada_de_luminus/#explicacion-teorica","text":"Luminus es un framework web escrito en Clojure que nos permite crear aplicaciones web de manera r\u00e1pida y sencilla. Su filosof\u00eda se basa en la simplicidad y la flexibilidad, lo que lo hace ideal para proyectos de cualquier tama\u00f1o y complejidad. En este m\u00f3dulo, nos enfocaremos en la configuraci\u00f3n avanzada de Luminus, lo que implica comprender c\u00f3mo funciona el framework y c\u00f3mo podemos optimizar su uso en entornos m\u00e1s complejos. Veremos c\u00f3mo trabajar con herramientas de automatizaci\u00f3n y gesti\u00f3n de dependencias para mejorar nuestro flujo de trabajo y c\u00f3mo configurar diferentes entornos para garantizar una aplicaci\u00f3n estable y eficiente.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"luminus/mid/configuraci%C3%B3n_avanzada_de_luminus/#palabras-clave-y-su-definicion","text":"Automatizaci\u00f3n: proceso de realizar tareas de manera autom\u00e1tica mediante el uso de herramientas y scripts. Gesti\u00f3n de dependencias: proceso de administrar y organizar las librer\u00edas y paquetes utilizados en un proyecto. Entorno de desarrollo: ambiente en el que se desarrolla y prueba una aplicaci\u00f3n antes de ser lanzada a producci\u00f3n. Entorno de prueba: ambiente en el que se realizan pruebas exhaustivas para garantizar el correcto funcionamiento de una aplicaci\u00f3n. Entorno de producci\u00f3n: ambiente en el que se ejecuta una aplicaci\u00f3n en vivo para su uso por parte de los usuarios finales.","title":"Palabras clave y su definici\u00f3n"},{"location":"luminus/mid/configuraci%C3%B3n_avanzada_de_luminus/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Luminus? \u00bfCu\u00e1l es la filosof\u00eda de Luminus? \u00bfPor qu\u00e9 es importante la configuraci\u00f3n avanzada de Luminus? \u00bfQu\u00e9 es la automatizaci\u00f3n y c\u00f3mo se aplica en el desarrollo de aplicaciones web? \u00bfPor qu\u00e9 es necesario trabajar con diferentes entornos en una aplicaci\u00f3n web? \u00bfQu\u00e9 es la gesti\u00f3n de dependencias y por qu\u00e9 es importante en el desarrollo de aplicaciones web? \u00bfCu\u00e1les son los entornos m\u00e1s comunes en una aplicaci\u00f3n web?","title":"Preguntas de repaso"},{"location":"luminus/mid/configuraci%C3%B3n_avanzada_de_luminus/#ejemplos-de-codigo-en-luminus-framework","text":"","title":"Ejemplos de c\u00f3digo en Luminus Framework"},{"location":"luminus/mid/configuraci%C3%B3n_avanzada_de_luminus/#configuracion-de-herramientas-de-automatizacion","text":"Para automatizar tareas en nuestro proyecto de Luminus, podemos utilizar herramientas como Leiningen o Boot. Para ello, debemos agregar las dependencias correspondientes en nuestro archivo project.clj y luego ejecutar los comandos correspondientes en la terminal.","title":"Configuraci\u00f3n de herramientas de automatizaci\u00f3n"},{"location":"luminus/mid/configuraci%C3%B3n_avanzada_de_luminus/#gestion-de-dependencias-con-leiningen","text":"Para agregar una dependencia en nuestro proyecto de Luminus utilizando Leiningen, debemos agregarla en el archivo project.clj dentro de la secci\u00f3n :dependencies . Por ejemplo: :dependencies [[org.clojure/clojure \"1.10.0\"] [compojure \"1.6.1\"]] Luego, podemos ejecutar el comando lein deps en la terminal para descargar y agregar la dependencia a nuestro proyecto.","title":"Gesti\u00f3n de dependencias con Leiningen"},{"location":"luminus/mid/configuraci%C3%B3n_avanzada_de_luminus/#configuracion-de-diferentes-entornos","text":"Para configurar diferentes entornos en nuestro proyecto de Luminus, debemos agregar un archivo profiles.clj en la ra\u00edz del proyecto. En este archivo, podemos definir diferentes perfiles con sus respectivas configuraciones. Por ejemplo: {: dev {: env {: production false } : middleware [ lein - ring . middleware / wrap - reload ]} : prod {: env {: production true }} Luego, podemos ejecutar nuestro proyecto utilizando el perfil deseado mediante el comando lein with-profile <perfil> ring server .","title":"Configuraci\u00f3n de diferentes entornos"},{"location":"luminus/mid/configuraci%C3%B3n_avanzada_de_luminus/#ejercicios-practicos-con-instrucciones-claras","text":"Utilizando Leiningen, agrega la dependencia de hiccup a tu proyecto de Luminus y crea una peque\u00f1a aplicaci\u00f3n que muestre un mensaje en una p\u00e1gina web. Crea diferentes perfiles en tu archivo profiles.clj y configura el entorno de desarrollo para que use la base de datos dev-db y el entorno de producci\u00f3n para que use la base de datos prod-db . Utilizando herramientas de automatizaci\u00f3n, crea un script que compile y empaquete tu proyecto de Luminus en un archivo jar ejecutable.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"luminus/mid/configuraci%C3%B3n_avanzada_de_luminus/#consejos-o-mejores-practicas","text":"Utiliza herramientas de automatizaci\u00f3n como Leiningen o Boot para optimizar tu flujo de trabajo y evitar tareas repetitivas. Organiza y gestiona tus dependencias de manera eficiente para garantizar un proyecto limpio y bien estructurado. Configura diferentes entornos para asegurar un proceso de desarrollo y pruebas s\u00f3lido antes de lanzar tu aplicaci\u00f3n a producci\u00f3n. Siempre sigue las mejores pr\u00e1cticas de seguridad y aseg\u00farate de proteger tu aplicaci\u00f3n en entornos de producci\u00f3n.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"luminus/mid/desarrollo_de_api_rest/","text":"Desarrollo de API REST con Luminus Framework \u00b6 M\u00f3dulo: Desarrollo de API REST \u00b6 En este m\u00f3dulo aprender\u00e1s c\u00f3mo desarrollar una API REST utilizando Luminus Framework. Una API REST (representational state transfer) es una arquitectura de dise\u00f1o web para crear servicios web que se basan en el protocolo HTTP. Este tipo de API es ampliamente utilizado en el desarrollo de aplicaciones web y m\u00f3viles, ya que proporciona una forma eficiente y escalable de comunicaci\u00f3n entre diferentes sistemas. Explicaci\u00f3n te\u00f3rica \u00b6 Una API REST se basa en el principio de que cada recurso en la aplicaci\u00f3n web tiene una URL \u00fanica y se puede acceder a \u00e9l a trav\u00e9s de los m\u00e9todos HTTP como GET, POST, PUT y DELETE. Esto permite a los clientes interactuar con la aplicaci\u00f3n web enviando peticiones a trav\u00e9s de estas URL y recibiendo respuestas en formato JSON o XML. Para desarrollar una API REST con Luminus, se utilizan diferentes herramientas y bibliotecas como Compojure, Ring y HTTP kit. Estas herramientas facilitan la creaci\u00f3n de rutas, manejo de peticiones y respuestas, y autenticaci\u00f3n de usuarios. Palabras clave y su definici\u00f3n \u00b6 API: Interfaz de programaci\u00f3n de aplicaciones, es un conjunto de protocolos, herramientas y definiciones para crear aplicaciones de software. REST: Representational State Transfer, es un estilo de arquitectura para sistemas hipermedia distribuidos. Luminus Framework: Framework de desarrollo web para aplicaciones en Clojure. Compojure: Biblioteca de enrutamiento para aplicaciones web en Clojure. Ring: Biblioteca para la creaci\u00f3n de aplicaciones web en Clojure. HTTP kit: Biblioteca para manejar peticiones y respuestas HTTP en Clojure. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es una API REST y por qu\u00e9 es ampliamente utilizado en el desarrollo de aplicaciones web y m\u00f3viles? \u00bfQu\u00e9 herramientas y bibliotecas se utilizan en Luminus Framework para desarrollar una API REST? \u00bfQu\u00e9 es Compojure y para qu\u00e9 se utiliza? \u00bfCu\u00e1l es la diferencia entre REST y SOAP? \u00bfQu\u00e9 es HTTP kit y cu\u00e1l es su funci\u00f3n en el desarrollo de una API REST? Ejemplos de c\u00f3digo en Luminus Framework \u00b6 A continuaci\u00f3n, se muestra un ejemplo de c\u00f3digo en Luminus Framework para crear una ruta GET que devuelve un listado de usuarios en formato JSON: ( GET \"/users\" [] ( json-response [{ :id 1 :name \"John\" } { :id 2 :name \"Jane\" }])) En este ejemplo, se utiliza la funci\u00f3n GET de Compojure para crear una ruta que responde a las peticiones en la URL \"/users\". La funci\u00f3n json-response de Ring se encarga de convertir la lista de usuarios en un formato JSON. Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una ruta POST en tu API REST que permita agregar un nuevo usuario a una base de datos. Implementa autenticaci\u00f3n de usuarios utilizando HTTP kit en tu API REST. Crea una ruta PUT que actualice la informaci\u00f3n de un usuario existente en la base de datos. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza verbos HTTP adecuados para cada operaci\u00f3n en tu API REST (GET para obtener informaci\u00f3n, POST para crear, PUT para actualizar y DELETE para eliminar). Documenta tu API de manera clara y concisa para que otros desarrolladores puedan utilizarla f\u00e1cilmente. Utiliza un buen sistema de manejo de errores y devuelve mensajes de error adecuados en caso de que ocurra alg\u00fan problema. Implementa autenticaci\u00f3n y autorizaci\u00f3n para proteger tu API de posibles ataques. Utiliza buenas pr\u00e1cticas de codificaci\u00f3n para mantener un c\u00f3digo limpio y f\u00e1cil de mantener. En resumen, el desarrollo de una API REST con Luminus Framework es una forma eficiente y escalable de crear servicios web. Con las herramientas y bibliotecas adecuadas, se puede desarrollar una API robusta y segura que permita a los clientes interactuar con tu aplicaci\u00f3n de manera sencilla. Recuerda siempre seguir las mejores pr\u00e1cticas y documentar tu API para facilitar su uso por parte de otros desarrolladores. \u00a1Ahora es tu turno de practicar y crear tu propia API REST con Luminus!","title":"Desarrollo de API REST con Luminus Framework"},{"location":"luminus/mid/desarrollo_de_api_rest/#desarrollo-de-api-rest-con-luminus-framework","text":"","title":"Desarrollo de API REST con Luminus Framework"},{"location":"luminus/mid/desarrollo_de_api_rest/#modulo-desarrollo-de-api-rest","text":"En este m\u00f3dulo aprender\u00e1s c\u00f3mo desarrollar una API REST utilizando Luminus Framework. Una API REST (representational state transfer) es una arquitectura de dise\u00f1o web para crear servicios web que se basan en el protocolo HTTP. Este tipo de API es ampliamente utilizado en el desarrollo de aplicaciones web y m\u00f3viles, ya que proporciona una forma eficiente y escalable de comunicaci\u00f3n entre diferentes sistemas.","title":"M\u00f3dulo: Desarrollo de API REST"},{"location":"luminus/mid/desarrollo_de_api_rest/#explicacion-teorica","text":"Una API REST se basa en el principio de que cada recurso en la aplicaci\u00f3n web tiene una URL \u00fanica y se puede acceder a \u00e9l a trav\u00e9s de los m\u00e9todos HTTP como GET, POST, PUT y DELETE. Esto permite a los clientes interactuar con la aplicaci\u00f3n web enviando peticiones a trav\u00e9s de estas URL y recibiendo respuestas en formato JSON o XML. Para desarrollar una API REST con Luminus, se utilizan diferentes herramientas y bibliotecas como Compojure, Ring y HTTP kit. Estas herramientas facilitan la creaci\u00f3n de rutas, manejo de peticiones y respuestas, y autenticaci\u00f3n de usuarios.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"luminus/mid/desarrollo_de_api_rest/#palabras-clave-y-su-definicion","text":"API: Interfaz de programaci\u00f3n de aplicaciones, es un conjunto de protocolos, herramientas y definiciones para crear aplicaciones de software. REST: Representational State Transfer, es un estilo de arquitectura para sistemas hipermedia distribuidos. Luminus Framework: Framework de desarrollo web para aplicaciones en Clojure. Compojure: Biblioteca de enrutamiento para aplicaciones web en Clojure. Ring: Biblioteca para la creaci\u00f3n de aplicaciones web en Clojure. HTTP kit: Biblioteca para manejar peticiones y respuestas HTTP en Clojure.","title":"Palabras clave y su definici\u00f3n"},{"location":"luminus/mid/desarrollo_de_api_rest/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es una API REST y por qu\u00e9 es ampliamente utilizado en el desarrollo de aplicaciones web y m\u00f3viles? \u00bfQu\u00e9 herramientas y bibliotecas se utilizan en Luminus Framework para desarrollar una API REST? \u00bfQu\u00e9 es Compojure y para qu\u00e9 se utiliza? \u00bfCu\u00e1l es la diferencia entre REST y SOAP? \u00bfQu\u00e9 es HTTP kit y cu\u00e1l es su funci\u00f3n en el desarrollo de una API REST?","title":"Preguntas de repaso"},{"location":"luminus/mid/desarrollo_de_api_rest/#ejemplos-de-codigo-en-luminus-framework","text":"A continuaci\u00f3n, se muestra un ejemplo de c\u00f3digo en Luminus Framework para crear una ruta GET que devuelve un listado de usuarios en formato JSON: ( GET \"/users\" [] ( json-response [{ :id 1 :name \"John\" } { :id 2 :name \"Jane\" }])) En este ejemplo, se utiliza la funci\u00f3n GET de Compojure para crear una ruta que responde a las peticiones en la URL \"/users\". La funci\u00f3n json-response de Ring se encarga de convertir la lista de usuarios en un formato JSON.","title":"Ejemplos de c\u00f3digo en Luminus Framework"},{"location":"luminus/mid/desarrollo_de_api_rest/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una ruta POST en tu API REST que permita agregar un nuevo usuario a una base de datos. Implementa autenticaci\u00f3n de usuarios utilizando HTTP kit en tu API REST. Crea una ruta PUT que actualice la informaci\u00f3n de un usuario existente en la base de datos.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"luminus/mid/desarrollo_de_api_rest/#consejos-o-mejores-practicas","text":"Utiliza verbos HTTP adecuados para cada operaci\u00f3n en tu API REST (GET para obtener informaci\u00f3n, POST para crear, PUT para actualizar y DELETE para eliminar). Documenta tu API de manera clara y concisa para que otros desarrolladores puedan utilizarla f\u00e1cilmente. Utiliza un buen sistema de manejo de errores y devuelve mensajes de error adecuados en caso de que ocurra alg\u00fan problema. Implementa autenticaci\u00f3n y autorizaci\u00f3n para proteger tu API de posibles ataques. Utiliza buenas pr\u00e1cticas de codificaci\u00f3n para mantener un c\u00f3digo limpio y f\u00e1cil de mantener. En resumen, el desarrollo de una API REST con Luminus Framework es una forma eficiente y escalable de crear servicios web. Con las herramientas y bibliotecas adecuadas, se puede desarrollar una API robusta y segura que permita a los clientes interactuar con tu aplicaci\u00f3n de manera sencilla. Recuerda siempre seguir las mejores pr\u00e1cticas y documentar tu API para facilitar su uso por parte de otros desarrolladores. \u00a1Ahora es tu turno de practicar y crear tu propia API REST con Luminus!","title":"Consejos o mejores pr\u00e1cticas"},{"location":"luminus/mid/desarrollo_de_aplicaciones_en_tiempo_real/","text":"Desarrollo de aplicaciones en tiempo real \u00b6 En el mundo actual, la necesidad de aplicaciones en tiempo real se ha vuelto cada vez m\u00e1s relevante. Desde aplicaciones de mensajer\u00eda hasta aplicaciones de monitoreo en tiempo real, la capacidad de actualizar y mostrar informaci\u00f3n en tiempo real se ha convertido en una caracter\u00edstica esencial para muchas aplicaciones. En este m\u00f3dulo, se explicar\u00e1 c\u00f3mo desarrollar aplicaciones en tiempo real utilizando Luminus Framework y otras herramientas y t\u00e9cnicas. Teor\u00eda \u00b6 Las aplicaciones en tiempo real se refieren a aquellas que actualizan y muestran informaci\u00f3n en tiempo real, sin la necesidad de que el usuario actualice o recargue la p\u00e1gina. Esto se logra a trav\u00e9s de tecnolog\u00edas como WebSockets y Server-Sent Events (SSE). WebSockets permiten una comunicaci\u00f3n bidireccional entre el cliente y el servidor, mientras que SSE permiten una comunicaci\u00f3n unidireccional del servidor al cliente. Al utilizar estas tecnolog\u00edas en conjunto con Luminus Framework, es posible crear aplicaciones en tiempo real altamente eficientes y escalables. Luminus proporciona un conjunto de herramientas y bibliotecas que facilitan la implementaci\u00f3n de estas tecnolog\u00edas y la gesti\u00f3n de conexiones en tiempo real. Palabras clave \u00b6 Aplicaciones en tiempo real: son aquellas que actualizan y muestran informaci\u00f3n en tiempo real, sin la necesidad de que el usuario actualice o recargue la p\u00e1gina. WebSockets: es una tecnolog\u00eda que permite una comunicaci\u00f3n bidireccional entre el cliente y el servidor. Server-Sent Events (SSE): es una tecnolog\u00eda que permite una comunicaci\u00f3n unidireccional del servidor al cliente. Luminus Framework: es un framework para desarrollar aplicaciones web en Clojure. Preguntas de repaso \u00b6 \u00bfQu\u00e9 son las aplicaciones en tiempo real? \u00bfCu\u00e1l es la diferencia entre WebSockets y SSE? \u00bfQu\u00e9 es Luminus Framework? \u00bfQu\u00e9 herramientas proporciona Luminus para desarrollar aplicaciones en tiempo real? Ejemplos de c\u00f3digo en Luminus Framework \u00b6 Implementaci\u00f3n de WebSockets \u00b6 En el archivo project.clj , se deben agregar las dependencias necesarias para utilizar WebSockets en Luminus: :dependencies [[ org.clojure/clojure \"1.10.0\" ] [ ring/ring-core \"1.7.1\" ] [ compojure \"1.6.1\" ] [ clj-websocket \"0.4.1\" ]] En el archivo handler.clj , se puede definir una ruta para la conexi\u00f3n WebSocket y un manejador para manejar los eventos de la conexi\u00f3n: ( ns myapp.handler ( :require [ ring.util.response :refer [ response ]] [ clj-websocket.core :as ws ])) ( defroutes app-routes ( GET \"/\" [] ( response \"Hello World!\" )) ( ws/websocket \"/ws\" [] ws-handler )) ( defn ws-handler [ session ] ( let [ on-message ( fn [ msg ] ( println \"Recibido:\" msg ))] { :on-open ( fn [ ws ] ( println \"Conexi\u00f3n abierta\" )) :on-message on-message :on-close ( fn [ ws ] ( println \"Conexi\u00f3n cerrada\" ))})) Implementaci\u00f3n de SSE \u00b6 En el archivo project.clj , se deben agregar las dependencias necesarias para utilizar SSE en Luminus: :dependencies [[ org.clojure/clojure \"1.10.0\" ] [ ring/ring-core \"1.7.1\" ] [ compojure \"1.6.1\" ] [ ring/ring-sse \"0.2.0\" ]] En el archivo handler.clj , se puede definir una ruta para la conexi\u00f3n SSE y un manejador para enviar eventos al cliente: ( ns myapp.handler ( :require [ ring.util.response :refer [ response ]] [ ring.sse :refer [ event ]] [ clojure.core.async :refer [ chan put! ]]) ( :import [ java.util.concurrent Executors ])) ( defroutes app-routes ( GET \"/\" [] ( response \"Hello World!\" )) ( GET \"/sse\" [] sse-handler )) ( defn sse-handler [ request ] ( let [ sse-channel ( chan )] ( Executors/ newSingleThreadExecutor ) ( .submit ( fn [] ( put! sse-channel ( event \"message\" \"Hola!\" )) ( put! sse-channel ( event \"message\" \"\u00bfC\u00f3mo est\u00e1s?\" )))) { :status 200 :headers { \"Content-Type\" \"text/event-stream\" } :body ( ring.sse/stream sse-channel )})) Ejercicios pr\u00e1cticos \u00b6 Crea una aplicaci\u00f3n en Luminus que utilice WebSockets para mostrar en tiempo real la temperatura de una ciudad. Modifica la aplicaci\u00f3n anterior para que utilice SSE en lugar de WebSockets. Implementa un chat en tiempo real utilizando WebSockets y Luminus. Consejos y mejores pr\u00e1cticas \u00b6 Utiliza WebSockets para aplicaciones que requieren una comunicaci\u00f3n bidireccional entre el cliente y el servidor, como chats o juegos en l\u00ednea. Utiliza SSE para aplicaciones que solo requieren una comunicaci\u00f3n unidireccional del servidor al cliente, como monitoreo en tiempo real. Utiliza bibliotecas y herramientas disponibles en Luminus para simplificar la implementaci\u00f3n de WebSockets y SSE. Aseg\u00farate de optimizar el rendimiento de tu aplicaci\u00f3n en tiempo real, ya que el uso de estas tecnolog\u00edas puede afectar la velocidad de carga de tu aplicaci\u00f3n. Con este m\u00f3dulo, has aprendido c\u00f3mo desarrollar aplicaciones en tiempo real utilizando Luminus Framework y herramientas como WebSockets y SSE. Recuerda siempre optimizar el rendimiento de tu aplicaci\u00f3n y elegir la tecnolog\u00eda adecuada seg\u00fan tus necesidades. \u00a1Sigue practicando y desarrollando tus habilidades en el desarrollo de aplicaciones en tiempo real con Luminus!","title":"Desarrollo de aplicaciones en tiempo real"},{"location":"luminus/mid/desarrollo_de_aplicaciones_en_tiempo_real/#desarrollo-de-aplicaciones-en-tiempo-real","text":"En el mundo actual, la necesidad de aplicaciones en tiempo real se ha vuelto cada vez m\u00e1s relevante. Desde aplicaciones de mensajer\u00eda hasta aplicaciones de monitoreo en tiempo real, la capacidad de actualizar y mostrar informaci\u00f3n en tiempo real se ha convertido en una caracter\u00edstica esencial para muchas aplicaciones. En este m\u00f3dulo, se explicar\u00e1 c\u00f3mo desarrollar aplicaciones en tiempo real utilizando Luminus Framework y otras herramientas y t\u00e9cnicas.","title":"Desarrollo de aplicaciones en tiempo real"},{"location":"luminus/mid/desarrollo_de_aplicaciones_en_tiempo_real/#teoria","text":"Las aplicaciones en tiempo real se refieren a aquellas que actualizan y muestran informaci\u00f3n en tiempo real, sin la necesidad de que el usuario actualice o recargue la p\u00e1gina. Esto se logra a trav\u00e9s de tecnolog\u00edas como WebSockets y Server-Sent Events (SSE). WebSockets permiten una comunicaci\u00f3n bidireccional entre el cliente y el servidor, mientras que SSE permiten una comunicaci\u00f3n unidireccional del servidor al cliente. Al utilizar estas tecnolog\u00edas en conjunto con Luminus Framework, es posible crear aplicaciones en tiempo real altamente eficientes y escalables. Luminus proporciona un conjunto de herramientas y bibliotecas que facilitan la implementaci\u00f3n de estas tecnolog\u00edas y la gesti\u00f3n de conexiones en tiempo real.","title":"Teor\u00eda"},{"location":"luminus/mid/desarrollo_de_aplicaciones_en_tiempo_real/#palabras-clave","text":"Aplicaciones en tiempo real: son aquellas que actualizan y muestran informaci\u00f3n en tiempo real, sin la necesidad de que el usuario actualice o recargue la p\u00e1gina. WebSockets: es una tecnolog\u00eda que permite una comunicaci\u00f3n bidireccional entre el cliente y el servidor. Server-Sent Events (SSE): es una tecnolog\u00eda que permite una comunicaci\u00f3n unidireccional del servidor al cliente. Luminus Framework: es un framework para desarrollar aplicaciones web en Clojure.","title":"Palabras clave"},{"location":"luminus/mid/desarrollo_de_aplicaciones_en_tiempo_real/#preguntas-de-repaso","text":"\u00bfQu\u00e9 son las aplicaciones en tiempo real? \u00bfCu\u00e1l es la diferencia entre WebSockets y SSE? \u00bfQu\u00e9 es Luminus Framework? \u00bfQu\u00e9 herramientas proporciona Luminus para desarrollar aplicaciones en tiempo real?","title":"Preguntas de repaso"},{"location":"luminus/mid/desarrollo_de_aplicaciones_en_tiempo_real/#ejemplos-de-codigo-en-luminus-framework","text":"","title":"Ejemplos de c\u00f3digo en Luminus Framework"},{"location":"luminus/mid/desarrollo_de_aplicaciones_en_tiempo_real/#implementacion-de-websockets","text":"En el archivo project.clj , se deben agregar las dependencias necesarias para utilizar WebSockets en Luminus: :dependencies [[ org.clojure/clojure \"1.10.0\" ] [ ring/ring-core \"1.7.1\" ] [ compojure \"1.6.1\" ] [ clj-websocket \"0.4.1\" ]] En el archivo handler.clj , se puede definir una ruta para la conexi\u00f3n WebSocket y un manejador para manejar los eventos de la conexi\u00f3n: ( ns myapp.handler ( :require [ ring.util.response :refer [ response ]] [ clj-websocket.core :as ws ])) ( defroutes app-routes ( GET \"/\" [] ( response \"Hello World!\" )) ( ws/websocket \"/ws\" [] ws-handler )) ( defn ws-handler [ session ] ( let [ on-message ( fn [ msg ] ( println \"Recibido:\" msg ))] { :on-open ( fn [ ws ] ( println \"Conexi\u00f3n abierta\" )) :on-message on-message :on-close ( fn [ ws ] ( println \"Conexi\u00f3n cerrada\" ))}))","title":"Implementaci\u00f3n de WebSockets"},{"location":"luminus/mid/desarrollo_de_aplicaciones_en_tiempo_real/#implementacion-de-sse","text":"En el archivo project.clj , se deben agregar las dependencias necesarias para utilizar SSE en Luminus: :dependencies [[ org.clojure/clojure \"1.10.0\" ] [ ring/ring-core \"1.7.1\" ] [ compojure \"1.6.1\" ] [ ring/ring-sse \"0.2.0\" ]] En el archivo handler.clj , se puede definir una ruta para la conexi\u00f3n SSE y un manejador para enviar eventos al cliente: ( ns myapp.handler ( :require [ ring.util.response :refer [ response ]] [ ring.sse :refer [ event ]] [ clojure.core.async :refer [ chan put! ]]) ( :import [ java.util.concurrent Executors ])) ( defroutes app-routes ( GET \"/\" [] ( response \"Hello World!\" )) ( GET \"/sse\" [] sse-handler )) ( defn sse-handler [ request ] ( let [ sse-channel ( chan )] ( Executors/ newSingleThreadExecutor ) ( .submit ( fn [] ( put! sse-channel ( event \"message\" \"Hola!\" )) ( put! sse-channel ( event \"message\" \"\u00bfC\u00f3mo est\u00e1s?\" )))) { :status 200 :headers { \"Content-Type\" \"text/event-stream\" } :body ( ring.sse/stream sse-channel )}))","title":"Implementaci\u00f3n de SSE"},{"location":"luminus/mid/desarrollo_de_aplicaciones_en_tiempo_real/#ejercicios-practicos","text":"Crea una aplicaci\u00f3n en Luminus que utilice WebSockets para mostrar en tiempo real la temperatura de una ciudad. Modifica la aplicaci\u00f3n anterior para que utilice SSE en lugar de WebSockets. Implementa un chat en tiempo real utilizando WebSockets y Luminus.","title":"Ejercicios pr\u00e1cticos"},{"location":"luminus/mid/desarrollo_de_aplicaciones_en_tiempo_real/#consejos-y-mejores-practicas","text":"Utiliza WebSockets para aplicaciones que requieren una comunicaci\u00f3n bidireccional entre el cliente y el servidor, como chats o juegos en l\u00ednea. Utiliza SSE para aplicaciones que solo requieren una comunicaci\u00f3n unidireccional del servidor al cliente, como monitoreo en tiempo real. Utiliza bibliotecas y herramientas disponibles en Luminus para simplificar la implementaci\u00f3n de WebSockets y SSE. Aseg\u00farate de optimizar el rendimiento de tu aplicaci\u00f3n en tiempo real, ya que el uso de estas tecnolog\u00edas puede afectar la velocidad de carga de tu aplicaci\u00f3n. Con este m\u00f3dulo, has aprendido c\u00f3mo desarrollar aplicaciones en tiempo real utilizando Luminus Framework y herramientas como WebSockets y SSE. Recuerda siempre optimizar el rendimiento de tu aplicaci\u00f3n y elegir la tecnolog\u00eda adecuada seg\u00fan tus necesidades. \u00a1Sigue practicando y desarrollando tus habilidades en el desarrollo de aplicaciones en tiempo real con Luminus!","title":"Consejos y mejores pr\u00e1cticas"},{"location":"luminus/mid/despliegue_en_la_nube/","text":"Despliegue en la nube \u00b6 En la actualidad, la nube se ha convertido en una opci\u00f3n cada vez m\u00e1s popular para desplegar aplicaciones debido a su flexibilidad, escalabilidad y facilidad de uso. En este m\u00f3dulo, aprenderemos c\u00f3mo desplegar una aplicaci\u00f3n en Luminus en la nube utilizando plataformas como Heroku o AWS. Explicaci\u00f3n te\u00f3rica \u00b6 El despliegue en la nube se refiere al proceso de alojar una aplicaci\u00f3n en servidores remotos en lugar de en servidores locales. Esto permite a los desarrolladores y empresas aprovechar la infraestructura existente en la nube y evitar la necesidad de mantener y actualizar sus propios servidores. Para desplegar una aplicaci\u00f3n en la nube, se deben seguir algunos pasos clave: configurar y gestionar la infraestructura en la nube, preparar la aplicaci\u00f3n para su despliegue y utilizar herramientas de orquestaci\u00f3n y automatizaci\u00f3n. En primer lugar, se debe elegir una plataforma en la nube, como Heroku o AWS, y crear una cuenta. Luego, se debe configurar la infraestructura necesaria, como servidores, bases de datos y almacenamiento, para alojar la aplicaci\u00f3n. Una vez que la infraestructura est\u00e1 lista, se debe preparar la aplicaci\u00f3n para su despliegue en la nube. Esto puede incluir la modificaci\u00f3n de la configuraci\u00f3n de la base de datos y la configuraci\u00f3n de las variables de entorno para que se adapten a la nube. Finalmente, se debe utilizar herramientas de orquestaci\u00f3n y automatizaci\u00f3n, como Docker y Ansible, para desplegar la aplicaci\u00f3n en la nube de manera eficiente y consistente. Palabras clave y su definici\u00f3n \u00b6 Nube: se refiere a servidores remotos que almacenan y procesan datos y aplicaciones en lugar de en servidores locales. Despliegue: proceso de alojar una aplicaci\u00f3n en la nube. Infraestructura en la nube: incluye servidores, bases de datos y almacenamiento en la nube necesarios para alojar una aplicaci\u00f3n. Orquestaci\u00f3n: automatizaci\u00f3n del proceso de despliegue de una aplicaci\u00f3n en la nube. Automatizaci\u00f3n: uso de herramientas para realizar tareas de manera eficiente y consistente. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es el despliegue en la nube? \u00bfPor qu\u00e9 es ventajoso desplegar una aplicaci\u00f3n en la nube? \u00bfCu\u00e1les son los pasos clave para desplegar una aplicaci\u00f3n en la nube? \u00bfQu\u00e9 se debe hacer antes de desplegar una aplicaci\u00f3n en la nube? \u00bfQu\u00e9 herramientas se pueden utilizar para automatizar el proceso de despliegue en la nube? Ejemplos de c\u00f3digo en Luminus Framework \u00b6 Para desplegar una aplicaci\u00f3n en la nube en Luminus, se pueden seguir los siguientes pasos: Crear una cuenta en la plataforma en la nube elegida. Configurar la infraestructura necesaria en la nube. Modificar la configuraci\u00f3n de la base de datos en el archivo project.clj para que se adapte a la nube. Configurar las variables de entorno en el archivo config.edn . Crear un archivo Dockerfile para definir la imagen de Docker de la aplicaci\u00f3n. Utilizar un archivo ansible-playbook para orquestar el despliegue en la nube. Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una cuenta en la plataforma en la nube de tu elecci\u00f3n. Sigue los pasos para configurar la infraestructura necesaria en la nube. Utiliza el comando lein new luminus <nombre-de-tu-aplicaci\u00f3n> para crear una nueva aplicaci\u00f3n en Luminus. Modifica la configuraci\u00f3n de la base de datos en el archivo project.clj para que se adapte a la nube. A\u00f1ade las variables de entorno necesarias en el archivo config.edn . Crea un archivo Dockerfile para definir la imagen de Docker de tu aplicaci\u00f3n. Utiliza un archivo ansible-playbook para orquestar el despliegue en la nube. Despliega tu aplicaci\u00f3n en la nube y verifica que funcione correctamente. Consejos o mejores pr\u00e1cticas \u00b6 Aseg\u00farate de seguir las buenas pr\u00e1cticas de seguridad al configurar la infraestructura en la nube y al desplegar la aplicaci\u00f3n. Utiliza herramientas de orquestaci\u00f3n y automatizaci\u00f3n para facilitar el proceso de despliegue y mantener consistencia en diferentes entornos. Realiza pruebas exhaustivas antes de desplegar la aplicaci\u00f3n en la nube para garantizar su correcto funcionamiento. Utiliza monitoreo y herramientas de escalabilidad para gestionar y ajustar la infraestructura en la nube seg\u00fan sea necesario. Mantente actualizado con las \u00faltimas tendencias y tecnolog\u00edas en la nube para optimizar y mejorar tu proceso de despliegue.","title":"Despliegue en la nube"},{"location":"luminus/mid/despliegue_en_la_nube/#despliegue-en-la-nube","text":"En la actualidad, la nube se ha convertido en una opci\u00f3n cada vez m\u00e1s popular para desplegar aplicaciones debido a su flexibilidad, escalabilidad y facilidad de uso. En este m\u00f3dulo, aprenderemos c\u00f3mo desplegar una aplicaci\u00f3n en Luminus en la nube utilizando plataformas como Heroku o AWS.","title":"Despliegue en la nube"},{"location":"luminus/mid/despliegue_en_la_nube/#explicacion-teorica","text":"El despliegue en la nube se refiere al proceso de alojar una aplicaci\u00f3n en servidores remotos en lugar de en servidores locales. Esto permite a los desarrolladores y empresas aprovechar la infraestructura existente en la nube y evitar la necesidad de mantener y actualizar sus propios servidores. Para desplegar una aplicaci\u00f3n en la nube, se deben seguir algunos pasos clave: configurar y gestionar la infraestructura en la nube, preparar la aplicaci\u00f3n para su despliegue y utilizar herramientas de orquestaci\u00f3n y automatizaci\u00f3n. En primer lugar, se debe elegir una plataforma en la nube, como Heroku o AWS, y crear una cuenta. Luego, se debe configurar la infraestructura necesaria, como servidores, bases de datos y almacenamiento, para alojar la aplicaci\u00f3n. Una vez que la infraestructura est\u00e1 lista, se debe preparar la aplicaci\u00f3n para su despliegue en la nube. Esto puede incluir la modificaci\u00f3n de la configuraci\u00f3n de la base de datos y la configuraci\u00f3n de las variables de entorno para que se adapten a la nube. Finalmente, se debe utilizar herramientas de orquestaci\u00f3n y automatizaci\u00f3n, como Docker y Ansible, para desplegar la aplicaci\u00f3n en la nube de manera eficiente y consistente.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"luminus/mid/despliegue_en_la_nube/#palabras-clave-y-su-definicion","text":"Nube: se refiere a servidores remotos que almacenan y procesan datos y aplicaciones en lugar de en servidores locales. Despliegue: proceso de alojar una aplicaci\u00f3n en la nube. Infraestructura en la nube: incluye servidores, bases de datos y almacenamiento en la nube necesarios para alojar una aplicaci\u00f3n. Orquestaci\u00f3n: automatizaci\u00f3n del proceso de despliegue de una aplicaci\u00f3n en la nube. Automatizaci\u00f3n: uso de herramientas para realizar tareas de manera eficiente y consistente.","title":"Palabras clave y su definici\u00f3n"},{"location":"luminus/mid/despliegue_en_la_nube/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es el despliegue en la nube? \u00bfPor qu\u00e9 es ventajoso desplegar una aplicaci\u00f3n en la nube? \u00bfCu\u00e1les son los pasos clave para desplegar una aplicaci\u00f3n en la nube? \u00bfQu\u00e9 se debe hacer antes de desplegar una aplicaci\u00f3n en la nube? \u00bfQu\u00e9 herramientas se pueden utilizar para automatizar el proceso de despliegue en la nube?","title":"Preguntas de repaso"},{"location":"luminus/mid/despliegue_en_la_nube/#ejemplos-de-codigo-en-luminus-framework","text":"Para desplegar una aplicaci\u00f3n en la nube en Luminus, se pueden seguir los siguientes pasos: Crear una cuenta en la plataforma en la nube elegida. Configurar la infraestructura necesaria en la nube. Modificar la configuraci\u00f3n de la base de datos en el archivo project.clj para que se adapte a la nube. Configurar las variables de entorno en el archivo config.edn . Crear un archivo Dockerfile para definir la imagen de Docker de la aplicaci\u00f3n. Utilizar un archivo ansible-playbook para orquestar el despliegue en la nube.","title":"Ejemplos de c\u00f3digo en Luminus Framework"},{"location":"luminus/mid/despliegue_en_la_nube/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una cuenta en la plataforma en la nube de tu elecci\u00f3n. Sigue los pasos para configurar la infraestructura necesaria en la nube. Utiliza el comando lein new luminus <nombre-de-tu-aplicaci\u00f3n> para crear una nueva aplicaci\u00f3n en Luminus. Modifica la configuraci\u00f3n de la base de datos en el archivo project.clj para que se adapte a la nube. A\u00f1ade las variables de entorno necesarias en el archivo config.edn . Crea un archivo Dockerfile para definir la imagen de Docker de tu aplicaci\u00f3n. Utiliza un archivo ansible-playbook para orquestar el despliegue en la nube. Despliega tu aplicaci\u00f3n en la nube y verifica que funcione correctamente.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"luminus/mid/despliegue_en_la_nube/#consejos-o-mejores-practicas","text":"Aseg\u00farate de seguir las buenas pr\u00e1cticas de seguridad al configurar la infraestructura en la nube y al desplegar la aplicaci\u00f3n. Utiliza herramientas de orquestaci\u00f3n y automatizaci\u00f3n para facilitar el proceso de despliegue y mantener consistencia en diferentes entornos. Realiza pruebas exhaustivas antes de desplegar la aplicaci\u00f3n en la nube para garantizar su correcto funcionamiento. Utiliza monitoreo y herramientas de escalabilidad para gestionar y ajustar la infraestructura en la nube seg\u00fan sea necesario. Mantente actualizado con las \u00faltimas tendencias y tecnolog\u00edas en la nube para optimizar y mejorar tu proceso de despliegue.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"luminus/mid/integraci%C3%B3n_con_otros_servicios/","text":"Integraci\u00f3n con otros servicios \u00b6 En este m\u00f3dulo se ense\u00f1ar\u00e1 c\u00f3mo integrar una aplicaci\u00f3n en Luminus con otros servicios, como bases de datos externas, servicios de almacenamiento en la nube o plataformas de pago. Se ver\u00e1 c\u00f3mo utilizar APIs y c\u00f3mo implementar la comunicaci\u00f3n entre servicios. Explicaci\u00f3n te\u00f3rica \u00b6 Luminus es un framework web escrito en Clojure que proporciona herramientas y estructuras para desarrollar aplicaciones web de manera eficiente y efectiva. Una de las ventajas de utilizar Luminus es su capacidad de integraci\u00f3n con otros servicios, lo que permite ampliar las funcionalidades de una aplicaci\u00f3n y aprovechar recursos externos. La integraci\u00f3n con otros servicios es fundamental en el desarrollo de aplicaciones modernas, ya que permite aprovechar funcionalidades ya existentes y no tener que desarrollarlas desde cero. Adem\u00e1s, se pueden utilizar servicios especializados en \u00e1reas espec\u00edficas, lo que puede mejorar significativamente el rendimiento de una aplicaci\u00f3n. En Luminus, la integraci\u00f3n con otros servicios se realiza principalmente a trav\u00e9s del uso de APIs (Application Programming Interfaces). Una API es un conjunto de protocolos y est\u00e1ndares que permiten la comunicaci\u00f3n entre diferentes aplicaciones. A trav\u00e9s de una API, una aplicaci\u00f3n puede enviar y recibir informaci\u00f3n de un servicio externo. Existen diferentes formas de integrar una aplicaci\u00f3n en Luminus con otros servicios, como por ejemplo: Integraci\u00f3n con bases de datos externas: Luminus permite conectarse a diferentes bases de datos, como MySQL, PostgreSQL, MongoDB, entre otros. Esto permite utilizar una base de datos externa para almacenar y gestionar datos de una aplicaci\u00f3n. Integraci\u00f3n con servicios de almacenamiento en la nube: Con Luminus, es posible utilizar servicios de almacenamiento en la nube, como Amazon S3 o Google Cloud Storage, para subir y descargar archivos en una aplicaci\u00f3n. Integraci\u00f3n con plataformas de pago: Luminus permite integrar diferentes plataformas de pago, como PayPal o Stripe, para procesar pagos en una aplicaci\u00f3n. Esto es especialmente \u00fatil para aplicaciones de comercio electr\u00f3nico. En resumen, la integraci\u00f3n con otros servicios en Luminus es una herramienta poderosa para ampliar las funcionalidades de una aplicaci\u00f3n y mejorar su rendimiento. Palabras clave y su definici\u00f3n \u00b6 Framework: conjunto de herramientas y estructuras que permiten el desarrollo de aplicaciones de manera m\u00e1s r\u00e1pida y eficiente. Integraci\u00f3n: proceso de conectar una aplicaci\u00f3n con otros servicios para ampliar sus funcionalidades. API: conjunto de protocolos y est\u00e1ndares que permiten la comunicaci\u00f3n entre diferentes aplicaciones. Bases de datos externas: bases de datos alojadas en servidores externos a la aplicaci\u00f3n. Servicios de almacenamiento en la nube: servicios que permiten almacenar y gestionar archivos en servidores externos. Plataformas de pago: plataformas que permiten procesar pagos en l\u00ednea. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es una API y cu\u00e1l es su importancia en la integraci\u00f3n de servicios en Luminus? Menciona algunos ejemplos de servicios externos con los que se puede integrar una aplicaci\u00f3n en Luminus. \u00bfPor qu\u00e9 es importante la integraci\u00f3n con otros servicios en el desarrollo de aplicaciones? \u00bfQu\u00e9 es una base de datos externa y c\u00f3mo se puede integrar en una aplicaci\u00f3n en Luminus? \u00bfQu\u00e9 son los servicios de almacenamiento en la nube y c\u00f3mo se pueden utilizar en una aplicaci\u00f3n en Luminus? Ejemplos de c\u00f3digo en Luminus Framework \u00b6 Integraci\u00f3n con bases de datos externas \u00b6 ( ns mi-app.db ( :require [ clojure.java.jdbc :as jdbc ] [ luminus.db.core :as db ])) ;; Conexi\u00f3n a una base de datos MySQL externa ( def db-spec { :classname \"com.mysql.jdbc.Driver\" :subprotocol \"mysql\" :subname \"//localhost:3306/mi_bd\" :user \"usuario\" :password \"contrase\u00f1a\" }) ( db/defdb db-spec :mi-db ) Integraci\u00f3n con servicios de almacenamiento en la nube \u00b6 ( ns mi-app.subir-archivo ( :require [ aws.sdk.s3 :as s3 ] [ luminus.s3 :as s3 ])) ;; Subir un archivo a Amazon S3 ( s3/put-object \"nombre-del-archivo\" \"mi-bucket\" \"ruta-al-archivo\" ) Integraci\u00f3n con plataformas de pago \u00b6 ( ns mi-app.pago ( :require [ luminus.stripe :as stripe ])) ;; Realizar un pago con Stripe ( stripe/charge { :amount 1000 :currency \"usd\" :source \"tok_mastercard\" }) Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Conecta una aplicaci\u00f3n en Luminus con una base de datos PostgreSQL externa. Utiliza un servicio de almacenamiento en la nube para subir y descargar archivos en una aplicaci\u00f3n en Luminus. Implementa un m\u00e9todo de pago utilizando una plataforma de pago en una aplicaci\u00f3n en Luminus. Consejos o mejores pr\u00e1cticas \u00b6 Antes de integrar una aplicaci\u00f3n en Luminus con un servicio externo, es importante leer la documentaci\u00f3n y entender c\u00f3mo funciona la API. Utilizar librer\u00edas y herramientas espec\u00edficas para la integraci\u00f3n con servicios externos puede facilitar el proceso y evitar errores. Realizar pruebas exhaustivas para asegurarse de que la comunicaci\u00f3n entre la aplicaci\u00f3n y el servicio externo funciona correctamente. Mantener actualizadas las versiones de las librer\u00edas y herramientas utilizadas para la integraci\u00f3n para evitar problemas de compatibilidad.","title":"Integraci\u00f3n con otros servicios"},{"location":"luminus/mid/integraci%C3%B3n_con_otros_servicios/#integracion-con-otros-servicios","text":"En este m\u00f3dulo se ense\u00f1ar\u00e1 c\u00f3mo integrar una aplicaci\u00f3n en Luminus con otros servicios, como bases de datos externas, servicios de almacenamiento en la nube o plataformas de pago. Se ver\u00e1 c\u00f3mo utilizar APIs y c\u00f3mo implementar la comunicaci\u00f3n entre servicios.","title":"Integraci\u00f3n con otros servicios"},{"location":"luminus/mid/integraci%C3%B3n_con_otros_servicios/#explicacion-teorica","text":"Luminus es un framework web escrito en Clojure que proporciona herramientas y estructuras para desarrollar aplicaciones web de manera eficiente y efectiva. Una de las ventajas de utilizar Luminus es su capacidad de integraci\u00f3n con otros servicios, lo que permite ampliar las funcionalidades de una aplicaci\u00f3n y aprovechar recursos externos. La integraci\u00f3n con otros servicios es fundamental en el desarrollo de aplicaciones modernas, ya que permite aprovechar funcionalidades ya existentes y no tener que desarrollarlas desde cero. Adem\u00e1s, se pueden utilizar servicios especializados en \u00e1reas espec\u00edficas, lo que puede mejorar significativamente el rendimiento de una aplicaci\u00f3n. En Luminus, la integraci\u00f3n con otros servicios se realiza principalmente a trav\u00e9s del uso de APIs (Application Programming Interfaces). Una API es un conjunto de protocolos y est\u00e1ndares que permiten la comunicaci\u00f3n entre diferentes aplicaciones. A trav\u00e9s de una API, una aplicaci\u00f3n puede enviar y recibir informaci\u00f3n de un servicio externo. Existen diferentes formas de integrar una aplicaci\u00f3n en Luminus con otros servicios, como por ejemplo: Integraci\u00f3n con bases de datos externas: Luminus permite conectarse a diferentes bases de datos, como MySQL, PostgreSQL, MongoDB, entre otros. Esto permite utilizar una base de datos externa para almacenar y gestionar datos de una aplicaci\u00f3n. Integraci\u00f3n con servicios de almacenamiento en la nube: Con Luminus, es posible utilizar servicios de almacenamiento en la nube, como Amazon S3 o Google Cloud Storage, para subir y descargar archivos en una aplicaci\u00f3n. Integraci\u00f3n con plataformas de pago: Luminus permite integrar diferentes plataformas de pago, como PayPal o Stripe, para procesar pagos en una aplicaci\u00f3n. Esto es especialmente \u00fatil para aplicaciones de comercio electr\u00f3nico. En resumen, la integraci\u00f3n con otros servicios en Luminus es una herramienta poderosa para ampliar las funcionalidades de una aplicaci\u00f3n y mejorar su rendimiento.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"luminus/mid/integraci%C3%B3n_con_otros_servicios/#palabras-clave-y-su-definicion","text":"Framework: conjunto de herramientas y estructuras que permiten el desarrollo de aplicaciones de manera m\u00e1s r\u00e1pida y eficiente. Integraci\u00f3n: proceso de conectar una aplicaci\u00f3n con otros servicios para ampliar sus funcionalidades. API: conjunto de protocolos y est\u00e1ndares que permiten la comunicaci\u00f3n entre diferentes aplicaciones. Bases de datos externas: bases de datos alojadas en servidores externos a la aplicaci\u00f3n. Servicios de almacenamiento en la nube: servicios que permiten almacenar y gestionar archivos en servidores externos. Plataformas de pago: plataformas que permiten procesar pagos en l\u00ednea.","title":"Palabras clave y su definici\u00f3n"},{"location":"luminus/mid/integraci%C3%B3n_con_otros_servicios/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es una API y cu\u00e1l es su importancia en la integraci\u00f3n de servicios en Luminus? Menciona algunos ejemplos de servicios externos con los que se puede integrar una aplicaci\u00f3n en Luminus. \u00bfPor qu\u00e9 es importante la integraci\u00f3n con otros servicios en el desarrollo de aplicaciones? \u00bfQu\u00e9 es una base de datos externa y c\u00f3mo se puede integrar en una aplicaci\u00f3n en Luminus? \u00bfQu\u00e9 son los servicios de almacenamiento en la nube y c\u00f3mo se pueden utilizar en una aplicaci\u00f3n en Luminus?","title":"Preguntas de repaso"},{"location":"luminus/mid/integraci%C3%B3n_con_otros_servicios/#ejemplos-de-codigo-en-luminus-framework","text":"","title":"Ejemplos de c\u00f3digo en Luminus Framework"},{"location":"luminus/mid/integraci%C3%B3n_con_otros_servicios/#integracion-con-bases-de-datos-externas","text":"( ns mi-app.db ( :require [ clojure.java.jdbc :as jdbc ] [ luminus.db.core :as db ])) ;; Conexi\u00f3n a una base de datos MySQL externa ( def db-spec { :classname \"com.mysql.jdbc.Driver\" :subprotocol \"mysql\" :subname \"//localhost:3306/mi_bd\" :user \"usuario\" :password \"contrase\u00f1a\" }) ( db/defdb db-spec :mi-db )","title":"Integraci\u00f3n con bases de datos externas"},{"location":"luminus/mid/integraci%C3%B3n_con_otros_servicios/#integracion-con-servicios-de-almacenamiento-en-la-nube","text":"( ns mi-app.subir-archivo ( :require [ aws.sdk.s3 :as s3 ] [ luminus.s3 :as s3 ])) ;; Subir un archivo a Amazon S3 ( s3/put-object \"nombre-del-archivo\" \"mi-bucket\" \"ruta-al-archivo\" )","title":"Integraci\u00f3n con servicios de almacenamiento en la nube"},{"location":"luminus/mid/integraci%C3%B3n_con_otros_servicios/#integracion-con-plataformas-de-pago","text":"( ns mi-app.pago ( :require [ luminus.stripe :as stripe ])) ;; Realizar un pago con Stripe ( stripe/charge { :amount 1000 :currency \"usd\" :source \"tok_mastercard\" })","title":"Integraci\u00f3n con plataformas de pago"},{"location":"luminus/mid/integraci%C3%B3n_con_otros_servicios/#ejercicios-practicos-con-instrucciones-claras","text":"Conecta una aplicaci\u00f3n en Luminus con una base de datos PostgreSQL externa. Utiliza un servicio de almacenamiento en la nube para subir y descargar archivos en una aplicaci\u00f3n en Luminus. Implementa un m\u00e9todo de pago utilizando una plataforma de pago en una aplicaci\u00f3n en Luminus.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"luminus/mid/integraci%C3%B3n_con_otros_servicios/#consejos-o-mejores-practicas","text":"Antes de integrar una aplicaci\u00f3n en Luminus con un servicio externo, es importante leer la documentaci\u00f3n y entender c\u00f3mo funciona la API. Utilizar librer\u00edas y herramientas espec\u00edficas para la integraci\u00f3n con servicios externos puede facilitar el proceso y evitar errores. Realizar pruebas exhaustivas para asegurarse de que la comunicaci\u00f3n entre la aplicaci\u00f3n y el servicio externo funciona correctamente. Mantener actualizadas las versiones de las librer\u00edas y herramientas utilizadas para la integraci\u00f3n para evitar problemas de compatibilidad.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"luminus/mid/introducci%C3%B3n_a_luminus_framework/","text":"Introducci\u00f3n a Luminus Framework \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En este m\u00f3dulo se repasar\u00e1n los conceptos b\u00e1sicos de Luminus Framework y se profundizar\u00e1 en su arquitectura. Se ver\u00e1 c\u00f3mo utilizar sus caracter\u00edsticas avanzadas y c\u00f3mo optimizar el rendimiento de las aplicaciones. Explicaci\u00f3n te\u00f3rica \u00b6 Luminus Framework es un framework web de c\u00f3digo abierto dise\u00f1ado para crear aplicaciones web modernas en el lenguaje de programaci\u00f3n Clojure. Fue creado con el objetivo de ser un framework minimalista y f\u00e1cil de aprender, manteniendo al mismo tiempo un alto rendimiento. Una de las caracter\u00edsticas m\u00e1s destacadas de Luminus es su arquitectura modular, que permite a los desarrolladores elegir los componentes que desean utilizar en su aplicaci\u00f3n. Esto hace que sea muy flexible y adaptable a diferentes tipos de proyectos. Luminus tambi\u00e9n se basa en el principio de \"convenci\u00f3n sobre configuraci\u00f3n\", lo que significa que proporciona una estructura predeterminada para la aplicaci\u00f3n, evitando as\u00ed la necesidad de configurar y organizar todo desde cero. Esto permite a los desarrolladores centrarse en la l\u00f3gica de la aplicaci\u00f3n en lugar de en la configuraci\u00f3n t\u00e9cnica. Palabras clave y su definici\u00f3n \u00b6 Luminus Framework: Framework web de c\u00f3digo abierto para el lenguaje Clojure. Arquitectura modular: Enfoque en el que una aplicaci\u00f3n se construye a partir de m\u00f3dulos independientes y reutilizables. Convenci\u00f3n sobre configuraci\u00f3n: Principio en el que se proporciona una estructura predeterminada para la aplicaci\u00f3n, evitando la necesidad de configurar todo desde cero. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es Luminus Framework? \u00bfQu\u00e9 ventajas ofrece su arquitectura modular? \u00bfEn qu\u00e9 se basa el principio de \"convenci\u00f3n sobre configuraci\u00f3n\" en Luminus? Ejemplos de c\u00f3digo en Luminus Framework \u00b6 A continuaci\u00f3n se muestra un ejemplo de c\u00f3digo en Luminus Framework para crear una ruta y una funci\u00f3n de controlador: ( defn index-page [ request ] { :status 200 :headers { \"Content-Type\" \"text/html\" } :body ( slurp \"index.html\" )}) ( defroutes app-routes ( GET \"/\" [] index-page )) ( def app ( -> ( handler/site app-routes ) ( wrap-defaults site-defaults ))) En este ejemplo, se define una funci\u00f3n index-page que devuelve una respuesta HTTP con el contenido de un archivo HTML. Luego se definen las rutas en app-routes y se envuelve en una configuraci\u00f3n predeterminada site-defaults . Finalmente, se crea la aplicaci\u00f3n app con la funci\u00f3n handler/site . Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una nueva aplicaci\u00f3n en Luminus Framework utilizando la herramienta lein . Agrega una nueva ruta para la p\u00e1gina \"about\" y crea una funci\u00f3n de controlador que devuelva un mensaje de bienvenida. Implementa una base de datos utilizando el componente jdbc y crea una funci\u00f3n de controlador para mostrar los datos de la base de datos en una p\u00e1gina. Agrega un middleware wrap-params para manejar los par\u00e1metros en las solicitudes. Optimiza el rendimiento de tu aplicaci\u00f3n utilizando el componente http-kit . Consejos o mejores pr\u00e1cticas \u00b6 Familiar\u00edzate con la documentaci\u00f3n oficial de Luminus Framework para aprovechar al m\u00e1ximo sus caracter\u00edsticas y opciones de configuraci\u00f3n. Utiliza la arquitectura modular de Luminus para mantener tu c\u00f3digo organizado y f\u00e1cil de mantener. Sigue las convenciones y buenas pr\u00e1cticas de Clojure para escribir un c\u00f3digo limpio y eficiente. Aprovecha los componentes y middleware de Luminus para agregar funcionalidades a tu aplicaci\u00f3n sin tener que escribir mucho c\u00f3digo adicional. Realiza pruebas unitarias y de integraci\u00f3n para asegurarte de que tu aplicaci\u00f3n funcione correctamente y sin errores.","title":"Introducci\u00f3n a Luminus Framework"},{"location":"luminus/mid/introducci%C3%B3n_a_luminus_framework/#introduccion-a-luminus-framework","text":"","title":"Introducci\u00f3n a Luminus Framework"},{"location":"luminus/mid/introducci%C3%B3n_a_luminus_framework/#descripcion-del-modulo","text":"En este m\u00f3dulo se repasar\u00e1n los conceptos b\u00e1sicos de Luminus Framework y se profundizar\u00e1 en su arquitectura. Se ver\u00e1 c\u00f3mo utilizar sus caracter\u00edsticas avanzadas y c\u00f3mo optimizar el rendimiento de las aplicaciones.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"luminus/mid/introducci%C3%B3n_a_luminus_framework/#explicacion-teorica","text":"Luminus Framework es un framework web de c\u00f3digo abierto dise\u00f1ado para crear aplicaciones web modernas en el lenguaje de programaci\u00f3n Clojure. Fue creado con el objetivo de ser un framework minimalista y f\u00e1cil de aprender, manteniendo al mismo tiempo un alto rendimiento. Una de las caracter\u00edsticas m\u00e1s destacadas de Luminus es su arquitectura modular, que permite a los desarrolladores elegir los componentes que desean utilizar en su aplicaci\u00f3n. Esto hace que sea muy flexible y adaptable a diferentes tipos de proyectos. Luminus tambi\u00e9n se basa en el principio de \"convenci\u00f3n sobre configuraci\u00f3n\", lo que significa que proporciona una estructura predeterminada para la aplicaci\u00f3n, evitando as\u00ed la necesidad de configurar y organizar todo desde cero. Esto permite a los desarrolladores centrarse en la l\u00f3gica de la aplicaci\u00f3n en lugar de en la configuraci\u00f3n t\u00e9cnica.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"luminus/mid/introducci%C3%B3n_a_luminus_framework/#palabras-clave-y-su-definicion","text":"Luminus Framework: Framework web de c\u00f3digo abierto para el lenguaje Clojure. Arquitectura modular: Enfoque en el que una aplicaci\u00f3n se construye a partir de m\u00f3dulos independientes y reutilizables. Convenci\u00f3n sobre configuraci\u00f3n: Principio en el que se proporciona una estructura predeterminada para la aplicaci\u00f3n, evitando la necesidad de configurar todo desde cero.","title":"Palabras clave y su definici\u00f3n"},{"location":"luminus/mid/introducci%C3%B3n_a_luminus_framework/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Luminus Framework? \u00bfQu\u00e9 ventajas ofrece su arquitectura modular? \u00bfEn qu\u00e9 se basa el principio de \"convenci\u00f3n sobre configuraci\u00f3n\" en Luminus?","title":"Preguntas de repaso"},{"location":"luminus/mid/introducci%C3%B3n_a_luminus_framework/#ejemplos-de-codigo-en-luminus-framework","text":"A continuaci\u00f3n se muestra un ejemplo de c\u00f3digo en Luminus Framework para crear una ruta y una funci\u00f3n de controlador: ( defn index-page [ request ] { :status 200 :headers { \"Content-Type\" \"text/html\" } :body ( slurp \"index.html\" )}) ( defroutes app-routes ( GET \"/\" [] index-page )) ( def app ( -> ( handler/site app-routes ) ( wrap-defaults site-defaults ))) En este ejemplo, se define una funci\u00f3n index-page que devuelve una respuesta HTTP con el contenido de un archivo HTML. Luego se definen las rutas en app-routes y se envuelve en una configuraci\u00f3n predeterminada site-defaults . Finalmente, se crea la aplicaci\u00f3n app con la funci\u00f3n handler/site .","title":"Ejemplos de c\u00f3digo en Luminus Framework"},{"location":"luminus/mid/introducci%C3%B3n_a_luminus_framework/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una nueva aplicaci\u00f3n en Luminus Framework utilizando la herramienta lein . Agrega una nueva ruta para la p\u00e1gina \"about\" y crea una funci\u00f3n de controlador que devuelva un mensaje de bienvenida. Implementa una base de datos utilizando el componente jdbc y crea una funci\u00f3n de controlador para mostrar los datos de la base de datos en una p\u00e1gina. Agrega un middleware wrap-params para manejar los par\u00e1metros en las solicitudes. Optimiza el rendimiento de tu aplicaci\u00f3n utilizando el componente http-kit .","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"luminus/mid/introducci%C3%B3n_a_luminus_framework/#consejos-o-mejores-practicas","text":"Familiar\u00edzate con la documentaci\u00f3n oficial de Luminus Framework para aprovechar al m\u00e1ximo sus caracter\u00edsticas y opciones de configuraci\u00f3n. Utiliza la arquitectura modular de Luminus para mantener tu c\u00f3digo organizado y f\u00e1cil de mantener. Sigue las convenciones y buenas pr\u00e1cticas de Clojure para escribir un c\u00f3digo limpio y eficiente. Aprovecha los componentes y middleware de Luminus para agregar funcionalidades a tu aplicaci\u00f3n sin tener que escribir mucho c\u00f3digo adicional. Realiza pruebas unitarias y de integraci\u00f3n para asegurarte de que tu aplicaci\u00f3n funcione correctamente y sin errores.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"luminus/mid/optimizaci%C3%B3n_y_escalabilidad/","text":"Optimizaci\u00f3n y escalabilidad en Luminus Framework \u00b6 Descripci\u00f3n del m\u00f3dulo: \u00b6 En este m\u00f3dulo aprenderemos c\u00f3mo optimizar y escalar una aplicaci\u00f3n en Luminus Framework para poder manejar un mayor n\u00famero de usuarios. Veremos c\u00f3mo utilizar herramientas de cacheo, distribuci\u00f3n de carga y sistemas de almacenamiento en memoria, para mejorar el rendimiento y la escalabilidad de nuestra aplicaci\u00f3n. 1. Explicaci\u00f3n te\u00f3rica: \u00b6 Cuando una aplicaci\u00f3n tiene un alto n\u00famero de usuarios, es necesario optimizarla y escalarla para que pueda seguir funcionando eficientemente y manejar la carga. Esto implica encontrar formas de mejorar el rendimiento, reducir el tiempo de respuesta y aumentar la capacidad de la aplicaci\u00f3n para manejar un mayor n\u00famero de peticiones. Una forma de lograr esto en Luminus Framework es utilizando herramientas de cacheo. El cacheo consiste en almacenar temporalmente datos o resultados de operaciones en memoria, para que puedan ser accedidos m\u00e1s r\u00e1pidamente en futuras solicitudes. De esta manera, se evita tener que procesar la misma informaci\u00f3n repetidamente, lo que puede mejorar significativamente el rendimiento de la aplicaci\u00f3n. Otra forma de optimizar y escalar una aplicaci\u00f3n en Luminus es distribuyendo la carga de trabajo. Esto implica utilizar t\u00e9cnicas de balanceo de carga para distribuir las peticiones entre varios servidores, en lugar de depender de un solo servidor para manejar todas las solicitudes. De esta manera, se puede evitar sobrecargar un solo servidor y mejorar la capacidad de la aplicaci\u00f3n para manejar un mayor n\u00famero de usuarios. Por \u00faltimo, trabajar con sistemas de almacenamiento en memoria tambi\u00e9n puede ser beneficioso para optimizar y escalar una aplicaci\u00f3n en Luminus. Estos sistemas permiten almacenar datos en memoria RAM en lugar de en una base de datos, lo que puede mejorar significativamente el rendimiento y la velocidad de acceso a los datos. 2. Palabras clave y su definici\u00f3n: \u00b6 Optimizaci\u00f3n: proceso de mejorar el rendimiento y la eficiencia de una aplicaci\u00f3n. Escalabilidad: capacidad de una aplicaci\u00f3n para manejar un mayor n\u00famero de usuarios. Cacheo: t\u00e9cnica de almacenamiento temporal de datos para mejorar el rendimiento. Distribuci\u00f3n de carga: t\u00e9cnica de balanceo de carga para distribuir las peticiones entre varios servidores. Almacenamiento en memoria: sistema de almacenamiento de datos en memoria RAM en lugar de en una base de datos. 3. Preguntas de repaso: \u00b6 \u00bfPor qu\u00e9 es importante optimizar y escalar una aplicaci\u00f3n en Luminus Framework? \u00bfQu\u00e9 es el cacheo y c\u00f3mo puede ayudar a mejorar el rendimiento de una aplicaci\u00f3n? \u00bfEn qu\u00e9 consiste la distribuci\u00f3n de carga y c\u00f3mo puede mejorar la escalabilidad de una aplicaci\u00f3n? \u00bfCu\u00e1les son los beneficios de utilizar sistemas de almacenamiento en memoria en lugar de en una base de datos? 4. Ejemplos de c\u00f3digo en Luminus Framework: \u00b6 Cacheo con Caching Middleware: \u00b6 ( def app ( middleware / wrap - cache {: ttl 3600 } ( routes ( GET \"/users\" [] ( do - something )) ( GET \"/products\" [] ( do - something - else ))))) Distribuci\u00f3n de carga con HAProxy: \u00b6 frontend main bind *:80 default_backend app_servers backend app_servers balance roundrobin server app1 192.168.0.1:3000 check server app2 192.168.0.2:3000 check server app3 192.168.0.3:3000 check Almacenamiento en memoria con Redis: \u00b6 ( defn add-user [ user ] ( let [ redis ( redis/client { :pool-size 10 })] ( redis/hmset \"users\" ( :id user ) ( pr-str user )))) 5. Ejercicios pr\u00e1cticos con instrucciones claras: \u00b6 Utiliza el middleware de cacheo en una ruta de tu aplicaci\u00f3n en Luminus y compara el tiempo de respuesta con y sin cacheo. Configura un balanceador de carga con HAProxy para distribuir las peticiones entre 3 servidores de tu aplicaci\u00f3n en Luminus. Implementa un sistema de almacenamiento en memoria con Redis para almacenar los datos de usuarios en tu aplicaci\u00f3n en Luminus. 6. Consejos o mejores pr\u00e1cticas: \u00b6 Realizar pruebas de rendimiento y monitorear el rendimiento de la aplicaci\u00f3n constantemente para identificar \u00e1reas de mejora. Utilizar herramientas de cacheo de forma estrat\u00e9gica, ya que un cacheo excesivo puede ocupar demasiada memoria. Distribuir la carga de trabajo de manera equitativa entre los servidores para evitar sobrecargar uno en particular. Utilizar sistemas de almacenamiento en memoria para datos que necesitan ser accedidos con frecuencia y de forma r\u00e1pida.","title":"Optimizaci\u00f3n y escalabilidad en Luminus Framework"},{"location":"luminus/mid/optimizaci%C3%B3n_y_escalabilidad/#optimizacion-y-escalabilidad-en-luminus-framework","text":"","title":"Optimizaci\u00f3n y escalabilidad en Luminus Framework"},{"location":"luminus/mid/optimizaci%C3%B3n_y_escalabilidad/#descripcion-del-modulo","text":"En este m\u00f3dulo aprenderemos c\u00f3mo optimizar y escalar una aplicaci\u00f3n en Luminus Framework para poder manejar un mayor n\u00famero de usuarios. Veremos c\u00f3mo utilizar herramientas de cacheo, distribuci\u00f3n de carga y sistemas de almacenamiento en memoria, para mejorar el rendimiento y la escalabilidad de nuestra aplicaci\u00f3n.","title":"Descripci\u00f3n del m\u00f3dulo:"},{"location":"luminus/mid/optimizaci%C3%B3n_y_escalabilidad/#1-explicacion-teorica","text":"Cuando una aplicaci\u00f3n tiene un alto n\u00famero de usuarios, es necesario optimizarla y escalarla para que pueda seguir funcionando eficientemente y manejar la carga. Esto implica encontrar formas de mejorar el rendimiento, reducir el tiempo de respuesta y aumentar la capacidad de la aplicaci\u00f3n para manejar un mayor n\u00famero de peticiones. Una forma de lograr esto en Luminus Framework es utilizando herramientas de cacheo. El cacheo consiste en almacenar temporalmente datos o resultados de operaciones en memoria, para que puedan ser accedidos m\u00e1s r\u00e1pidamente en futuras solicitudes. De esta manera, se evita tener que procesar la misma informaci\u00f3n repetidamente, lo que puede mejorar significativamente el rendimiento de la aplicaci\u00f3n. Otra forma de optimizar y escalar una aplicaci\u00f3n en Luminus es distribuyendo la carga de trabajo. Esto implica utilizar t\u00e9cnicas de balanceo de carga para distribuir las peticiones entre varios servidores, en lugar de depender de un solo servidor para manejar todas las solicitudes. De esta manera, se puede evitar sobrecargar un solo servidor y mejorar la capacidad de la aplicaci\u00f3n para manejar un mayor n\u00famero de usuarios. Por \u00faltimo, trabajar con sistemas de almacenamiento en memoria tambi\u00e9n puede ser beneficioso para optimizar y escalar una aplicaci\u00f3n en Luminus. Estos sistemas permiten almacenar datos en memoria RAM en lugar de en una base de datos, lo que puede mejorar significativamente el rendimiento y la velocidad de acceso a los datos.","title":"1. Explicaci\u00f3n te\u00f3rica:"},{"location":"luminus/mid/optimizaci%C3%B3n_y_escalabilidad/#2-palabras-clave-y-su-definicion","text":"Optimizaci\u00f3n: proceso de mejorar el rendimiento y la eficiencia de una aplicaci\u00f3n. Escalabilidad: capacidad de una aplicaci\u00f3n para manejar un mayor n\u00famero de usuarios. Cacheo: t\u00e9cnica de almacenamiento temporal de datos para mejorar el rendimiento. Distribuci\u00f3n de carga: t\u00e9cnica de balanceo de carga para distribuir las peticiones entre varios servidores. Almacenamiento en memoria: sistema de almacenamiento de datos en memoria RAM en lugar de en una base de datos.","title":"2. Palabras clave y su definici\u00f3n:"},{"location":"luminus/mid/optimizaci%C3%B3n_y_escalabilidad/#3-preguntas-de-repaso","text":"\u00bfPor qu\u00e9 es importante optimizar y escalar una aplicaci\u00f3n en Luminus Framework? \u00bfQu\u00e9 es el cacheo y c\u00f3mo puede ayudar a mejorar el rendimiento de una aplicaci\u00f3n? \u00bfEn qu\u00e9 consiste la distribuci\u00f3n de carga y c\u00f3mo puede mejorar la escalabilidad de una aplicaci\u00f3n? \u00bfCu\u00e1les son los beneficios de utilizar sistemas de almacenamiento en memoria en lugar de en una base de datos?","title":"3. Preguntas de repaso:"},{"location":"luminus/mid/optimizaci%C3%B3n_y_escalabilidad/#4-ejemplos-de-codigo-en-luminus-framework","text":"","title":"4. Ejemplos de c\u00f3digo en Luminus Framework:"},{"location":"luminus/mid/optimizaci%C3%B3n_y_escalabilidad/#cacheo-con-caching-middleware","text":"( def app ( middleware / wrap - cache {: ttl 3600 } ( routes ( GET \"/users\" [] ( do - something )) ( GET \"/products\" [] ( do - something - else )))))","title":"Cacheo con Caching Middleware:"},{"location":"luminus/mid/optimizaci%C3%B3n_y_escalabilidad/#distribucion-de-carga-con-haproxy","text":"frontend main bind *:80 default_backend app_servers backend app_servers balance roundrobin server app1 192.168.0.1:3000 check server app2 192.168.0.2:3000 check server app3 192.168.0.3:3000 check","title":"Distribuci\u00f3n de carga con HAProxy:"},{"location":"luminus/mid/optimizaci%C3%B3n_y_escalabilidad/#almacenamiento-en-memoria-con-redis","text":"( defn add-user [ user ] ( let [ redis ( redis/client { :pool-size 10 })] ( redis/hmset \"users\" ( :id user ) ( pr-str user ))))","title":"Almacenamiento en memoria con Redis:"},{"location":"luminus/mid/optimizaci%C3%B3n_y_escalabilidad/#5-ejercicios-practicos-con-instrucciones-claras","text":"Utiliza el middleware de cacheo en una ruta de tu aplicaci\u00f3n en Luminus y compara el tiempo de respuesta con y sin cacheo. Configura un balanceador de carga con HAProxy para distribuir las peticiones entre 3 servidores de tu aplicaci\u00f3n en Luminus. Implementa un sistema de almacenamiento en memoria con Redis para almacenar los datos de usuarios en tu aplicaci\u00f3n en Luminus.","title":"5. Ejercicios pr\u00e1cticos con instrucciones claras:"},{"location":"luminus/mid/optimizaci%C3%B3n_y_escalabilidad/#6-consejos-o-mejores-practicas","text":"Realizar pruebas de rendimiento y monitorear el rendimiento de la aplicaci\u00f3n constantemente para identificar \u00e1reas de mejora. Utilizar herramientas de cacheo de forma estrat\u00e9gica, ya que un cacheo excesivo puede ocupar demasiada memoria. Distribuir la carga de trabajo de manera equitativa entre los servidores para evitar sobrecargar uno en particular. Utilizar sistemas de almacenamiento en memoria para datos que necesitan ser accedidos con frecuencia y de forma r\u00e1pida.","title":"6. Consejos o mejores pr\u00e1cticas:"},{"location":"luminus/mid/proyecto_final/","text":"Proyecto final \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En este m\u00f3dulo se realizar\u00e1 un proyecto final en el que se aplicar\u00e1n todos los conocimientos adquiridos durante el curso de Luminus Framework. El objetivo principal es que los estudiantes puedan poner en pr\u00e1ctica lo aprendido y desarrollar una aplicaci\u00f3n m\u00e1s compleja utilizando este framework. Al final del curso, se presentar\u00e1 el proyecto final y se evaluar\u00e1 la comprensi\u00f3n y aplicaci\u00f3n de los conceptos. Explicaci\u00f3n te\u00f3rica \u00b6 El proyecto final es una forma de consolidar los conocimientos adquiridos a lo largo del curso de Luminus Framework. En este m\u00f3dulo, los estudiantes tendr\u00e1n la oportunidad de desarrollar una aplicaci\u00f3n completa, utilizando todas las funcionalidades del framework y aplicando buenas pr\u00e1cticas de programaci\u00f3n. Adem\u00e1s, tambi\u00e9n podr\u00e1n demostrar su creatividad e innovaci\u00f3n en el dise\u00f1o y funcionalidad de la aplicaci\u00f3n. Palabras clave y su definici\u00f3n \u00b6 Luminus Framework: Framework de desarrollo web basado en Clojure y que utiliza herramientas como Ring, Compojure y ClojureScript para crear aplicaciones web. Aplicaci\u00f3n web: Es un programa inform\u00e1tico que se ejecuta en un servidor web y que permite al usuario interactuar a trav\u00e9s de un navegador web. Ring: Biblioteca de Clojure que proporciona una interfaz unificada para las aplicaciones web. Compojure: Biblioteca de Clojure que proporciona un enrutador para las aplicaciones web. ClojureScript: Dialecto de Clojure que compila a JavaScript y permite desarrollar aplicaciones para el lado del cliente. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es el proyecto final en el curso de Luminus Framework? \u00bfCu\u00e1l es el objetivo del proyecto final? \u00bfQu\u00e9 herramientas utiliza Luminus Framework? \u00bfQu\u00e9 es una aplicaci\u00f3n web? \u00bfCu\u00e1les son las bibliotecas de Clojure utilizadas en Luminus Framework? Ejemplos de c\u00f3digo en Luminus Framework \u00b6 ( defn home-page [] ( html5 [ :head [ :title \"Mi aplicaci\u00f3n Luminus\" ]] [ :body [ :h1 \"Bienvenido a mi aplicaci\u00f3n\" ] [ :p \"Esta es una aplicaci\u00f3n creada con Luminus Framework.\" ]])) Ejercicios pr\u00e1cticos \u00b6 Desarrollar una aplicaci\u00f3n web utilizando Luminus Framework. Implementar un enrutador utilizando Compojure. Crear una p\u00e1gina de inicio utilizando la funci\u00f3n home-page del ejemplo de c\u00f3digo. Agregar una funcionalidad de autenticaci\u00f3n utilizando Ring. Desplegar la aplicaci\u00f3n en un servidor web. Consejos o mejores pr\u00e1cticas \u00b6 Planificar bien el proyecto antes de comenzar a escribir c\u00f3digo. Utilizar buenas pr\u00e1cticas de programaci\u00f3n y seguir las convenciones de Luminus Framework. Revisar y probar el c\u00f3digo regularmente para evitar errores. Documentar el c\u00f3digo para facilitar su comprensi\u00f3n y mantenimiento. Utilizar herramientas como Leiningen para gestionar las dependencias y el despliegue de la aplicaci\u00f3n.","title":"Proyecto final"},{"location":"luminus/mid/proyecto_final/#proyecto-final","text":"","title":"Proyecto final"},{"location":"luminus/mid/proyecto_final/#descripcion-del-modulo","text":"En este m\u00f3dulo se realizar\u00e1 un proyecto final en el que se aplicar\u00e1n todos los conocimientos adquiridos durante el curso de Luminus Framework. El objetivo principal es que los estudiantes puedan poner en pr\u00e1ctica lo aprendido y desarrollar una aplicaci\u00f3n m\u00e1s compleja utilizando este framework. Al final del curso, se presentar\u00e1 el proyecto final y se evaluar\u00e1 la comprensi\u00f3n y aplicaci\u00f3n de los conceptos.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"luminus/mid/proyecto_final/#explicacion-teorica","text":"El proyecto final es una forma de consolidar los conocimientos adquiridos a lo largo del curso de Luminus Framework. En este m\u00f3dulo, los estudiantes tendr\u00e1n la oportunidad de desarrollar una aplicaci\u00f3n completa, utilizando todas las funcionalidades del framework y aplicando buenas pr\u00e1cticas de programaci\u00f3n. Adem\u00e1s, tambi\u00e9n podr\u00e1n demostrar su creatividad e innovaci\u00f3n en el dise\u00f1o y funcionalidad de la aplicaci\u00f3n.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"luminus/mid/proyecto_final/#palabras-clave-y-su-definicion","text":"Luminus Framework: Framework de desarrollo web basado en Clojure y que utiliza herramientas como Ring, Compojure y ClojureScript para crear aplicaciones web. Aplicaci\u00f3n web: Es un programa inform\u00e1tico que se ejecuta en un servidor web y que permite al usuario interactuar a trav\u00e9s de un navegador web. Ring: Biblioteca de Clojure que proporciona una interfaz unificada para las aplicaciones web. Compojure: Biblioteca de Clojure que proporciona un enrutador para las aplicaciones web. ClojureScript: Dialecto de Clojure que compila a JavaScript y permite desarrollar aplicaciones para el lado del cliente.","title":"Palabras clave y su definici\u00f3n"},{"location":"luminus/mid/proyecto_final/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es el proyecto final en el curso de Luminus Framework? \u00bfCu\u00e1l es el objetivo del proyecto final? \u00bfQu\u00e9 herramientas utiliza Luminus Framework? \u00bfQu\u00e9 es una aplicaci\u00f3n web? \u00bfCu\u00e1les son las bibliotecas de Clojure utilizadas en Luminus Framework?","title":"Preguntas de repaso"},{"location":"luminus/mid/proyecto_final/#ejemplos-de-codigo-en-luminus-framework","text":"( defn home-page [] ( html5 [ :head [ :title \"Mi aplicaci\u00f3n Luminus\" ]] [ :body [ :h1 \"Bienvenido a mi aplicaci\u00f3n\" ] [ :p \"Esta es una aplicaci\u00f3n creada con Luminus Framework.\" ]]))","title":"Ejemplos de c\u00f3digo en Luminus Framework"},{"location":"luminus/mid/proyecto_final/#ejercicios-practicos","text":"Desarrollar una aplicaci\u00f3n web utilizando Luminus Framework. Implementar un enrutador utilizando Compojure. Crear una p\u00e1gina de inicio utilizando la funci\u00f3n home-page del ejemplo de c\u00f3digo. Agregar una funcionalidad de autenticaci\u00f3n utilizando Ring. Desplegar la aplicaci\u00f3n en un servidor web.","title":"Ejercicios pr\u00e1cticos"},{"location":"luminus/mid/proyecto_final/#consejos-o-mejores-practicas","text":"Planificar bien el proyecto antes de comenzar a escribir c\u00f3digo. Utilizar buenas pr\u00e1cticas de programaci\u00f3n y seguir las convenciones de Luminus Framework. Revisar y probar el c\u00f3digo regularmente para evitar errores. Documentar el c\u00f3digo para facilitar su comprensi\u00f3n y mantenimiento. Utilizar herramientas como Leiningen para gestionar las dependencias y el despliegue de la aplicaci\u00f3n.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"luminus/mid/seguridad_avanzada/","text":"Seguridad avanzada \u00b6 En este m\u00f3dulo, aprenderemos c\u00f3mo implementar medidas de seguridad avanzadas en una aplicaci\u00f3n en Luminus Framework. La seguridad es una parte crucial en el desarrollo de cualquier aplicaci\u00f3n web, ya que protege tanto los datos de los usuarios como la integridad de la aplicaci\u00f3n en s\u00ed. Aprender a implementar medidas de seguridad avanzadas en Luminus Framework nos ayudar\u00e1 a proteger nuestra aplicaci\u00f3n contra ataques maliciosos y garantizar la confidencialidad, integridad y disponibilidad de los datos. Teor\u00eda de seguridad avanzada \u00b6 En este apartado, abordaremos los conceptos te\u00f3ricos fundamentales de la seguridad avanzada en Luminus Framework. Protecci\u00f3n contra ataques comunes \u00b6 Los ataques m\u00e1s comunes en aplicaciones web son la inyecci\u00f3n de c\u00f3digo, el cross-site scripting (XSS) y el cross-site request forgery (CSRF). Para proteger nuestra aplicaci\u00f3n contra estos ataques, es importante implementar medidas de seguridad como la validaci\u00f3n y sanitizaci\u00f3n de datos de entrada, el uso de tokens de seguridad y la configuraci\u00f3n adecuada de las cabeceras HTTP. Encriptaci\u00f3n \u00b6 La encriptaci\u00f3n es una t\u00e9cnica esencial para proteger la informaci\u00f3n confidencial en nuestra aplicaci\u00f3n. En Luminus Framework, podemos utilizar librer\u00edas como Bcrypt o Jasypt para encriptar contrase\u00f1as y otros datos sensibles almacenados en nuestra base de datos. Pol\u00edticas de seguridad \u00b6 Las pol\u00edticas de seguridad son un conjunto de reglas y procedimientos que definen c\u00f3mo se manejan los datos en nuestra aplicaci\u00f3n. Algunas pr\u00e1cticas comunes incluyen la implementaci\u00f3n de pol\u00edticas de contrase\u00f1as seguras, el uso de autenticaci\u00f3n de dos factores y la limitaci\u00f3n de los permisos de los usuarios. Palabras clave y su definici\u00f3n \u00b6 Seguridad: Conjunto de medidas y t\u00e9cnicas utilizadas para proteger una aplicaci\u00f3n contra amenazas y ataques maliciosos. Inyecci\u00f3n de c\u00f3digo: T\u00e9cnica de ataque que consiste en insertar c\u00f3digo malicioso en una aplicaci\u00f3n. Cross-site scripting (XSS): Ataque que permite a un atacante ejecutar c\u00f3digo malicioso en el navegador de un usuario. Cross-site request forgery (CSRF): Ataque que utiliza la sesi\u00f3n de un usuario autenticado para realizar acciones maliciosas en su nombre. Encriptaci\u00f3n: Proceso de transformar datos legibles en un formato ilegible para proteger su confidencialidad. Bcrypt: Librer\u00eda de encriptaci\u00f3n de contrase\u00f1as utilizada en aplicaciones en Luminus Framework. Jasypt: Librer\u00eda de encriptaci\u00f3n de datos sensibles utilizada en aplicaciones en Luminus Framework. Pol\u00edticas de seguridad: Reglas y procedimientos que definen c\u00f3mo se manejan los datos en una aplicaci\u00f3n. Preguntas de repaso \u00b6 \u00bfCu\u00e1les son los ataques m\u00e1s comunes en aplicaciones web? \u00bfQu\u00e9 medidas de seguridad podemos implementar para proteger nuestra aplicaci\u00f3n contra estos ataques? \u00bfQu\u00e9 es la encriptaci\u00f3n y por qu\u00e9 es importante en una aplicaci\u00f3n web? \u00bfQu\u00e9 es Bcrypt y c\u00f3mo se utiliza en Luminus Framework? \u00bfQu\u00e9 son las pol\u00edticas de seguridad y por qu\u00e9 son importantes en una aplicaci\u00f3n web? Ejemplos de c\u00f3digo en Luminus Framework \u00b6 Validaci\u00f3n de datos de entrada \u00b6 ( defn create-user [ request ] ( let [ params ( :params request )] ( if ( and ( valid-email? ( :email params )) ( valid-password? ( :password params ))) ( create-user-db params ) ( throw ( ex-info \"Datos de usuario no v\u00e1lidos\" { :status 400 })))) Encriptaci\u00f3n de contrase\u00f1as con Bcrypt \u00b6 ( defn create-user-db [ params ] ( let [ hashed-password ( bcrypt/encrypt ( :password params ))] ( insert-into-db { :email ( :email params ) :password hashed-password }))) Configuraci\u00f3n de cabeceras HTTP \u00b6 ( defroutes app-routes ( GET \"/\" [] \"P\u00e1gina de inicio\" ) ( GET \"/cuenta\" { :headers { \"X-Frame-Options\" \"DENY\" } :body \"Informaci\u00f3n de la cuenta\" })) Ejercicios pr\u00e1cticos \u00b6 Implementa una funci\u00f3n en tu aplicaci\u00f3n en Luminus Framework que valide y sanitice los datos de entrada del formulario de registro de usuarios. Utiliza la librer\u00eda Jasypt para encriptar la informaci\u00f3n de tarjetas de cr\u00e9dito almacenada en tu base de datos. Configura las cabeceras HTTP en tu aplicaci\u00f3n para protegerla contra ataques de clickjacking. Consejos o mejores pr\u00e1cticas \u00b6 Nunca conf\u00edes en los datos de entrada del usuario. Siempre valida y sanitiza los datos antes de utilizarlos en la aplicaci\u00f3n. Utiliza librer\u00edas de encriptaci\u00f3n confiables y actualizadas para proteger datos sensibles en tu aplicaci\u00f3n. Implementa pol\u00edticas de seguridad s\u00f3lidas y aseg\u00farate de que todos los usuarios las sigan. Mant\u00e9n tu aplicaci\u00f3n actualizada y realiza pruebas de seguridad peri\u00f3dicamente para detectar posibles vulnerabilidades.","title":"Seguridad avanzada"},{"location":"luminus/mid/seguridad_avanzada/#seguridad-avanzada","text":"En este m\u00f3dulo, aprenderemos c\u00f3mo implementar medidas de seguridad avanzadas en una aplicaci\u00f3n en Luminus Framework. La seguridad es una parte crucial en el desarrollo de cualquier aplicaci\u00f3n web, ya que protege tanto los datos de los usuarios como la integridad de la aplicaci\u00f3n en s\u00ed. Aprender a implementar medidas de seguridad avanzadas en Luminus Framework nos ayudar\u00e1 a proteger nuestra aplicaci\u00f3n contra ataques maliciosos y garantizar la confidencialidad, integridad y disponibilidad de los datos.","title":"Seguridad avanzada"},{"location":"luminus/mid/seguridad_avanzada/#teoria-de-seguridad-avanzada","text":"En este apartado, abordaremos los conceptos te\u00f3ricos fundamentales de la seguridad avanzada en Luminus Framework.","title":"Teor\u00eda de seguridad avanzada"},{"location":"luminus/mid/seguridad_avanzada/#proteccion-contra-ataques-comunes","text":"Los ataques m\u00e1s comunes en aplicaciones web son la inyecci\u00f3n de c\u00f3digo, el cross-site scripting (XSS) y el cross-site request forgery (CSRF). Para proteger nuestra aplicaci\u00f3n contra estos ataques, es importante implementar medidas de seguridad como la validaci\u00f3n y sanitizaci\u00f3n de datos de entrada, el uso de tokens de seguridad y la configuraci\u00f3n adecuada de las cabeceras HTTP.","title":"Protecci\u00f3n contra ataques comunes"},{"location":"luminus/mid/seguridad_avanzada/#encriptacion","text":"La encriptaci\u00f3n es una t\u00e9cnica esencial para proteger la informaci\u00f3n confidencial en nuestra aplicaci\u00f3n. En Luminus Framework, podemos utilizar librer\u00edas como Bcrypt o Jasypt para encriptar contrase\u00f1as y otros datos sensibles almacenados en nuestra base de datos.","title":"Encriptaci\u00f3n"},{"location":"luminus/mid/seguridad_avanzada/#politicas-de-seguridad","text":"Las pol\u00edticas de seguridad son un conjunto de reglas y procedimientos que definen c\u00f3mo se manejan los datos en nuestra aplicaci\u00f3n. Algunas pr\u00e1cticas comunes incluyen la implementaci\u00f3n de pol\u00edticas de contrase\u00f1as seguras, el uso de autenticaci\u00f3n de dos factores y la limitaci\u00f3n de los permisos de los usuarios.","title":"Pol\u00edticas de seguridad"},{"location":"luminus/mid/seguridad_avanzada/#palabras-clave-y-su-definicion","text":"Seguridad: Conjunto de medidas y t\u00e9cnicas utilizadas para proteger una aplicaci\u00f3n contra amenazas y ataques maliciosos. Inyecci\u00f3n de c\u00f3digo: T\u00e9cnica de ataque que consiste en insertar c\u00f3digo malicioso en una aplicaci\u00f3n. Cross-site scripting (XSS): Ataque que permite a un atacante ejecutar c\u00f3digo malicioso en el navegador de un usuario. Cross-site request forgery (CSRF): Ataque que utiliza la sesi\u00f3n de un usuario autenticado para realizar acciones maliciosas en su nombre. Encriptaci\u00f3n: Proceso de transformar datos legibles en un formato ilegible para proteger su confidencialidad. Bcrypt: Librer\u00eda de encriptaci\u00f3n de contrase\u00f1as utilizada en aplicaciones en Luminus Framework. Jasypt: Librer\u00eda de encriptaci\u00f3n de datos sensibles utilizada en aplicaciones en Luminus Framework. Pol\u00edticas de seguridad: Reglas y procedimientos que definen c\u00f3mo se manejan los datos en una aplicaci\u00f3n.","title":"Palabras clave y su definici\u00f3n"},{"location":"luminus/mid/seguridad_avanzada/#preguntas-de-repaso","text":"\u00bfCu\u00e1les son los ataques m\u00e1s comunes en aplicaciones web? \u00bfQu\u00e9 medidas de seguridad podemos implementar para proteger nuestra aplicaci\u00f3n contra estos ataques? \u00bfQu\u00e9 es la encriptaci\u00f3n y por qu\u00e9 es importante en una aplicaci\u00f3n web? \u00bfQu\u00e9 es Bcrypt y c\u00f3mo se utiliza en Luminus Framework? \u00bfQu\u00e9 son las pol\u00edticas de seguridad y por qu\u00e9 son importantes en una aplicaci\u00f3n web?","title":"Preguntas de repaso"},{"location":"luminus/mid/seguridad_avanzada/#ejemplos-de-codigo-en-luminus-framework","text":"","title":"Ejemplos de c\u00f3digo en Luminus Framework"},{"location":"luminus/mid/seguridad_avanzada/#validacion-de-datos-de-entrada","text":"( defn create-user [ request ] ( let [ params ( :params request )] ( if ( and ( valid-email? ( :email params )) ( valid-password? ( :password params ))) ( create-user-db params ) ( throw ( ex-info \"Datos de usuario no v\u00e1lidos\" { :status 400 }))))","title":"Validaci\u00f3n de datos de entrada"},{"location":"luminus/mid/seguridad_avanzada/#encriptacion-de-contrasenas-con-bcrypt","text":"( defn create-user-db [ params ] ( let [ hashed-password ( bcrypt/encrypt ( :password params ))] ( insert-into-db { :email ( :email params ) :password hashed-password })))","title":"Encriptaci\u00f3n de contrase\u00f1as con Bcrypt"},{"location":"luminus/mid/seguridad_avanzada/#configuracion-de-cabeceras-http","text":"( defroutes app-routes ( GET \"/\" [] \"P\u00e1gina de inicio\" ) ( GET \"/cuenta\" { :headers { \"X-Frame-Options\" \"DENY\" } :body \"Informaci\u00f3n de la cuenta\" }))","title":"Configuraci\u00f3n de cabeceras HTTP"},{"location":"luminus/mid/seguridad_avanzada/#ejercicios-practicos","text":"Implementa una funci\u00f3n en tu aplicaci\u00f3n en Luminus Framework que valide y sanitice los datos de entrada del formulario de registro de usuarios. Utiliza la librer\u00eda Jasypt para encriptar la informaci\u00f3n de tarjetas de cr\u00e9dito almacenada en tu base de datos. Configura las cabeceras HTTP en tu aplicaci\u00f3n para protegerla contra ataques de clickjacking.","title":"Ejercicios pr\u00e1cticos"},{"location":"luminus/mid/seguridad_avanzada/#consejos-o-mejores-practicas","text":"Nunca conf\u00edes en los datos de entrada del usuario. Siempre valida y sanitiza los datos antes de utilizarlos en la aplicaci\u00f3n. Utiliza librer\u00edas de encriptaci\u00f3n confiables y actualizadas para proteger datos sensibles en tu aplicaci\u00f3n. Implementa pol\u00edticas de seguridad s\u00f3lidas y aseg\u00farate de que todos los usuarios las sigan. Mant\u00e9n tu aplicaci\u00f3n actualizada y realiza pruebas de seguridad peri\u00f3dicamente para detectar posibles vulnerabilidades.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"luminus/sr/","text":"Luminus - Nivel Senior \u00b6 \u00a1Bienvenido/a al nivel Senior de Luminus! Aqu\u00ed ver\u00e1s temas de arquitectura y gesti\u00f3n de grandes proyectos: Profundizaci\u00f3n en Luminus Framework Mejores pr\u00e1cticas y patrones de dise\u00f1o Gesti\u00f3n de proyectos y equipos Desarrollo de aplicaciones en grandes proyectos Desarrollo de aplicaciones m\u00f3viles Integraci\u00f3n con tecnolog\u00edas emergentes Proceso de despliegue continuo Proyecto final luminus_sr.json re\u00fane los detalles de cada lecci\u00f3n.","title":"Luminus - Nivel Senior"},{"location":"luminus/sr/#luminus-nivel-senior","text":"\u00a1Bienvenido/a al nivel Senior de Luminus! Aqu\u00ed ver\u00e1s temas de arquitectura y gesti\u00f3n de grandes proyectos: Profundizaci\u00f3n en Luminus Framework Mejores pr\u00e1cticas y patrones de dise\u00f1o Gesti\u00f3n de proyectos y equipos Desarrollo de aplicaciones en grandes proyectos Desarrollo de aplicaciones m\u00f3viles Integraci\u00f3n con tecnolog\u00edas emergentes Proceso de despliegue continuo Proyecto final luminus_sr.json re\u00fane los detalles de cada lecci\u00f3n.","title":"Luminus - Nivel Senior"},{"location":"luminus/sr/desarrollo_de_aplicaciones_en_grandes_proyectos/","text":"Desarrollo de aplicaciones en grandes proyectos \u00b6 En este m\u00f3dulo, aprenderemos c\u00f3mo trabajar con Luminus en grandes proyectos. Esto es especialmente importante ya que en proyectos de mayor escala, es crucial tener una estructura y organizaci\u00f3n adecuadas para facilitar la colaboraci\u00f3n y el seguimiento de cambios. Teor\u00eda \u00b6 Luminus es un framework de desarrollo web basado en Clojure que permite crear aplicaciones de manera r\u00e1pida y eficiente. Sin embargo, cuando se trata de proyectos m\u00e1s grandes, es importante tener en cuenta ciertas consideraciones para mantener el c\u00f3digo ordenado y f\u00e1cil de mantener. Una de las principales ventajas de Luminus es que utiliza el patr\u00f3n de dise\u00f1o MVC (Modelo-Vista-Controlador), lo que permite dividir la aplicaci\u00f3n en diferentes capas y facilita la separaci\u00f3n de preocupaciones. Esto significa que el c\u00f3digo estar\u00e1 organizado en diferentes m\u00f3dulos, lo que hace que sea m\u00e1s f\u00e1cil de mantener y escalar en el futuro. Otra consideraci\u00f3n importante es seguir las mejores pr\u00e1cticas de programaci\u00f3n, como el uso de buenas convenciones de nomenclatura, la documentaci\u00f3n adecuada y la implementaci\u00f3n de pruebas automatizadas. Esto ayudar\u00e1 a garantizar la calidad del c\u00f3digo y facilitar\u00e1 la colaboraci\u00f3n con otros desarrolladores. Palabras clave y definiciones \u00b6 MVC: Patr\u00f3n de dise\u00f1o que separa una aplicaci\u00f3n en tres capas: modelo (l\u00f3gica de negocio), vista (interfaz de usuario) y controlador (manejo de solicitudes y respuestas). Convenciones de nomenclatura: Normas establecidas para nombrar variables, funciones y otros elementos en el c\u00f3digo. Documentaci\u00f3n: Informaci\u00f3n detallada sobre el funcionamiento de una aplicaci\u00f3n o c\u00f3digo, que facilita su comprensi\u00f3n y mantenimiento. Pruebas automatizadas: Procesos de prueba que se pueden ejecutar de forma autom\u00e1tica para garantizar el correcto funcionamiento de la aplicaci\u00f3n. Preguntas de repaso \u00b6 \u00bfQu\u00e9 patr\u00f3n de dise\u00f1o utiliza Luminus? \u00bfPor qu\u00e9 es importante seguir las mejores pr\u00e1cticas de programaci\u00f3n en proyectos grandes? \u00bfQu\u00e9 es la documentaci\u00f3n y por qu\u00e9 es importante en el desarrollo de aplicaciones? \u00bfQu\u00e9 son las pruebas automatizadas y c\u00f3mo pueden ayudar en proyectos grandes? Ejemplos de c\u00f3digo en Luminus Framework \u00b6 Estructura de un proyecto Luminus \u00b6 Un proyecto Luminus t\u00edpico tiene la siguiente estructura de directorios: resources: Contiene archivos est\u00e1ticos y plantillas de vistas. src: Contiene el c\u00f3digo fuente de la aplicaci\u00f3n. routes: Contiene los archivos de rutas, que manejan las solicitudes del usuario. controllers: Contiene los archivos de controladores, que manejan la l\u00f3gica de negocio. models: Contiene los archivos de modelos, que representan la estructura de datos de la aplicaci\u00f3n. test: Contiene archivos de pruebas automatizadas. Ejemplo de una ruta en Luminus \u00b6 En el archivo \"routes/home.clj\": ( ns my-app.routes.home ( :require [ my-app.controllers.home :refer [ home-page ]])) ( defn home-routes [] ( GET \"/\" [] ( home-page ))) Este archivo define una ruta \"/\" que llama a la funci\u00f3n \"home-page\" del controlador \"home\". Esta funci\u00f3n se encargar\u00e1 de mostrar la vista correspondiente a la p\u00e1gina de inicio. Ejemplo de un controlador en Luminus \u00b6 En el archivo \"controllers/home.clj\": ( ns my-app.controllers.home ) ( defn home-page [] ( render \"home.html\" )) Este archivo define la funci\u00f3n \"home-page\" que se encarga de devolver la vista \"home.html\", que se encuentra en la carpeta \"resources/templates\". Ejercicios pr\u00e1cticos \u00b6 Crea un proyecto Luminus y agrega una nueva ruta que muestre una p\u00e1gina de contacto. Agrega un nuevo controlador para manejar la l\u00f3gica de la p\u00e1gina de contacto y una vista correspondiente. Implementa pruebas automatizadas para el controlador de la p\u00e1gina de contacto. Consejos y mejores pr\u00e1cticas \u00b6 Utiliza una estructura de directorios clara y coherente para facilitar la navegaci\u00f3n y el mantenimiento del c\u00f3digo. Sigue las convenciones de nomenclatura establecidas para mantener un c\u00f3digo uniforme. Documenta adecuadamente el c\u00f3digo para facilitar su comprensi\u00f3n y mantenimiento. Implementa pruebas automatizadas para garantizar la calidad del c\u00f3digo y facilitar la detecci\u00f3n de errores. Utiliza herramientas de colaboraci\u00f3n y seguimiento de cambios, como Git y Trello, para trabajar en equipo de manera m\u00e1s eficiente.","title":"Desarrollo de aplicaciones en grandes proyectos"},{"location":"luminus/sr/desarrollo_de_aplicaciones_en_grandes_proyectos/#desarrollo-de-aplicaciones-en-grandes-proyectos","text":"En este m\u00f3dulo, aprenderemos c\u00f3mo trabajar con Luminus en grandes proyectos. Esto es especialmente importante ya que en proyectos de mayor escala, es crucial tener una estructura y organizaci\u00f3n adecuadas para facilitar la colaboraci\u00f3n y el seguimiento de cambios.","title":"Desarrollo de aplicaciones en grandes proyectos"},{"location":"luminus/sr/desarrollo_de_aplicaciones_en_grandes_proyectos/#teoria","text":"Luminus es un framework de desarrollo web basado en Clojure que permite crear aplicaciones de manera r\u00e1pida y eficiente. Sin embargo, cuando se trata de proyectos m\u00e1s grandes, es importante tener en cuenta ciertas consideraciones para mantener el c\u00f3digo ordenado y f\u00e1cil de mantener. Una de las principales ventajas de Luminus es que utiliza el patr\u00f3n de dise\u00f1o MVC (Modelo-Vista-Controlador), lo que permite dividir la aplicaci\u00f3n en diferentes capas y facilita la separaci\u00f3n de preocupaciones. Esto significa que el c\u00f3digo estar\u00e1 organizado en diferentes m\u00f3dulos, lo que hace que sea m\u00e1s f\u00e1cil de mantener y escalar en el futuro. Otra consideraci\u00f3n importante es seguir las mejores pr\u00e1cticas de programaci\u00f3n, como el uso de buenas convenciones de nomenclatura, la documentaci\u00f3n adecuada y la implementaci\u00f3n de pruebas automatizadas. Esto ayudar\u00e1 a garantizar la calidad del c\u00f3digo y facilitar\u00e1 la colaboraci\u00f3n con otros desarrolladores.","title":"Teor\u00eda"},{"location":"luminus/sr/desarrollo_de_aplicaciones_en_grandes_proyectos/#palabras-clave-y-definiciones","text":"MVC: Patr\u00f3n de dise\u00f1o que separa una aplicaci\u00f3n en tres capas: modelo (l\u00f3gica de negocio), vista (interfaz de usuario) y controlador (manejo de solicitudes y respuestas). Convenciones de nomenclatura: Normas establecidas para nombrar variables, funciones y otros elementos en el c\u00f3digo. Documentaci\u00f3n: Informaci\u00f3n detallada sobre el funcionamiento de una aplicaci\u00f3n o c\u00f3digo, que facilita su comprensi\u00f3n y mantenimiento. Pruebas automatizadas: Procesos de prueba que se pueden ejecutar de forma autom\u00e1tica para garantizar el correcto funcionamiento de la aplicaci\u00f3n.","title":"Palabras clave y definiciones"},{"location":"luminus/sr/desarrollo_de_aplicaciones_en_grandes_proyectos/#preguntas-de-repaso","text":"\u00bfQu\u00e9 patr\u00f3n de dise\u00f1o utiliza Luminus? \u00bfPor qu\u00e9 es importante seguir las mejores pr\u00e1cticas de programaci\u00f3n en proyectos grandes? \u00bfQu\u00e9 es la documentaci\u00f3n y por qu\u00e9 es importante en el desarrollo de aplicaciones? \u00bfQu\u00e9 son las pruebas automatizadas y c\u00f3mo pueden ayudar en proyectos grandes?","title":"Preguntas de repaso"},{"location":"luminus/sr/desarrollo_de_aplicaciones_en_grandes_proyectos/#ejemplos-de-codigo-en-luminus-framework","text":"","title":"Ejemplos de c\u00f3digo en Luminus Framework"},{"location":"luminus/sr/desarrollo_de_aplicaciones_en_grandes_proyectos/#estructura-de-un-proyecto-luminus","text":"Un proyecto Luminus t\u00edpico tiene la siguiente estructura de directorios: resources: Contiene archivos est\u00e1ticos y plantillas de vistas. src: Contiene el c\u00f3digo fuente de la aplicaci\u00f3n. routes: Contiene los archivos de rutas, que manejan las solicitudes del usuario. controllers: Contiene los archivos de controladores, que manejan la l\u00f3gica de negocio. models: Contiene los archivos de modelos, que representan la estructura de datos de la aplicaci\u00f3n. test: Contiene archivos de pruebas automatizadas.","title":"Estructura de un proyecto Luminus"},{"location":"luminus/sr/desarrollo_de_aplicaciones_en_grandes_proyectos/#ejemplo-de-una-ruta-en-luminus","text":"En el archivo \"routes/home.clj\": ( ns my-app.routes.home ( :require [ my-app.controllers.home :refer [ home-page ]])) ( defn home-routes [] ( GET \"/\" [] ( home-page ))) Este archivo define una ruta \"/\" que llama a la funci\u00f3n \"home-page\" del controlador \"home\". Esta funci\u00f3n se encargar\u00e1 de mostrar la vista correspondiente a la p\u00e1gina de inicio.","title":"Ejemplo de una ruta en Luminus"},{"location":"luminus/sr/desarrollo_de_aplicaciones_en_grandes_proyectos/#ejemplo-de-un-controlador-en-luminus","text":"En el archivo \"controllers/home.clj\": ( ns my-app.controllers.home ) ( defn home-page [] ( render \"home.html\" )) Este archivo define la funci\u00f3n \"home-page\" que se encarga de devolver la vista \"home.html\", que se encuentra en la carpeta \"resources/templates\".","title":"Ejemplo de un controlador en Luminus"},{"location":"luminus/sr/desarrollo_de_aplicaciones_en_grandes_proyectos/#ejercicios-practicos","text":"Crea un proyecto Luminus y agrega una nueva ruta que muestre una p\u00e1gina de contacto. Agrega un nuevo controlador para manejar la l\u00f3gica de la p\u00e1gina de contacto y una vista correspondiente. Implementa pruebas automatizadas para el controlador de la p\u00e1gina de contacto.","title":"Ejercicios pr\u00e1cticos"},{"location":"luminus/sr/desarrollo_de_aplicaciones_en_grandes_proyectos/#consejos-y-mejores-practicas","text":"Utiliza una estructura de directorios clara y coherente para facilitar la navegaci\u00f3n y el mantenimiento del c\u00f3digo. Sigue las convenciones de nomenclatura establecidas para mantener un c\u00f3digo uniforme. Documenta adecuadamente el c\u00f3digo para facilitar su comprensi\u00f3n y mantenimiento. Implementa pruebas automatizadas para garantizar la calidad del c\u00f3digo y facilitar la detecci\u00f3n de errores. Utiliza herramientas de colaboraci\u00f3n y seguimiento de cambios, como Git y Trello, para trabajar en equipo de manera m\u00e1s eficiente.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"luminus/sr/desarrollo_de_aplicaciones_m%C3%B3viles/","text":"Desarrollo de aplicaciones m\u00f3viles \u00b6 En la actualidad, el uso de dispositivos m\u00f3viles es cada vez m\u00e1s com\u00fan y las aplicaciones m\u00f3viles son una herramienta fundamental para acceder a servicios y contenidos en cualquier momento y lugar. Por esta raz\u00f3n, el desarrollo de aplicaciones m\u00f3viles se ha vuelto una necesidad para muchas empresas y desarrolladores. En este m\u00f3dulo, aprenderemos c\u00f3mo utilizar Luminus Framework para desarrollar aplicaciones m\u00f3viles de manera eficiente y efectiva. Tambi\u00e9n veremos c\u00f3mo integrar una aplicaci\u00f3n m\u00f3vil con una aplicaci\u00f3n desarrollada en Luminus. Palabras clave y su definici\u00f3n \u00b6 Luminus Framework: Es un framework basado en Clojure que permite desarrollar aplicaciones web y m\u00f3viles de manera r\u00e1pida y sencilla. Est\u00e1 basado en otros frameworks como Ring y Compojure y utiliza herramientas como Leiningen y ClojureScript para la gesti\u00f3n de dependencias y la compilaci\u00f3n de c\u00f3digo. React Native: Es un framework de c\u00f3digo abierto desarrollado por Facebook que permite crear aplicaciones m\u00f3viles multiplataforma utilizando JavaScript. Utiliza el mismo c\u00f3digo base para desarrollar aplicaciones para iOS y Android, lo que lo hace una herramienta muy \u00fatil para el desarrollo de aplicaciones m\u00f3viles. Multiplataforma: Se refiere a la capacidad de una aplicaci\u00f3n de funcionar en diferentes sistemas operativos y dispositivos m\u00f3viles. Integraci\u00f3n: Se refiere al proceso de conectar dos o m\u00e1s aplicaciones para que puedan compartir datos y funcionar juntas. Clojure: Es un lenguaje de programaci\u00f3n funcional y din\u00e1mico que permite desarrollar aplicaciones de manera concisa y eficiente. Es el lenguaje en el que est\u00e1 basado Luminus Framework. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es Luminus Framework y para qu\u00e9 se utiliza? \u00bfQu\u00e9 es React Native y cu\u00e1l es su ventaja en el desarrollo de aplicaciones m\u00f3viles? \u00bfQu\u00e9 significa que una aplicaci\u00f3n sea multiplataforma? \u00bfQu\u00e9 es la integraci\u00f3n entre aplicaciones y por qu\u00e9 es importante? \u00bfEn qu\u00e9 lenguaje est\u00e1 basado Luminus Framework? Ejemplos de c\u00f3digo en Luminus Framework \u00b6 Creaci\u00f3n de una aplicaci\u00f3n m\u00f3vil en Luminus \u00b6 Primero, debemos crear un proyecto en Luminus utilizando el comando lein new luminus <nombre-de-la-app> +mobile . Esto crear\u00e1 una estructura de proyecto con todas las dependencias necesarias para el desarrollo de una aplicaci\u00f3n m\u00f3vil. Luego, podemos utilizar el comando lein cljsbuild auto para compilar nuestro c\u00f3digo ClojureScript cada vez que realicemos un cambio en \u00e9l. Finalmente, podemos ejecutar lein ring server-headless para probar nuestra aplicaci\u00f3n en un navegador web. Integraci\u00f3n con una aplicaci\u00f3n m\u00f3vil en React Native \u00b6 Para integrar una aplicaci\u00f3n m\u00f3vil con una aplicaci\u00f3n desarrollada en Luminus, podemos utilizar el m\u00f3dulo cljs-react-native que nos permite comunicar ambas aplicaciones a trav\u00e9s de una API. Primero, debemos agregar cljs-react-native como una dependencia en nuestro proyecto de Luminus. Luego, en nuestra aplicaci\u00f3n m\u00f3vil en React Native, podemos importar y utilizar esta API para comunicarnos con nuestra aplicaci\u00f3n en Luminus. Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una aplicaci\u00f3n m\u00f3vil en Luminus utilizando el comando lein new luminus <nombre-de-la-app> +mobile . Agrega una vista en la aplicaci\u00f3n m\u00f3vil que muestre un texto de bienvenida. Utiliza el m\u00f3dulo cljs-react-native para comunicar esta vista con una aplicaci\u00f3n m\u00f3vil en React Native. Crea una funcionalidad en la aplicaci\u00f3n de React Native que env\u00ede un mensaje a la vista en Luminus y muestre el texto en pantalla. Consejos o mejores pr\u00e1cticas \u00b6 Utilizar herramientas de desarrollo multiplataforma como Luminus y React Native nos permite ahorrar tiempo y recursos al desarrollar aplicaciones m\u00f3viles. Siempre es importante tener en cuenta la experiencia del usuario al desarrollar una aplicaci\u00f3n m\u00f3vil, por lo que se recomienda realizar pruebas en diferentes dispositivos y sistemas operativos. La integraci\u00f3n entre aplicaciones es una habilidad valiosa en el mundo del desarrollo de software, por lo que es importante aprender a trabajar con diferentes tecnolog\u00edas y frameworks para poder crear soluciones m\u00e1s completas y eficientes.","title":"Desarrollo de aplicaciones m\u00f3viles"},{"location":"luminus/sr/desarrollo_de_aplicaciones_m%C3%B3viles/#desarrollo-de-aplicaciones-moviles","text":"En la actualidad, el uso de dispositivos m\u00f3viles es cada vez m\u00e1s com\u00fan y las aplicaciones m\u00f3viles son una herramienta fundamental para acceder a servicios y contenidos en cualquier momento y lugar. Por esta raz\u00f3n, el desarrollo de aplicaciones m\u00f3viles se ha vuelto una necesidad para muchas empresas y desarrolladores. En este m\u00f3dulo, aprenderemos c\u00f3mo utilizar Luminus Framework para desarrollar aplicaciones m\u00f3viles de manera eficiente y efectiva. Tambi\u00e9n veremos c\u00f3mo integrar una aplicaci\u00f3n m\u00f3vil con una aplicaci\u00f3n desarrollada en Luminus.","title":"Desarrollo de aplicaciones m\u00f3viles"},{"location":"luminus/sr/desarrollo_de_aplicaciones_m%C3%B3viles/#palabras-clave-y-su-definicion","text":"Luminus Framework: Es un framework basado en Clojure que permite desarrollar aplicaciones web y m\u00f3viles de manera r\u00e1pida y sencilla. Est\u00e1 basado en otros frameworks como Ring y Compojure y utiliza herramientas como Leiningen y ClojureScript para la gesti\u00f3n de dependencias y la compilaci\u00f3n de c\u00f3digo. React Native: Es un framework de c\u00f3digo abierto desarrollado por Facebook que permite crear aplicaciones m\u00f3viles multiplataforma utilizando JavaScript. Utiliza el mismo c\u00f3digo base para desarrollar aplicaciones para iOS y Android, lo que lo hace una herramienta muy \u00fatil para el desarrollo de aplicaciones m\u00f3viles. Multiplataforma: Se refiere a la capacidad de una aplicaci\u00f3n de funcionar en diferentes sistemas operativos y dispositivos m\u00f3viles. Integraci\u00f3n: Se refiere al proceso de conectar dos o m\u00e1s aplicaciones para que puedan compartir datos y funcionar juntas. Clojure: Es un lenguaje de programaci\u00f3n funcional y din\u00e1mico que permite desarrollar aplicaciones de manera concisa y eficiente. Es el lenguaje en el que est\u00e1 basado Luminus Framework.","title":"Palabras clave y su definici\u00f3n"},{"location":"luminus/sr/desarrollo_de_aplicaciones_m%C3%B3viles/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Luminus Framework y para qu\u00e9 se utiliza? \u00bfQu\u00e9 es React Native y cu\u00e1l es su ventaja en el desarrollo de aplicaciones m\u00f3viles? \u00bfQu\u00e9 significa que una aplicaci\u00f3n sea multiplataforma? \u00bfQu\u00e9 es la integraci\u00f3n entre aplicaciones y por qu\u00e9 es importante? \u00bfEn qu\u00e9 lenguaje est\u00e1 basado Luminus Framework?","title":"Preguntas de repaso"},{"location":"luminus/sr/desarrollo_de_aplicaciones_m%C3%B3viles/#ejemplos-de-codigo-en-luminus-framework","text":"","title":"Ejemplos de c\u00f3digo en Luminus Framework"},{"location":"luminus/sr/desarrollo_de_aplicaciones_m%C3%B3viles/#creacion-de-una-aplicacion-movil-en-luminus","text":"Primero, debemos crear un proyecto en Luminus utilizando el comando lein new luminus <nombre-de-la-app> +mobile . Esto crear\u00e1 una estructura de proyecto con todas las dependencias necesarias para el desarrollo de una aplicaci\u00f3n m\u00f3vil. Luego, podemos utilizar el comando lein cljsbuild auto para compilar nuestro c\u00f3digo ClojureScript cada vez que realicemos un cambio en \u00e9l. Finalmente, podemos ejecutar lein ring server-headless para probar nuestra aplicaci\u00f3n en un navegador web.","title":"Creaci\u00f3n de una aplicaci\u00f3n m\u00f3vil en Luminus"},{"location":"luminus/sr/desarrollo_de_aplicaciones_m%C3%B3viles/#integracion-con-una-aplicacion-movil-en-react-native","text":"Para integrar una aplicaci\u00f3n m\u00f3vil con una aplicaci\u00f3n desarrollada en Luminus, podemos utilizar el m\u00f3dulo cljs-react-native que nos permite comunicar ambas aplicaciones a trav\u00e9s de una API. Primero, debemos agregar cljs-react-native como una dependencia en nuestro proyecto de Luminus. Luego, en nuestra aplicaci\u00f3n m\u00f3vil en React Native, podemos importar y utilizar esta API para comunicarnos con nuestra aplicaci\u00f3n en Luminus.","title":"Integraci\u00f3n con una aplicaci\u00f3n m\u00f3vil en React Native"},{"location":"luminus/sr/desarrollo_de_aplicaciones_m%C3%B3viles/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una aplicaci\u00f3n m\u00f3vil en Luminus utilizando el comando lein new luminus <nombre-de-la-app> +mobile . Agrega una vista en la aplicaci\u00f3n m\u00f3vil que muestre un texto de bienvenida. Utiliza el m\u00f3dulo cljs-react-native para comunicar esta vista con una aplicaci\u00f3n m\u00f3vil en React Native. Crea una funcionalidad en la aplicaci\u00f3n de React Native que env\u00ede un mensaje a la vista en Luminus y muestre el texto en pantalla.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"luminus/sr/desarrollo_de_aplicaciones_m%C3%B3viles/#consejos-o-mejores-practicas","text":"Utilizar herramientas de desarrollo multiplataforma como Luminus y React Native nos permite ahorrar tiempo y recursos al desarrollar aplicaciones m\u00f3viles. Siempre es importante tener en cuenta la experiencia del usuario al desarrollar una aplicaci\u00f3n m\u00f3vil, por lo que se recomienda realizar pruebas en diferentes dispositivos y sistemas operativos. La integraci\u00f3n entre aplicaciones es una habilidad valiosa en el mundo del desarrollo de software, por lo que es importante aprender a trabajar con diferentes tecnolog\u00edas y frameworks para poder crear soluciones m\u00e1s completas y eficientes.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"luminus/sr/gesti%C3%B3n_de_proyectos_y_equipos/","text":"Gesti\u00f3n de proyectos y equipos \u00b6 En el desarrollo de una aplicaci\u00f3n en Luminus Framework, es esencial contar con una gesti\u00f3n adecuada de proyectos y equipos para garantizar el \u00e9xito del proyecto. En este m\u00f3dulo, aprenderemos c\u00f3mo liderar un equipo de desarrollo, c\u00f3mo manejar los recursos y c\u00f3mo establecer objetivos y plazos para una mejor gesti\u00f3n del proyecto. Teor\u00eda \u00b6 La gesti\u00f3n de proyectos y equipos es el proceso de planificar, organizar, dirigir y controlar los recursos para alcanzar los objetivos de un proyecto. En el contexto de una aplicaci\u00f3n en Luminus, esto implica establecer metas claras, asignar tareas y responsabilidades, monitorear el progreso y asegurar la entrega de un producto de calidad en tiempo y forma. Un buen l\u00edder de equipo es esencial para una gesti\u00f3n exitosa del proyecto. Debe tener habilidades de comunicaci\u00f3n efectiva, capacidad para tomar decisiones y resolver conflictos, y ser capaz de motivar y guiar al equipo hacia el \u00e9xito. Palabras clave \u00b6 Gesti\u00f3n de proyectos: Proceso de planificar, organizar, dirigir y controlar los recursos para alcanzar los objetivos de un proyecto. Liderazgo: Habilidad para guiar y motivar a un equipo hacia el \u00e9xito. Recursos: Personas, tiempo, dinero y materiales necesarios para completar un proyecto. Objetivos: Metas claras y medibles que se deben alcanzar durante el proyecto. Plazos: Fechas l\u00edmite para completar tareas y entregar el producto final. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la gesti\u00f3n de proyectos y equipos? \u00bfCu\u00e1l es el papel del l\u00edder de equipo en la gesti\u00f3n de proyectos? \u00bfQu\u00e9 recursos se deben manejar en un proyecto en Luminus Framework? \u00bfPor qu\u00e9 es importante establecer objetivos y plazos en un proyecto? \u00bfQu\u00e9 habilidades debe tener un buen l\u00edder de equipo? Ejemplos de c\u00f3digo en Luminus Framework \u00b6 Asignaci\u00f3n de tareas a un equipo \u00b6 En el archivo project.clj , se pueden definir las tareas que deben realizar los miembros del equipo: :tasks { \"frontend\" [\"development\", \"testing\", \"deployment\"] \"backend\" [\"development\", \"testing\", \"deployment\"] } Luego, en el archivo resources/templates/home/index.html , se puede mostrar las tareas asignadas a un miembro del equipo: <h3> Tareas asignadas a {{ current-user }} : </h3> <ul> {% for task in tasks %} <li> {{ task }} </li> {% endfor %} </ul> Seguimiento del progreso del proyecto \u00b6 En el archivo project.clj , se pueden definir los objetivos y plazos del proyecto: :project-goals [ {:goal \"Lanzamiento de la versi\u00f3n beta\" :deadline \"30 de septiembre\"} {:goal \"Mejoras de rendimiento\" :deadline \"15 de octubre\"} ] Luego, en el archivo resources/templates/project/goals.html , se puede mostrar el progreso del equipo en relaci\u00f3n a los objetivos establecidos: <h2> Objetivos del proyecto </h2> {% for goal in project-goals %} <h3> {{ goal.goal }} </h3> <p> Plazo: {{ goal.deadline }} </p> <p> Progreso: {{ goal.progress }} % </p> {% endfor %} Ejercicios pr\u00e1cticos \u00b6 Asigna tareas a diferentes miembros de un equipo en el archivo project.clj y muestra las tareas asignadas en la p\u00e1gina de inicio de la aplicaci\u00f3n. Define objetivos y plazos para un proyecto y muestra el progreso en una p\u00e1gina dedicada. Consejos o mejores pr\u00e1cticas \u00b6 Comunica claramente las expectativas y responsabilidades de cada miembro del equipo. Establece objetivos realistas y alcanzables. Monitorea regularmente el progreso del equipo y realiza ajustes si es necesario. Fomenta una comunicaci\u00f3n abierta y resuelve los conflictos de manera efectiva. Celebra los logros y reconoce el trabajo bien hecho por parte del equipo. En resumen, la gesti\u00f3n de proyectos y equipos es crucial para el \u00e9xito de una aplicaci\u00f3n en Luminus Framework. Un buen l\u00edder de equipo y una planificaci\u00f3n adecuada pueden ayudar a garantizar la entrega de un producto de calidad en tiempo y forma. Adem\u00e1s, es importante ser flexible y estar preparado para realizar ajustes en caso de cambios en el proyecto.","title":"Gesti\u00f3n de proyectos y equipos"},{"location":"luminus/sr/gesti%C3%B3n_de_proyectos_y_equipos/#gestion-de-proyectos-y-equipos","text":"En el desarrollo de una aplicaci\u00f3n en Luminus Framework, es esencial contar con una gesti\u00f3n adecuada de proyectos y equipos para garantizar el \u00e9xito del proyecto. En este m\u00f3dulo, aprenderemos c\u00f3mo liderar un equipo de desarrollo, c\u00f3mo manejar los recursos y c\u00f3mo establecer objetivos y plazos para una mejor gesti\u00f3n del proyecto.","title":"Gesti\u00f3n de proyectos y equipos"},{"location":"luminus/sr/gesti%C3%B3n_de_proyectos_y_equipos/#teoria","text":"La gesti\u00f3n de proyectos y equipos es el proceso de planificar, organizar, dirigir y controlar los recursos para alcanzar los objetivos de un proyecto. En el contexto de una aplicaci\u00f3n en Luminus, esto implica establecer metas claras, asignar tareas y responsabilidades, monitorear el progreso y asegurar la entrega de un producto de calidad en tiempo y forma. Un buen l\u00edder de equipo es esencial para una gesti\u00f3n exitosa del proyecto. Debe tener habilidades de comunicaci\u00f3n efectiva, capacidad para tomar decisiones y resolver conflictos, y ser capaz de motivar y guiar al equipo hacia el \u00e9xito.","title":"Teor\u00eda"},{"location":"luminus/sr/gesti%C3%B3n_de_proyectos_y_equipos/#palabras-clave","text":"Gesti\u00f3n de proyectos: Proceso de planificar, organizar, dirigir y controlar los recursos para alcanzar los objetivos de un proyecto. Liderazgo: Habilidad para guiar y motivar a un equipo hacia el \u00e9xito. Recursos: Personas, tiempo, dinero y materiales necesarios para completar un proyecto. Objetivos: Metas claras y medibles que se deben alcanzar durante el proyecto. Plazos: Fechas l\u00edmite para completar tareas y entregar el producto final.","title":"Palabras clave"},{"location":"luminus/sr/gesti%C3%B3n_de_proyectos_y_equipos/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la gesti\u00f3n de proyectos y equipos? \u00bfCu\u00e1l es el papel del l\u00edder de equipo en la gesti\u00f3n de proyectos? \u00bfQu\u00e9 recursos se deben manejar en un proyecto en Luminus Framework? \u00bfPor qu\u00e9 es importante establecer objetivos y plazos en un proyecto? \u00bfQu\u00e9 habilidades debe tener un buen l\u00edder de equipo?","title":"Preguntas de repaso"},{"location":"luminus/sr/gesti%C3%B3n_de_proyectos_y_equipos/#ejemplos-de-codigo-en-luminus-framework","text":"","title":"Ejemplos de c\u00f3digo en Luminus Framework"},{"location":"luminus/sr/gesti%C3%B3n_de_proyectos_y_equipos/#asignacion-de-tareas-a-un-equipo","text":"En el archivo project.clj , se pueden definir las tareas que deben realizar los miembros del equipo: :tasks { \"frontend\" [\"development\", \"testing\", \"deployment\"] \"backend\" [\"development\", \"testing\", \"deployment\"] } Luego, en el archivo resources/templates/home/index.html , se puede mostrar las tareas asignadas a un miembro del equipo: <h3> Tareas asignadas a {{ current-user }} : </h3> <ul> {% for task in tasks %} <li> {{ task }} </li> {% endfor %} </ul>","title":"Asignaci\u00f3n de tareas a un equipo"},{"location":"luminus/sr/gesti%C3%B3n_de_proyectos_y_equipos/#seguimiento-del-progreso-del-proyecto","text":"En el archivo project.clj , se pueden definir los objetivos y plazos del proyecto: :project-goals [ {:goal \"Lanzamiento de la versi\u00f3n beta\" :deadline \"30 de septiembre\"} {:goal \"Mejoras de rendimiento\" :deadline \"15 de octubre\"} ] Luego, en el archivo resources/templates/project/goals.html , se puede mostrar el progreso del equipo en relaci\u00f3n a los objetivos establecidos: <h2> Objetivos del proyecto </h2> {% for goal in project-goals %} <h3> {{ goal.goal }} </h3> <p> Plazo: {{ goal.deadline }} </p> <p> Progreso: {{ goal.progress }} % </p> {% endfor %}","title":"Seguimiento del progreso del proyecto"},{"location":"luminus/sr/gesti%C3%B3n_de_proyectos_y_equipos/#ejercicios-practicos","text":"Asigna tareas a diferentes miembros de un equipo en el archivo project.clj y muestra las tareas asignadas en la p\u00e1gina de inicio de la aplicaci\u00f3n. Define objetivos y plazos para un proyecto y muestra el progreso en una p\u00e1gina dedicada.","title":"Ejercicios pr\u00e1cticos"},{"location":"luminus/sr/gesti%C3%B3n_de_proyectos_y_equipos/#consejos-o-mejores-practicas","text":"Comunica claramente las expectativas y responsabilidades de cada miembro del equipo. Establece objetivos realistas y alcanzables. Monitorea regularmente el progreso del equipo y realiza ajustes si es necesario. Fomenta una comunicaci\u00f3n abierta y resuelve los conflictos de manera efectiva. Celebra los logros y reconoce el trabajo bien hecho por parte del equipo. En resumen, la gesti\u00f3n de proyectos y equipos es crucial para el \u00e9xito de una aplicaci\u00f3n en Luminus Framework. Un buen l\u00edder de equipo y una planificaci\u00f3n adecuada pueden ayudar a garantizar la entrega de un producto de calidad en tiempo y forma. Adem\u00e1s, es importante ser flexible y estar preparado para realizar ajustes en caso de cambios en el proyecto.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"luminus/sr/integraci%C3%B3n_con_tecnolog%C3%ADas_emergentes/","text":"Integraci\u00f3n con tecnolog\u00edas emergentes \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En este m\u00f3dulo se abordar\u00e1 la integraci\u00f3n de Luminus Framework con tecnolog\u00edas emergentes, como inteligencia artificial, internet de las cosas o blockchain. Se explorar\u00e1 c\u00f3mo utilizar APIs y c\u00f3mo desarrollar aplicaciones que aprovechen estas tecnolog\u00edas para mejorar la funcionalidad y la experiencia del usuario. 1. Explicaci\u00f3n te\u00f3rica \u00b6 La integraci\u00f3n con tecnolog\u00edas emergentes es un aspecto clave en el desarrollo de aplicaciones modernas. Estas tecnolog\u00edas est\u00e1n en constante evoluci\u00f3n y ofrecen nuevas posibilidades para mejorar la eficiencia, la seguridad y la innovaci\u00f3n en las aplicaciones. Luminus Framework es una excelente opci\u00f3n para integrar estas tecnolog\u00edas debido a su flexibilidad y su amplia gama de herramientas y librer\u00edas. La integraci\u00f3n con tecnolog\u00edas emergentes implica la conexi\u00f3n de la aplicaci\u00f3n con APIs externas o la implementaci\u00f3n de nuevas funcionalidades basadas en estas tecnolog\u00edas. Esto puede incluir la incorporaci\u00f3n de un chatbot basado en inteligencia artificial, la conexi\u00f3n con dispositivos IoT para recopilar datos o la implementaci\u00f3n de contratos inteligentes utilizando blockchain. 2. Palabras clave y su definici\u00f3n \u00b6 Inteligencia artificial (IA): rama de la inform\u00e1tica que se encarga de desarrollar sistemas que pueden realizar tareas que requieren inteligencia humana, como el aprendizaje, la toma de decisiones y el procesamiento del lenguaje natural. Internet de las cosas (IoT): concepto que se refiere a la conexi\u00f3n de dispositivos cotidianos a internet, permitiendo la recopilaci\u00f3n y el intercambio de datos entre ellos. Blockchain: tecnolog\u00eda de registro distribuido que permite la creaci\u00f3n de registros inmutables y seguros utilizando criptograf\u00eda y consenso entre los nodos de una red. APIs: interfaces de programaci\u00f3n de aplicaciones, que permiten la comunicaci\u00f3n y el intercambio de datos entre diferentes sistemas o aplicaciones. 3. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la integraci\u00f3n con tecnolog\u00edas emergentes? \u00bfPor qu\u00e9 es importante integrar tecnolog\u00edas emergentes en las aplicaciones? \u00bfQu\u00e9 es una API y c\u00f3mo se utiliza en la integraci\u00f3n con Luminus Framework? Menciona al menos tres ejemplos de tecnolog\u00edas emergentes que se pueden integrar con Luminus Framework. 4. Ejemplos de c\u00f3digo en Luminus Framework \u00b6 Integraci\u00f3n con una API de inteligencia artificial \u00b6 En este ejemplo, se utiliza una API de inteligencia artificial para implementar un chatbot en una aplicaci\u00f3n web desarrollada con Luminus Framework. ( defn chatbot-api [ message ] ( http/get \"https://api.chatbot.com\" { :query-params { :message message }})) ( defn send-message [ message ] ( let [ response ( chatbot-api message )] ( println ( str \"El chatbot responde: \" ( :body response ))))) Integraci\u00f3n con dispositivos IoT \u00b6 En este caso, se utiliza la librer\u00eda clj-iot para conectarse con dispositivos IoT y obtener datos en tiempo real en una aplicaci\u00f3n desarrollada con Luminus Framework. ( defn get-iot-data [ device ] ( let [ iot ( iot/connect-device device ) data ( iot/get-data iot )] ( println ( str \"Los datos del dispositivo \" device \" son: \" data )))) ( defn display-iot-data [] ( get-iot-data \"Sensor1\" ) ( get-iot-data \"Sensor2\" )) Integraci\u00f3n con blockchain \u00b6 Para integrar blockchain en una aplicaci\u00f3n desarrollada con Luminus Framework, se puede utilizar la librer\u00eda clj-blockchain y conectarse a una red blockchain mediante una API. ( defn create-contract [ amount ] ( let [ contract ( blockchain/create-contract \"mi-contrato\" amount )] ( println ( str \"Se ha creado un contrato con el ID: \" ( :id contract )))) ( :id contract )) ( defn transfer-funds [ contract-id recipient ] ( blockchain/transfer-funds contract-id recipient )) ;; Ejemplo de uso ( def contract-id ( create-contract 100 )) ( transfer-funds contract-id \"Usuario2\" ) 5. Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Integrar una API de inteligencia artificial en una aplicaci\u00f3n web desarrollada con Luminus Framework para implementar un chatbot que responda preguntas sobre el clima. Utilizar la librer\u00eda clj-iot para conectarse a un dispositivo IoT y obtener datos en tiempo real, y mostrarlos en una p\u00e1gina web desarrollada con Luminus Framework. Implementar un sistema de votaci\u00f3n utilizando blockchain y la librer\u00eda clj-blockchain en una aplicaci\u00f3n desarrollada con Luminus Framework. 6. Consejos o mejores pr\u00e1cticas \u00b6 Antes de integrar una tecnolog\u00eda emergente en una aplicaci\u00f3n, es importante evaluar si realmente aportar\u00e1 valor y mejorar\u00e1 la experiencia del usuario. Investigar y probar diferentes opciones de APIs y librer\u00edas antes de decidir cu\u00e1l utilizar para la integraci\u00f3n. Mantenerse actualizado sobre las \u00faltimas tendencias y tecnolog\u00edas emergentes para poder integrarlas en las aplicaciones de manera eficiente. Asegurarse de seguir las buenas pr\u00e1cticas de seguridad y privacidad al utilizar tecnolog\u00edas emergentes en las aplicaciones.","title":"Integraci\u00f3n con tecnolog\u00edas emergentes"},{"location":"luminus/sr/integraci%C3%B3n_con_tecnolog%C3%ADas_emergentes/#integracion-con-tecnologias-emergentes","text":"","title":"Integraci\u00f3n con tecnolog\u00edas emergentes"},{"location":"luminus/sr/integraci%C3%B3n_con_tecnolog%C3%ADas_emergentes/#descripcion-del-modulo","text":"En este m\u00f3dulo se abordar\u00e1 la integraci\u00f3n de Luminus Framework con tecnolog\u00edas emergentes, como inteligencia artificial, internet de las cosas o blockchain. Se explorar\u00e1 c\u00f3mo utilizar APIs y c\u00f3mo desarrollar aplicaciones que aprovechen estas tecnolog\u00edas para mejorar la funcionalidad y la experiencia del usuario.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"luminus/sr/integraci%C3%B3n_con_tecnolog%C3%ADas_emergentes/#1-explicacion-teorica","text":"La integraci\u00f3n con tecnolog\u00edas emergentes es un aspecto clave en el desarrollo de aplicaciones modernas. Estas tecnolog\u00edas est\u00e1n en constante evoluci\u00f3n y ofrecen nuevas posibilidades para mejorar la eficiencia, la seguridad y la innovaci\u00f3n en las aplicaciones. Luminus Framework es una excelente opci\u00f3n para integrar estas tecnolog\u00edas debido a su flexibilidad y su amplia gama de herramientas y librer\u00edas. La integraci\u00f3n con tecnolog\u00edas emergentes implica la conexi\u00f3n de la aplicaci\u00f3n con APIs externas o la implementaci\u00f3n de nuevas funcionalidades basadas en estas tecnolog\u00edas. Esto puede incluir la incorporaci\u00f3n de un chatbot basado en inteligencia artificial, la conexi\u00f3n con dispositivos IoT para recopilar datos o la implementaci\u00f3n de contratos inteligentes utilizando blockchain.","title":"1. Explicaci\u00f3n te\u00f3rica"},{"location":"luminus/sr/integraci%C3%B3n_con_tecnolog%C3%ADas_emergentes/#2-palabras-clave-y-su-definicion","text":"Inteligencia artificial (IA): rama de la inform\u00e1tica que se encarga de desarrollar sistemas que pueden realizar tareas que requieren inteligencia humana, como el aprendizaje, la toma de decisiones y el procesamiento del lenguaje natural. Internet de las cosas (IoT): concepto que se refiere a la conexi\u00f3n de dispositivos cotidianos a internet, permitiendo la recopilaci\u00f3n y el intercambio de datos entre ellos. Blockchain: tecnolog\u00eda de registro distribuido que permite la creaci\u00f3n de registros inmutables y seguros utilizando criptograf\u00eda y consenso entre los nodos de una red. APIs: interfaces de programaci\u00f3n de aplicaciones, que permiten la comunicaci\u00f3n y el intercambio de datos entre diferentes sistemas o aplicaciones.","title":"2. Palabras clave y su definici\u00f3n"},{"location":"luminus/sr/integraci%C3%B3n_con_tecnolog%C3%ADas_emergentes/#3-preguntas-de-repaso","text":"\u00bfQu\u00e9 es la integraci\u00f3n con tecnolog\u00edas emergentes? \u00bfPor qu\u00e9 es importante integrar tecnolog\u00edas emergentes en las aplicaciones? \u00bfQu\u00e9 es una API y c\u00f3mo se utiliza en la integraci\u00f3n con Luminus Framework? Menciona al menos tres ejemplos de tecnolog\u00edas emergentes que se pueden integrar con Luminus Framework.","title":"3. Preguntas de repaso"},{"location":"luminus/sr/integraci%C3%B3n_con_tecnolog%C3%ADas_emergentes/#4-ejemplos-de-codigo-en-luminus-framework","text":"","title":"4. Ejemplos de c\u00f3digo en Luminus Framework"},{"location":"luminus/sr/integraci%C3%B3n_con_tecnolog%C3%ADas_emergentes/#integracion-con-una-api-de-inteligencia-artificial","text":"En este ejemplo, se utiliza una API de inteligencia artificial para implementar un chatbot en una aplicaci\u00f3n web desarrollada con Luminus Framework. ( defn chatbot-api [ message ] ( http/get \"https://api.chatbot.com\" { :query-params { :message message }})) ( defn send-message [ message ] ( let [ response ( chatbot-api message )] ( println ( str \"El chatbot responde: \" ( :body response )))))","title":"Integraci\u00f3n con una API de inteligencia artificial"},{"location":"luminus/sr/integraci%C3%B3n_con_tecnolog%C3%ADas_emergentes/#integracion-con-dispositivos-iot","text":"En este caso, se utiliza la librer\u00eda clj-iot para conectarse con dispositivos IoT y obtener datos en tiempo real en una aplicaci\u00f3n desarrollada con Luminus Framework. ( defn get-iot-data [ device ] ( let [ iot ( iot/connect-device device ) data ( iot/get-data iot )] ( println ( str \"Los datos del dispositivo \" device \" son: \" data )))) ( defn display-iot-data [] ( get-iot-data \"Sensor1\" ) ( get-iot-data \"Sensor2\" ))","title":"Integraci\u00f3n con dispositivos IoT"},{"location":"luminus/sr/integraci%C3%B3n_con_tecnolog%C3%ADas_emergentes/#integracion-con-blockchain","text":"Para integrar blockchain en una aplicaci\u00f3n desarrollada con Luminus Framework, se puede utilizar la librer\u00eda clj-blockchain y conectarse a una red blockchain mediante una API. ( defn create-contract [ amount ] ( let [ contract ( blockchain/create-contract \"mi-contrato\" amount )] ( println ( str \"Se ha creado un contrato con el ID: \" ( :id contract )))) ( :id contract )) ( defn transfer-funds [ contract-id recipient ] ( blockchain/transfer-funds contract-id recipient )) ;; Ejemplo de uso ( def contract-id ( create-contract 100 )) ( transfer-funds contract-id \"Usuario2\" )","title":"Integraci\u00f3n con blockchain"},{"location":"luminus/sr/integraci%C3%B3n_con_tecnolog%C3%ADas_emergentes/#5-ejercicios-practicos-con-instrucciones-claras","text":"Integrar una API de inteligencia artificial en una aplicaci\u00f3n web desarrollada con Luminus Framework para implementar un chatbot que responda preguntas sobre el clima. Utilizar la librer\u00eda clj-iot para conectarse a un dispositivo IoT y obtener datos en tiempo real, y mostrarlos en una p\u00e1gina web desarrollada con Luminus Framework. Implementar un sistema de votaci\u00f3n utilizando blockchain y la librer\u00eda clj-blockchain en una aplicaci\u00f3n desarrollada con Luminus Framework.","title":"5. Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"luminus/sr/integraci%C3%B3n_con_tecnolog%C3%ADas_emergentes/#6-consejos-o-mejores-practicas","text":"Antes de integrar una tecnolog\u00eda emergente en una aplicaci\u00f3n, es importante evaluar si realmente aportar\u00e1 valor y mejorar\u00e1 la experiencia del usuario. Investigar y probar diferentes opciones de APIs y librer\u00edas antes de decidir cu\u00e1l utilizar para la integraci\u00f3n. Mantenerse actualizado sobre las \u00faltimas tendencias y tecnolog\u00edas emergentes para poder integrarlas en las aplicaciones de manera eficiente. Asegurarse de seguir las buenas pr\u00e1cticas de seguridad y privacidad al utilizar tecnolog\u00edas emergentes en las aplicaciones.","title":"6. Consejos o mejores pr\u00e1cticas"},{"location":"luminus/sr/mejores_pr%C3%A1cticas_y_patrones_de_dise%C3%B1o/","text":"Mejores pr\u00e1cticas y patrones de dise\u00f1o en Luminus Framework \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En este m\u00f3dulo se abordar\u00e1n las mejores pr\u00e1cticas y patrones de dise\u00f1o para aplicaciones en Luminus Framework. Se explicar\u00e1 c\u00f3mo optimizar el c\u00f3digo, manejar errores y c\u00f3mo implementar arquitecturas escalables y mantenibles. Estos conocimientos son esenciales para desarrollar aplicaciones robustas y eficientes en Luminus. 1. Explicaci\u00f3n te\u00f3rica \u00b6 Luminus Framework es un framework de desarrollo web en Clojure que se basa en las mejores pr\u00e1cticas y patrones de dise\u00f1o de la comunidad de Clojure. Estas pr\u00e1cticas y patrones se enfocan en la simplicidad, el rendimiento y la escalabilidad de las aplicaciones. Mejores pr\u00e1cticas \u00b6 Utilizar funciones puras: En Luminus, se recomienda utilizar funciones puras siempre que sea posible. Estas funciones no tienen efectos secundarios y son m\u00e1s f\u00e1ciles de probar y depurar. Separar l\u00f3gica de presentaci\u00f3n: Es importante separar la l\u00f3gica de negocio de la presentaci\u00f3n en vistas. De esta manera, se puede reutilizar la l\u00f3gica en diferentes vistas y se mantiene un c\u00f3digo m\u00e1s limpio y organizado. Utilizar estructuras de datos inmutables: En lugar de modificar directamente una estructura de datos, se deben crear nuevas versiones inmutables. Esto ayuda a evitar errores y hacer que el c\u00f3digo sea m\u00e1s predecible. Utilizar macros con moderaci\u00f3n: Aunque las macros pueden ser muy \u00fatiles en ciertos casos, se deben utilizar con moderaci\u00f3n ya que pueden hacer que el c\u00f3digo sea m\u00e1s dif\u00edcil de entender y depurar. Hacer pruebas unitarias: Las pruebas unitarias son esenciales para garantizar que el c\u00f3digo funcione correctamente. En Luminus, se pueden utilizar herramientas como Midje o clojure.test para escribir pruebas unitarias. Mantener un c\u00f3digo limpio y legible: Es importante seguir buenas pr\u00e1cticas de codificaci\u00f3n, como utilizar nombres descriptivos de variables y funciones, y mantener una estructura coherente en el c\u00f3digo. Patrones de dise\u00f1o \u00b6 Modelo-Vista-Controlador (MVC): Luminus sigue el patr\u00f3n de dise\u00f1o MVC, donde el modelo es la l\u00f3gica de negocio, la vista es la presentaci\u00f3n de datos y el controlador maneja las solicitudes del usuario y las comunica con el modelo y la vista. Inyecci\u00f3n de dependencias: Este patr\u00f3n se utiliza para gestionar las dependencias entre diferentes componentes de una aplicaci\u00f3n. En Luminus, se puede utilizar la biblioteca integrada integrant para implementar la inyecci\u00f3n de dependencias. Middleware: El uso de middleware es un patr\u00f3n com\u00fan en Luminus para agregar funcionalidades a una aplicaci\u00f3n sin modificar el c\u00f3digo existente. El middleware se ejecuta antes o despu\u00e9s de una solicitud, lo que permite agregar funcionalidades de manera modular. Arquitectura de microservicios: En lugar de construir una aplicaci\u00f3n monol\u00edtica, Luminus permite implementar una arquitectura de microservicios, donde cada servicio es una aplicaci\u00f3n independiente y se comunica con otros servicios a trav\u00e9s de API. 2. Palabras clave y su definici\u00f3n \u00b6 Funciones puras: Funciones que no tienen efectos secundarios y siempre producen el mismo resultado para los mismos argumentos. Estructuras de datos inmutables: Estructuras de datos que no pueden ser modificadas despu\u00e9s de su creaci\u00f3n. Macros: Estructuras de c\u00f3digo que se expanden en el c\u00f3digo fuente durante la compilaci\u00f3n. Pruebas unitarias: Pruebas que se enfocan en probar una unidad de c\u00f3digo aislada, como una funci\u00f3n o un m\u00f3dulo. MVC: Patr\u00f3n de dise\u00f1o que separa la l\u00f3gica de negocio, la presentaci\u00f3n y la gesti\u00f3n de solicitudes en tres componentes diferentes. Inyecci\u00f3n de dependencias: Patr\u00f3n que permite gestionar las dependencias entre diferentes componentes de una aplicaci\u00f3n. Middleware: Software que se ejecuta antes o despu\u00e9s de una solicitud y permite agregar funcionalidades de manera modular. Arquitectura de microservicios: Enfoque de dise\u00f1o de aplicaciones donde cada servicio es una aplicaci\u00f3n independiente y se comunica con otros servicios a trav\u00e9s de API. 3. Preguntas de repaso \u00b6 \u00bfCu\u00e1les son las mejores pr\u00e1cticas en Luminus Framework? \u00bfQu\u00e9 es la inyecci\u00f3n de dependencias y c\u00f3mo se puede implementar en Luminus? \u00bfCu\u00e1les son los beneficios de utilizar funciones puras en una aplicaci\u00f3n Luminus? \u00bfC\u00f3mo se puede separar la l\u00f3gica de negocio de la presentaci\u00f3n en una aplicaci\u00f3n Luminus? \u00bfQu\u00e9 patr\u00f3n de dise\u00f1o sigue Luminus y c\u00f3mo se divide en componentes? 4. Ejemplos de c\u00f3digo en Luminus Framework \u00b6 Uso de funciones puras \u00b6 ( defn sum [ x y ] ( + x y )) Implementaci\u00f3n de inyecci\u00f3n de dependencias con integrant \u00b6 (require '[integrant.core :as ig]) (def system (ig/init {:db (ig/component (create-db)) :service (ig/component (create-service))})) Creaci\u00f3n de una vista \u00b6 ( defn index [] [ :div [ :h1 \"Bienvenido a mi aplicaci\u00f3n\" ] [ :p \"Esta es una vista creada con Luminus\" ]]) Implementaci\u00f3n de middleware \u00b6 ( defn wrap-time [ handler ] ( fn [ request ] ( let [ start ( System/currentTimeMillis ) response ( handler request ) end ( System/currentTimeMillis )] ( println ( str \"Tiempo de respuesta: \" ( - end start ))) response ))) ( defn index [] [ :h1 \"Esta es mi p\u00e1gina principal\" ]) ( def app ( -> ( handler/site app-routes ) ( wrap-time ))) 5. Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una funci\u00f3n que reciba un n\u00famero y devuelva el resultado de su cuadrado. Implementa la inyecci\u00f3n de dependencias en una aplicaci\u00f3n Luminus utilizando la biblioteca integrant. Crea una vista en tu aplicaci\u00f3n Luminus que muestre una lista de usuarios y sus respectivos correos electr\u00f3nicos. Agrega un middleware a tu aplicaci\u00f3n Luminus que registre el tiempo de respuesta de cada solicitud. Implementa una arquitectura de microservicios en una aplicaci\u00f3n Luminus, donde cada servicio sea responsable de una funcionalidad espec\u00edfica. 6. Consejos o mejores pr\u00e1cticas \u00b6 Sigue las convenciones de nombres de Luminus: Utilizar nombres descriptivos para las funciones, utilizar la convenci\u00f3n de nombres de clojure para las variables (snake_case) y utilizar el idioma ingl\u00e9s. Utiliza m\u00f3dulos y namespaces: Organiza tu c\u00f3digo en m\u00f3dulos y namespaces para mantener una estructura clara y evitar conflictos entre nombres. Usa bibliotecas de terceros: Luminus tiene una amplia comunidad con muchas bibliotecas \u00fatiles que pueden ayudar a mejorar tu aplicaci\u00f3n. Realiza pruebas unitarias: No subestimes la importancia de las pruebas unitarias, ya que te ayudar\u00e1n a detectar errores y asegurar que el c\u00f3digo funcione como se espera.","title":"Mejores pr\u00e1cticas y patrones de dise\u00f1o en Luminus Framework"},{"location":"luminus/sr/mejores_pr%C3%A1cticas_y_patrones_de_dise%C3%B1o/#mejores-practicas-y-patrones-de-diseno-en-luminus-framework","text":"","title":"Mejores pr\u00e1cticas y patrones de dise\u00f1o en Luminus Framework"},{"location":"luminus/sr/mejores_pr%C3%A1cticas_y_patrones_de_dise%C3%B1o/#descripcion-del-modulo","text":"En este m\u00f3dulo se abordar\u00e1n las mejores pr\u00e1cticas y patrones de dise\u00f1o para aplicaciones en Luminus Framework. Se explicar\u00e1 c\u00f3mo optimizar el c\u00f3digo, manejar errores y c\u00f3mo implementar arquitecturas escalables y mantenibles. Estos conocimientos son esenciales para desarrollar aplicaciones robustas y eficientes en Luminus.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"luminus/sr/mejores_pr%C3%A1cticas_y_patrones_de_dise%C3%B1o/#1-explicacion-teorica","text":"Luminus Framework es un framework de desarrollo web en Clojure que se basa en las mejores pr\u00e1cticas y patrones de dise\u00f1o de la comunidad de Clojure. Estas pr\u00e1cticas y patrones se enfocan en la simplicidad, el rendimiento y la escalabilidad de las aplicaciones.","title":"1. Explicaci\u00f3n te\u00f3rica"},{"location":"luminus/sr/mejores_pr%C3%A1cticas_y_patrones_de_dise%C3%B1o/#mejores-practicas","text":"Utilizar funciones puras: En Luminus, se recomienda utilizar funciones puras siempre que sea posible. Estas funciones no tienen efectos secundarios y son m\u00e1s f\u00e1ciles de probar y depurar. Separar l\u00f3gica de presentaci\u00f3n: Es importante separar la l\u00f3gica de negocio de la presentaci\u00f3n en vistas. De esta manera, se puede reutilizar la l\u00f3gica en diferentes vistas y se mantiene un c\u00f3digo m\u00e1s limpio y organizado. Utilizar estructuras de datos inmutables: En lugar de modificar directamente una estructura de datos, se deben crear nuevas versiones inmutables. Esto ayuda a evitar errores y hacer que el c\u00f3digo sea m\u00e1s predecible. Utilizar macros con moderaci\u00f3n: Aunque las macros pueden ser muy \u00fatiles en ciertos casos, se deben utilizar con moderaci\u00f3n ya que pueden hacer que el c\u00f3digo sea m\u00e1s dif\u00edcil de entender y depurar. Hacer pruebas unitarias: Las pruebas unitarias son esenciales para garantizar que el c\u00f3digo funcione correctamente. En Luminus, se pueden utilizar herramientas como Midje o clojure.test para escribir pruebas unitarias. Mantener un c\u00f3digo limpio y legible: Es importante seguir buenas pr\u00e1cticas de codificaci\u00f3n, como utilizar nombres descriptivos de variables y funciones, y mantener una estructura coherente en el c\u00f3digo.","title":"Mejores pr\u00e1cticas"},{"location":"luminus/sr/mejores_pr%C3%A1cticas_y_patrones_de_dise%C3%B1o/#patrones-de-diseno","text":"Modelo-Vista-Controlador (MVC): Luminus sigue el patr\u00f3n de dise\u00f1o MVC, donde el modelo es la l\u00f3gica de negocio, la vista es la presentaci\u00f3n de datos y el controlador maneja las solicitudes del usuario y las comunica con el modelo y la vista. Inyecci\u00f3n de dependencias: Este patr\u00f3n se utiliza para gestionar las dependencias entre diferentes componentes de una aplicaci\u00f3n. En Luminus, se puede utilizar la biblioteca integrada integrant para implementar la inyecci\u00f3n de dependencias. Middleware: El uso de middleware es un patr\u00f3n com\u00fan en Luminus para agregar funcionalidades a una aplicaci\u00f3n sin modificar el c\u00f3digo existente. El middleware se ejecuta antes o despu\u00e9s de una solicitud, lo que permite agregar funcionalidades de manera modular. Arquitectura de microservicios: En lugar de construir una aplicaci\u00f3n monol\u00edtica, Luminus permite implementar una arquitectura de microservicios, donde cada servicio es una aplicaci\u00f3n independiente y se comunica con otros servicios a trav\u00e9s de API.","title":"Patrones de dise\u00f1o"},{"location":"luminus/sr/mejores_pr%C3%A1cticas_y_patrones_de_dise%C3%B1o/#2-palabras-clave-y-su-definicion","text":"Funciones puras: Funciones que no tienen efectos secundarios y siempre producen el mismo resultado para los mismos argumentos. Estructuras de datos inmutables: Estructuras de datos que no pueden ser modificadas despu\u00e9s de su creaci\u00f3n. Macros: Estructuras de c\u00f3digo que se expanden en el c\u00f3digo fuente durante la compilaci\u00f3n. Pruebas unitarias: Pruebas que se enfocan en probar una unidad de c\u00f3digo aislada, como una funci\u00f3n o un m\u00f3dulo. MVC: Patr\u00f3n de dise\u00f1o que separa la l\u00f3gica de negocio, la presentaci\u00f3n y la gesti\u00f3n de solicitudes en tres componentes diferentes. Inyecci\u00f3n de dependencias: Patr\u00f3n que permite gestionar las dependencias entre diferentes componentes de una aplicaci\u00f3n. Middleware: Software que se ejecuta antes o despu\u00e9s de una solicitud y permite agregar funcionalidades de manera modular. Arquitectura de microservicios: Enfoque de dise\u00f1o de aplicaciones donde cada servicio es una aplicaci\u00f3n independiente y se comunica con otros servicios a trav\u00e9s de API.","title":"2. Palabras clave y su definici\u00f3n"},{"location":"luminus/sr/mejores_pr%C3%A1cticas_y_patrones_de_dise%C3%B1o/#3-preguntas-de-repaso","text":"\u00bfCu\u00e1les son las mejores pr\u00e1cticas en Luminus Framework? \u00bfQu\u00e9 es la inyecci\u00f3n de dependencias y c\u00f3mo se puede implementar en Luminus? \u00bfCu\u00e1les son los beneficios de utilizar funciones puras en una aplicaci\u00f3n Luminus? \u00bfC\u00f3mo se puede separar la l\u00f3gica de negocio de la presentaci\u00f3n en una aplicaci\u00f3n Luminus? \u00bfQu\u00e9 patr\u00f3n de dise\u00f1o sigue Luminus y c\u00f3mo se divide en componentes?","title":"3. Preguntas de repaso"},{"location":"luminus/sr/mejores_pr%C3%A1cticas_y_patrones_de_dise%C3%B1o/#4-ejemplos-de-codigo-en-luminus-framework","text":"","title":"4. Ejemplos de c\u00f3digo en Luminus Framework"},{"location":"luminus/sr/mejores_pr%C3%A1cticas_y_patrones_de_dise%C3%B1o/#uso-de-funciones-puras","text":"( defn sum [ x y ] ( + x y ))","title":"Uso de funciones puras"},{"location":"luminus/sr/mejores_pr%C3%A1cticas_y_patrones_de_dise%C3%B1o/#implementacion-de-inyeccion-de-dependencias-con-integrant","text":"(require '[integrant.core :as ig]) (def system (ig/init {:db (ig/component (create-db)) :service (ig/component (create-service))}))","title":"Implementaci\u00f3n de inyecci\u00f3n de dependencias con integrant"},{"location":"luminus/sr/mejores_pr%C3%A1cticas_y_patrones_de_dise%C3%B1o/#creacion-de-una-vista","text":"( defn index [] [ :div [ :h1 \"Bienvenido a mi aplicaci\u00f3n\" ] [ :p \"Esta es una vista creada con Luminus\" ]])","title":"Creaci\u00f3n de una vista"},{"location":"luminus/sr/mejores_pr%C3%A1cticas_y_patrones_de_dise%C3%B1o/#implementacion-de-middleware","text":"( defn wrap-time [ handler ] ( fn [ request ] ( let [ start ( System/currentTimeMillis ) response ( handler request ) end ( System/currentTimeMillis )] ( println ( str \"Tiempo de respuesta: \" ( - end start ))) response ))) ( defn index [] [ :h1 \"Esta es mi p\u00e1gina principal\" ]) ( def app ( -> ( handler/site app-routes ) ( wrap-time )))","title":"Implementaci\u00f3n de middleware"},{"location":"luminus/sr/mejores_pr%C3%A1cticas_y_patrones_de_dise%C3%B1o/#5-ejercicios-practicos-con-instrucciones-claras","text":"Crea una funci\u00f3n que reciba un n\u00famero y devuelva el resultado de su cuadrado. Implementa la inyecci\u00f3n de dependencias en una aplicaci\u00f3n Luminus utilizando la biblioteca integrant. Crea una vista en tu aplicaci\u00f3n Luminus que muestre una lista de usuarios y sus respectivos correos electr\u00f3nicos. Agrega un middleware a tu aplicaci\u00f3n Luminus que registre el tiempo de respuesta de cada solicitud. Implementa una arquitectura de microservicios en una aplicaci\u00f3n Luminus, donde cada servicio sea responsable de una funcionalidad espec\u00edfica.","title":"5. Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"luminus/sr/mejores_pr%C3%A1cticas_y_patrones_de_dise%C3%B1o/#6-consejos-o-mejores-practicas","text":"Sigue las convenciones de nombres de Luminus: Utilizar nombres descriptivos para las funciones, utilizar la convenci\u00f3n de nombres de clojure para las variables (snake_case) y utilizar el idioma ingl\u00e9s. Utiliza m\u00f3dulos y namespaces: Organiza tu c\u00f3digo en m\u00f3dulos y namespaces para mantener una estructura clara y evitar conflictos entre nombres. Usa bibliotecas de terceros: Luminus tiene una amplia comunidad con muchas bibliotecas \u00fatiles que pueden ayudar a mejorar tu aplicaci\u00f3n. Realiza pruebas unitarias: No subestimes la importancia de las pruebas unitarias, ya que te ayudar\u00e1n a detectar errores y asegurar que el c\u00f3digo funcione como se espera.","title":"6. Consejos o mejores pr\u00e1cticas"},{"location":"luminus/sr/proceso_de_despliegue_continuo/","text":"Proceso de despliegue continuo en Luminus Framework \u00b6 Introducci\u00f3n \u00b6 El proceso de despliegue continuo es una pr\u00e1ctica de desarrollo de software que consiste en automatizar todo el proceso de lanzamiento de una aplicaci\u00f3n desde la fase de desarrollo hasta su puesta en producci\u00f3n. En el caso espec\u00edfico de Luminus Framework, esto implica automatizar la construcci\u00f3n de la aplicaci\u00f3n, la ejecuci\u00f3n de pruebas y el despliegue en diferentes entornos. Palabras clave \u00b6 Despliegue continuo: Pr\u00e1ctica de desarrollo de software que consiste en automatizar todo el proceso de lanzamiento de una aplicaci\u00f3n. Jenkins: Herramienta de integraci\u00f3n continua que permite automatizar tareas de construcci\u00f3n, pruebas y despliegue. Travis CI: Servicio de integraci\u00f3n continua en la nube que tambi\u00e9n permite automatizar tareas de construcci\u00f3n, pruebas y despliegue. Automatizaci\u00f3n: Proceso de realizar tareas de forma autom\u00e1tica mediante el uso de herramientas y scripts. Entornos: Diferentes ambientes en los que se puede desplegar una aplicaci\u00f3n, como desarrollo, pruebas, preproducci\u00f3n y producci\u00f3n. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es el proceso de despliegue continuo? \u00bfCu\u00e1les son las herramientas m\u00e1s utilizadas para automatizar el proceso de despliegue continuo en Luminus Framework? \u00bfQu\u00e9 es la integraci\u00f3n continua? \u00bfPor qu\u00e9 es importante automatizar el proceso de despliegue en diferentes entornos? \u00bfCu\u00e1les son los principales beneficios del despliegue continuo en Luminus Framework? Ejemplos de c\u00f3digo en Luminus Framework \u00b6 Configuraci\u00f3n de Jenkins \u00b6 { :profiles { :dev { :env { :database-url \"jdbc:postgresql://localhost:5432/myapp_dev\" :database-username \"username\" :database-password \"password\" }} :test { :env { :database-url \"jdbc:postgresql://localhost:5432/myapp_test\" :database-username \"username\" :database-password \"password\" }} :production { :env { :database-url \"jdbc:postgresql://localhost:5432/myapp_production\" :database-username \"username\" :database-password \"password\" }}}} Configuraci\u00f3n de Travis CI \u00b6 language : clojure lein : lein2 before_script : - psql -c \"create database myapp_test;\" -U postgres script : lein2 test jdk : - openjdk8 Ejercicios pr\u00e1cticos \u00b6 Configurar un proyecto de Luminus Framework en GitHub y conectarlo con Travis CI para realizar pruebas y despliegue. Crear diferentes perfiles de entorno en el proyecto de Luminus Framework y configurarlos en Jenkins para realizar despliegues en cada uno de ellos. Automatizar la ejecuci\u00f3n de pruebas en cada cambio en el repositorio de GitHub utilizando Travis CI. Desplegar una aplicaci\u00f3n de Luminus en un servidor de prueba utilizando Jenkins. Consejos y mejores pr\u00e1cticas \u00b6 Utilizar herramientas de integraci\u00f3n continua y despliegue continuo como Jenkins o Travis CI para automatizar el proceso. Configurar diferentes perfiles de entorno en el proyecto de Luminus Framework para realizar pruebas en cada uno de ellos. Realizar pruebas automatizadas en cada cambio en el repositorio de GitHub para detectar errores de forma temprana. Realizar despliegues en entornos de prueba antes de realizar el despliegue en producci\u00f3n para asegurar la estabilidad de la aplicaci\u00f3n. Realizar backups y versionamiento de la aplicaci\u00f3n para poder revertir cambios en caso de errores en el despliegue. En resumen, el proceso de despliegue continuo en Luminus Framework permite automatizar todo el proceso de lanzamiento de una aplicaci\u00f3n, lo que ahorra tiempo y reduce errores humanos. Utilizando herramientas como Jenkins o Travis CI, es posible integrar pruebas automatizadas y despliegues en diferentes entornos para garantizar la calidad y estabilidad de la aplicaci\u00f3n.","title":"Proceso de despliegue continuo en Luminus Framework"},{"location":"luminus/sr/proceso_de_despliegue_continuo/#proceso-de-despliegue-continuo-en-luminus-framework","text":"","title":"Proceso de despliegue continuo en Luminus Framework"},{"location":"luminus/sr/proceso_de_despliegue_continuo/#introduccion","text":"El proceso de despliegue continuo es una pr\u00e1ctica de desarrollo de software que consiste en automatizar todo el proceso de lanzamiento de una aplicaci\u00f3n desde la fase de desarrollo hasta su puesta en producci\u00f3n. En el caso espec\u00edfico de Luminus Framework, esto implica automatizar la construcci\u00f3n de la aplicaci\u00f3n, la ejecuci\u00f3n de pruebas y el despliegue en diferentes entornos.","title":"Introducci\u00f3n"},{"location":"luminus/sr/proceso_de_despliegue_continuo/#palabras-clave","text":"Despliegue continuo: Pr\u00e1ctica de desarrollo de software que consiste en automatizar todo el proceso de lanzamiento de una aplicaci\u00f3n. Jenkins: Herramienta de integraci\u00f3n continua que permite automatizar tareas de construcci\u00f3n, pruebas y despliegue. Travis CI: Servicio de integraci\u00f3n continua en la nube que tambi\u00e9n permite automatizar tareas de construcci\u00f3n, pruebas y despliegue. Automatizaci\u00f3n: Proceso de realizar tareas de forma autom\u00e1tica mediante el uso de herramientas y scripts. Entornos: Diferentes ambientes en los que se puede desplegar una aplicaci\u00f3n, como desarrollo, pruebas, preproducci\u00f3n y producci\u00f3n.","title":"Palabras clave"},{"location":"luminus/sr/proceso_de_despliegue_continuo/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es el proceso de despliegue continuo? \u00bfCu\u00e1les son las herramientas m\u00e1s utilizadas para automatizar el proceso de despliegue continuo en Luminus Framework? \u00bfQu\u00e9 es la integraci\u00f3n continua? \u00bfPor qu\u00e9 es importante automatizar el proceso de despliegue en diferentes entornos? \u00bfCu\u00e1les son los principales beneficios del despliegue continuo en Luminus Framework?","title":"Preguntas de repaso"},{"location":"luminus/sr/proceso_de_despliegue_continuo/#ejemplos-de-codigo-en-luminus-framework","text":"","title":"Ejemplos de c\u00f3digo en Luminus Framework"},{"location":"luminus/sr/proceso_de_despliegue_continuo/#configuracion-de-jenkins","text":"{ :profiles { :dev { :env { :database-url \"jdbc:postgresql://localhost:5432/myapp_dev\" :database-username \"username\" :database-password \"password\" }} :test { :env { :database-url \"jdbc:postgresql://localhost:5432/myapp_test\" :database-username \"username\" :database-password \"password\" }} :production { :env { :database-url \"jdbc:postgresql://localhost:5432/myapp_production\" :database-username \"username\" :database-password \"password\" }}}}","title":"Configuraci\u00f3n de Jenkins"},{"location":"luminus/sr/proceso_de_despliegue_continuo/#configuracion-de-travis-ci","text":"language : clojure lein : lein2 before_script : - psql -c \"create database myapp_test;\" -U postgres script : lein2 test jdk : - openjdk8","title":"Configuraci\u00f3n de Travis CI"},{"location":"luminus/sr/proceso_de_despliegue_continuo/#ejercicios-practicos","text":"Configurar un proyecto de Luminus Framework en GitHub y conectarlo con Travis CI para realizar pruebas y despliegue. Crear diferentes perfiles de entorno en el proyecto de Luminus Framework y configurarlos en Jenkins para realizar despliegues en cada uno de ellos. Automatizar la ejecuci\u00f3n de pruebas en cada cambio en el repositorio de GitHub utilizando Travis CI. Desplegar una aplicaci\u00f3n de Luminus en un servidor de prueba utilizando Jenkins.","title":"Ejercicios pr\u00e1cticos"},{"location":"luminus/sr/proceso_de_despliegue_continuo/#consejos-y-mejores-practicas","text":"Utilizar herramientas de integraci\u00f3n continua y despliegue continuo como Jenkins o Travis CI para automatizar el proceso. Configurar diferentes perfiles de entorno en el proyecto de Luminus Framework para realizar pruebas en cada uno de ellos. Realizar pruebas automatizadas en cada cambio en el repositorio de GitHub para detectar errores de forma temprana. Realizar despliegues en entornos de prueba antes de realizar el despliegue en producci\u00f3n para asegurar la estabilidad de la aplicaci\u00f3n. Realizar backups y versionamiento de la aplicaci\u00f3n para poder revertir cambios en caso de errores en el despliegue. En resumen, el proceso de despliegue continuo en Luminus Framework permite automatizar todo el proceso de lanzamiento de una aplicaci\u00f3n, lo que ahorra tiempo y reduce errores humanos. Utilizando herramientas como Jenkins o Travis CI, es posible integrar pruebas automatizadas y despliegues en diferentes entornos para garantizar la calidad y estabilidad de la aplicaci\u00f3n.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"luminus/sr/profundizaci%C3%B3n_en_luminus_framework/","text":"Profundizaci\u00f3n en Luminus Framework \u00b6 En este m\u00f3dulo nos adentraremos en los conceptos avanzados de Luminus Framework, un framework de desarrollo web escrito en el lenguaje de programaci\u00f3n Clojure. Aprenderemos sobre su funcionamiento interno y c\u00f3mo extender sus capacidades mediante la creaci\u00f3n de plugins. Explicaci\u00f3n te\u00f3rica \u00b6 Luminus Framework se basa en el patr\u00f3n de arquitectura de software \"Modelo Vista Controlador\" (MVC). Esto significa que divide la aplicaci\u00f3n en tres componentes principales: el modelo, la vista y el controlador. El modelo se encarga de la l\u00f3gica de la aplicaci\u00f3n y la manipulaci\u00f3n de los datos, la vista se encarga de la presentaci\u00f3n de la informaci\u00f3n y el controlador act\u00faa como intermediario entre el modelo y la vista. Una de las caracter\u00edsticas principales de Luminus es su \u00e9nfasis en la simplicidad y en seguir el principio de \"convenci\u00f3n sobre configuraci\u00f3n\". Esto significa que el desarrollador no tiene que preocuparse por configurar la aplicaci\u00f3n en exceso, ya que el framework asume ciertas convenciones de configuraci\u00f3n por defecto. Luminus utiliza el servidor web Jetty y el sistema de plantillas Hiccup, lo que lo hace muy ligero y r\u00e1pido. Adem\u00e1s, cuenta con una amplia documentaci\u00f3n y una comunidad activa que lo respalda. Palabras clave y su definici\u00f3n \u00b6 MVC: Modelo Vista Controlador, un patr\u00f3n de arquitectura de software en el que la aplicaci\u00f3n se divide en tres componentes principales: modelo, vista y controlador. Convenci\u00f3n sobre configuraci\u00f3n: principio en el que se asume que existen ciertas convenciones de configuraci\u00f3n por defecto, lo que facilita el desarrollo y reduce la cantidad de c\u00f3digo necesario. Jetty: servidor web utilizado por Luminus para manejar las solicitudes HTTP. Hiccup: sistema de plantillas utilizado por Luminus para generar contenido HTML. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es MVC y c\u00f3mo se relaciona con Luminus Framework? \u00bfQu\u00e9 significa \"convenci\u00f3n sobre configuraci\u00f3n\" en el contexto de Luminus? \u00bfQu\u00e9 servidor web y sistema de plantillas utiliza Luminus? Ejemplos de c\u00f3digo en Luminus Framework \u00b6 A continuaci\u00f3n se muestra un ejemplo de un controlador en Luminus que maneja una solicitud GET y devuelve una vista con algunos datos: ( ns my-app.controllers.hello ) ( defn hello-view [ name ] [ :h1 \"\u00a1Hola, \" name \"!\" ]) ( defn hello-world [ request ] ( let [ name ( get-in request [ :params :name ]) view ( hello-view name )] { :status 200 :headers { \"Content-Type\" \"text/html\" } :body ( hiccup.core/html view )})) Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crear un nuevo proyecto en Luminus utilizando el comando lein new luminus my-app . Este comando crear\u00e1 una estructura de proyecto b\u00e1sica y descargar\u00e1 las dependencias necesarias. En el archivo project.clj , agregar la dependencia para utilizar la base de datos MySQL: [mysql/mysql-connector-java \"5.1.38\"] . En el archivo src/my_app/db.clj , configurar la conexi\u00f3n a la base de datos y escribir una funci\u00f3n que devuelva una lista con todos los usuarios de la tabla users . Crear un controlador que maneje una solicitud GET a la ruta \"/users\" y llame a la funci\u00f3n creada en el paso anterior para obtener la lista de usuarios. Crear una vista que muestre la lista de usuarios en una tabla HTML. Ejecutar el proyecto y comprobar que al acceder a la ruta \"/users\" se muestra la lista de usuarios correctamente. Consejos o mejores pr\u00e1cticas \u00b6 Utilizar las convenciones de configuraci\u00f3n por defecto de Luminus siempre que sea posible, ya que esto reduce la cantidad de c\u00f3digo necesario y facilita el desarrollo. Revisar la documentaci\u00f3n oficial y la comunidad en l\u00ednea para encontrar soluciones a posibles problemas o dudas. Utilizar la estructura de proyecto recomendada por Luminus para mantener un c\u00f3digo organizado y f\u00e1cil de mantener.","title":"Profundizaci\u00f3n en Luminus Framework"},{"location":"luminus/sr/profundizaci%C3%B3n_en_luminus_framework/#profundizacion-en-luminus-framework","text":"En este m\u00f3dulo nos adentraremos en los conceptos avanzados de Luminus Framework, un framework de desarrollo web escrito en el lenguaje de programaci\u00f3n Clojure. Aprenderemos sobre su funcionamiento interno y c\u00f3mo extender sus capacidades mediante la creaci\u00f3n de plugins.","title":"Profundizaci\u00f3n en Luminus Framework"},{"location":"luminus/sr/profundizaci%C3%B3n_en_luminus_framework/#explicacion-teorica","text":"Luminus Framework se basa en el patr\u00f3n de arquitectura de software \"Modelo Vista Controlador\" (MVC). Esto significa que divide la aplicaci\u00f3n en tres componentes principales: el modelo, la vista y el controlador. El modelo se encarga de la l\u00f3gica de la aplicaci\u00f3n y la manipulaci\u00f3n de los datos, la vista se encarga de la presentaci\u00f3n de la informaci\u00f3n y el controlador act\u00faa como intermediario entre el modelo y la vista. Una de las caracter\u00edsticas principales de Luminus es su \u00e9nfasis en la simplicidad y en seguir el principio de \"convenci\u00f3n sobre configuraci\u00f3n\". Esto significa que el desarrollador no tiene que preocuparse por configurar la aplicaci\u00f3n en exceso, ya que el framework asume ciertas convenciones de configuraci\u00f3n por defecto. Luminus utiliza el servidor web Jetty y el sistema de plantillas Hiccup, lo que lo hace muy ligero y r\u00e1pido. Adem\u00e1s, cuenta con una amplia documentaci\u00f3n y una comunidad activa que lo respalda.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"luminus/sr/profundizaci%C3%B3n_en_luminus_framework/#palabras-clave-y-su-definicion","text":"MVC: Modelo Vista Controlador, un patr\u00f3n de arquitectura de software en el que la aplicaci\u00f3n se divide en tres componentes principales: modelo, vista y controlador. Convenci\u00f3n sobre configuraci\u00f3n: principio en el que se asume que existen ciertas convenciones de configuraci\u00f3n por defecto, lo que facilita el desarrollo y reduce la cantidad de c\u00f3digo necesario. Jetty: servidor web utilizado por Luminus para manejar las solicitudes HTTP. Hiccup: sistema de plantillas utilizado por Luminus para generar contenido HTML.","title":"Palabras clave y su definici\u00f3n"},{"location":"luminus/sr/profundizaci%C3%B3n_en_luminus_framework/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es MVC y c\u00f3mo se relaciona con Luminus Framework? \u00bfQu\u00e9 significa \"convenci\u00f3n sobre configuraci\u00f3n\" en el contexto de Luminus? \u00bfQu\u00e9 servidor web y sistema de plantillas utiliza Luminus?","title":"Preguntas de repaso"},{"location":"luminus/sr/profundizaci%C3%B3n_en_luminus_framework/#ejemplos-de-codigo-en-luminus-framework","text":"A continuaci\u00f3n se muestra un ejemplo de un controlador en Luminus que maneja una solicitud GET y devuelve una vista con algunos datos: ( ns my-app.controllers.hello ) ( defn hello-view [ name ] [ :h1 \"\u00a1Hola, \" name \"!\" ]) ( defn hello-world [ request ] ( let [ name ( get-in request [ :params :name ]) view ( hello-view name )] { :status 200 :headers { \"Content-Type\" \"text/html\" } :body ( hiccup.core/html view )}))","title":"Ejemplos de c\u00f3digo en Luminus Framework"},{"location":"luminus/sr/profundizaci%C3%B3n_en_luminus_framework/#ejercicios-practicos-con-instrucciones-claras","text":"Crear un nuevo proyecto en Luminus utilizando el comando lein new luminus my-app . Este comando crear\u00e1 una estructura de proyecto b\u00e1sica y descargar\u00e1 las dependencias necesarias. En el archivo project.clj , agregar la dependencia para utilizar la base de datos MySQL: [mysql/mysql-connector-java \"5.1.38\"] . En el archivo src/my_app/db.clj , configurar la conexi\u00f3n a la base de datos y escribir una funci\u00f3n que devuelva una lista con todos los usuarios de la tabla users . Crear un controlador que maneje una solicitud GET a la ruta \"/users\" y llame a la funci\u00f3n creada en el paso anterior para obtener la lista de usuarios. Crear una vista que muestre la lista de usuarios en una tabla HTML. Ejecutar el proyecto y comprobar que al acceder a la ruta \"/users\" se muestra la lista de usuarios correctamente.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"luminus/sr/profundizaci%C3%B3n_en_luminus_framework/#consejos-o-mejores-practicas","text":"Utilizar las convenciones de configuraci\u00f3n por defecto de Luminus siempre que sea posible, ya que esto reduce la cantidad de c\u00f3digo necesario y facilita el desarrollo. Revisar la documentaci\u00f3n oficial y la comunidad en l\u00ednea para encontrar soluciones a posibles problemas o dudas. Utilizar la estructura de proyecto recomendada por Luminus para mantener un c\u00f3digo organizado y f\u00e1cil de mantener.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"luminus/sr/proyecto_final/","text":"Proyecto final \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En este m\u00f3dulo final del curso de Luminus Framework, se pondr\u00e1n en pr\u00e1ctica todos los conceptos aprendidos a lo largo del curso para desarrollar un proyecto completo utilizando esta herramienta. Este proyecto final servir\u00e1 como una evaluaci\u00f3n y una oportunidad para aplicar los conocimientos adquiridos en un escenario real. Explicaci\u00f3n te\u00f3rica \u00b6 El proyecto final consistir\u00e1 en la creaci\u00f3n de una aplicaci\u00f3n web utilizando Luminus Framework. Esta aplicaci\u00f3n tendr\u00e1 como objetivo gestionar una lista de tareas, permitiendo a los usuarios crear, editar y eliminar tareas, as\u00ed como tambi\u00e9n marcarlas como completadas. Para desarrollar este proyecto, se utilizar\u00e1n los conceptos aprendidos en los m\u00f3dulos anteriores, como la estructura de un proyecto en Luminus, la creaci\u00f3n de rutas, la utilizaci\u00f3n de plantillas HTML, el acceso a bases de datos, entre otros. Palabras clave y su definici\u00f3n \u00b6 Luminus Framework: Es un framework de aplicaciones web para el lenguaje de programaci\u00f3n Clojure. Proyecto final: Es una actividad en la que se aplican todos los conocimientos adquiridos en un curso o m\u00f3dulo. Aplicaci\u00f3n web: Es un software accesible a trav\u00e9s de un navegador web que permite realizar diferentes tareas o funciones. Gesti\u00f3n de tareas: Es el proceso de organizar y administrar las tareas de una manera eficiente y efectiva. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es Luminus Framework? \u00bfEn qu\u00e9 consiste el proyecto final? \u00bfCu\u00e1l es el objetivo de la aplicaci\u00f3n a desarrollar? \u00bfQu\u00e9 conceptos se utilizar\u00e1n en este proyecto? \u00bfQu\u00e9 es la gesti\u00f3n de tareas? Ejemplos de c\u00f3digo en Luminus Framework \u00b6 Creaci\u00f3n de una ruta en Luminus: ( defroutes app-routes ( GET \"/\" [] ( home-page )) ( POST \"/task\" [ task ] ( create-task task )) ( PUT \"/task/:id\" [ id task ] ( update-task id task )) ( DELETE \"/task/:id\" [ id ] ( delete-task id ))) Utilizaci\u00f3n de plantillas HTML en Luminus: ( defn home-page [] ( layout/common [ :h1 \"Lista de tareas\" ] [ :ul ( for [ task tasks ] [ :li [ :h3 ( :title task )] [ :p ( :description task )] [ :button { :onclick ( str \"editTask(\" ( :id task ) \")\" )} \"Editar\" ] [ :button { :onclick ( str \"deleteTask(\" ( :id task ) \")\" )} \"Eliminar\" ]])])) Acceso a una base de datos en Luminus: ( defn create-task [ task ] ( let [ new-task ( Task. ( :title task ) ( :description task ))] ( db/save new-task ))) ( defn update-task [ id task ] ( db/update! ( Task. ( :title task ) ( :description task )) id )) ( defn delete-task [ id ] ( db/delete! ( db/find-by-id Task id ))) Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crear una aplicaci\u00f3n web utilizando Luminus Framework que permita gestionar una lista de tareas. La aplicaci\u00f3n debe tener las siguientes funcionalidades: Crear una nueva tarea con un t\u00edtulo y una descripci\u00f3n. Editar una tarea existente. Eliminar una tarea. Marcar una tarea como completada. Utilizar una base de datos para almacenar las tareas. Implementar un sistema de autenticaci\u00f3n de usuarios para que solo puedan acceder a la aplicaci\u00f3n aquellos que est\u00e9n registrados. A\u00f1adir validaciones en los campos de t\u00edtulo y descripci\u00f3n para evitar tareas vac\u00edas o con informaci\u00f3n incompleta. Consejos o mejores pr\u00e1cticas \u00b6 Antes de comenzar a desarrollar, es importante planificar y definir claramente los objetivos y funcionalidades de la aplicaci\u00f3n. Utilizar la documentaci\u00f3n oficial de Luminus para consultar dudas o encontrar soluciones a problemas. Realizar pruebas continuas durante el desarrollo para asegurarse de que todo funciona correctamente. Seguir buenas pr\u00e1cticas de programaci\u00f3n, como utilizar nombres de variables descriptivos y comentarios adecuados en el c\u00f3digo. No tener miedo de probar nuevas funcionalidades o experimentar con diferentes enfoques para resolver un problema.","title":"Proyecto final"},{"location":"luminus/sr/proyecto_final/#proyecto-final","text":"","title":"Proyecto final"},{"location":"luminus/sr/proyecto_final/#descripcion-del-modulo","text":"En este m\u00f3dulo final del curso de Luminus Framework, se pondr\u00e1n en pr\u00e1ctica todos los conceptos aprendidos a lo largo del curso para desarrollar un proyecto completo utilizando esta herramienta. Este proyecto final servir\u00e1 como una evaluaci\u00f3n y una oportunidad para aplicar los conocimientos adquiridos en un escenario real.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"luminus/sr/proyecto_final/#explicacion-teorica","text":"El proyecto final consistir\u00e1 en la creaci\u00f3n de una aplicaci\u00f3n web utilizando Luminus Framework. Esta aplicaci\u00f3n tendr\u00e1 como objetivo gestionar una lista de tareas, permitiendo a los usuarios crear, editar y eliminar tareas, as\u00ed como tambi\u00e9n marcarlas como completadas. Para desarrollar este proyecto, se utilizar\u00e1n los conceptos aprendidos en los m\u00f3dulos anteriores, como la estructura de un proyecto en Luminus, la creaci\u00f3n de rutas, la utilizaci\u00f3n de plantillas HTML, el acceso a bases de datos, entre otros.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"luminus/sr/proyecto_final/#palabras-clave-y-su-definicion","text":"Luminus Framework: Es un framework de aplicaciones web para el lenguaje de programaci\u00f3n Clojure. Proyecto final: Es una actividad en la que se aplican todos los conocimientos adquiridos en un curso o m\u00f3dulo. Aplicaci\u00f3n web: Es un software accesible a trav\u00e9s de un navegador web que permite realizar diferentes tareas o funciones. Gesti\u00f3n de tareas: Es el proceso de organizar y administrar las tareas de una manera eficiente y efectiva.","title":"Palabras clave y su definici\u00f3n"},{"location":"luminus/sr/proyecto_final/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Luminus Framework? \u00bfEn qu\u00e9 consiste el proyecto final? \u00bfCu\u00e1l es el objetivo de la aplicaci\u00f3n a desarrollar? \u00bfQu\u00e9 conceptos se utilizar\u00e1n en este proyecto? \u00bfQu\u00e9 es la gesti\u00f3n de tareas?","title":"Preguntas de repaso"},{"location":"luminus/sr/proyecto_final/#ejemplos-de-codigo-en-luminus-framework","text":"Creaci\u00f3n de una ruta en Luminus: ( defroutes app-routes ( GET \"/\" [] ( home-page )) ( POST \"/task\" [ task ] ( create-task task )) ( PUT \"/task/:id\" [ id task ] ( update-task id task )) ( DELETE \"/task/:id\" [ id ] ( delete-task id ))) Utilizaci\u00f3n de plantillas HTML en Luminus: ( defn home-page [] ( layout/common [ :h1 \"Lista de tareas\" ] [ :ul ( for [ task tasks ] [ :li [ :h3 ( :title task )] [ :p ( :description task )] [ :button { :onclick ( str \"editTask(\" ( :id task ) \")\" )} \"Editar\" ] [ :button { :onclick ( str \"deleteTask(\" ( :id task ) \")\" )} \"Eliminar\" ]])])) Acceso a una base de datos en Luminus: ( defn create-task [ task ] ( let [ new-task ( Task. ( :title task ) ( :description task ))] ( db/save new-task ))) ( defn update-task [ id task ] ( db/update! ( Task. ( :title task ) ( :description task )) id )) ( defn delete-task [ id ] ( db/delete! ( db/find-by-id Task id )))","title":"Ejemplos de c\u00f3digo en Luminus Framework"},{"location":"luminus/sr/proyecto_final/#ejercicios-practicos-con-instrucciones-claras","text":"Crear una aplicaci\u00f3n web utilizando Luminus Framework que permita gestionar una lista de tareas. La aplicaci\u00f3n debe tener las siguientes funcionalidades: Crear una nueva tarea con un t\u00edtulo y una descripci\u00f3n. Editar una tarea existente. Eliminar una tarea. Marcar una tarea como completada. Utilizar una base de datos para almacenar las tareas. Implementar un sistema de autenticaci\u00f3n de usuarios para que solo puedan acceder a la aplicaci\u00f3n aquellos que est\u00e9n registrados. A\u00f1adir validaciones en los campos de t\u00edtulo y descripci\u00f3n para evitar tareas vac\u00edas o con informaci\u00f3n incompleta.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"luminus/sr/proyecto_final/#consejos-o-mejores-practicas","text":"Antes de comenzar a desarrollar, es importante planificar y definir claramente los objetivos y funcionalidades de la aplicaci\u00f3n. Utilizar la documentaci\u00f3n oficial de Luminus para consultar dudas o encontrar soluciones a problemas. Realizar pruebas continuas durante el desarrollo para asegurarse de que todo funciona correctamente. Seguir buenas pr\u00e1cticas de programaci\u00f3n, como utilizar nombres de variables descriptivos y comentarios adecuados en el c\u00f3digo. No tener miedo de probar nuevas funcionalidades o experimentar con diferentes enfoques para resolver un problema.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix/","text":"Curso de Phoenix \u00b6 \u00a1Bienvenido(a) al curso de Phoenix ! Phoenix es un framework web escrito en Elixir que permite desarrollar aplicaciones escalables y de alto rendimiento. Este contenido se organiza en: Junior Mid Senior Explora cada nivel para aprender desde la creaci\u00f3n de un proyecto b\u00e1sico hasta temas como despliegue, seguridad, pruebas y funcionalidades avanzadas.","title":"Curso de Phoenix"},{"location":"phoenix/#curso-de-phoenix","text":"\u00a1Bienvenido(a) al curso de Phoenix ! Phoenix es un framework web escrito en Elixir que permite desarrollar aplicaciones escalables y de alto rendimiento. Este contenido se organiza en: Junior Mid Senior Explora cada nivel para aprender desde la creaci\u00f3n de un proyecto b\u00e1sico hasta temas como despliegue, seguridad, pruebas y funcionalidades avanzadas.","title":"Curso de Phoenix"},{"location":"phoenix/jr/","text":"Phoenix - Nivel Junior \u00b6 \u00a1Bienvenido/a al nivel Junior del curso de Phoenix! Aprende los fundamentos de este framework web de Elixir: Introducci\u00f3n a Phoenix Framework Instalaci\u00f3n y configuraci\u00f3n Estructura de una aplicaci\u00f3n Phoenix Creaci\u00f3n de un proyecto b\u00e1sico Rutas y controladores Vistas y templates Modelos y bases de datos Autenticaci\u00f3n y autorizaci\u00f3n Despliegue de una aplicaci\u00f3n Phoenix","title":"Phoenix - Nivel Junior"},{"location":"phoenix/jr/#phoenix-nivel-junior","text":"\u00a1Bienvenido/a al nivel Junior del curso de Phoenix! Aprende los fundamentos de este framework web de Elixir: Introducci\u00f3n a Phoenix Framework Instalaci\u00f3n y configuraci\u00f3n Estructura de una aplicaci\u00f3n Phoenix Creaci\u00f3n de un proyecto b\u00e1sico Rutas y controladores Vistas y templates Modelos y bases de datos Autenticaci\u00f3n y autorizaci\u00f3n Despliegue de una aplicaci\u00f3n Phoenix","title":"Phoenix - Nivel Junior"},{"location":"phoenix/jr/autenticaci%C3%B3n_y_autorizaci%C3%B3n/","text":"Autenticaci\u00f3n y Autorizaci\u00f3n en Phoenix \u00b6 Descripci\u00f3n del m\u00f3dulo: \u00b6 En este m\u00f3dulo aprenderemos c\u00f3mo implementar la autenticaci\u00f3n y autorizaci\u00f3n en una aplicaci\u00f3n Phoenix utilizando Guardian, una librer\u00eda de autenticaci\u00f3n y autorizaci\u00f3n para Elixir. La autenticaci\u00f3n y autorizaci\u00f3n son dos aspectos fundamentales en cualquier aplicaci\u00f3n web moderna, ya que permiten controlar el acceso a recursos y garantizar la seguridad de los datos. Explicaci\u00f3n te\u00f3rica: \u00b6 La autenticaci\u00f3n se refiere al proceso de verificar la identidad de un usuario, es decir, comprobar que el usuario es quien dice ser. Por otro lado, la autorizaci\u00f3n se encarga de determinar qu\u00e9 recursos o acciones tiene permitido un usuario una vez que ha sido autenticado. Ambos conceptos son esenciales para garantizar la seguridad de una aplicaci\u00f3n y proteger los datos de los usuarios. En el contexto de una aplicaci\u00f3n Phoenix, la autenticaci\u00f3n y autorizaci\u00f3n se pueden implementar utilizando una combinaci\u00f3n de Guardian, una librer\u00eda de autenticaci\u00f3n y autorizaci\u00f3n para Elixir, y Plug, un m\u00f3dulo de Phoenix que permite la creaci\u00f3n de middlewares para el manejo de peticiones HTTP. Palabras clave y su definici\u00f3n: \u00b6 Autenticaci\u00f3n: Proceso de verificaci\u00f3n de la identidad de un usuario. Autorizaci\u00f3n: Determinaci\u00f3n de los recursos y acciones permitidos a un usuario. Guardian: Librer\u00eda de autenticaci\u00f3n y autorizaci\u00f3n para Elixir. Plug: M\u00f3dulo de Phoenix para la creaci\u00f3n de middlewares. JWT: JSON Web Token, un est\u00e1ndar para la creaci\u00f3n de tokens de seguridad. Preguntas de repaso: \u00b6 \u00bfCu\u00e1l es la diferencia entre autenticaci\u00f3n y autorizaci\u00f3n? \u00bfQu\u00e9 librer\u00eda se utiliza en Phoenix para implementar la autenticaci\u00f3n y autorizaci\u00f3n? \u00bfQu\u00e9 es un JWT y para qu\u00e9 se utiliza en la autenticaci\u00f3n? \u00bfQu\u00e9 es un middleware y c\u00f3mo se utiliza en Phoenix? Ejemplos de c\u00f3digo en Phoenix Framework: \u00b6 A continuaci\u00f3n, se muestra un ejemplo de c\u00f3mo se puede implementar la autenticaci\u00f3n y autorizaci\u00f3n en una aplicaci\u00f3n Phoenix utilizando Guardian: En el archivo router.ex , se define un pipeline para la autenticaci\u00f3n que utilizar\u00e1 Guardian: pipeline :auth do plug Guardian.Plug.VerifyHeader plug Guardian.Plug.LoadResource plug Guardian.Plug.EnsureAuthenticated end Luego, en el archivo controllers/session_controller.ex , se pueden definir las acciones para el inicio de sesi\u00f3n y el cierre de sesi\u00f3n: def create ( conn , %{ \"email\" => email , \"password\" => password }) do case MyApp.Authenticator . authenticate ( email , password ) do { :ok , user } -> token = MyApp.Guardian . encode_and_sign ( user ) conn |> put_status ( :created ) |> render ( MyApp.SessionView , \"token.json\" , token : token ) { :error , reason } -> conn |> put_status ( :unauthorized ) |> render ( MyApp.SessionView , \"error.json\" , reason : reason ) end end def delete ( conn , _params ) do conn |> Guardian.Plug . sign_out () |> put_status ( :ok ) |> render ( MyApp.SessionView , \"delete.json\" ) end Y finalmente, en el archivo models/user.ex , se puede definir la funci\u00f3n generate_token para generar el token JWT correspondiente al usuario: def generate_token ( user ) do %{ \"id\" => user . id , \"name\" => user . name } end Ejercicios pr\u00e1cticos con instrucciones claras: \u00b6 Crea una nueva aplicaci\u00f3n Phoenix utilizando el comando mix phx.new my_app . A\u00f1ade la librer\u00eda Guardian a tu proyecto editando el archivo mix.exs y ejecutando el comando mix deps.get . Crea un nuevo endpoint para el inicio de sesi\u00f3n en el archivo router.ex utilizando el pipeline :auth y la acci\u00f3n create del controlador de sesi\u00f3n. Implementa la funci\u00f3n authenticate en el m\u00f3dulo MyApp.Authenticator para verificar las credenciales del usuario y devolver un token JWT v\u00e1lido. A\u00f1ade una ruta para el cierre de sesi\u00f3n en el archivo router.ex utilizando la acci\u00f3n delete del controlador de sesi\u00f3n. Implementa la funci\u00f3n generate_token en el modelo User para generar el token JWT correspondiente al usuario. Prueba tu implementaci\u00f3n utilizando herramientas como Postman o cURL para realizar peticiones HTTP al endpoint de inicio de sesi\u00f3n y de cierre de sesi\u00f3n. Modifica tu aplicaci\u00f3n para que solo los usuarios autenticados puedan acceder a ciertas rutas utilizando el pipeline :auth . Consejos o mejores pr\u00e1cticas: \u00b6 Utiliza un middleware como Guardian para manejar la autenticaci\u00f3n y autorizaci\u00f3n en tu aplicaci\u00f3n Phoenix, en lugar de implementar tu propia soluci\u00f3n desde cero. Aseg\u00farate de implementar las medidas de seguridad adecuadas, como el encriptado de contrase\u00f1as, para proteger las credenciales de los usuarios. Utiliza tokens JWT en lugar de sesiones para el manejo de la autenticaci\u00f3n, ya que son m\u00e1s seguros y escalables. Realiza pruebas exhaustivas para asegurarte de que tu sistema de autenticaci\u00f3n y autorizaci\u00f3n funciona correctamente y no presenta vulnerabilidades.","title":"Autenticaci\u00f3n y Autorizaci\u00f3n en Phoenix"},{"location":"phoenix/jr/autenticaci%C3%B3n_y_autorizaci%C3%B3n/#autenticacion-y-autorizacion-en-phoenix","text":"","title":"Autenticaci\u00f3n y Autorizaci\u00f3n en Phoenix"},{"location":"phoenix/jr/autenticaci%C3%B3n_y_autorizaci%C3%B3n/#descripcion-del-modulo","text":"En este m\u00f3dulo aprenderemos c\u00f3mo implementar la autenticaci\u00f3n y autorizaci\u00f3n en una aplicaci\u00f3n Phoenix utilizando Guardian, una librer\u00eda de autenticaci\u00f3n y autorizaci\u00f3n para Elixir. La autenticaci\u00f3n y autorizaci\u00f3n son dos aspectos fundamentales en cualquier aplicaci\u00f3n web moderna, ya que permiten controlar el acceso a recursos y garantizar la seguridad de los datos.","title":"Descripci\u00f3n del m\u00f3dulo:"},{"location":"phoenix/jr/autenticaci%C3%B3n_y_autorizaci%C3%B3n/#explicacion-teorica","text":"La autenticaci\u00f3n se refiere al proceso de verificar la identidad de un usuario, es decir, comprobar que el usuario es quien dice ser. Por otro lado, la autorizaci\u00f3n se encarga de determinar qu\u00e9 recursos o acciones tiene permitido un usuario una vez que ha sido autenticado. Ambos conceptos son esenciales para garantizar la seguridad de una aplicaci\u00f3n y proteger los datos de los usuarios. En el contexto de una aplicaci\u00f3n Phoenix, la autenticaci\u00f3n y autorizaci\u00f3n se pueden implementar utilizando una combinaci\u00f3n de Guardian, una librer\u00eda de autenticaci\u00f3n y autorizaci\u00f3n para Elixir, y Plug, un m\u00f3dulo de Phoenix que permite la creaci\u00f3n de middlewares para el manejo de peticiones HTTP.","title":"Explicaci\u00f3n te\u00f3rica:"},{"location":"phoenix/jr/autenticaci%C3%B3n_y_autorizaci%C3%B3n/#palabras-clave-y-su-definicion","text":"Autenticaci\u00f3n: Proceso de verificaci\u00f3n de la identidad de un usuario. Autorizaci\u00f3n: Determinaci\u00f3n de los recursos y acciones permitidos a un usuario. Guardian: Librer\u00eda de autenticaci\u00f3n y autorizaci\u00f3n para Elixir. Plug: M\u00f3dulo de Phoenix para la creaci\u00f3n de middlewares. JWT: JSON Web Token, un est\u00e1ndar para la creaci\u00f3n de tokens de seguridad.","title":"Palabras clave y su definici\u00f3n:"},{"location":"phoenix/jr/autenticaci%C3%B3n_y_autorizaci%C3%B3n/#preguntas-de-repaso","text":"\u00bfCu\u00e1l es la diferencia entre autenticaci\u00f3n y autorizaci\u00f3n? \u00bfQu\u00e9 librer\u00eda se utiliza en Phoenix para implementar la autenticaci\u00f3n y autorizaci\u00f3n? \u00bfQu\u00e9 es un JWT y para qu\u00e9 se utiliza en la autenticaci\u00f3n? \u00bfQu\u00e9 es un middleware y c\u00f3mo se utiliza en Phoenix?","title":"Preguntas de repaso:"},{"location":"phoenix/jr/autenticaci%C3%B3n_y_autorizaci%C3%B3n/#ejemplos-de-codigo-en-phoenix-framework","text":"A continuaci\u00f3n, se muestra un ejemplo de c\u00f3mo se puede implementar la autenticaci\u00f3n y autorizaci\u00f3n en una aplicaci\u00f3n Phoenix utilizando Guardian: En el archivo router.ex , se define un pipeline para la autenticaci\u00f3n que utilizar\u00e1 Guardian: pipeline :auth do plug Guardian.Plug.VerifyHeader plug Guardian.Plug.LoadResource plug Guardian.Plug.EnsureAuthenticated end Luego, en el archivo controllers/session_controller.ex , se pueden definir las acciones para el inicio de sesi\u00f3n y el cierre de sesi\u00f3n: def create ( conn , %{ \"email\" => email , \"password\" => password }) do case MyApp.Authenticator . authenticate ( email , password ) do { :ok , user } -> token = MyApp.Guardian . encode_and_sign ( user ) conn |> put_status ( :created ) |> render ( MyApp.SessionView , \"token.json\" , token : token ) { :error , reason } -> conn |> put_status ( :unauthorized ) |> render ( MyApp.SessionView , \"error.json\" , reason : reason ) end end def delete ( conn , _params ) do conn |> Guardian.Plug . sign_out () |> put_status ( :ok ) |> render ( MyApp.SessionView , \"delete.json\" ) end Y finalmente, en el archivo models/user.ex , se puede definir la funci\u00f3n generate_token para generar el token JWT correspondiente al usuario: def generate_token ( user ) do %{ \"id\" => user . id , \"name\" => user . name } end","title":"Ejemplos de c\u00f3digo en Phoenix Framework:"},{"location":"phoenix/jr/autenticaci%C3%B3n_y_autorizaci%C3%B3n/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una nueva aplicaci\u00f3n Phoenix utilizando el comando mix phx.new my_app . A\u00f1ade la librer\u00eda Guardian a tu proyecto editando el archivo mix.exs y ejecutando el comando mix deps.get . Crea un nuevo endpoint para el inicio de sesi\u00f3n en el archivo router.ex utilizando el pipeline :auth y la acci\u00f3n create del controlador de sesi\u00f3n. Implementa la funci\u00f3n authenticate en el m\u00f3dulo MyApp.Authenticator para verificar las credenciales del usuario y devolver un token JWT v\u00e1lido. A\u00f1ade una ruta para el cierre de sesi\u00f3n en el archivo router.ex utilizando la acci\u00f3n delete del controlador de sesi\u00f3n. Implementa la funci\u00f3n generate_token en el modelo User para generar el token JWT correspondiente al usuario. Prueba tu implementaci\u00f3n utilizando herramientas como Postman o cURL para realizar peticiones HTTP al endpoint de inicio de sesi\u00f3n y de cierre de sesi\u00f3n. Modifica tu aplicaci\u00f3n para que solo los usuarios autenticados puedan acceder a ciertas rutas utilizando el pipeline :auth .","title":"Ejercicios pr\u00e1cticos con instrucciones claras:"},{"location":"phoenix/jr/autenticaci%C3%B3n_y_autorizaci%C3%B3n/#consejos-o-mejores-practicas","text":"Utiliza un middleware como Guardian para manejar la autenticaci\u00f3n y autorizaci\u00f3n en tu aplicaci\u00f3n Phoenix, en lugar de implementar tu propia soluci\u00f3n desde cero. Aseg\u00farate de implementar las medidas de seguridad adecuadas, como el encriptado de contrase\u00f1as, para proteger las credenciales de los usuarios. Utiliza tokens JWT en lugar de sesiones para el manejo de la autenticaci\u00f3n, ya que son m\u00e1s seguros y escalables. Realiza pruebas exhaustivas para asegurarte de que tu sistema de autenticaci\u00f3n y autorizaci\u00f3n funciona correctamente y no presenta vulnerabilidades.","title":"Consejos o mejores pr\u00e1cticas:"},{"location":"phoenix/jr/creaci%C3%B3n_de_un_proyecto_b%C3%A1sico/","text":"Creaci\u00f3n de un proyecto b\u00e1sico en Phoenix \u00b6 El Phoenix Framework es un framework web de c\u00f3digo abierto basado en el lenguaje de programaci\u00f3n Elixir y que sigue el patr\u00f3n de arquitectura Modelo-Vista-Controlador (MVC). Este framework es ideal para el desarrollo de aplicaciones web r\u00e1pidas y escalables, gracias a su enfoque en la concurrencia y el rendimiento. Explicaci\u00f3n te\u00f3rica \u00b6 Para crear un proyecto b\u00e1sico en Phoenix, primero debemos tener instalado Elixir y el Phoenix Framework en nuestro sistema. Una vez que tengamos estos requisitos, podemos seguir los siguientes pasos: Abrir una terminal y navegar hasta el directorio en el que queramos crear nuestro proyecto. Ejecutar el comando mix phx.new nombre_del_proyecto para crear un nuevo proyecto en Phoenix. Este comando generar\u00e1 una estructura de directorios y archivos para nuestro proyecto. Navegar hasta el directorio del proyecto ( cd nombre_del_proyecto ) y ejecutar mix deps.get para instalar las dependencias del proyecto. Luego, ejecutar mix ecto.create para crear la base de datos para nuestro proyecto. Finalmente, ejecutar mix phx.server para correr el servidor local y visualizar nuestro proyecto en el navegador. Palabras clave y su definici\u00f3n \u00b6 Phoenix Framework: Framework web de c\u00f3digo abierto basado en Elixir que sigue el patr\u00f3n MVC. Elixir: Lenguaje de programaci\u00f3n funcional y din\u00e1mico que se ejecuta en la m\u00e1quina virtual de Erlang (BEAM). MVC: Patr\u00f3n de arquitectura de software que separa la aplicaci\u00f3n en modelos, vistas y controladores. Dependencias: Librer\u00edas externas necesarias para el funcionamiento de un proyecto. Base de datos: Conjunto estructurado de datos que se almacena en un sistema de gesti\u00f3n de bases de datos. Servidor local: Servidor que se ejecuta en nuestra propia computadora para acceder al proyecto en desarrollo en el navegador. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es Phoenix Framework? \u00bfQu\u00e9 patr\u00f3n de arquitectura sigue Phoenix Framework? \u00bfQu\u00e9 necesitamos tener instalado en nuestro sistema para crear un proyecto en Phoenix? \u00bfCu\u00e1les son los comandos necesarios para crear y correr un proyecto en Phoenix? \u00bfEn qu\u00e9 consiste el paso de instalaci\u00f3n de dependencias? \u00bfQu\u00e9 es una base de datos? \u00bfQu\u00e9 es un servidor local? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 Creaci\u00f3n de un controlador \u00b6 defmodule MiProyectoWeb.UserController do use MiProyectoWeb , :controller def index ( conn , _params ) do users = Repo . all ( User ) render ( conn , \"index.html\" , users : users ) end end Creaci\u00f3n de una vista \u00b6 defmodule MiProyectoWeb.UserView do use MiProyectoWeb , :view def render ( \"index.html\" , %{ users : users }) do ~H \"\"\" <ul> <%= for user <- users do %> <li><%= user.name %></li> <% end %> </ul> \"\"\" end end Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea un nuevo proyecto en Phoenix llamado \"mi_proyecto\". Agrega una vista y un controlador para mostrar una lista de usuarios en la p\u00e1gina de inicio. Crea un modelo para almacenar informaci\u00f3n de usuarios en una base de datos. Agrega una funci\u00f3n en el controlador para crear un nuevo usuario y guardarlo en la base de datos. Actualiza la vista para mostrar la lista de usuarios actualizada despu\u00e9s de crear uno nuevo. Ejecuta el servidor local y comprueba que todo funcione correctamente en el navegador. Consejos o mejores pr\u00e1cticas \u00b6 Sigue la convenci\u00f3n de nombres de Phoenix Framework para mantener una estructura clara y consistente en tu proyecto. Utiliza las migraciones de Ecto para manejar los cambios en la estructura de la base de datos. Aprovecha las ventajas de la concurrencia y el rendimiento de Elixir al desarrollar tu proyecto en Phoenix. Utiliza Phoenix LiveView para agregar interactividad a tu aplicaci\u00f3n web en tiempo real.","title":"Creaci\u00f3n de un proyecto b\u00e1sico en Phoenix"},{"location":"phoenix/jr/creaci%C3%B3n_de_un_proyecto_b%C3%A1sico/#creacion-de-un-proyecto-basico-en-phoenix","text":"El Phoenix Framework es un framework web de c\u00f3digo abierto basado en el lenguaje de programaci\u00f3n Elixir y que sigue el patr\u00f3n de arquitectura Modelo-Vista-Controlador (MVC). Este framework es ideal para el desarrollo de aplicaciones web r\u00e1pidas y escalables, gracias a su enfoque en la concurrencia y el rendimiento.","title":"Creaci\u00f3n de un proyecto b\u00e1sico en Phoenix"},{"location":"phoenix/jr/creaci%C3%B3n_de_un_proyecto_b%C3%A1sico/#explicacion-teorica","text":"Para crear un proyecto b\u00e1sico en Phoenix, primero debemos tener instalado Elixir y el Phoenix Framework en nuestro sistema. Una vez que tengamos estos requisitos, podemos seguir los siguientes pasos: Abrir una terminal y navegar hasta el directorio en el que queramos crear nuestro proyecto. Ejecutar el comando mix phx.new nombre_del_proyecto para crear un nuevo proyecto en Phoenix. Este comando generar\u00e1 una estructura de directorios y archivos para nuestro proyecto. Navegar hasta el directorio del proyecto ( cd nombre_del_proyecto ) y ejecutar mix deps.get para instalar las dependencias del proyecto. Luego, ejecutar mix ecto.create para crear la base de datos para nuestro proyecto. Finalmente, ejecutar mix phx.server para correr el servidor local y visualizar nuestro proyecto en el navegador.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix/jr/creaci%C3%B3n_de_un_proyecto_b%C3%A1sico/#palabras-clave-y-su-definicion","text":"Phoenix Framework: Framework web de c\u00f3digo abierto basado en Elixir que sigue el patr\u00f3n MVC. Elixir: Lenguaje de programaci\u00f3n funcional y din\u00e1mico que se ejecuta en la m\u00e1quina virtual de Erlang (BEAM). MVC: Patr\u00f3n de arquitectura de software que separa la aplicaci\u00f3n en modelos, vistas y controladores. Dependencias: Librer\u00edas externas necesarias para el funcionamiento de un proyecto. Base de datos: Conjunto estructurado de datos que se almacena en un sistema de gesti\u00f3n de bases de datos. Servidor local: Servidor que se ejecuta en nuestra propia computadora para acceder al proyecto en desarrollo en el navegador.","title":"Palabras clave y su definici\u00f3n"},{"location":"phoenix/jr/creaci%C3%B3n_de_un_proyecto_b%C3%A1sico/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Phoenix Framework? \u00bfQu\u00e9 patr\u00f3n de arquitectura sigue Phoenix Framework? \u00bfQu\u00e9 necesitamos tener instalado en nuestro sistema para crear un proyecto en Phoenix? \u00bfCu\u00e1les son los comandos necesarios para crear y correr un proyecto en Phoenix? \u00bfEn qu\u00e9 consiste el paso de instalaci\u00f3n de dependencias? \u00bfQu\u00e9 es una base de datos? \u00bfQu\u00e9 es un servidor local?","title":"Preguntas de repaso"},{"location":"phoenix/jr/creaci%C3%B3n_de_un_proyecto_b%C3%A1sico/#ejemplos-de-codigo-en-phoenix-framework","text":"","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix/jr/creaci%C3%B3n_de_un_proyecto_b%C3%A1sico/#creacion-de-un-controlador","text":"defmodule MiProyectoWeb.UserController do use MiProyectoWeb , :controller def index ( conn , _params ) do users = Repo . all ( User ) render ( conn , \"index.html\" , users : users ) end end","title":"Creaci\u00f3n de un controlador"},{"location":"phoenix/jr/creaci%C3%B3n_de_un_proyecto_b%C3%A1sico/#creacion-de-una-vista","text":"defmodule MiProyectoWeb.UserView do use MiProyectoWeb , :view def render ( \"index.html\" , %{ users : users }) do ~H \"\"\" <ul> <%= for user <- users do %> <li><%= user.name %></li> <% end %> </ul> \"\"\" end end","title":"Creaci\u00f3n de una vista"},{"location":"phoenix/jr/creaci%C3%B3n_de_un_proyecto_b%C3%A1sico/#ejercicios-practicos-con-instrucciones-claras","text":"Crea un nuevo proyecto en Phoenix llamado \"mi_proyecto\". Agrega una vista y un controlador para mostrar una lista de usuarios en la p\u00e1gina de inicio. Crea un modelo para almacenar informaci\u00f3n de usuarios en una base de datos. Agrega una funci\u00f3n en el controlador para crear un nuevo usuario y guardarlo en la base de datos. Actualiza la vista para mostrar la lista de usuarios actualizada despu\u00e9s de crear uno nuevo. Ejecuta el servidor local y comprueba que todo funcione correctamente en el navegador.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"phoenix/jr/creaci%C3%B3n_de_un_proyecto_b%C3%A1sico/#consejos-o-mejores-practicas","text":"Sigue la convenci\u00f3n de nombres de Phoenix Framework para mantener una estructura clara y consistente en tu proyecto. Utiliza las migraciones de Ecto para manejar los cambios en la estructura de la base de datos. Aprovecha las ventajas de la concurrencia y el rendimiento de Elixir al desarrollar tu proyecto en Phoenix. Utiliza Phoenix LiveView para agregar interactividad a tu aplicaci\u00f3n web en tiempo real.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix/jr/despliegue_de_una_aplicaci%C3%B3n_phoenix/","text":"Despliegue de una aplicaci\u00f3n Phoenix \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 Este m\u00f3dulo tiene como objetivo brindar instrucciones paso a paso para desplegar una aplicaci\u00f3n Phoenix en un servidor de producci\u00f3n. Comenzaremos con una explicaci\u00f3n te\u00f3rica de los conceptos clave, seguida de preguntas de repaso para evaluar la comprensi\u00f3n. Tambi\u00e9n incluiremos ejemplos de c\u00f3digo en Phoenix Framework y ejercicios pr\u00e1cticos con instrucciones claras para reforzar el aprendizaje. Finalmente, compartiremos algunos consejos y mejores pr\u00e1cticas para un despliegue exitoso. Explicaci\u00f3n te\u00f3rica \u00b6 El despliegue de una aplicaci\u00f3n Phoenix implica ponerla en funcionamiento en un servidor web para que los usuarios puedan acceder a ella. Para ello, es necesario seguir una serie de pasos que incluyen la configuraci\u00f3n del servidor, la compilaci\u00f3n de la aplicaci\u00f3n y la configuraci\u00f3n de la base de datos. A continuaci\u00f3n, se detallan los pasos principales para desplegar una aplicaci\u00f3n Phoenix: Configuraci\u00f3n del servidor: para desplegar una aplicaci\u00f3n Phoenix, se necesita un servidor web que pueda ejecutar aplicaciones Elixir/Phoenix. Algunas opciones populares son Nginx, Apache o Cowboy. Es importante asegurarse de que el servidor tenga instalado Erlang y Elixir antes de comenzar el proceso de despliegue. Compilaci\u00f3n de la aplicaci\u00f3n: despu\u00e9s de configurar el servidor, se debe compilar la aplicaci\u00f3n Phoenix. Esto implica ejecutar los comandos mix deps.get y mix compile para instalar las dependencias y compilar el c\u00f3digo de la aplicaci\u00f3n. Configuraci\u00f3n de la base de datos: si la aplicaci\u00f3n utiliza una base de datos, es necesario configurarla en el servidor de producci\u00f3n. Esto implica crear una nueva base de datos y configurar las credenciales de acceso para la aplicaci\u00f3n. Configuraci\u00f3n del entorno: antes de iniciar la aplicaci\u00f3n, es importante configurar el entorno en el servidor de producci\u00f3n. Esto incluye definir variables de entorno, como la clave secreta de la aplicaci\u00f3n y la URL del servidor. Iniciar la aplicaci\u00f3n: una vez que todo est\u00e1 configurado, se puede iniciar la aplicaci\u00f3n Phoenix con el comando mix phx.server . Esto pondr\u00e1 en marcha la aplicaci\u00f3n en el servidor web y estar\u00e1 lista para recibir peticiones de los usuarios. Palabras clave y su definici\u00f3n \u00b6 Despliegue: proceso de poner en funcionamiento una aplicaci\u00f3n en un servidor de producci\u00f3n. Servidor web: software que permite el acceso a una aplicaci\u00f3n a trav\u00e9s de Internet. Configuraci\u00f3n: ajustes y cambios necesarios para que una aplicaci\u00f3n funcione correctamente. Compilaci\u00f3n: proceso de transformar el c\u00f3digo fuente de una aplicaci\u00f3n en un ejecutable. Dependencias: software o bibliotecas necesarias para que una aplicaci\u00f3n funcione. Base de datos: sistema de almacenamiento de datos utilizado por una aplicaci\u00f3n. Entorno: configuraci\u00f3n de variables y ajustes espec\u00edficos para una aplicaci\u00f3n en un servidor de producci\u00f3n. Peticiones: solicitudes realizadas por los usuarios a una aplicaci\u00f3n. Preguntas de repaso \u00b6 \u00bfCu\u00e1les son los pasos principales para desplegar una aplicaci\u00f3n Phoenix? \u00bfQu\u00e9 es un servidor web y por qu\u00e9 es necesario para el despliegue de una aplicaci\u00f3n Phoenix? \u00bfQu\u00e9 es la compilaci\u00f3n de una aplicaci\u00f3n y por qu\u00e9 es importante antes del despliegue? \u00bfCu\u00e1l es la diferencia entre una dependencia y una base de datos? \u00bfQu\u00e9 es el entorno de una aplicaci\u00f3n y por qu\u00e9 es necesario configurarlo antes del despliegue? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 A continuaci\u00f3n se muestra un ejemplo de archivo de configuraci\u00f3n para un servidor Nginx que sirve una aplicaci\u00f3n Phoenix: server { listen 80 ; server_name example . com ; location / { proxy_pass http :/ / localhost : 4000 ; proxy_http_version 1.1 ; proxy_set_header Upgrade $ http_upgrade ; proxy_set_header Connection \"Upgrade\" ; } } Este archivo redirige todas las solicitudes a la aplicaci\u00f3n Phoenix que se est\u00e1 ejecutando en el puerto 4000. Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Configurar un servidor web en el servidor de producci\u00f3n. Compilar la aplicaci\u00f3n Phoenix en el servidor. Configurar la base de datos en el servidor de producci\u00f3n. Definir las variables de entorno necesarias para la aplicaci\u00f3n en el servidor. Iniciar la aplicaci\u00f3n en el servidor web. Consejos o mejores pr\u00e1cticas \u00b6 Realizar pruebas exhaustivas en un entorno de desarrollo antes de desplegar en producci\u00f3n. Utilizar un sistema de control de versiones para gestionar los cambios en el c\u00f3digo de la aplicaci\u00f3n. Configurar un sistema de monitoreo para detectar y solucionar problemas de manera r\u00e1pida. Realizar copias de seguridad regularmente para evitar la p\u00e9rdida de datos en caso de alg\u00fan error en el servidor. Mantener actualizadas las dependencias y el software del servidor para garantizar la seguridad y el rendimiento de la aplicaci\u00f3n.","title":"Despliegue de una aplicaci\u00f3n Phoenix"},{"location":"phoenix/jr/despliegue_de_una_aplicaci%C3%B3n_phoenix/#despliegue-de-una-aplicacion-phoenix","text":"","title":"Despliegue de una aplicaci\u00f3n Phoenix"},{"location":"phoenix/jr/despliegue_de_una_aplicaci%C3%B3n_phoenix/#descripcion-del-modulo","text":"Este m\u00f3dulo tiene como objetivo brindar instrucciones paso a paso para desplegar una aplicaci\u00f3n Phoenix en un servidor de producci\u00f3n. Comenzaremos con una explicaci\u00f3n te\u00f3rica de los conceptos clave, seguida de preguntas de repaso para evaluar la comprensi\u00f3n. Tambi\u00e9n incluiremos ejemplos de c\u00f3digo en Phoenix Framework y ejercicios pr\u00e1cticos con instrucciones claras para reforzar el aprendizaje. Finalmente, compartiremos algunos consejos y mejores pr\u00e1cticas para un despliegue exitoso.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"phoenix/jr/despliegue_de_una_aplicaci%C3%B3n_phoenix/#explicacion-teorica","text":"El despliegue de una aplicaci\u00f3n Phoenix implica ponerla en funcionamiento en un servidor web para que los usuarios puedan acceder a ella. Para ello, es necesario seguir una serie de pasos que incluyen la configuraci\u00f3n del servidor, la compilaci\u00f3n de la aplicaci\u00f3n y la configuraci\u00f3n de la base de datos. A continuaci\u00f3n, se detallan los pasos principales para desplegar una aplicaci\u00f3n Phoenix: Configuraci\u00f3n del servidor: para desplegar una aplicaci\u00f3n Phoenix, se necesita un servidor web que pueda ejecutar aplicaciones Elixir/Phoenix. Algunas opciones populares son Nginx, Apache o Cowboy. Es importante asegurarse de que el servidor tenga instalado Erlang y Elixir antes de comenzar el proceso de despliegue. Compilaci\u00f3n de la aplicaci\u00f3n: despu\u00e9s de configurar el servidor, se debe compilar la aplicaci\u00f3n Phoenix. Esto implica ejecutar los comandos mix deps.get y mix compile para instalar las dependencias y compilar el c\u00f3digo de la aplicaci\u00f3n. Configuraci\u00f3n de la base de datos: si la aplicaci\u00f3n utiliza una base de datos, es necesario configurarla en el servidor de producci\u00f3n. Esto implica crear una nueva base de datos y configurar las credenciales de acceso para la aplicaci\u00f3n. Configuraci\u00f3n del entorno: antes de iniciar la aplicaci\u00f3n, es importante configurar el entorno en el servidor de producci\u00f3n. Esto incluye definir variables de entorno, como la clave secreta de la aplicaci\u00f3n y la URL del servidor. Iniciar la aplicaci\u00f3n: una vez que todo est\u00e1 configurado, se puede iniciar la aplicaci\u00f3n Phoenix con el comando mix phx.server . Esto pondr\u00e1 en marcha la aplicaci\u00f3n en el servidor web y estar\u00e1 lista para recibir peticiones de los usuarios.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix/jr/despliegue_de_una_aplicaci%C3%B3n_phoenix/#palabras-clave-y-su-definicion","text":"Despliegue: proceso de poner en funcionamiento una aplicaci\u00f3n en un servidor de producci\u00f3n. Servidor web: software que permite el acceso a una aplicaci\u00f3n a trav\u00e9s de Internet. Configuraci\u00f3n: ajustes y cambios necesarios para que una aplicaci\u00f3n funcione correctamente. Compilaci\u00f3n: proceso de transformar el c\u00f3digo fuente de una aplicaci\u00f3n en un ejecutable. Dependencias: software o bibliotecas necesarias para que una aplicaci\u00f3n funcione. Base de datos: sistema de almacenamiento de datos utilizado por una aplicaci\u00f3n. Entorno: configuraci\u00f3n de variables y ajustes espec\u00edficos para una aplicaci\u00f3n en un servidor de producci\u00f3n. Peticiones: solicitudes realizadas por los usuarios a una aplicaci\u00f3n.","title":"Palabras clave y su definici\u00f3n"},{"location":"phoenix/jr/despliegue_de_una_aplicaci%C3%B3n_phoenix/#preguntas-de-repaso","text":"\u00bfCu\u00e1les son los pasos principales para desplegar una aplicaci\u00f3n Phoenix? \u00bfQu\u00e9 es un servidor web y por qu\u00e9 es necesario para el despliegue de una aplicaci\u00f3n Phoenix? \u00bfQu\u00e9 es la compilaci\u00f3n de una aplicaci\u00f3n y por qu\u00e9 es importante antes del despliegue? \u00bfCu\u00e1l es la diferencia entre una dependencia y una base de datos? \u00bfQu\u00e9 es el entorno de una aplicaci\u00f3n y por qu\u00e9 es necesario configurarlo antes del despliegue?","title":"Preguntas de repaso"},{"location":"phoenix/jr/despliegue_de_una_aplicaci%C3%B3n_phoenix/#ejemplos-de-codigo-en-phoenix-framework","text":"A continuaci\u00f3n se muestra un ejemplo de archivo de configuraci\u00f3n para un servidor Nginx que sirve una aplicaci\u00f3n Phoenix: server { listen 80 ; server_name example . com ; location / { proxy_pass http :/ / localhost : 4000 ; proxy_http_version 1.1 ; proxy_set_header Upgrade $ http_upgrade ; proxy_set_header Connection \"Upgrade\" ; } } Este archivo redirige todas las solicitudes a la aplicaci\u00f3n Phoenix que se est\u00e1 ejecutando en el puerto 4000.","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix/jr/despliegue_de_una_aplicaci%C3%B3n_phoenix/#ejercicios-practicos-con-instrucciones-claras","text":"Configurar un servidor web en el servidor de producci\u00f3n. Compilar la aplicaci\u00f3n Phoenix en el servidor. Configurar la base de datos en el servidor de producci\u00f3n. Definir las variables de entorno necesarias para la aplicaci\u00f3n en el servidor. Iniciar la aplicaci\u00f3n en el servidor web.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"phoenix/jr/despliegue_de_una_aplicaci%C3%B3n_phoenix/#consejos-o-mejores-practicas","text":"Realizar pruebas exhaustivas en un entorno de desarrollo antes de desplegar en producci\u00f3n. Utilizar un sistema de control de versiones para gestionar los cambios en el c\u00f3digo de la aplicaci\u00f3n. Configurar un sistema de monitoreo para detectar y solucionar problemas de manera r\u00e1pida. Realizar copias de seguridad regularmente para evitar la p\u00e9rdida de datos en caso de alg\u00fan error en el servidor. Mantener actualizadas las dependencias y el software del servidor para garantizar la seguridad y el rendimiento de la aplicaci\u00f3n.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix/jr/estructura_de_una_aplicaci%C3%B3n_phoenix/","text":"Estructura de una aplicaci\u00f3n Phoenix \u00b6 La estructura de una aplicaci\u00f3n Phoenix es uno de los aspectos m\u00e1s importantes a entender para poder desarrollar de manera efectiva con este framework. Phoenix sigue una estructura de convenci\u00f3n sobre configuraci\u00f3n, lo que significa que hay una manera predeterminada de organizar los archivos y carpetas de una aplicaci\u00f3n Phoenix, aunque se pueden realizar cambios si es necesario. Explicaci\u00f3n te\u00f3rica \u00b6 La estructura de una aplicaci\u00f3n Phoenix se basa en el patr\u00f3n de dise\u00f1o Modelo-Vista-Controlador (MVC), que separa la l\u00f3gica de la aplicaci\u00f3n en tres partes: el modelo, la vista y el controlador. El modelo se encarga de interactuar con la base de datos y manejar los datos de la aplicaci\u00f3n, mientras que la vista se encarga de mostrar la informaci\u00f3n al usuario. El controlador act\u00faa como intermediario entre el modelo y la vista, procesando las solicitudes del usuario y enviando los datos necesarios a la vista. Adem\u00e1s de los tres componentes principales, una aplicaci\u00f3n Phoenix tambi\u00e9n cuenta con otros directorios y archivos importantes, como las rutas, los modelos de base de datos, las migraciones y los controladores. Palabras clave y su definici\u00f3n \u00b6 MVC: Modelo-Vista-Controlador, un patr\u00f3n de dise\u00f1o de software que separa la l\u00f3gica de una aplicaci\u00f3n en tres partes principales: el modelo, la vista y el controlador. Rutas: Definen las URL y las acciones correspondientes en el controlador para manejar las solicitudes del usuario. Modelos de base de datos: Representan las entidades de la aplicaci\u00f3n y se encargan de interactuar con la base de datos. Migraciones: Archivos que permiten realizar cambios en la estructura de la base de datos. Controladores: Se encargan de procesar las solicitudes del usuario y enviar los datos necesarios a la vista. Vistas: Son las encargadas de mostrar la informaci\u00f3n al usuario, generalmente en formato HTML. Ecto: Biblioteca de mapeo objeto-relacional utilizada en Phoenix para interactuar con la base de datos. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es MVC y c\u00f3mo se relaciona con la estructura de una aplicaci\u00f3n Phoenix? \u00bfCu\u00e1les son los componentes principales de una aplicaci\u00f3n Phoenix? \u00bfQu\u00e9 son las rutas y cu\u00e1l es su funci\u00f3n en una aplicaci\u00f3n Phoenix? \u00bfCu\u00e1l es el prop\u00f3sito de los modelos de base de datos en una aplicaci\u00f3n Phoenix? \u00bfQu\u00e9 son las migraciones y por qu\u00e9 son importantes en una aplicaci\u00f3n Phoenix? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 Definici\u00f3n de una ruta en el archivo router.ex : get \"/users\", UserController, :index Creaci\u00f3n de un modelo de base de datos en Phoenix: defmodule MyApp . User do use Ecto . Schema import Ecto.Changeset schema \"users\" do field : name , : string field : email , : string field : age , : integer end def changeset ( user , params \\\\ % {}) do user |> cast ( params , [: name , : email , : age ]) |> validate_required ([: name , : email , : age ]) |> validate_format (: email , ~ r /@/ ) end end Creaci\u00f3n de una migraci\u00f3n en Phoenix: defmodule MyApp . Repo . Migrations . CreateUsers do use Ecto . Migration def change do create table ( : users ) do add : name , : string add : email , : string add : age , : integer timestamps () end end end Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una nueva aplicaci\u00f3n Phoenix utilizando el comando mix phx.new my_app . Agrega una nueva ruta en el archivo router.ex que maneje la solicitud GET /posts . Crea un modelo de base de datos para la entidad \"post\" con los campos title , content y author . Agrega una migraci\u00f3n para crear la tabla correspondiente en la base de datos. Crea un controlador para manejar las solicitudes relacionadas con los posts. En el controlador, define una acci\u00f3n index que obtenga todos los posts de la base de datos y los env\u00ede a una vista para mostrarlos. Crea una vista para mostrar los posts en formato HTML. Agrega un enlace en la p\u00e1gina principal de la aplicaci\u00f3n que redirija al usuario a la p\u00e1gina de posts. Ejecuta la aplicaci\u00f3n y comprueba que los posts se muestren correctamente en la vista. Consejos o mejores pr\u00e1cticas \u00b6 Sigue la convenci\u00f3n sobre configuraci\u00f3n de Phoenix y mant\u00e9n la estructura de la aplicaci\u00f3n lo m\u00e1s limpia y organizada posible. Utiliza nombres descriptivos para las rutas, modelos, controladores y vistas. Divide la l\u00f3gica de la aplicaci\u00f3n en peque\u00f1as acciones en lugar de crear controladores con demasiadas acciones. Utiliza migraciones para realizar cambios en la estructura de la base de datos y evita modificarla manualmente. Investiga sobre los diferentes generadores y herramientas disponibles en Phoenix para agilizar el desarrollo. Utiliza Ecto para realizar consultas a la base de datos en lugar de escribir consultas SQL directamente. Utiliza el archivo config.exs para configurar opciones globales de la aplicaci\u00f3n. Lee la documentaci\u00f3n oficial de Phoenix para aprender m\u00e1s sobre la estructura y las mejores pr\u00e1cticas de desarrollo.","title":"Estructura de una aplicaci\u00f3n phoenix"},{"location":"phoenix/jr/estructura_de_una_aplicaci%C3%B3n_phoenix/#estructura-de-una-aplicacion-phoenix","text":"La estructura de una aplicaci\u00f3n Phoenix es uno de los aspectos m\u00e1s importantes a entender para poder desarrollar de manera efectiva con este framework. Phoenix sigue una estructura de convenci\u00f3n sobre configuraci\u00f3n, lo que significa que hay una manera predeterminada de organizar los archivos y carpetas de una aplicaci\u00f3n Phoenix, aunque se pueden realizar cambios si es necesario.","title":"Estructura de una aplicaci\u00f3n Phoenix"},{"location":"phoenix/jr/estructura_de_una_aplicaci%C3%B3n_phoenix/#explicacion-teorica","text":"La estructura de una aplicaci\u00f3n Phoenix se basa en el patr\u00f3n de dise\u00f1o Modelo-Vista-Controlador (MVC), que separa la l\u00f3gica de la aplicaci\u00f3n en tres partes: el modelo, la vista y el controlador. El modelo se encarga de interactuar con la base de datos y manejar los datos de la aplicaci\u00f3n, mientras que la vista se encarga de mostrar la informaci\u00f3n al usuario. El controlador act\u00faa como intermediario entre el modelo y la vista, procesando las solicitudes del usuario y enviando los datos necesarios a la vista. Adem\u00e1s de los tres componentes principales, una aplicaci\u00f3n Phoenix tambi\u00e9n cuenta con otros directorios y archivos importantes, como las rutas, los modelos de base de datos, las migraciones y los controladores.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix/jr/estructura_de_una_aplicaci%C3%B3n_phoenix/#palabras-clave-y-su-definicion","text":"MVC: Modelo-Vista-Controlador, un patr\u00f3n de dise\u00f1o de software que separa la l\u00f3gica de una aplicaci\u00f3n en tres partes principales: el modelo, la vista y el controlador. Rutas: Definen las URL y las acciones correspondientes en el controlador para manejar las solicitudes del usuario. Modelos de base de datos: Representan las entidades de la aplicaci\u00f3n y se encargan de interactuar con la base de datos. Migraciones: Archivos que permiten realizar cambios en la estructura de la base de datos. Controladores: Se encargan de procesar las solicitudes del usuario y enviar los datos necesarios a la vista. Vistas: Son las encargadas de mostrar la informaci\u00f3n al usuario, generalmente en formato HTML. Ecto: Biblioteca de mapeo objeto-relacional utilizada en Phoenix para interactuar con la base de datos.","title":"Palabras clave y su definici\u00f3n"},{"location":"phoenix/jr/estructura_de_una_aplicaci%C3%B3n_phoenix/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es MVC y c\u00f3mo se relaciona con la estructura de una aplicaci\u00f3n Phoenix? \u00bfCu\u00e1les son los componentes principales de una aplicaci\u00f3n Phoenix? \u00bfQu\u00e9 son las rutas y cu\u00e1l es su funci\u00f3n en una aplicaci\u00f3n Phoenix? \u00bfCu\u00e1l es el prop\u00f3sito de los modelos de base de datos en una aplicaci\u00f3n Phoenix? \u00bfQu\u00e9 son las migraciones y por qu\u00e9 son importantes en una aplicaci\u00f3n Phoenix?","title":"Preguntas de repaso"},{"location":"phoenix/jr/estructura_de_una_aplicaci%C3%B3n_phoenix/#ejemplos-de-codigo-en-phoenix-framework","text":"Definici\u00f3n de una ruta en el archivo router.ex : get \"/users\", UserController, :index Creaci\u00f3n de un modelo de base de datos en Phoenix: defmodule MyApp . User do use Ecto . Schema import Ecto.Changeset schema \"users\" do field : name , : string field : email , : string field : age , : integer end def changeset ( user , params \\\\ % {}) do user |> cast ( params , [: name , : email , : age ]) |> validate_required ([: name , : email , : age ]) |> validate_format (: email , ~ r /@/ ) end end Creaci\u00f3n de una migraci\u00f3n en Phoenix: defmodule MyApp . Repo . Migrations . CreateUsers do use Ecto . Migration def change do create table ( : users ) do add : name , : string add : email , : string add : age , : integer timestamps () end end end","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix/jr/estructura_de_una_aplicaci%C3%B3n_phoenix/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una nueva aplicaci\u00f3n Phoenix utilizando el comando mix phx.new my_app . Agrega una nueva ruta en el archivo router.ex que maneje la solicitud GET /posts . Crea un modelo de base de datos para la entidad \"post\" con los campos title , content y author . Agrega una migraci\u00f3n para crear la tabla correspondiente en la base de datos. Crea un controlador para manejar las solicitudes relacionadas con los posts. En el controlador, define una acci\u00f3n index que obtenga todos los posts de la base de datos y los env\u00ede a una vista para mostrarlos. Crea una vista para mostrar los posts en formato HTML. Agrega un enlace en la p\u00e1gina principal de la aplicaci\u00f3n que redirija al usuario a la p\u00e1gina de posts. Ejecuta la aplicaci\u00f3n y comprueba que los posts se muestren correctamente en la vista.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"phoenix/jr/estructura_de_una_aplicaci%C3%B3n_phoenix/#consejos-o-mejores-practicas","text":"Sigue la convenci\u00f3n sobre configuraci\u00f3n de Phoenix y mant\u00e9n la estructura de la aplicaci\u00f3n lo m\u00e1s limpia y organizada posible. Utiliza nombres descriptivos para las rutas, modelos, controladores y vistas. Divide la l\u00f3gica de la aplicaci\u00f3n en peque\u00f1as acciones en lugar de crear controladores con demasiadas acciones. Utiliza migraciones para realizar cambios en la estructura de la base de datos y evita modificarla manualmente. Investiga sobre los diferentes generadores y herramientas disponibles en Phoenix para agilizar el desarrollo. Utiliza Ecto para realizar consultas a la base de datos en lugar de escribir consultas SQL directamente. Utiliza el archivo config.exs para configurar opciones globales de la aplicaci\u00f3n. Lee la documentaci\u00f3n oficial de Phoenix para aprender m\u00e1s sobre la estructura y las mejores pr\u00e1cticas de desarrollo.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix/jr/instalaci%C3%B3n_y_configuraci%C3%B3n/","text":"Instalaci\u00f3n y configuraci\u00f3n de Phoenix Framework \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 Phoenix Framework es un framework web de c\u00f3digo abierto escrito en el lenguaje de programaci\u00f3n Elixir. Est\u00e1 dise\u00f1ado para crear aplicaciones web escalables y de alto rendimiento utilizando el patr\u00f3n de arquitectura Modelo-Vista-Controlador (MVC). Phoenix se basa en el lenguaje de programaci\u00f3n funcional Elixir y se ejecuta en la m\u00e1quina virtual de Erlang (BEAM), lo que le brinda una gran estabilidad y tolerancia a fallos. Phoenix Framework proporciona una estructura s\u00f3lida y un conjunto de herramientas para el desarrollo de aplicaciones web, incluyendo un enrutador de URL, un sistema de plantillas, un ORM (Object Relational Mapper) para interactuar con bases de datos, y un sistema de autenticaci\u00f3n. Tambi\u00e9n es altamente extensible y permite integrar f\u00e1cilmente otras herramientas y librer\u00edas. Palabras clave y su definici\u00f3n \u00b6 Phoenix Framework: Framework web de c\u00f3digo abierto basado en Elixir y la m\u00e1quina virtual de Erlang (BEAM). Elixir: Lenguaje de programaci\u00f3n funcional que se ejecuta en la m\u00e1quina virtual de Erlang (BEAM). MVC: Patr\u00f3n de arquitectura Modelo-Vista-Controlador utilizado en el desarrollo de aplicaciones web. ORM: Object Relational Mapper, herramienta que permite interactuar con bases de datos utilizando objetos en lugar de consultas SQL. Enrutador de URL: Sistema que se encarga de dirigir las solicitudes HTTP a las acciones correspondientes en la aplicaci\u00f3n. Sistema de plantillas: Herramienta que permite generar contenido HTML din\u00e1mico utilizando marcado y lenguaje de programaci\u00f3n. Autenticaci\u00f3n: Proceso de verificaci\u00f3n de la identidad de un usuario para acceder a una aplicaci\u00f3n o sistema. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es Phoenix Framework y en qu\u00e9 lenguaje est\u00e1 escrito? \u00bfQu\u00e9 patr\u00f3n de arquitectura utiliza Phoenix Framework? \u00bfQu\u00e9 es un ORM y para qu\u00e9 se utiliza? \u00bfCu\u00e1l es la funci\u00f3n del enrutador de URL en una aplicaci\u00f3n web? \u00bfQu\u00e9 herramienta permite generar contenido HTML din\u00e1mico en Phoenix Framework? \u00bfCu\u00e1l es el proceso de verificaci\u00f3n de la identidad de un usuario en una aplicaci\u00f3n? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 Creaci\u00f3n de una ruta en el enrutador de URL: get \"/users\" , UserController , :index Creaci\u00f3n de una acci\u00f3n en el controlador de usuarios: def index ( conn , _params ) do users = Repo . all ( User ) render ( conn , \"index.html\" , users : users ) end Utilizaci\u00f3n de una plantilla para mostrar los usuarios en una vista: < %= for user < - @ users do % > < p > < %= user.name %> </ p > < % end %> Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Instalaci\u00f3n de Phoenix Framework: Descargar e instalar Elixir y Erlang en tu sistema. Abrir una terminal y ejecutar el comando mix archive.install hex phx_new para instalar el generador de proyectos de Phoenix. Crear un nuevo proyecto con el comando mix phx.new my_app y seguir las instrucciones para configurar la base de datos y otras opciones. Ejecutar mix deps.get para instalar las dependencias del proyecto. Ejecutar mix ecto.create para crear la base de datos. Ejecutar mix phx.server para iniciar el servidor web. Creaci\u00f3n de una ruta y una acci\u00f3n en el controlador: En el archivo lib/my_app_web/router.ex , agregar la siguiente l\u00ednea dentro del bloque scope \"/api\", MyAppWeb do : get \"/products\" , ProductController , :index En el archivo lib/my_app_web/controllers/product_controller.ex , agregar la siguiente acci\u00f3n: def index ( conn , _params ) do products = Repo . all ( Product ) render ( conn , \"index.json\" , products : products ) end Utilizaci\u00f3n de una plantilla para mostrar los productos en una vista: En el archivo lib/my_app_web/templates/product/index.html.eex , agregar el siguiente c\u00f3digo: < %= for product < - @ products do % > < p > < %= product.name %> </ p > < % end %> Creaci\u00f3n de un modelo y migraci\u00f3n para la tabla de productos: Ejecutar mix ecto.gen.migration create_products para generar el archivo de migraci\u00f3n. En el archivo generado, agregar las columnas deseadas a la tabla de productos. Ejecutar mix ecto.migrate para aplicar la migraci\u00f3n a la base de datos. En el archivo lib/my_app/product.ex , agregar las especificaciones del modelo de producto. Consejos o mejores pr\u00e1cticas \u00b6 Familiarizarse con el lenguaje de programaci\u00f3n Elixir antes de utilizar Phoenix Framework. Utilizar las convenciones y estructuras recomendadas por Phoenix para mantener una aplicaci\u00f3n bien organizada y f\u00e1cil de mantener. Aprovechar las funcionalidades de enrutamiento y plantillas para facilitar la creaci\u00f3n de rutas y vistas en la aplicaci\u00f3n. Utilizar librer\u00edas y herramientas recomendadas por la comunidad para extender las funcionalidades de Phoenix. Realizar pruebas unitarias y de integraci\u00f3n para asegurar el correcto funcionamiento de la aplicaci\u00f3n.","title":"Instalaci\u00f3n y configuraci\u00f3n de Phoenix Framework"},{"location":"phoenix/jr/instalaci%C3%B3n_y_configuraci%C3%B3n/#instalacion-y-configuracion-de-phoenix-framework","text":"","title":"Instalaci\u00f3n y configuraci\u00f3n de Phoenix Framework"},{"location":"phoenix/jr/instalaci%C3%B3n_y_configuraci%C3%B3n/#explicacion-teorica","text":"Phoenix Framework es un framework web de c\u00f3digo abierto escrito en el lenguaje de programaci\u00f3n Elixir. Est\u00e1 dise\u00f1ado para crear aplicaciones web escalables y de alto rendimiento utilizando el patr\u00f3n de arquitectura Modelo-Vista-Controlador (MVC). Phoenix se basa en el lenguaje de programaci\u00f3n funcional Elixir y se ejecuta en la m\u00e1quina virtual de Erlang (BEAM), lo que le brinda una gran estabilidad y tolerancia a fallos. Phoenix Framework proporciona una estructura s\u00f3lida y un conjunto de herramientas para el desarrollo de aplicaciones web, incluyendo un enrutador de URL, un sistema de plantillas, un ORM (Object Relational Mapper) para interactuar con bases de datos, y un sistema de autenticaci\u00f3n. Tambi\u00e9n es altamente extensible y permite integrar f\u00e1cilmente otras herramientas y librer\u00edas.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix/jr/instalaci%C3%B3n_y_configuraci%C3%B3n/#palabras-clave-y-su-definicion","text":"Phoenix Framework: Framework web de c\u00f3digo abierto basado en Elixir y la m\u00e1quina virtual de Erlang (BEAM). Elixir: Lenguaje de programaci\u00f3n funcional que se ejecuta en la m\u00e1quina virtual de Erlang (BEAM). MVC: Patr\u00f3n de arquitectura Modelo-Vista-Controlador utilizado en el desarrollo de aplicaciones web. ORM: Object Relational Mapper, herramienta que permite interactuar con bases de datos utilizando objetos en lugar de consultas SQL. Enrutador de URL: Sistema que se encarga de dirigir las solicitudes HTTP a las acciones correspondientes en la aplicaci\u00f3n. Sistema de plantillas: Herramienta que permite generar contenido HTML din\u00e1mico utilizando marcado y lenguaje de programaci\u00f3n. Autenticaci\u00f3n: Proceso de verificaci\u00f3n de la identidad de un usuario para acceder a una aplicaci\u00f3n o sistema.","title":"Palabras clave y su definici\u00f3n"},{"location":"phoenix/jr/instalaci%C3%B3n_y_configuraci%C3%B3n/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Phoenix Framework y en qu\u00e9 lenguaje est\u00e1 escrito? \u00bfQu\u00e9 patr\u00f3n de arquitectura utiliza Phoenix Framework? \u00bfQu\u00e9 es un ORM y para qu\u00e9 se utiliza? \u00bfCu\u00e1l es la funci\u00f3n del enrutador de URL en una aplicaci\u00f3n web? \u00bfQu\u00e9 herramienta permite generar contenido HTML din\u00e1mico en Phoenix Framework? \u00bfCu\u00e1l es el proceso de verificaci\u00f3n de la identidad de un usuario en una aplicaci\u00f3n?","title":"Preguntas de repaso"},{"location":"phoenix/jr/instalaci%C3%B3n_y_configuraci%C3%B3n/#ejemplos-de-codigo-en-phoenix-framework","text":"Creaci\u00f3n de una ruta en el enrutador de URL: get \"/users\" , UserController , :index Creaci\u00f3n de una acci\u00f3n en el controlador de usuarios: def index ( conn , _params ) do users = Repo . all ( User ) render ( conn , \"index.html\" , users : users ) end Utilizaci\u00f3n de una plantilla para mostrar los usuarios en una vista: < %= for user < - @ users do % > < p > < %= user.name %> </ p > < % end %>","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix/jr/instalaci%C3%B3n_y_configuraci%C3%B3n/#ejercicios-practicos-con-instrucciones-claras","text":"Instalaci\u00f3n de Phoenix Framework: Descargar e instalar Elixir y Erlang en tu sistema. Abrir una terminal y ejecutar el comando mix archive.install hex phx_new para instalar el generador de proyectos de Phoenix. Crear un nuevo proyecto con el comando mix phx.new my_app y seguir las instrucciones para configurar la base de datos y otras opciones. Ejecutar mix deps.get para instalar las dependencias del proyecto. Ejecutar mix ecto.create para crear la base de datos. Ejecutar mix phx.server para iniciar el servidor web. Creaci\u00f3n de una ruta y una acci\u00f3n en el controlador: En el archivo lib/my_app_web/router.ex , agregar la siguiente l\u00ednea dentro del bloque scope \"/api\", MyAppWeb do : get \"/products\" , ProductController , :index En el archivo lib/my_app_web/controllers/product_controller.ex , agregar la siguiente acci\u00f3n: def index ( conn , _params ) do products = Repo . all ( Product ) render ( conn , \"index.json\" , products : products ) end Utilizaci\u00f3n de una plantilla para mostrar los productos en una vista: En el archivo lib/my_app_web/templates/product/index.html.eex , agregar el siguiente c\u00f3digo: < %= for product < - @ products do % > < p > < %= product.name %> </ p > < % end %> Creaci\u00f3n de un modelo y migraci\u00f3n para la tabla de productos: Ejecutar mix ecto.gen.migration create_products para generar el archivo de migraci\u00f3n. En el archivo generado, agregar las columnas deseadas a la tabla de productos. Ejecutar mix ecto.migrate para aplicar la migraci\u00f3n a la base de datos. En el archivo lib/my_app/product.ex , agregar las especificaciones del modelo de producto.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"phoenix/jr/instalaci%C3%B3n_y_configuraci%C3%B3n/#consejos-o-mejores-practicas","text":"Familiarizarse con el lenguaje de programaci\u00f3n Elixir antes de utilizar Phoenix Framework. Utilizar las convenciones y estructuras recomendadas por Phoenix para mantener una aplicaci\u00f3n bien organizada y f\u00e1cil de mantener. Aprovechar las funcionalidades de enrutamiento y plantillas para facilitar la creaci\u00f3n de rutas y vistas en la aplicaci\u00f3n. Utilizar librer\u00edas y herramientas recomendadas por la comunidad para extender las funcionalidades de Phoenix. Realizar pruebas unitarias y de integraci\u00f3n para asegurar el correcto funcionamiento de la aplicaci\u00f3n.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix/jr/introducci%C3%B3n_a_phoenix_framework/","text":"Introducci\u00f3n a Phoenix Framework \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 Phoenix Framework es un framework de desarrollo web de c\u00f3digo abierto basado en el lenguaje de programaci\u00f3n Elixir. Fue creado por Chris McCord en 2014 y est\u00e1 inspirado en el framework Ruby on Rails, aunque con algunas diferencias en su arquitectura y filosof\u00eda. En este m\u00f3dulo, exploraremos la historia y caracter\u00edsticas de Phoenix Framework, as\u00ed como tambi\u00e9n su uso y ventajas para el desarrollo de aplicaciones web. Explicaci\u00f3n te\u00f3rica \u00b6 Phoenix Framework se basa en el patr\u00f3n de arquitectura Modelo-Vista-Controlador (MVC), el cual se utiliza para separar la l\u00f3gica de negocio, la presentaci\u00f3n de datos y la interacci\u00f3n con el usuario en diferentes capas. Esto permite una mayor modularidad, escalabilidad y mantenibilidad en el c\u00f3digo de una aplicaci\u00f3n web. Una de las principales caracter\u00edsticas de Phoenix Framework es su enfoque en la concurrencia y el rendimiento. Est\u00e1 construido sobre la plataforma de programaci\u00f3n funcional de Elixir, que se ejecuta en la m\u00e1quina virtual de Erlang (BEAM). Esto permite a Phoenix utilizar el modelo de procesos ligeros (lightweight processes) de Erlang para manejar grandes cantidades de solicitudes concurrentes, sin afectar el rendimiento de la aplicaci\u00f3n. Otra caracter\u00edstica importante de Phoenix Framework es su sistema de enrutamiento din\u00e1mico, que permite crear rutas y controladores de manera sencilla y flexible. Adem\u00e1s, cuenta con un sistema de vistas que utiliza el lenguaje de plantillas EEx para generar HTML de forma eficiente. Palabras clave y definiciones \u00b6 Framework: Es un conjunto de herramientas, librer\u00edas y patrones de dise\u00f1o que facilitan el desarrollo de aplicaciones web. Elixir: Lenguaje de programaci\u00f3n funcional dise\u00f1ado para construir aplicaciones escalables y tolerantes a fallos. MVC: Patr\u00f3n de arquitectura que separa la l\u00f3gica de negocio, la presentaci\u00f3n de datos y la interacci\u00f3n con el usuario en diferentes capas. Concurrencia: Capacidad de un sistema para realizar m\u00faltiples tareas al mismo tiempo. Rendimiento: Medida de la eficiencia con la que una aplicaci\u00f3n realiza sus tareas. Procesos ligeros: Unidad de ejecuci\u00f3n independiente y liviana en la m\u00e1quina virtual de Erlang. Erlang: Lenguaje de programaci\u00f3n funcional utilizado en la construcci\u00f3n de sistemas distribuidos y tolerantes a fallos. Sistema de enrutamiento: Mecanismo que permite asociar una URL a un controlador y una acci\u00f3n en una aplicaci\u00f3n web. Controlador: Componente que maneja las solicitudes HTTP recibidas y es responsable de coordinar la l\u00f3gica de negocio. Vistas: Componentes que generan la presentaci\u00f3n de datos en una aplicaci\u00f3n web. EEx: Lenguaje de plantillas basado en Elixir utilizado para generar HTML de forma din\u00e1mica. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es Phoenix Framework y en qu\u00e9 lenguaje de programaci\u00f3n est\u00e1 basado? \u00bfCu\u00e1l es la arquitectura utilizada por Phoenix Framework? \u00bfQu\u00e9 ventajas ofrece Phoenix Framework en t\u00e9rminos de rendimiento? \u00bfQu\u00e9 es el sistema de enrutamiento en Phoenix Framework? \u00bfCu\u00e1l es el lenguaje de plantillas utilizado por Phoenix Framework para generar HTML? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 A continuaci\u00f3n, se muestra un ejemplo de un controlador en Phoenix Framework que maneja una solicitud GET para obtener todos los usuarios de una aplicaci\u00f3n: defmodule MyApp.UserController do use MyApp.Web , :controller def index ( conn , _params ) do users = MyApp.Repo . all ( MyApp.User ) render ( conn , \"index.html\" , users : users ) end end Este controlador utiliza la funci\u00f3n MyApp.Repo.all/1 para consultar todos los usuarios de la base de datos y luego renderiza la vista index.html con los datos obtenidos. Ejercicios pr\u00e1cticos \u00b6 Crea un nuevo proyecto en Phoenix Framework utilizando el comando mix phx.new my_app . Crea un modelo y migraci\u00f3n de base de datos para almacenar informaci\u00f3n de libros. Crea un controlador y sus correspondientes rutas para gestionar la creaci\u00f3n y visualizaci\u00f3n de libros. Crea una vista que muestre una lista de todos los libros almacenados en la base de datos. Agrega una funcionalidad para que los usuarios puedan agregar comentarios a los libros. Implementa una autenticaci\u00f3n de usuario utilizando el m\u00f3dulo Comeonin y el sistema de autenticaci\u00f3n de Phoenix. Agrega una funcionalidad de b\u00fasqueda para encontrar libros por t\u00edtulo o autor. Crea un sistema de paginaci\u00f3n para mostrar una cantidad limitada de libros por p\u00e1gina. Agrega la posibilidad de editar y eliminar libros existentes. Implementa pruebas automatizadas para el controlador y modelos creados. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza el generador de Phoenix Framework mix phx.gen.html para crear modelos, migraciones, controladores y vistas de manera r\u00e1pida y sencilla. Sigue las convenciones de nombres y estructura de carpetas de Phoenix Framework para una mejor organizaci\u00f3n y legibilidad del c\u00f3digo. Utiliza el sistema de migraciones de Ecto para realizar cambios en la estructura de la base de datos de forma segura y controlada. Aprovecha las ventajas de la programaci\u00f3n funcional en Elixir para escribir un c\u00f3digo m\u00e1s legible, mantenible y escalable. Utiliza el m\u00f3dulo Plug para agregar middlewares y funcionalidades adicionales a tu aplicaci\u00f3n.","title":"Introducci\u00f3n a Phoenix Framework"},{"location":"phoenix/jr/introducci%C3%B3n_a_phoenix_framework/#introduccion-a-phoenix-framework","text":"","title":"Introducci\u00f3n a Phoenix Framework"},{"location":"phoenix/jr/introducci%C3%B3n_a_phoenix_framework/#descripcion-del-modulo","text":"Phoenix Framework es un framework de desarrollo web de c\u00f3digo abierto basado en el lenguaje de programaci\u00f3n Elixir. Fue creado por Chris McCord en 2014 y est\u00e1 inspirado en el framework Ruby on Rails, aunque con algunas diferencias en su arquitectura y filosof\u00eda. En este m\u00f3dulo, exploraremos la historia y caracter\u00edsticas de Phoenix Framework, as\u00ed como tambi\u00e9n su uso y ventajas para el desarrollo de aplicaciones web.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"phoenix/jr/introducci%C3%B3n_a_phoenix_framework/#explicacion-teorica","text":"Phoenix Framework se basa en el patr\u00f3n de arquitectura Modelo-Vista-Controlador (MVC), el cual se utiliza para separar la l\u00f3gica de negocio, la presentaci\u00f3n de datos y la interacci\u00f3n con el usuario en diferentes capas. Esto permite una mayor modularidad, escalabilidad y mantenibilidad en el c\u00f3digo de una aplicaci\u00f3n web. Una de las principales caracter\u00edsticas de Phoenix Framework es su enfoque en la concurrencia y el rendimiento. Est\u00e1 construido sobre la plataforma de programaci\u00f3n funcional de Elixir, que se ejecuta en la m\u00e1quina virtual de Erlang (BEAM). Esto permite a Phoenix utilizar el modelo de procesos ligeros (lightweight processes) de Erlang para manejar grandes cantidades de solicitudes concurrentes, sin afectar el rendimiento de la aplicaci\u00f3n. Otra caracter\u00edstica importante de Phoenix Framework es su sistema de enrutamiento din\u00e1mico, que permite crear rutas y controladores de manera sencilla y flexible. Adem\u00e1s, cuenta con un sistema de vistas que utiliza el lenguaje de plantillas EEx para generar HTML de forma eficiente.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix/jr/introducci%C3%B3n_a_phoenix_framework/#palabras-clave-y-definiciones","text":"Framework: Es un conjunto de herramientas, librer\u00edas y patrones de dise\u00f1o que facilitan el desarrollo de aplicaciones web. Elixir: Lenguaje de programaci\u00f3n funcional dise\u00f1ado para construir aplicaciones escalables y tolerantes a fallos. MVC: Patr\u00f3n de arquitectura que separa la l\u00f3gica de negocio, la presentaci\u00f3n de datos y la interacci\u00f3n con el usuario en diferentes capas. Concurrencia: Capacidad de un sistema para realizar m\u00faltiples tareas al mismo tiempo. Rendimiento: Medida de la eficiencia con la que una aplicaci\u00f3n realiza sus tareas. Procesos ligeros: Unidad de ejecuci\u00f3n independiente y liviana en la m\u00e1quina virtual de Erlang. Erlang: Lenguaje de programaci\u00f3n funcional utilizado en la construcci\u00f3n de sistemas distribuidos y tolerantes a fallos. Sistema de enrutamiento: Mecanismo que permite asociar una URL a un controlador y una acci\u00f3n en una aplicaci\u00f3n web. Controlador: Componente que maneja las solicitudes HTTP recibidas y es responsable de coordinar la l\u00f3gica de negocio. Vistas: Componentes que generan la presentaci\u00f3n de datos en una aplicaci\u00f3n web. EEx: Lenguaje de plantillas basado en Elixir utilizado para generar HTML de forma din\u00e1mica.","title":"Palabras clave y definiciones"},{"location":"phoenix/jr/introducci%C3%B3n_a_phoenix_framework/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Phoenix Framework y en qu\u00e9 lenguaje de programaci\u00f3n est\u00e1 basado? \u00bfCu\u00e1l es la arquitectura utilizada por Phoenix Framework? \u00bfQu\u00e9 ventajas ofrece Phoenix Framework en t\u00e9rminos de rendimiento? \u00bfQu\u00e9 es el sistema de enrutamiento en Phoenix Framework? \u00bfCu\u00e1l es el lenguaje de plantillas utilizado por Phoenix Framework para generar HTML?","title":"Preguntas de repaso"},{"location":"phoenix/jr/introducci%C3%B3n_a_phoenix_framework/#ejemplos-de-codigo-en-phoenix-framework","text":"A continuaci\u00f3n, se muestra un ejemplo de un controlador en Phoenix Framework que maneja una solicitud GET para obtener todos los usuarios de una aplicaci\u00f3n: defmodule MyApp.UserController do use MyApp.Web , :controller def index ( conn , _params ) do users = MyApp.Repo . all ( MyApp.User ) render ( conn , \"index.html\" , users : users ) end end Este controlador utiliza la funci\u00f3n MyApp.Repo.all/1 para consultar todos los usuarios de la base de datos y luego renderiza la vista index.html con los datos obtenidos.","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix/jr/introducci%C3%B3n_a_phoenix_framework/#ejercicios-practicos","text":"Crea un nuevo proyecto en Phoenix Framework utilizando el comando mix phx.new my_app . Crea un modelo y migraci\u00f3n de base de datos para almacenar informaci\u00f3n de libros. Crea un controlador y sus correspondientes rutas para gestionar la creaci\u00f3n y visualizaci\u00f3n de libros. Crea una vista que muestre una lista de todos los libros almacenados en la base de datos. Agrega una funcionalidad para que los usuarios puedan agregar comentarios a los libros. Implementa una autenticaci\u00f3n de usuario utilizando el m\u00f3dulo Comeonin y el sistema de autenticaci\u00f3n de Phoenix. Agrega una funcionalidad de b\u00fasqueda para encontrar libros por t\u00edtulo o autor. Crea un sistema de paginaci\u00f3n para mostrar una cantidad limitada de libros por p\u00e1gina. Agrega la posibilidad de editar y eliminar libros existentes. Implementa pruebas automatizadas para el controlador y modelos creados.","title":"Ejercicios pr\u00e1cticos"},{"location":"phoenix/jr/introducci%C3%B3n_a_phoenix_framework/#consejos-o-mejores-practicas","text":"Utiliza el generador de Phoenix Framework mix phx.gen.html para crear modelos, migraciones, controladores y vistas de manera r\u00e1pida y sencilla. Sigue las convenciones de nombres y estructura de carpetas de Phoenix Framework para una mejor organizaci\u00f3n y legibilidad del c\u00f3digo. Utiliza el sistema de migraciones de Ecto para realizar cambios en la estructura de la base de datos de forma segura y controlada. Aprovecha las ventajas de la programaci\u00f3n funcional en Elixir para escribir un c\u00f3digo m\u00e1s legible, mantenible y escalable. Utiliza el m\u00f3dulo Plug para agregar middlewares y funcionalidades adicionales a tu aplicaci\u00f3n.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix/jr/modelos_y_bases_de_datos/","text":"Modelos y bases de datos \u00b6 Los modelos son una parte fundamental en el desarrollo de aplicaciones web con Phoenix Framework. Estos nos permiten representar y manipular los datos de nuestra aplicaci\u00f3n de una manera estructurada y eficiente. Para poder trabajar con bases de datos en Phoenix, utilizamos Ecto, un m\u00f3dulo que nos proporciona un conjunto de herramientas para interactuar con diferentes sistemas de gesti\u00f3n de bases de datos como PostgreSQL, MySQL, MongoDB, entre otros. Explicaci\u00f3n te\u00f3rica \u00b6 En Phoenix, los modelos son representados como m\u00f3dulos de Elixir que se encargan de definir la estructura y las relaciones entre los datos de nuestra aplicaci\u00f3n. Estos modelos se relacionan directamente con tablas en la base de datos, lo que nos permite realizar operaciones de lectura, escritura, actualizaci\u00f3n y eliminaci\u00f3n de registros. Para trabajar con modelos en Phoenix, es necesario seguir el patr\u00f3n de dise\u00f1o MVC (Modelo-Vista-Controlador), donde los modelos se encargan de interactuar con la base de datos, las vistas se encargan de mostrar la informaci\u00f3n al usuario y los controladores act\u00faan como intermediarios entre los modelos y las vistas. Para crear un modelo en Phoenix, utilizamos el generador de modelos mix ecto.gen.model , que nos ayudar\u00e1 a generar el esqueleto del modelo, as\u00ed como tambi\u00e9n la migraci\u00f3n correspondiente para crear la tabla en la base de datos. Palabras clave y su definici\u00f3n \u00b6 Modelo: Representaci\u00f3n de una entidad o concepto en la base de datos, definido como un m\u00f3dulo en Elixir. Ecto: M\u00f3dulo de Phoenix que nos proporciona herramientas para interactuar con bases de datos. Migraci\u00f3n: Archivo que define los cambios en la estructura de la base de datos. MVC: Patr\u00f3n de dise\u00f1o que divide la aplicaci\u00f3n en tres componentes: Modelo, Vista y Controlador. Relaci\u00f3n: V\u00ednculo entre dos o m\u00e1s modelos, que nos permite acceder y manipular datos relacionados. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es un modelo en Phoenix? \u00bfQu\u00e9 m\u00f3dulo se utiliza en Phoenix para trabajar con bases de datos? \u00bfCu\u00e1l es el patr\u00f3n de dise\u00f1o utilizado en Phoenix para la organizaci\u00f3n de la aplicaci\u00f3n? \u00bfQu\u00e9 es una migraci\u00f3n en Phoenix? \u00bfQu\u00e9 es una relaci\u00f3n entre modelos y para qu\u00e9 sirve? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 Para crear un modelo en Phoenix, utilizamos el siguiente comando en la terminal: mix ecto.gen.model Modelo nombre_campo:tipo_dato nombre_campo:tipo_dato Esto generar\u00e1 dos archivos: el modelo en lib/app_web/models y la migraci\u00f3n en priv/repo/migrations . Por ejemplo: mix ecto.gen.model User name:string email:string Esto generar\u00e1 un modelo llamado User con dos campos: name de tipo string y email de tipo string . Para realizar consultas en la base de datos, podemos utilizar el m\u00f3dulo Repo de Ecto. Por ejemplo, para obtener todos los usuarios de la tabla users en la base de datos, utilizamos el siguiente c\u00f3digo en un controlador: def index(conn, _params) do users = App.Repo.all(User) render(conn, \"index.html\", users: users) end Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea un modelo llamado Post con los campos title de tipo string y content de tipo text . Crea una migraci\u00f3n para agregar un campo author de tipo string a la tabla posts . Realiza una consulta para obtener todos los posts de un usuario espec\u00edfico. Crea un modelo Comment con los campos content de tipo text y post_id de tipo integer . Crea una relaci\u00f3n entre los modelos Post y Comment de manera que un post pueda tener varios comentarios. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza nombres descriptivos y en singular para tus modelos. Identifica de antemano las relaciones entre tus modelos para poder definirlas correctamente. Utiliza las migraciones para realizar cambios en la estructura de la base de datos. Utiliza el m\u00f3dulo Repo de Ecto para realizar consultas en la base de datos de manera eficiente. Sigue el patr\u00f3n de dise\u00f1o MVC para mantener tu aplicaci\u00f3n organizada y f\u00e1cil de mantener.","title":"Modelos y bases de datos"},{"location":"phoenix/jr/modelos_y_bases_de_datos/#modelos-y-bases-de-datos","text":"Los modelos son una parte fundamental en el desarrollo de aplicaciones web con Phoenix Framework. Estos nos permiten representar y manipular los datos de nuestra aplicaci\u00f3n de una manera estructurada y eficiente. Para poder trabajar con bases de datos en Phoenix, utilizamos Ecto, un m\u00f3dulo que nos proporciona un conjunto de herramientas para interactuar con diferentes sistemas de gesti\u00f3n de bases de datos como PostgreSQL, MySQL, MongoDB, entre otros.","title":"Modelos y bases de datos"},{"location":"phoenix/jr/modelos_y_bases_de_datos/#explicacion-teorica","text":"En Phoenix, los modelos son representados como m\u00f3dulos de Elixir que se encargan de definir la estructura y las relaciones entre los datos de nuestra aplicaci\u00f3n. Estos modelos se relacionan directamente con tablas en la base de datos, lo que nos permite realizar operaciones de lectura, escritura, actualizaci\u00f3n y eliminaci\u00f3n de registros. Para trabajar con modelos en Phoenix, es necesario seguir el patr\u00f3n de dise\u00f1o MVC (Modelo-Vista-Controlador), donde los modelos se encargan de interactuar con la base de datos, las vistas se encargan de mostrar la informaci\u00f3n al usuario y los controladores act\u00faan como intermediarios entre los modelos y las vistas. Para crear un modelo en Phoenix, utilizamos el generador de modelos mix ecto.gen.model , que nos ayudar\u00e1 a generar el esqueleto del modelo, as\u00ed como tambi\u00e9n la migraci\u00f3n correspondiente para crear la tabla en la base de datos.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix/jr/modelos_y_bases_de_datos/#palabras-clave-y-su-definicion","text":"Modelo: Representaci\u00f3n de una entidad o concepto en la base de datos, definido como un m\u00f3dulo en Elixir. Ecto: M\u00f3dulo de Phoenix que nos proporciona herramientas para interactuar con bases de datos. Migraci\u00f3n: Archivo que define los cambios en la estructura de la base de datos. MVC: Patr\u00f3n de dise\u00f1o que divide la aplicaci\u00f3n en tres componentes: Modelo, Vista y Controlador. Relaci\u00f3n: V\u00ednculo entre dos o m\u00e1s modelos, que nos permite acceder y manipular datos relacionados.","title":"Palabras clave y su definici\u00f3n"},{"location":"phoenix/jr/modelos_y_bases_de_datos/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es un modelo en Phoenix? \u00bfQu\u00e9 m\u00f3dulo se utiliza en Phoenix para trabajar con bases de datos? \u00bfCu\u00e1l es el patr\u00f3n de dise\u00f1o utilizado en Phoenix para la organizaci\u00f3n de la aplicaci\u00f3n? \u00bfQu\u00e9 es una migraci\u00f3n en Phoenix? \u00bfQu\u00e9 es una relaci\u00f3n entre modelos y para qu\u00e9 sirve?","title":"Preguntas de repaso"},{"location":"phoenix/jr/modelos_y_bases_de_datos/#ejemplos-de-codigo-en-phoenix-framework","text":"Para crear un modelo en Phoenix, utilizamos el siguiente comando en la terminal: mix ecto.gen.model Modelo nombre_campo:tipo_dato nombre_campo:tipo_dato Esto generar\u00e1 dos archivos: el modelo en lib/app_web/models y la migraci\u00f3n en priv/repo/migrations . Por ejemplo: mix ecto.gen.model User name:string email:string Esto generar\u00e1 un modelo llamado User con dos campos: name de tipo string y email de tipo string . Para realizar consultas en la base de datos, podemos utilizar el m\u00f3dulo Repo de Ecto. Por ejemplo, para obtener todos los usuarios de la tabla users en la base de datos, utilizamos el siguiente c\u00f3digo en un controlador: def index(conn, _params) do users = App.Repo.all(User) render(conn, \"index.html\", users: users) end","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix/jr/modelos_y_bases_de_datos/#ejercicios-practicos-con-instrucciones-claras","text":"Crea un modelo llamado Post con los campos title de tipo string y content de tipo text . Crea una migraci\u00f3n para agregar un campo author de tipo string a la tabla posts . Realiza una consulta para obtener todos los posts de un usuario espec\u00edfico. Crea un modelo Comment con los campos content de tipo text y post_id de tipo integer . Crea una relaci\u00f3n entre los modelos Post y Comment de manera que un post pueda tener varios comentarios.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"phoenix/jr/modelos_y_bases_de_datos/#consejos-o-mejores-practicas","text":"Utiliza nombres descriptivos y en singular para tus modelos. Identifica de antemano las relaciones entre tus modelos para poder definirlas correctamente. Utiliza las migraciones para realizar cambios en la estructura de la base de datos. Utiliza el m\u00f3dulo Repo de Ecto para realizar consultas en la base de datos de manera eficiente. Sigue el patr\u00f3n de dise\u00f1o MVC para mantener tu aplicaci\u00f3n organizada y f\u00e1cil de mantener.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix/jr/rutas_y_controladores/","text":"Rutas y controladores en Phoenix Framework \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 En Phoenix Framework, las rutas y los controladores son elementos fundamentales para el desarrollo de aplicaciones web. Las rutas se encargan de definir c\u00f3mo se accede a las diferentes acciones de un controlador, mientras que los controladores son responsables de manejar las solicitudes y generar una respuesta adecuada. Las rutas en Phoenix se definen en el archivo router.ex y siguen el patr\u00f3n de HTTP method path, ControllerName, action (m\u00e9todo HTTP, ruta, nombre del controlador, acci\u00f3n). Por ejemplo: get \"/users\", UserController, :index definir\u00eda una ruta GET a la ruta /users que ser\u00e1 manejada por el controlador UserController en su acci\u00f3n index . Por otro lado, los controladores en Phoenix se encargan de manejar las solicitudes del cliente y generar una respuesta. Cada controlador es una estructura de m\u00f3dulo que contiene diferentes acciones, que son funciones que corresponden a una ruta espec\u00edfica. Las acciones pueden realizar tareas como obtener datos de la base de datos, renderizar una vista o redirigir a otra ruta. Palabras clave y su definici\u00f3n \u00b6 Rutas: Son las direcciones a las que se pueden acceder en una aplicaci\u00f3n web y se definen en el archivo router.ex en Phoenix Framework. Controladores: Son estructuras de m\u00f3dulo que se encargan de manejar las solicitudes del cliente y generar una respuesta adecuada. Acciones: Son funciones que corresponden a una ruta espec\u00edfica en un controlador y pueden realizar diferentes tareas como obtener datos, renderizar vistas o redirigir a otras rutas. Preguntas de repaso \u00b6 \u00bfQu\u00e9 son las rutas y c\u00f3mo se definen en Phoenix Framework? \u00bfQu\u00e9 son los controladores y cu\u00e1l es su funci\u00f3n en una aplicaci\u00f3n web? \u00bfQu\u00e9 son las acciones en Phoenix Framework y qu\u00e9 tareas pueden realizar? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 # Definir una ruta a la p\u00e1gina principal get \"/\", PageController, :index # Controlador para manejar la p\u00e1gina principal defmodule MyApp.PageController do use MyApp, :controller # Acci\u00f3n para la ruta \"/\" def index(conn, _params) do render(conn, \"index.html\") end end Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una nueva ruta GET a la ruta /about que ser\u00e1 manejada por el controlador AboutController en su acci\u00f3n index . En el controlador AboutController , agrega una acci\u00f3n index que renderice la vista about.html . En la vista about.html , agrega un t\u00edtulo y un p\u00e1rrafo con informaci\u00f3n sobre tu aplicaci\u00f3n. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza nombres descriptivos para tus rutas y acciones, esto facilitar\u00e1 su mantenimiento en el futuro. Divide las acciones en diferentes controladores seg\u00fan su funcionalidad para mantener un c\u00f3digo m\u00e1s organizado. Si necesitas compartir l\u00f3gica entre diferentes controladores, puedes crear un m\u00f3dulo de ayuda y utilizarlo en cada controlador que lo necesite.","title":"Rutas y controladores en Phoenix Framework"},{"location":"phoenix/jr/rutas_y_controladores/#rutas-y-controladores-en-phoenix-framework","text":"","title":"Rutas y controladores en Phoenix Framework"},{"location":"phoenix/jr/rutas_y_controladores/#explicacion-teorica","text":"En Phoenix Framework, las rutas y los controladores son elementos fundamentales para el desarrollo de aplicaciones web. Las rutas se encargan de definir c\u00f3mo se accede a las diferentes acciones de un controlador, mientras que los controladores son responsables de manejar las solicitudes y generar una respuesta adecuada. Las rutas en Phoenix se definen en el archivo router.ex y siguen el patr\u00f3n de HTTP method path, ControllerName, action (m\u00e9todo HTTP, ruta, nombre del controlador, acci\u00f3n). Por ejemplo: get \"/users\", UserController, :index definir\u00eda una ruta GET a la ruta /users que ser\u00e1 manejada por el controlador UserController en su acci\u00f3n index . Por otro lado, los controladores en Phoenix se encargan de manejar las solicitudes del cliente y generar una respuesta. Cada controlador es una estructura de m\u00f3dulo que contiene diferentes acciones, que son funciones que corresponden a una ruta espec\u00edfica. Las acciones pueden realizar tareas como obtener datos de la base de datos, renderizar una vista o redirigir a otra ruta.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix/jr/rutas_y_controladores/#palabras-clave-y-su-definicion","text":"Rutas: Son las direcciones a las que se pueden acceder en una aplicaci\u00f3n web y se definen en el archivo router.ex en Phoenix Framework. Controladores: Son estructuras de m\u00f3dulo que se encargan de manejar las solicitudes del cliente y generar una respuesta adecuada. Acciones: Son funciones que corresponden a una ruta espec\u00edfica en un controlador y pueden realizar diferentes tareas como obtener datos, renderizar vistas o redirigir a otras rutas.","title":"Palabras clave y su definici\u00f3n"},{"location":"phoenix/jr/rutas_y_controladores/#preguntas-de-repaso","text":"\u00bfQu\u00e9 son las rutas y c\u00f3mo se definen en Phoenix Framework? \u00bfQu\u00e9 son los controladores y cu\u00e1l es su funci\u00f3n en una aplicaci\u00f3n web? \u00bfQu\u00e9 son las acciones en Phoenix Framework y qu\u00e9 tareas pueden realizar?","title":"Preguntas de repaso"},{"location":"phoenix/jr/rutas_y_controladores/#ejemplos-de-codigo-en-phoenix-framework","text":"# Definir una ruta a la p\u00e1gina principal get \"/\", PageController, :index # Controlador para manejar la p\u00e1gina principal defmodule MyApp.PageController do use MyApp, :controller # Acci\u00f3n para la ruta \"/\" def index(conn, _params) do render(conn, \"index.html\") end end","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix/jr/rutas_y_controladores/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una nueva ruta GET a la ruta /about que ser\u00e1 manejada por el controlador AboutController en su acci\u00f3n index . En el controlador AboutController , agrega una acci\u00f3n index que renderice la vista about.html . En la vista about.html , agrega un t\u00edtulo y un p\u00e1rrafo con informaci\u00f3n sobre tu aplicaci\u00f3n.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"phoenix/jr/rutas_y_controladores/#consejos-o-mejores-practicas","text":"Utiliza nombres descriptivos para tus rutas y acciones, esto facilitar\u00e1 su mantenimiento en el futuro. Divide las acciones en diferentes controladores seg\u00fan su funcionalidad para mantener un c\u00f3digo m\u00e1s organizado. Si necesitas compartir l\u00f3gica entre diferentes controladores, puedes crear un m\u00f3dulo de ayuda y utilizarlo en cada controlador que lo necesite.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix/jr/vistas_y_templates/","text":"Vistas y templates en Phoenix Framework \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 Phoenix Framework es un framework web escrito en el lenguaje de programaci\u00f3n Elixir, que sigue el patr\u00f3n de arquitectura MVC (Modelo-Vista-Controlador). Las vistas y templates son una parte fundamental de este patr\u00f3n, ya que se encargan de renderizar la interfaz de usuario para que sea visualizada por el usuario final. Una vista en Phoenix es una funci\u00f3n que se encarga de recibir los datos del controlador y generar una respuesta en alg\u00fan formato, como HTML, JSON o XML. Esta respuesta es enviada al navegador del cliente para que pueda ser visualizada. Por otro lado, un template es un archivo que contiene el c\u00f3digo HTML y Elixir necesario para generar una vista. En otras palabras, las vistas utilizan los templates para renderizar el contenido de la p\u00e1gina. Palabras clave y su definici\u00f3n \u00b6 Vista: Funci\u00f3n en Phoenix encargada de recibir los datos del controlador y generar una respuesta en alg\u00fan formato. Template: Archivo que contiene el c\u00f3digo HTML y Elixir necesario para generar una vista. Renderizar: Proceso de generar una respuesta a partir de una vista y un template. Interfaz de usuario: Parte de la aplicaci\u00f3n que interact\u00faa con el usuario final. MVC: Patr\u00f3n de arquitectura de software que divide una aplicaci\u00f3n en tres componentes: Modelo, Vista y Controlador. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es una vista en Phoenix Framework? \u00bfCu\u00e1l es la funci\u00f3n de los templates en Phoenix? \u00bfQu\u00e9 es renderizar? \u00bfCu\u00e1l es el patr\u00f3n de arquitectura que sigue Phoenix Framework? \u00bfCu\u00e1l es la diferencia entre una vista y un template en Phoenix? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 Vista b\u00e1sica en Phoenix \u00b6 defmodule MyApp.Web.UserView do use MyApp.Web , :view def index ( conn , _params ) do users = Repo . all ( User ) render ( conn , \"index.html\" , users : users ) end end En este ejemplo, se define una vista b\u00e1sica en la que se obtienen todos los usuarios de la base de datos y se los pasa como par\u00e1metro al template \"index.html\" para ser renderizado. Template b\u00e1sico en Phoenix \u00b6 <!-- index.html.eex --> < h1 > Lista de usuarios </ h1 > < ul > < %= for user < - @ users do % > < li > < %= user.name %> </ li > < % end %> </ ul > En este ejemplo, se utiliza el lenguaje de plantillas Elixir para generar una lista con los nombres de los usuarios obtenidos en la vista. Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una nueva vista en Phoenix llamada \"ProductView\". Define una acci\u00f3n \"index\" en la vista que reciba todos los productos de la base de datos y los pase como par\u00e1metro al template \"index.html\". Crea un nuevo template llamado \"index.html\" en la carpeta \"product\" de la vista. Utiliza el lenguaje de plantillas Elixir para generar una tabla con los nombres y precios de los productos obtenidos en la vista. Crea una acci\u00f3n \"show\" en la vista que reciba un producto espec\u00edfico y lo pase como par\u00e1metro al template \"show.html\". Crea un nuevo template llamado \"show.html\" en la carpeta \"product\" de la vista. Utiliza el lenguaje de plantillas Elixir para mostrar los detalles del producto recibido en la vista. Consejos o mejores pr\u00e1cticas \u00b6 Mantener las vistas y templates lo m\u00e1s simples y limpios posible. Utilizar el lenguaje de plantillas Elixir de forma eficiente para evitar c\u00f3digo redundante. Utilizar la funci\u00f3n \"render\" en las vistas para pasar los datos al template de forma clara y ordenada. Organizar las vistas y templates en carpetas y subcarpetas seg\u00fan la funcionalidad que cumplan en la aplicaci\u00f3n. Utilizar nombres descriptivos para las vistas y templates para facilitar su mantenimiento y comprensi\u00f3n en el futuro.","title":"Vistas y templates en Phoenix Framework"},{"location":"phoenix/jr/vistas_y_templates/#vistas-y-templates-en-phoenix-framework","text":"","title":"Vistas y templates en Phoenix Framework"},{"location":"phoenix/jr/vistas_y_templates/#explicacion-teorica","text":"Phoenix Framework es un framework web escrito en el lenguaje de programaci\u00f3n Elixir, que sigue el patr\u00f3n de arquitectura MVC (Modelo-Vista-Controlador). Las vistas y templates son una parte fundamental de este patr\u00f3n, ya que se encargan de renderizar la interfaz de usuario para que sea visualizada por el usuario final. Una vista en Phoenix es una funci\u00f3n que se encarga de recibir los datos del controlador y generar una respuesta en alg\u00fan formato, como HTML, JSON o XML. Esta respuesta es enviada al navegador del cliente para que pueda ser visualizada. Por otro lado, un template es un archivo que contiene el c\u00f3digo HTML y Elixir necesario para generar una vista. En otras palabras, las vistas utilizan los templates para renderizar el contenido de la p\u00e1gina.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix/jr/vistas_y_templates/#palabras-clave-y-su-definicion","text":"Vista: Funci\u00f3n en Phoenix encargada de recibir los datos del controlador y generar una respuesta en alg\u00fan formato. Template: Archivo que contiene el c\u00f3digo HTML y Elixir necesario para generar una vista. Renderizar: Proceso de generar una respuesta a partir de una vista y un template. Interfaz de usuario: Parte de la aplicaci\u00f3n que interact\u00faa con el usuario final. MVC: Patr\u00f3n de arquitectura de software que divide una aplicaci\u00f3n en tres componentes: Modelo, Vista y Controlador.","title":"Palabras clave y su definici\u00f3n"},{"location":"phoenix/jr/vistas_y_templates/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es una vista en Phoenix Framework? \u00bfCu\u00e1l es la funci\u00f3n de los templates en Phoenix? \u00bfQu\u00e9 es renderizar? \u00bfCu\u00e1l es el patr\u00f3n de arquitectura que sigue Phoenix Framework? \u00bfCu\u00e1l es la diferencia entre una vista y un template en Phoenix?","title":"Preguntas de repaso"},{"location":"phoenix/jr/vistas_y_templates/#ejemplos-de-codigo-en-phoenix-framework","text":"","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix/jr/vistas_y_templates/#vista-basica-en-phoenix","text":"defmodule MyApp.Web.UserView do use MyApp.Web , :view def index ( conn , _params ) do users = Repo . all ( User ) render ( conn , \"index.html\" , users : users ) end end En este ejemplo, se define una vista b\u00e1sica en la que se obtienen todos los usuarios de la base de datos y se los pasa como par\u00e1metro al template \"index.html\" para ser renderizado.","title":"Vista b\u00e1sica en Phoenix"},{"location":"phoenix/jr/vistas_y_templates/#template-basico-en-phoenix","text":"<!-- index.html.eex --> < h1 > Lista de usuarios </ h1 > < ul > < %= for user < - @ users do % > < li > < %= user.name %> </ li > < % end %> </ ul > En este ejemplo, se utiliza el lenguaje de plantillas Elixir para generar una lista con los nombres de los usuarios obtenidos en la vista.","title":"Template b\u00e1sico en Phoenix"},{"location":"phoenix/jr/vistas_y_templates/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una nueva vista en Phoenix llamada \"ProductView\". Define una acci\u00f3n \"index\" en la vista que reciba todos los productos de la base de datos y los pase como par\u00e1metro al template \"index.html\". Crea un nuevo template llamado \"index.html\" en la carpeta \"product\" de la vista. Utiliza el lenguaje de plantillas Elixir para generar una tabla con los nombres y precios de los productos obtenidos en la vista. Crea una acci\u00f3n \"show\" en la vista que reciba un producto espec\u00edfico y lo pase como par\u00e1metro al template \"show.html\". Crea un nuevo template llamado \"show.html\" en la carpeta \"product\" de la vista. Utiliza el lenguaje de plantillas Elixir para mostrar los detalles del producto recibido en la vista.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"phoenix/jr/vistas_y_templates/#consejos-o-mejores-practicas","text":"Mantener las vistas y templates lo m\u00e1s simples y limpios posible. Utilizar el lenguaje de plantillas Elixir de forma eficiente para evitar c\u00f3digo redundante. Utilizar la funci\u00f3n \"render\" en las vistas para pasar los datos al template de forma clara y ordenada. Organizar las vistas y templates en carpetas y subcarpetas seg\u00fan la funcionalidad que cumplan en la aplicaci\u00f3n. Utilizar nombres descriptivos para las vistas y templates para facilitar su mantenimiento y comprensi\u00f3n en el futuro.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix/mid/","text":"Phoenix - Nivel Mid \u00b6 \u00a1Bienvenido/a al nivel Mid del curso de Phoenix! En este nivel profundizar\u00e1s en funcionalidades intermedias de Phoenix: APIs en Phoenix Endpoints y canales Middlewares y Plug Seguridad en Phoenix Pruebas en Phoenix Optimizaci\u00f3n de rendimiento Integraci\u00f3n con otras tecnolog\u00edas","title":"Phoenix - Nivel Mid"},{"location":"phoenix/mid/#phoenix-nivel-mid","text":"\u00a1Bienvenido/a al nivel Mid del curso de Phoenix! En este nivel profundizar\u00e1s en funcionalidades intermedias de Phoenix: APIs en Phoenix Endpoints y canales Middlewares y Plug Seguridad en Phoenix Pruebas en Phoenix Optimizaci\u00f3n de rendimiento Integraci\u00f3n con otras tecnolog\u00edas","title":"Phoenix - Nivel Mid"},{"location":"phoenix/mid/apis_en_phoenix/","text":"APIs en Phoenix \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En este m\u00f3dulo aprender\u00e1s a crear y documentar APIs en Phoenix Framework. Las APIs son interfaces de programaci\u00f3n de aplicaciones que permiten la comunicaci\u00f3n entre diferentes aplicaciones y sistemas. Con Phoenix, podemos crear APIs robustas y escalables que pueden ser utilizadas por aplicaciones web, m\u00f3viles y otras plataformas. Explicaci\u00f3n te\u00f3rica \u00b6 Phoenix es un framework web escrito en el lenguaje de programaci\u00f3n Elixir, el cual est\u00e1 basado en la arquitectura de patr\u00f3n de dise\u00f1o MVC (Modelo-Vista-Controlador). Sin embargo, tambi\u00e9n nos permite crear APIs utilizando el patr\u00f3n de dise\u00f1o de arquitectura REST (Representational State Transfer). REST es un estilo de arquitectura para sistemas distribuidos que se basa en el protocolo de transferencia de hipertexto (HTTP). Esto significa que nuestras APIs en Phoenix se basar\u00e1n en los m\u00e9todos HTTP como GET, POST, PUT y DELETE para realizar diferentes operaciones en nuestros datos. Palabras clave y su definici\u00f3n \u00b6 API: Interfaz de programaci\u00f3n de aplicaciones que permite la comunicaci\u00f3n entre diferentes aplicaciones y sistemas. Phoenix: Framework web escrito en Elixir que utiliza el patr\u00f3n de dise\u00f1o MVC y REST para crear aplicaciones y APIs. Swagger: Herramienta para documentar APIs de forma interactiva y visualmente atractiva. ExDoc: Herramienta para generar documentaci\u00f3n de c\u00f3digo en formato HTML. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es una API y para qu\u00e9 se utiliza? \u00bfCu\u00e1l es el patr\u00f3n de dise\u00f1o utilizado en Phoenix para crear APIs? \u00bfQu\u00e9 m\u00e9todos HTTP se utilizan en REST? \u00bfQu\u00e9 es Swagger y para qu\u00e9 se utiliza? \u00bfQu\u00e9 es ExDoc y para qu\u00e9 se utiliza? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 Crear un recurso para nuestra API \u00b6 Para crear un recurso en nuestra API, primero debemos definir una ruta en nuestro archivo router.ex que apunte al controlador correspondiente. Por ejemplo: defmodule MyApp.Router do use MyApp.Web, :router scope \"/api\", MyApp do pipe_through :api resources \"/users\", UserController end end Luego, en nuestro controlador user_controller.ex , definiremos las acciones correspondientes a cada verbo HTTP: defmodule MyApp.UserController do use MyApp.Web, :controller def index(conn, _params) do # c\u00f3digo para obtener todos los usuarios end def show(conn, %{\"id\" => id}) do # c\u00f3digo para obtener un usuario espec\u00edfico end def create(conn, %{\"user\" => user_params}) do # c\u00f3digo para crear un nuevo usuario end def update(conn, %{\"id\" => id, \"user\" => user_params}) do # c\u00f3digo para actualizar un usuario existente end def delete(conn, %{\"id\" => id}) do # c\u00f3digo para eliminar un usuario existente end end Autenticaci\u00f3n en nuestra API \u00b6 Para autenticar nuestras peticiones a la API, podemos utilizar el m\u00f3dulo Phoenix.Token para generar tokens que nos permitan verificar la identidad de los usuarios. Por ejemplo: defmodule MyApp . UserController do use MyApp . Web , : controller # otras acciones def login ( conn , %{ \"email\" => email , \"password\" => password }) do # c\u00f3digo para autenticar al usuario y generar un token token = Phoenix . Token . sign ( MyApp . Endpoint , \"user\" , user . id ) conn |> put_status (: ok ) |> put_resp_header ( \"authorization\" , \"Bearer #{token}\" ) |> render ( \"login.json\" , user : user ) end end Ejercicios pr\u00e1cticos \u00b6 Crea una API en Phoenix que permita realizar operaciones CRUD (crear, leer, actualizar y eliminar) en una lista de tareas. A\u00f1ade autenticaci\u00f3n a tu API utilizando tokens generados con Phoenix.Token . Documenta tu API utilizando Swagger. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza el patr\u00f3n de dise\u00f1o REST para crear una API consistente y f\u00e1cil de entender. Utiliza el m\u00f3dulo Phoenix.Token para a\u00f1adir autenticaci\u00f3n a tu API. Documenta tu API utilizando herramientas como Swagger y ExDoc para una mejor comprensi\u00f3n y uso por parte de otros desarrolladores.","title":"APIs en Phoenix"},{"location":"phoenix/mid/apis_en_phoenix/#apis-en-phoenix","text":"","title":"APIs en Phoenix"},{"location":"phoenix/mid/apis_en_phoenix/#descripcion-del-modulo","text":"En este m\u00f3dulo aprender\u00e1s a crear y documentar APIs en Phoenix Framework. Las APIs son interfaces de programaci\u00f3n de aplicaciones que permiten la comunicaci\u00f3n entre diferentes aplicaciones y sistemas. Con Phoenix, podemos crear APIs robustas y escalables que pueden ser utilizadas por aplicaciones web, m\u00f3viles y otras plataformas.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"phoenix/mid/apis_en_phoenix/#explicacion-teorica","text":"Phoenix es un framework web escrito en el lenguaje de programaci\u00f3n Elixir, el cual est\u00e1 basado en la arquitectura de patr\u00f3n de dise\u00f1o MVC (Modelo-Vista-Controlador). Sin embargo, tambi\u00e9n nos permite crear APIs utilizando el patr\u00f3n de dise\u00f1o de arquitectura REST (Representational State Transfer). REST es un estilo de arquitectura para sistemas distribuidos que se basa en el protocolo de transferencia de hipertexto (HTTP). Esto significa que nuestras APIs en Phoenix se basar\u00e1n en los m\u00e9todos HTTP como GET, POST, PUT y DELETE para realizar diferentes operaciones en nuestros datos.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix/mid/apis_en_phoenix/#palabras-clave-y-su-definicion","text":"API: Interfaz de programaci\u00f3n de aplicaciones que permite la comunicaci\u00f3n entre diferentes aplicaciones y sistemas. Phoenix: Framework web escrito en Elixir que utiliza el patr\u00f3n de dise\u00f1o MVC y REST para crear aplicaciones y APIs. Swagger: Herramienta para documentar APIs de forma interactiva y visualmente atractiva. ExDoc: Herramienta para generar documentaci\u00f3n de c\u00f3digo en formato HTML.","title":"Palabras clave y su definici\u00f3n"},{"location":"phoenix/mid/apis_en_phoenix/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es una API y para qu\u00e9 se utiliza? \u00bfCu\u00e1l es el patr\u00f3n de dise\u00f1o utilizado en Phoenix para crear APIs? \u00bfQu\u00e9 m\u00e9todos HTTP se utilizan en REST? \u00bfQu\u00e9 es Swagger y para qu\u00e9 se utiliza? \u00bfQu\u00e9 es ExDoc y para qu\u00e9 se utiliza?","title":"Preguntas de repaso"},{"location":"phoenix/mid/apis_en_phoenix/#ejemplos-de-codigo-en-phoenix-framework","text":"","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix/mid/apis_en_phoenix/#crear-un-recurso-para-nuestra-api","text":"Para crear un recurso en nuestra API, primero debemos definir una ruta en nuestro archivo router.ex que apunte al controlador correspondiente. Por ejemplo: defmodule MyApp.Router do use MyApp.Web, :router scope \"/api\", MyApp do pipe_through :api resources \"/users\", UserController end end Luego, en nuestro controlador user_controller.ex , definiremos las acciones correspondientes a cada verbo HTTP: defmodule MyApp.UserController do use MyApp.Web, :controller def index(conn, _params) do # c\u00f3digo para obtener todos los usuarios end def show(conn, %{\"id\" => id}) do # c\u00f3digo para obtener un usuario espec\u00edfico end def create(conn, %{\"user\" => user_params}) do # c\u00f3digo para crear un nuevo usuario end def update(conn, %{\"id\" => id, \"user\" => user_params}) do # c\u00f3digo para actualizar un usuario existente end def delete(conn, %{\"id\" => id}) do # c\u00f3digo para eliminar un usuario existente end end","title":"Crear un recurso para nuestra API"},{"location":"phoenix/mid/apis_en_phoenix/#autenticacion-en-nuestra-api","text":"Para autenticar nuestras peticiones a la API, podemos utilizar el m\u00f3dulo Phoenix.Token para generar tokens que nos permitan verificar la identidad de los usuarios. Por ejemplo: defmodule MyApp . UserController do use MyApp . Web , : controller # otras acciones def login ( conn , %{ \"email\" => email , \"password\" => password }) do # c\u00f3digo para autenticar al usuario y generar un token token = Phoenix . Token . sign ( MyApp . Endpoint , \"user\" , user . id ) conn |> put_status (: ok ) |> put_resp_header ( \"authorization\" , \"Bearer #{token}\" ) |> render ( \"login.json\" , user : user ) end end","title":"Autenticaci\u00f3n en nuestra API"},{"location":"phoenix/mid/apis_en_phoenix/#ejercicios-practicos","text":"Crea una API en Phoenix que permita realizar operaciones CRUD (crear, leer, actualizar y eliminar) en una lista de tareas. A\u00f1ade autenticaci\u00f3n a tu API utilizando tokens generados con Phoenix.Token . Documenta tu API utilizando Swagger.","title":"Ejercicios pr\u00e1cticos"},{"location":"phoenix/mid/apis_en_phoenix/#consejos-o-mejores-practicas","text":"Utiliza el patr\u00f3n de dise\u00f1o REST para crear una API consistente y f\u00e1cil de entender. Utiliza el m\u00f3dulo Phoenix.Token para a\u00f1adir autenticaci\u00f3n a tu API. Documenta tu API utilizando herramientas como Swagger y ExDoc para una mejor comprensi\u00f3n y uso por parte de otros desarrolladores.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix/mid/endpoints_y_canales/","text":"Endpoints y canales en Phoenix Framework \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En este m\u00f3dulo aprender\u00e1s a trabajar con endpoints y canales en Phoenix Framework, una herramienta de desarrollo web que utiliza el lenguaje de programaci\u00f3n Elixir. Los endpoints y canales son fundamentales para construir aplicaciones en tiempo real, ya que permiten la comunicaci\u00f3n entre el cliente y el servidor de forma bidireccional y en tiempo real. Explicaci\u00f3n te\u00f3rica \u00b6 Endpoints \u00b6 Un endpoint en Phoenix Framework es un punto de acceso a una aplicaci\u00f3n web. Es el encargado de recibir las peticiones HTTP del cliente y enviar las respuestas correspondientes. Cada endpoint tiene una ruta, que es la direcci\u00f3n a la que se env\u00eda la petici\u00f3n y un controlador, que es el encargado de manejar la l\u00f3gica de la petici\u00f3n y generar la respuesta. En Phoenix, los endpoints se definen en el archivo endpoint.ex dentro de la carpeta lib/nombre_de_la_app_web/ . Por lo general, una aplicaci\u00f3n Phoenix tiene varios endpoints, cada uno para manejar diferentes tipos de peticiones. Canales \u00b6 Los canales en Phoenix Framework son una forma de establecer una conexi\u00f3n bidireccional y en tiempo real entre el cliente y el servidor. Se utilizan principalmente para construir aplicaciones en tiempo real como chats, juegos en l\u00ednea, entre otros. Los canales est\u00e1n basados en el protocolo de websockets, que permite una comunicaci\u00f3n bidireccional y en tiempo real entre el cliente y el servidor. En Phoenix, los canales se definen en el archivo socket.ex dentro de la carpeta lib/nombre_de_la_app_web/channels/ . Cada canal tiene un identificador \u00fanico y una funci\u00f3n handle_in que se encarga de manejar los eventos recibidos del cliente. Palabras clave y su definici\u00f3n \u00b6 Endpoint: Punto de acceso a una aplicaci\u00f3n web que recibe peticiones HTTP del cliente y env\u00eda respuestas. Controlador: Funci\u00f3n que maneja la l\u00f3gica de una petici\u00f3n en un endpoint. Ruta: Direcci\u00f3n a la que se env\u00eda una petici\u00f3n HTTP. Canal: Conexi\u00f3n bidireccional y en tiempo real entre el cliente y el servidor. Protocolo de websockets: Protocolo de comunicaci\u00f3n que permite una conexi\u00f3n bidireccional y en tiempo real entre el cliente y el servidor. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es un endpoint en Phoenix Framework? \u00bfQu\u00e9 funci\u00f3n tiene un controlador en un endpoint? \u00bfQu\u00e9 es una ruta en Phoenix? \u00bfPara qu\u00e9 se utilizan los canales en Phoenix? \u00bfEn qu\u00e9 archivo se definen los canales en una aplicaci\u00f3n Phoenix? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 Definici\u00f3n de un endpoint \u00b6 # lib/nombre_de_la_app_web/endpoint.ex defmodule NombreDeLaAppWeb.Endpoint do use Phoenix.Endpoint , otp_app : :nombre_de_la_app_web # Ruta del endpoint socket \"/socket\" , NombreDeLaAppWeb.UserSocket # Configuraci\u00f3n de la base de datos # ... # Configuraci\u00f3n de las vistas # ... # Configuraci\u00f3n del pipeline de la aplicaci\u00f3n # ... end Definici\u00f3n de un canal \u00b6 # lib/nombre_de_la_app_web/channels/user_socket.ex defmodule NombreDeLaAppWeb.UserSocket do use Phoenix.Socket # Identificador \u00fanico del canal channel \"user:*\" , NombreDeLaAppWeb.UserChannel # Funci\u00f3n para manejar eventos recibidos del cliente def handle_in ( \"nuevo_mensaje\" , %{ \"usuario\" => usuario , \"mensaje\" => mensaje }, socket ) do broadcast! socket , \"nuevo_mensaje\" , %{ usuario : usuario , mensaje : mensaje } { :reply , { :ok , %{ mensaje : \"Mensaje enviado con \u00e9xito\" }}, socket } end end Ejercicios pr\u00e1cticos \u00b6 Crea un endpoint en tu aplicaci\u00f3n Phoenix que maneje peticiones GET a la ruta /hola y responda con un mensaje de bienvenida. Crea un canal en tu aplicaci\u00f3n Phoenix que permita a los usuarios enviar mensajes en tiempo real y mostrarlos en la pantalla. Modifica tu canal para que solo los usuarios autenticados puedan enviar mensajes. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza endpoints para manejar diferentes tipos de peticiones en tu aplicaci\u00f3n. Utiliza canales para construir aplicaciones en tiempo real. Utiliza el protocolo de websockets para establecer una conexi\u00f3n bidireccional y en tiempo real entre el cliente y el servidor. Separa la l\u00f3gica de tus canales en funciones handle_in para facilitar su mantenimiento y escalabilidad. Utiliza rutas descriptivas y significativas en tus endpoints para tener un c\u00f3digo m\u00e1s legible y f\u00e1cil de entender.","title":"Endpoints y canales en Phoenix Framework"},{"location":"phoenix/mid/endpoints_y_canales/#endpoints-y-canales-en-phoenix-framework","text":"","title":"Endpoints y canales en Phoenix Framework"},{"location":"phoenix/mid/endpoints_y_canales/#descripcion-del-modulo","text":"En este m\u00f3dulo aprender\u00e1s a trabajar con endpoints y canales en Phoenix Framework, una herramienta de desarrollo web que utiliza el lenguaje de programaci\u00f3n Elixir. Los endpoints y canales son fundamentales para construir aplicaciones en tiempo real, ya que permiten la comunicaci\u00f3n entre el cliente y el servidor de forma bidireccional y en tiempo real.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"phoenix/mid/endpoints_y_canales/#explicacion-teorica","text":"","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix/mid/endpoints_y_canales/#endpoints","text":"Un endpoint en Phoenix Framework es un punto de acceso a una aplicaci\u00f3n web. Es el encargado de recibir las peticiones HTTP del cliente y enviar las respuestas correspondientes. Cada endpoint tiene una ruta, que es la direcci\u00f3n a la que se env\u00eda la petici\u00f3n y un controlador, que es el encargado de manejar la l\u00f3gica de la petici\u00f3n y generar la respuesta. En Phoenix, los endpoints se definen en el archivo endpoint.ex dentro de la carpeta lib/nombre_de_la_app_web/ . Por lo general, una aplicaci\u00f3n Phoenix tiene varios endpoints, cada uno para manejar diferentes tipos de peticiones.","title":"Endpoints"},{"location":"phoenix/mid/endpoints_y_canales/#canales","text":"Los canales en Phoenix Framework son una forma de establecer una conexi\u00f3n bidireccional y en tiempo real entre el cliente y el servidor. Se utilizan principalmente para construir aplicaciones en tiempo real como chats, juegos en l\u00ednea, entre otros. Los canales est\u00e1n basados en el protocolo de websockets, que permite una comunicaci\u00f3n bidireccional y en tiempo real entre el cliente y el servidor. En Phoenix, los canales se definen en el archivo socket.ex dentro de la carpeta lib/nombre_de_la_app_web/channels/ . Cada canal tiene un identificador \u00fanico y una funci\u00f3n handle_in que se encarga de manejar los eventos recibidos del cliente.","title":"Canales"},{"location":"phoenix/mid/endpoints_y_canales/#palabras-clave-y-su-definicion","text":"Endpoint: Punto de acceso a una aplicaci\u00f3n web que recibe peticiones HTTP del cliente y env\u00eda respuestas. Controlador: Funci\u00f3n que maneja la l\u00f3gica de una petici\u00f3n en un endpoint. Ruta: Direcci\u00f3n a la que se env\u00eda una petici\u00f3n HTTP. Canal: Conexi\u00f3n bidireccional y en tiempo real entre el cliente y el servidor. Protocolo de websockets: Protocolo de comunicaci\u00f3n que permite una conexi\u00f3n bidireccional y en tiempo real entre el cliente y el servidor.","title":"Palabras clave y su definici\u00f3n"},{"location":"phoenix/mid/endpoints_y_canales/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es un endpoint en Phoenix Framework? \u00bfQu\u00e9 funci\u00f3n tiene un controlador en un endpoint? \u00bfQu\u00e9 es una ruta en Phoenix? \u00bfPara qu\u00e9 se utilizan los canales en Phoenix? \u00bfEn qu\u00e9 archivo se definen los canales en una aplicaci\u00f3n Phoenix?","title":"Preguntas de repaso"},{"location":"phoenix/mid/endpoints_y_canales/#ejemplos-de-codigo-en-phoenix-framework","text":"","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix/mid/endpoints_y_canales/#definicion-de-un-endpoint","text":"# lib/nombre_de_la_app_web/endpoint.ex defmodule NombreDeLaAppWeb.Endpoint do use Phoenix.Endpoint , otp_app : :nombre_de_la_app_web # Ruta del endpoint socket \"/socket\" , NombreDeLaAppWeb.UserSocket # Configuraci\u00f3n de la base de datos # ... # Configuraci\u00f3n de las vistas # ... # Configuraci\u00f3n del pipeline de la aplicaci\u00f3n # ... end","title":"Definici\u00f3n de un endpoint"},{"location":"phoenix/mid/endpoints_y_canales/#definicion-de-un-canal","text":"# lib/nombre_de_la_app_web/channels/user_socket.ex defmodule NombreDeLaAppWeb.UserSocket do use Phoenix.Socket # Identificador \u00fanico del canal channel \"user:*\" , NombreDeLaAppWeb.UserChannel # Funci\u00f3n para manejar eventos recibidos del cliente def handle_in ( \"nuevo_mensaje\" , %{ \"usuario\" => usuario , \"mensaje\" => mensaje }, socket ) do broadcast! socket , \"nuevo_mensaje\" , %{ usuario : usuario , mensaje : mensaje } { :reply , { :ok , %{ mensaje : \"Mensaje enviado con \u00e9xito\" }}, socket } end end","title":"Definici\u00f3n de un canal"},{"location":"phoenix/mid/endpoints_y_canales/#ejercicios-practicos","text":"Crea un endpoint en tu aplicaci\u00f3n Phoenix que maneje peticiones GET a la ruta /hola y responda con un mensaje de bienvenida. Crea un canal en tu aplicaci\u00f3n Phoenix que permita a los usuarios enviar mensajes en tiempo real y mostrarlos en la pantalla. Modifica tu canal para que solo los usuarios autenticados puedan enviar mensajes.","title":"Ejercicios pr\u00e1cticos"},{"location":"phoenix/mid/endpoints_y_canales/#consejos-o-mejores-practicas","text":"Utiliza endpoints para manejar diferentes tipos de peticiones en tu aplicaci\u00f3n. Utiliza canales para construir aplicaciones en tiempo real. Utiliza el protocolo de websockets para establecer una conexi\u00f3n bidireccional y en tiempo real entre el cliente y el servidor. Separa la l\u00f3gica de tus canales en funciones handle_in para facilitar su mantenimiento y escalabilidad. Utiliza rutas descriptivas y significativas en tus endpoints para tener un c\u00f3digo m\u00e1s legible y f\u00e1cil de entender.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix/mid/integraci%C3%B3n_con_otras_tecnolog%C3%ADas/","text":"Integraci\u00f3n con otras tecnolog\u00edas en Phoenix Framework \u00b6 En el mundo del desarrollo web, es com\u00fan encontrar aplicaciones que utilizan diferentes tecnolog\u00edas para su creaci\u00f3n. Una de las ventajas de Phoenix Framework es su capacidad de integrarse con otras tecnolog\u00edas, permitiendo crear aplicaciones m\u00e1s robustas y escalables. En esta lecci\u00f3n, aprenderemos c\u00f3mo integrar Phoenix con otras tecnolog\u00edas populares como React, GraphQL y Elasticsearch. Teor\u00eda \u00b6 Integrar Phoenix con otras tecnolog\u00edas implica utilizar diferentes herramientas y librer\u00edas para conectar y comunicar diferentes sistemas entre s\u00ed. Esto permite aprovechar las fortalezas de cada tecnolog\u00eda y crear aplicaciones m\u00e1s complejas y poderosas. La integraci\u00f3n tambi\u00e9n permite mejorar el rendimiento y la experiencia del usuario al utilizar tecnolog\u00edas m\u00e1s avanzadas y especializadas. Palabras clave y definiciones \u00b6 React : una librer\u00eda de JavaScript para crear interfaces de usuario interactivas y din\u00e1micas. GraphQL : un lenguaje de consulta y una capa de transporte para APIs que permite a los clientes especificar exactamente los datos que necesitan. Elasticsearch : una base de datos de b\u00fasqueda y an\u00e1lisis distribuida y escalable. REST : Representational State Transfer es un estilo arquitect\u00f3nico para la creaci\u00f3n de servicios web. WebSocket : un protocolo de comunicaci\u00f3n bidireccional entre un cliente y un servidor que permite una conexi\u00f3n persistente y en tiempo real. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es React y c\u00f3mo se integra con Phoenix? \u00bfCu\u00e1l es la funci\u00f3n de GraphQL en la integraci\u00f3n de tecnolog\u00edas en Phoenix? \u00bfQu\u00e9 es Elasticsearch y c\u00f3mo se utiliza en conjunto con Phoenix? \u00bfCu\u00e1l es la diferencia entre REST y WebSocket? \u00bfPor qu\u00e9 es importante la integraci\u00f3n de tecnolog\u00edas en Phoenix Framework? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 Integraci\u00f3n con React \u00b6 Para integrar React en Phoenix Framework, se puede utilizar la librer\u00eda phoenix_react que proporciona una manera sencilla de crear componentes React en una aplicaci\u00f3n Phoenix. Por ejemplo, para crear un componente HelloWorld en React, se puede utilizar el siguiente c\u00f3digo en el archivo hello_world.js : import React from 'react' import { render } from 'react-dom' const HelloWorld = () => ( < h1 > Hello World ! </ h1 > ) render ( < HelloWorld /> , document . getElementById ( 'root' )) Luego, en el archivo index.html.eex se puede incluir el componente como sigue: <div id= \"root\" > <%= react_component @conn , HelloWorld %> </div> Integraci\u00f3n con GraphQL \u00b6 Para integrar GraphQL en Phoenix, se puede utilizar la librer\u00eda absinthe que proporciona una implementaci\u00f3n de GraphQL para Elixir. Primero, se debe configurar el esquema de GraphQL en el archivo schema.ex y luego definir los resolvers para manejar las consultas. Un ejemplo de un esquema b\u00e1sico de GraphQL en Phoenix ser\u00eda el siguiente: defmodule MyApp.Schema do use Absinthe.Schema query do field :greeting, :string do resolve &MyApp.Resolvers.greeting/3 end end end defmodule MyApp.Resolvers do def greeting(_, _, _ ), do: \"Hello World!\" end Integraci\u00f3n con Elasticsearch \u00b6 Para integrar Elasticsearch en Phoenix, se puede utilizar la librer\u00eda elastic que proporciona una interfaz para interactuar con Elasticsearch. Por ejemplo, para realizar una consulta de b\u00fasqueda en Elasticsearch, se puede utilizar el siguiente c\u00f3digo: {:ok, conn} = Elastic.conn() Elastic.search(conn, \"index_name\", \"query\") Ejercicios pr\u00e1cticos \u00b6 Integra un componente React en una aplicaci\u00f3n Phoenix utilizando la librer\u00eda phoenix_react . Crea un esquema de GraphQL en Phoenix utilizando la librer\u00eda absinthe y realiza una consulta b\u00e1sica. Realiza una consulta de b\u00fasqueda en Elasticsearch desde una aplicaci\u00f3n Phoenix utilizando la librer\u00eda elastic . Consejos y mejores pr\u00e1cticas \u00b6 Al integrar diferentes tecnolog\u00edas en Phoenix, es importante mantener un buen equilibrio entre la complejidad y la funcionalidad. No es necesario utilizar todas las tecnolog\u00edas disponibles, solo aquellas que agreguen valor a la aplicaci\u00f3n. Al utilizar librer\u00edas de terceros, es necesario asegurarse de que est\u00e9n bien mantenidas y actualizadas para evitar posibles problemas de seguridad. Es importante comprender c\u00f3mo funcionan las diferentes tecnolog\u00edas y c\u00f3mo se integran entre s\u00ed para poder solucionar problemas si surgen. Al utilizar diferentes tecnolog\u00edas, es necesario asegurarse de que sean compatibles entre s\u00ed y que se puedan integrar de manera efectiva. Al integrar tecnolog\u00edas externas, se debe tener en cuenta la seguridad y proteger la aplicaci\u00f3n de posibles vulnerabilidades.","title":"Integraci\u00f3n con otras tecnolog\u00edas"},{"location":"phoenix/mid/integraci%C3%B3n_con_otras_tecnolog%C3%ADas/#integracion-con-otras-tecnologias-en-phoenix-framework","text":"En el mundo del desarrollo web, es com\u00fan encontrar aplicaciones que utilizan diferentes tecnolog\u00edas para su creaci\u00f3n. Una de las ventajas de Phoenix Framework es su capacidad de integrarse con otras tecnolog\u00edas, permitiendo crear aplicaciones m\u00e1s robustas y escalables. En esta lecci\u00f3n, aprenderemos c\u00f3mo integrar Phoenix con otras tecnolog\u00edas populares como React, GraphQL y Elasticsearch.","title":"Integraci\u00f3n con otras tecnolog\u00edas en Phoenix Framework"},{"location":"phoenix/mid/integraci%C3%B3n_con_otras_tecnolog%C3%ADas/#teoria","text":"Integrar Phoenix con otras tecnolog\u00edas implica utilizar diferentes herramientas y librer\u00edas para conectar y comunicar diferentes sistemas entre s\u00ed. Esto permite aprovechar las fortalezas de cada tecnolog\u00eda y crear aplicaciones m\u00e1s complejas y poderosas. La integraci\u00f3n tambi\u00e9n permite mejorar el rendimiento y la experiencia del usuario al utilizar tecnolog\u00edas m\u00e1s avanzadas y especializadas.","title":"Teor\u00eda"},{"location":"phoenix/mid/integraci%C3%B3n_con_otras_tecnolog%C3%ADas/#palabras-clave-y-definiciones","text":"React : una librer\u00eda de JavaScript para crear interfaces de usuario interactivas y din\u00e1micas. GraphQL : un lenguaje de consulta y una capa de transporte para APIs que permite a los clientes especificar exactamente los datos que necesitan. Elasticsearch : una base de datos de b\u00fasqueda y an\u00e1lisis distribuida y escalable. REST : Representational State Transfer es un estilo arquitect\u00f3nico para la creaci\u00f3n de servicios web. WebSocket : un protocolo de comunicaci\u00f3n bidireccional entre un cliente y un servidor que permite una conexi\u00f3n persistente y en tiempo real.","title":"Palabras clave y definiciones"},{"location":"phoenix/mid/integraci%C3%B3n_con_otras_tecnolog%C3%ADas/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es React y c\u00f3mo se integra con Phoenix? \u00bfCu\u00e1l es la funci\u00f3n de GraphQL en la integraci\u00f3n de tecnolog\u00edas en Phoenix? \u00bfQu\u00e9 es Elasticsearch y c\u00f3mo se utiliza en conjunto con Phoenix? \u00bfCu\u00e1l es la diferencia entre REST y WebSocket? \u00bfPor qu\u00e9 es importante la integraci\u00f3n de tecnolog\u00edas en Phoenix Framework?","title":"Preguntas de repaso"},{"location":"phoenix/mid/integraci%C3%B3n_con_otras_tecnolog%C3%ADas/#ejemplos-de-codigo-en-phoenix-framework","text":"","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix/mid/integraci%C3%B3n_con_otras_tecnolog%C3%ADas/#integracion-con-react","text":"Para integrar React en Phoenix Framework, se puede utilizar la librer\u00eda phoenix_react que proporciona una manera sencilla de crear componentes React en una aplicaci\u00f3n Phoenix. Por ejemplo, para crear un componente HelloWorld en React, se puede utilizar el siguiente c\u00f3digo en el archivo hello_world.js : import React from 'react' import { render } from 'react-dom' const HelloWorld = () => ( < h1 > Hello World ! </ h1 > ) render ( < HelloWorld /> , document . getElementById ( 'root' )) Luego, en el archivo index.html.eex se puede incluir el componente como sigue: <div id= \"root\" > <%= react_component @conn , HelloWorld %> </div>","title":"Integraci\u00f3n con React"},{"location":"phoenix/mid/integraci%C3%B3n_con_otras_tecnolog%C3%ADas/#integracion-con-graphql","text":"Para integrar GraphQL en Phoenix, se puede utilizar la librer\u00eda absinthe que proporciona una implementaci\u00f3n de GraphQL para Elixir. Primero, se debe configurar el esquema de GraphQL en el archivo schema.ex y luego definir los resolvers para manejar las consultas. Un ejemplo de un esquema b\u00e1sico de GraphQL en Phoenix ser\u00eda el siguiente: defmodule MyApp.Schema do use Absinthe.Schema query do field :greeting, :string do resolve &MyApp.Resolvers.greeting/3 end end end defmodule MyApp.Resolvers do def greeting(_, _, _ ), do: \"Hello World!\" end","title":"Integraci\u00f3n con GraphQL"},{"location":"phoenix/mid/integraci%C3%B3n_con_otras_tecnolog%C3%ADas/#integracion-con-elasticsearch","text":"Para integrar Elasticsearch en Phoenix, se puede utilizar la librer\u00eda elastic que proporciona una interfaz para interactuar con Elasticsearch. Por ejemplo, para realizar una consulta de b\u00fasqueda en Elasticsearch, se puede utilizar el siguiente c\u00f3digo: {:ok, conn} = Elastic.conn() Elastic.search(conn, \"index_name\", \"query\")","title":"Integraci\u00f3n con Elasticsearch"},{"location":"phoenix/mid/integraci%C3%B3n_con_otras_tecnolog%C3%ADas/#ejercicios-practicos","text":"Integra un componente React en una aplicaci\u00f3n Phoenix utilizando la librer\u00eda phoenix_react . Crea un esquema de GraphQL en Phoenix utilizando la librer\u00eda absinthe y realiza una consulta b\u00e1sica. Realiza una consulta de b\u00fasqueda en Elasticsearch desde una aplicaci\u00f3n Phoenix utilizando la librer\u00eda elastic .","title":"Ejercicios pr\u00e1cticos"},{"location":"phoenix/mid/integraci%C3%B3n_con_otras_tecnolog%C3%ADas/#consejos-y-mejores-practicas","text":"Al integrar diferentes tecnolog\u00edas en Phoenix, es importante mantener un buen equilibrio entre la complejidad y la funcionalidad. No es necesario utilizar todas las tecnolog\u00edas disponibles, solo aquellas que agreguen valor a la aplicaci\u00f3n. Al utilizar librer\u00edas de terceros, es necesario asegurarse de que est\u00e9n bien mantenidas y actualizadas para evitar posibles problemas de seguridad. Es importante comprender c\u00f3mo funcionan las diferentes tecnolog\u00edas y c\u00f3mo se integran entre s\u00ed para poder solucionar problemas si surgen. Al utilizar diferentes tecnolog\u00edas, es necesario asegurarse de que sean compatibles entre s\u00ed y que se puedan integrar de manera efectiva. Al integrar tecnolog\u00edas externas, se debe tener en cuenta la seguridad y proteger la aplicaci\u00f3n de posibles vulnerabilidades.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"phoenix/mid/middlewares_y_plug/","text":"Middlewares y Plug \u00b6 Introducci\u00f3n \u00b6 Los middlewares son una parte esencial en cualquier aplicaci\u00f3n web, ya que permiten el procesamiento de las peticiones antes de llegar al controlador. Esto nos da la oportunidad de realizar tareas como la autenticaci\u00f3n, la validaci\u00f3n de datos y la gesti\u00f3n de errores de manera centralizada y eficiente. En Phoenix Framework, los middlewares son implementados utilizando el m\u00f3dulo Plug, que nos proporciona una manera sencilla y robusta de crear nuestros propios middlewares. Teor\u00eda \u00b6 Un middleware es una funci\u00f3n que se ejecuta antes o despu\u00e9s de que una petici\u00f3n llegue al controlador. Es una forma de encapsular l\u00f3gica que puede ser aplicada a m\u00faltiples rutas dentro de una aplicaci\u00f3n. Los middlewares son \u00fatiles para tareas como la autenticaci\u00f3n, la gesti\u00f3n de sesiones, la compresi\u00f3n de respuestas, el registro de solicitudes, entre otras. En Phoenix, los middlewares se ejecutan en una cadena, lo que significa que el resultado de uno se pasa al siguiente y as\u00ed sucesivamente. Esto nos permite crear una l\u00f3gica de procesamiento en capas para nuestras peticiones. Palabras clave y su definici\u00f3n \u00b6 Middleware: Funci\u00f3n que se ejecuta antes o despu\u00e9s de que una petici\u00f3n llegue al controlador. Plug: M\u00f3dulo en Phoenix Framework utilizado para crear middlewares. Chain: Cadena de ejecuci\u00f3n de middlewares, donde el resultado de uno se pasa al siguiente. Preguntas de repaso \u00b6 \u00bfQu\u00e9 son los middlewares y para qu\u00e9 se utilizan? \u00bfQu\u00e9 m\u00f3dulo se utiliza en Phoenix Framework para crear middlewares? \u00bfC\u00f3mo se ejecutan los middlewares en Phoenix? \u00bfPara qu\u00e9 tareas son \u00fatiles los middlewares? \u00bfQu\u00e9 es una cadena de ejecuci\u00f3n de middlewares? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 Para crear un middleware en Phoenix, primero debemos crear un m\u00f3dulo Plug que implemente la funci\u00f3n call/2 . Esta funci\u00f3n recibir\u00e1 la petici\u00f3n y el siguiente middleware en la cadena como par\u00e1metros. A continuaci\u00f3n, se muestra un ejemplo de un middleware de autenticaci\u00f3n b\u00e1sico que verifica si el usuario est\u00e1 autenticado antes de permitir el acceso a una ruta determinada: defmodule MyApp . AuthenticationMiddleware do import Plug.Conn alias MyApp . Authentication def init ( _opts ), do : % {} def call ( conn , _opts ) do if Authentication . is_authenticated ? ( conn ) do conn else conn |> put_status ( 401 ) |> send_resp ( \"No est\u00e1s autenticado\" ) |> halt () end end end Una vez que tenemos nuestro middleware, podemos utilizarlo en nuestras rutas utilizando la macro plug , como se muestra a continuaci\u00f3n: defmodule MyApp . Router do use MyApp . Web , : router plug MyApp . AuthenticationMiddleware when action in [: show , : update ] scope \"/users\" do get \"/:id\" , UserController , : show put \"/:id\" , UserController , : update end end En este ejemplo, nuestro middleware se ejecutar\u00e1 antes de las acciones show y update del controlador UserController . Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea un nuevo m\u00f3dulo Plug que implemente una funci\u00f3n call/2 y que imprima un mensaje en la consola cada vez que se le llame. Utiliza este middleware en una de tus rutas y verifica que el mensaje se imprima correctamente. Crea un nuevo middleware que verifique si el usuario tiene un rol espec\u00edfico antes de permitir el acceso a una ruta determinada. Utiliza este middleware en una ruta de tu aplicaci\u00f3n y comprueba que solo los usuarios con el rol adecuado puedan acceder a ella. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza middlewares para tareas que se aplican a m\u00faltiples rutas en tu aplicaci\u00f3n. Crea middlewares reutilizables para tareas comunes como la autenticaci\u00f3n y la gesti\u00f3n de sesiones. Aseg\u00farate de que los middlewares se ejecuten en el orden adecuado en la cadena, ya que esto puede afectar su funcionamiento. Utiliza la documentaci\u00f3n de Plug para conocer todas las opciones y funciones disponibles para crear middlewares en Phoenix.","title":"Middlewares y Plug"},{"location":"phoenix/mid/middlewares_y_plug/#middlewares-y-plug","text":"","title":"Middlewares y Plug"},{"location":"phoenix/mid/middlewares_y_plug/#introduccion","text":"Los middlewares son una parte esencial en cualquier aplicaci\u00f3n web, ya que permiten el procesamiento de las peticiones antes de llegar al controlador. Esto nos da la oportunidad de realizar tareas como la autenticaci\u00f3n, la validaci\u00f3n de datos y la gesti\u00f3n de errores de manera centralizada y eficiente. En Phoenix Framework, los middlewares son implementados utilizando el m\u00f3dulo Plug, que nos proporciona una manera sencilla y robusta de crear nuestros propios middlewares.","title":"Introducci\u00f3n"},{"location":"phoenix/mid/middlewares_y_plug/#teoria","text":"Un middleware es una funci\u00f3n que se ejecuta antes o despu\u00e9s de que una petici\u00f3n llegue al controlador. Es una forma de encapsular l\u00f3gica que puede ser aplicada a m\u00faltiples rutas dentro de una aplicaci\u00f3n. Los middlewares son \u00fatiles para tareas como la autenticaci\u00f3n, la gesti\u00f3n de sesiones, la compresi\u00f3n de respuestas, el registro de solicitudes, entre otras. En Phoenix, los middlewares se ejecutan en una cadena, lo que significa que el resultado de uno se pasa al siguiente y as\u00ed sucesivamente. Esto nos permite crear una l\u00f3gica de procesamiento en capas para nuestras peticiones.","title":"Teor\u00eda"},{"location":"phoenix/mid/middlewares_y_plug/#palabras-clave-y-su-definicion","text":"Middleware: Funci\u00f3n que se ejecuta antes o despu\u00e9s de que una petici\u00f3n llegue al controlador. Plug: M\u00f3dulo en Phoenix Framework utilizado para crear middlewares. Chain: Cadena de ejecuci\u00f3n de middlewares, donde el resultado de uno se pasa al siguiente.","title":"Palabras clave y su definici\u00f3n"},{"location":"phoenix/mid/middlewares_y_plug/#preguntas-de-repaso","text":"\u00bfQu\u00e9 son los middlewares y para qu\u00e9 se utilizan? \u00bfQu\u00e9 m\u00f3dulo se utiliza en Phoenix Framework para crear middlewares? \u00bfC\u00f3mo se ejecutan los middlewares en Phoenix? \u00bfPara qu\u00e9 tareas son \u00fatiles los middlewares? \u00bfQu\u00e9 es una cadena de ejecuci\u00f3n de middlewares?","title":"Preguntas de repaso"},{"location":"phoenix/mid/middlewares_y_plug/#ejemplos-de-codigo-en-phoenix-framework","text":"Para crear un middleware en Phoenix, primero debemos crear un m\u00f3dulo Plug que implemente la funci\u00f3n call/2 . Esta funci\u00f3n recibir\u00e1 la petici\u00f3n y el siguiente middleware en la cadena como par\u00e1metros. A continuaci\u00f3n, se muestra un ejemplo de un middleware de autenticaci\u00f3n b\u00e1sico que verifica si el usuario est\u00e1 autenticado antes de permitir el acceso a una ruta determinada: defmodule MyApp . AuthenticationMiddleware do import Plug.Conn alias MyApp . Authentication def init ( _opts ), do : % {} def call ( conn , _opts ) do if Authentication . is_authenticated ? ( conn ) do conn else conn |> put_status ( 401 ) |> send_resp ( \"No est\u00e1s autenticado\" ) |> halt () end end end Una vez que tenemos nuestro middleware, podemos utilizarlo en nuestras rutas utilizando la macro plug , como se muestra a continuaci\u00f3n: defmodule MyApp . Router do use MyApp . Web , : router plug MyApp . AuthenticationMiddleware when action in [: show , : update ] scope \"/users\" do get \"/:id\" , UserController , : show put \"/:id\" , UserController , : update end end En este ejemplo, nuestro middleware se ejecutar\u00e1 antes de las acciones show y update del controlador UserController .","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix/mid/middlewares_y_plug/#ejercicios-practicos-con-instrucciones-claras","text":"Crea un nuevo m\u00f3dulo Plug que implemente una funci\u00f3n call/2 y que imprima un mensaje en la consola cada vez que se le llame. Utiliza este middleware en una de tus rutas y verifica que el mensaje se imprima correctamente. Crea un nuevo middleware que verifique si el usuario tiene un rol espec\u00edfico antes de permitir el acceso a una ruta determinada. Utiliza este middleware en una ruta de tu aplicaci\u00f3n y comprueba que solo los usuarios con el rol adecuado puedan acceder a ella.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"phoenix/mid/middlewares_y_plug/#consejos-o-mejores-practicas","text":"Utiliza middlewares para tareas que se aplican a m\u00faltiples rutas en tu aplicaci\u00f3n. Crea middlewares reutilizables para tareas comunes como la autenticaci\u00f3n y la gesti\u00f3n de sesiones. Aseg\u00farate de que los middlewares se ejecuten en el orden adecuado en la cadena, ya que esto puede afectar su funcionamiento. Utiliza la documentaci\u00f3n de Plug para conocer todas las opciones y funciones disponibles para crear middlewares en Phoenix.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix/mid/optimizaci%C3%B3n_de_rendimiento/","text":"Optimizaci\u00f3n de rendimiento en Phoenix Framework \u00b6 Introducci\u00f3n \u00b6 La optimizaci\u00f3n de rendimiento es un aspecto clave en el desarrollo de aplicaciones Phoenix, ya que permite mejorar la velocidad y eficiencia de la aplicaci\u00f3n, lo que se traduce en una mejor experiencia para los usuarios y una mayor escalabilidad del sistema. En este m\u00f3dulo, aprenderemos t\u00e9cnicas y mejores pr\u00e1cticas para optimizar el rendimiento de una aplicaci\u00f3n Phoenix. Teor\u00eda \u00b6 La optimizaci\u00f3n de rendimiento en Phoenix se centra en mejorar el tiempo de respuesta de la aplicaci\u00f3n, minimizar el consumo de recursos y reducir la latencia. Esto se logra mediante la identificaci\u00f3n y soluci\u00f3n de posibles cuellos de botella en la aplicaci\u00f3n. Algunas de las t\u00e9cnicas comunes para mejorar el rendimiento en Phoenix incluyen el uso de cach\u00e9, la optimizaci\u00f3n del c\u00f3digo y el uso eficiente de las bases de datos. Tambi\u00e9n es importante tener en cuenta el hardware y la infraestructura en la que se ejecuta la aplicaci\u00f3n, ya que pueden tener un impacto significativo en el rendimiento. Palabras clave \u00b6 Rendimiento: Se refiere a la velocidad y eficiencia de una aplicaci\u00f3n en t\u00e9rminos de tiempo de respuesta, consumo de recursos y latencia. Cach\u00e9: Almacenamiento temporal de datos para reducir el tiempo de acceso y mejorar el rendimiento. Cuellos de botella: Puntos cr\u00edticos en una aplicaci\u00f3n que limitan su rendimiento. Latencia: Tiempo que tarda una solicitud en ser procesada y responder. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la optimizaci\u00f3n de rendimiento en Phoenix? \u00bfCu\u00e1les son algunas t\u00e9cnicas comunes para mejorar el rendimiento en Phoenix? \u00bfQu\u00e9 es el cach\u00e9 y c\u00f3mo puede ayudar a mejorar el rendimiento? \u00bfQu\u00e9 son los cuellos de botella en una aplicaci\u00f3n? \u00bfPor qu\u00e9 es importante tener en cuenta el hardware y la infraestructura al optimizar el rendimiento en Phoenix? Ejemplos de c\u00f3digo \u00b6 Uso de cach\u00e9 en Phoenix \u00b6 # En el controlador def index ( conn , _params ) do # Verificar si los datos ya est\u00e1n en cach\u00e9 cached_data = Cache . get ( \"data\" ) if cached_data do # Utilizar los datos de cach\u00e9 render ( conn , \"index.html\" , data : cached_data ) else # Obtener los datos de la base de datos data = Repo . all ( Data ) # Almacenar los datos en cach\u00e9 por 5 minutos Cache . put ( \"data\" , data , 5 * 60 ) render ( conn , \"index.html\" , data : data ) end end Uso de consultas eficientes en la base de datos \u00b6 # Evitar cargar todos los registros en memoria # Usar paginaci\u00f3n para limitar la cantidad de registros por p\u00e1gina Repo . all ( from ( d in Data , limit : 20 )) # Utilizar la funci\u00f3n preload para cargar relaciones en una sola consulta Repo . all ( from ( d in Data , preload : [ :relation ])) Ejercicios pr\u00e1cticos \u00b6 Implementar un cach\u00e9 para una lista de noticias en un controlador de una aplicaci\u00f3n Phoenix. Optimizar una consulta en la base de datos utilizando paginaci\u00f3n y la funci\u00f3n preload. Consejos y mejores pr\u00e1cticas \u00b6 Realizar pruebas de rendimiento regularmente para identificar posibles problemas. Evitar cargar grandes cantidades de datos en memoria. Utilizar el cach\u00e9 de manera estrat\u00e9gica para mejorar el rendimiento. Utilizar consultas eficientes en la base de datos, evitando cargar relaciones innecesarias. Considerar la escalabilidad al dise\u00f1ar la arquitectura de la aplicaci\u00f3n. Utilizar herramientas de monitorizaci\u00f3n para identificar cuellos de botella y tomar medidas para solucionarlos. En resumen, la optimizaci\u00f3n de rendimiento en Phoenix es un proceso continuo que requiere de un enfoque estrat\u00e9gico y el uso de t\u00e9cnicas y mejores pr\u00e1cticas para garantizar una aplicaci\u00f3n r\u00e1pida, eficiente y escalable. Con la implementaci\u00f3n adecuada, se puede lograr una mejor experiencia para los usuarios y un sistema robusto y confiable.","title":"Optimizaci\u00f3n de rendimiento en Phoenix Framework"},{"location":"phoenix/mid/optimizaci%C3%B3n_de_rendimiento/#optimizacion-de-rendimiento-en-phoenix-framework","text":"","title":"Optimizaci\u00f3n de rendimiento en Phoenix Framework"},{"location":"phoenix/mid/optimizaci%C3%B3n_de_rendimiento/#introduccion","text":"La optimizaci\u00f3n de rendimiento es un aspecto clave en el desarrollo de aplicaciones Phoenix, ya que permite mejorar la velocidad y eficiencia de la aplicaci\u00f3n, lo que se traduce en una mejor experiencia para los usuarios y una mayor escalabilidad del sistema. En este m\u00f3dulo, aprenderemos t\u00e9cnicas y mejores pr\u00e1cticas para optimizar el rendimiento de una aplicaci\u00f3n Phoenix.","title":"Introducci\u00f3n"},{"location":"phoenix/mid/optimizaci%C3%B3n_de_rendimiento/#teoria","text":"La optimizaci\u00f3n de rendimiento en Phoenix se centra en mejorar el tiempo de respuesta de la aplicaci\u00f3n, minimizar el consumo de recursos y reducir la latencia. Esto se logra mediante la identificaci\u00f3n y soluci\u00f3n de posibles cuellos de botella en la aplicaci\u00f3n. Algunas de las t\u00e9cnicas comunes para mejorar el rendimiento en Phoenix incluyen el uso de cach\u00e9, la optimizaci\u00f3n del c\u00f3digo y el uso eficiente de las bases de datos. Tambi\u00e9n es importante tener en cuenta el hardware y la infraestructura en la que se ejecuta la aplicaci\u00f3n, ya que pueden tener un impacto significativo en el rendimiento.","title":"Teor\u00eda"},{"location":"phoenix/mid/optimizaci%C3%B3n_de_rendimiento/#palabras-clave","text":"Rendimiento: Se refiere a la velocidad y eficiencia de una aplicaci\u00f3n en t\u00e9rminos de tiempo de respuesta, consumo de recursos y latencia. Cach\u00e9: Almacenamiento temporal de datos para reducir el tiempo de acceso y mejorar el rendimiento. Cuellos de botella: Puntos cr\u00edticos en una aplicaci\u00f3n que limitan su rendimiento. Latencia: Tiempo que tarda una solicitud en ser procesada y responder.","title":"Palabras clave"},{"location":"phoenix/mid/optimizaci%C3%B3n_de_rendimiento/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la optimizaci\u00f3n de rendimiento en Phoenix? \u00bfCu\u00e1les son algunas t\u00e9cnicas comunes para mejorar el rendimiento en Phoenix? \u00bfQu\u00e9 es el cach\u00e9 y c\u00f3mo puede ayudar a mejorar el rendimiento? \u00bfQu\u00e9 son los cuellos de botella en una aplicaci\u00f3n? \u00bfPor qu\u00e9 es importante tener en cuenta el hardware y la infraestructura al optimizar el rendimiento en Phoenix?","title":"Preguntas de repaso"},{"location":"phoenix/mid/optimizaci%C3%B3n_de_rendimiento/#ejemplos-de-codigo","text":"","title":"Ejemplos de c\u00f3digo"},{"location":"phoenix/mid/optimizaci%C3%B3n_de_rendimiento/#uso-de-cache-en-phoenix","text":"# En el controlador def index ( conn , _params ) do # Verificar si los datos ya est\u00e1n en cach\u00e9 cached_data = Cache . get ( \"data\" ) if cached_data do # Utilizar los datos de cach\u00e9 render ( conn , \"index.html\" , data : cached_data ) else # Obtener los datos de la base de datos data = Repo . all ( Data ) # Almacenar los datos en cach\u00e9 por 5 minutos Cache . put ( \"data\" , data , 5 * 60 ) render ( conn , \"index.html\" , data : data ) end end","title":"Uso de cach\u00e9 en Phoenix"},{"location":"phoenix/mid/optimizaci%C3%B3n_de_rendimiento/#uso-de-consultas-eficientes-en-la-base-de-datos","text":"# Evitar cargar todos los registros en memoria # Usar paginaci\u00f3n para limitar la cantidad de registros por p\u00e1gina Repo . all ( from ( d in Data , limit : 20 )) # Utilizar la funci\u00f3n preload para cargar relaciones en una sola consulta Repo . all ( from ( d in Data , preload : [ :relation ]))","title":"Uso de consultas eficientes en la base de datos"},{"location":"phoenix/mid/optimizaci%C3%B3n_de_rendimiento/#ejercicios-practicos","text":"Implementar un cach\u00e9 para una lista de noticias en un controlador de una aplicaci\u00f3n Phoenix. Optimizar una consulta en la base de datos utilizando paginaci\u00f3n y la funci\u00f3n preload.","title":"Ejercicios pr\u00e1cticos"},{"location":"phoenix/mid/optimizaci%C3%B3n_de_rendimiento/#consejos-y-mejores-practicas","text":"Realizar pruebas de rendimiento regularmente para identificar posibles problemas. Evitar cargar grandes cantidades de datos en memoria. Utilizar el cach\u00e9 de manera estrat\u00e9gica para mejorar el rendimiento. Utilizar consultas eficientes en la base de datos, evitando cargar relaciones innecesarias. Considerar la escalabilidad al dise\u00f1ar la arquitectura de la aplicaci\u00f3n. Utilizar herramientas de monitorizaci\u00f3n para identificar cuellos de botella y tomar medidas para solucionarlos. En resumen, la optimizaci\u00f3n de rendimiento en Phoenix es un proceso continuo que requiere de un enfoque estrat\u00e9gico y el uso de t\u00e9cnicas y mejores pr\u00e1cticas para garantizar una aplicaci\u00f3n r\u00e1pida, eficiente y escalable. Con la implementaci\u00f3n adecuada, se puede lograr una mejor experiencia para los usuarios y un sistema robusto y confiable.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"phoenix/mid/pruebas_en_phoenix/","text":"Pruebas en Phoenix \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En este m\u00f3dulo aprenderemos sobre la importancia de las pruebas en el desarrollo de aplicaciones con Phoenix Framework. Veremos c\u00f3mo utilizar herramientas como ExUnit y Hound para escribir pruebas automatizadas que nos ayuden a garantizar el correcto funcionamiento de nuestra aplicaci\u00f3n. Explicaci\u00f3n te\u00f3rica \u00b6 Las pruebas son una parte fundamental en el desarrollo de aplicaciones. Nos permiten verificar que nuestro c\u00f3digo funciona correctamente y que no se introducen errores al realizar cambios o a\u00f1adir nuevas funcionalidades. Adem\u00e1s, nos ayudan a mantener un c\u00f3digo m\u00e1s limpio y organizado, ya que nos obligan a escribir un c\u00f3digo m\u00e1s modular y f\u00e1cil de probar. En Phoenix Framework, las pruebas se realizan a trav\u00e9s de dos herramientas principales: ExUnit y Hound. ExUnit es una librer\u00eda de pruebas unitarias que nos permite probar funciones y m\u00f3dulos de forma aislada. Por otro lado, Hound es una librer\u00eda de pruebas de integraci\u00f3n que nos permite simular interacciones con la aplicaci\u00f3n como si fuera un usuario real. Palabras clave y definiciones \u00b6 Pruebas: Son el proceso de verificar que nuestro c\u00f3digo funciona correctamente. ExUnit: Librer\u00eda de pruebas unitarias en Phoenix Framework. Hound: Librer\u00eda de pruebas de integraci\u00f3n en Phoenix Framework. Pruebas unitarias: Son pruebas que se realizan sobre funciones y m\u00f3dulos de forma aislada. Pruebas de integraci\u00f3n: Son pruebas que se realizan sobre la aplicaci\u00f3n en su conjunto, simulando interacciones con ella. Preguntas de repaso \u00b6 \u00bfPor qu\u00e9 son importantes las pruebas en el desarrollo de aplicaciones? \u00bfQu\u00e9 es ExUnit y para qu\u00e9 se utiliza? \u00bfQu\u00e9 es Hound y para qu\u00e9 se utiliza? \u00bfCu\u00e1l es la diferencia entre pruebas unitarias y pruebas de integraci\u00f3n? \u00bfCu\u00e1les son algunas de las ventajas de utilizar pruebas en nuestro c\u00f3digo? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 Pruebas unitarias con ExUnit \u00b6 defmodule CalculatorTest do use ExUnit.Case test \"suma dos n\u00fameros\" do assert Calculator . sum ( 2 , 3 ) == 5 end test \"resta dos n\u00fameros\" do assert Calculator . sub ( 5 , 2 ) == 3 end end Pruebas de integraci\u00f3n con Hound \u00b6 defmodule LoginTest do use ExUnit.Case , async : true use Hound.Helpers setup do :ok = Application . ensure_all_started ( :my_app ) { :ok , driver : \"phantomjs\" } end test \"iniciar sesi\u00f3n con credenciales v\u00e1lidas\" do navigate_to ( \"http://localhost:4000/login\" ) fill_field ( \" # email\" , \"test@example.com\" ) fill_field ( \" # password\" , \"password\" ) click ( \" # login-btn\" ) assert_title ( \"P\u00e1gina de inicio\" ) end end Ejercicios pr\u00e1cticos \u00b6 Realiza pruebas unitarias para una funci\u00f3n que calcule el \u00e1rea de un tri\u00e1ngulo. Implementa pruebas de integraci\u00f3n para un formulario de registro en tu aplicaci\u00f3n. Consejos o mejores pr\u00e1cticas \u00b6 Es importante tener una buena cobertura de pruebas, pero no es necesario probar absolutamente cada l\u00ednea de c\u00f3digo. Enf\u00f3cate en las partes cr\u00edticas y en las funcionalidades m\u00e1s complejas. Utiliza nombres descriptivos para tus pruebas, esto te ayudar\u00e1 a entender r\u00e1pidamente qu\u00e9 se est\u00e1 probando. No te olvides de actualizar tus pruebas cuando hagas cambios en el c\u00f3digo. De lo contrario, podr\u00edas estar probando funcionalidades que ya no existen o introduciendo nuevos errores. Utiliza herramientas de an\u00e1lisis de cobertura de pruebas para asegurarte de que no hay partes de tu c\u00f3digo que no est\u00e1n siendo probadas. Siempre piensa en los casos de prueba m\u00e1s extremos y en los posibles errores que pueden ocurrir. No tengas miedo de refactorizar tus pruebas si el c\u00f3digo cambia y se vuelve m\u00e1s f\u00e1cil de probar. Las pruebas tambi\u00e9n deben evolucionar junto con el c\u00f3digo.","title":"Pruebas en Phoenix"},{"location":"phoenix/mid/pruebas_en_phoenix/#pruebas-en-phoenix","text":"","title":"Pruebas en Phoenix"},{"location":"phoenix/mid/pruebas_en_phoenix/#descripcion-del-modulo","text":"En este m\u00f3dulo aprenderemos sobre la importancia de las pruebas en el desarrollo de aplicaciones con Phoenix Framework. Veremos c\u00f3mo utilizar herramientas como ExUnit y Hound para escribir pruebas automatizadas que nos ayuden a garantizar el correcto funcionamiento de nuestra aplicaci\u00f3n.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"phoenix/mid/pruebas_en_phoenix/#explicacion-teorica","text":"Las pruebas son una parte fundamental en el desarrollo de aplicaciones. Nos permiten verificar que nuestro c\u00f3digo funciona correctamente y que no se introducen errores al realizar cambios o a\u00f1adir nuevas funcionalidades. Adem\u00e1s, nos ayudan a mantener un c\u00f3digo m\u00e1s limpio y organizado, ya que nos obligan a escribir un c\u00f3digo m\u00e1s modular y f\u00e1cil de probar. En Phoenix Framework, las pruebas se realizan a trav\u00e9s de dos herramientas principales: ExUnit y Hound. ExUnit es una librer\u00eda de pruebas unitarias que nos permite probar funciones y m\u00f3dulos de forma aislada. Por otro lado, Hound es una librer\u00eda de pruebas de integraci\u00f3n que nos permite simular interacciones con la aplicaci\u00f3n como si fuera un usuario real.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix/mid/pruebas_en_phoenix/#palabras-clave-y-definiciones","text":"Pruebas: Son el proceso de verificar que nuestro c\u00f3digo funciona correctamente. ExUnit: Librer\u00eda de pruebas unitarias en Phoenix Framework. Hound: Librer\u00eda de pruebas de integraci\u00f3n en Phoenix Framework. Pruebas unitarias: Son pruebas que se realizan sobre funciones y m\u00f3dulos de forma aislada. Pruebas de integraci\u00f3n: Son pruebas que se realizan sobre la aplicaci\u00f3n en su conjunto, simulando interacciones con ella.","title":"Palabras clave y definiciones"},{"location":"phoenix/mid/pruebas_en_phoenix/#preguntas-de-repaso","text":"\u00bfPor qu\u00e9 son importantes las pruebas en el desarrollo de aplicaciones? \u00bfQu\u00e9 es ExUnit y para qu\u00e9 se utiliza? \u00bfQu\u00e9 es Hound y para qu\u00e9 se utiliza? \u00bfCu\u00e1l es la diferencia entre pruebas unitarias y pruebas de integraci\u00f3n? \u00bfCu\u00e1les son algunas de las ventajas de utilizar pruebas en nuestro c\u00f3digo?","title":"Preguntas de repaso"},{"location":"phoenix/mid/pruebas_en_phoenix/#ejemplos-de-codigo-en-phoenix-framework","text":"","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix/mid/pruebas_en_phoenix/#pruebas-unitarias-con-exunit","text":"defmodule CalculatorTest do use ExUnit.Case test \"suma dos n\u00fameros\" do assert Calculator . sum ( 2 , 3 ) == 5 end test \"resta dos n\u00fameros\" do assert Calculator . sub ( 5 , 2 ) == 3 end end","title":"Pruebas unitarias con ExUnit"},{"location":"phoenix/mid/pruebas_en_phoenix/#pruebas-de-integracion-con-hound","text":"defmodule LoginTest do use ExUnit.Case , async : true use Hound.Helpers setup do :ok = Application . ensure_all_started ( :my_app ) { :ok , driver : \"phantomjs\" } end test \"iniciar sesi\u00f3n con credenciales v\u00e1lidas\" do navigate_to ( \"http://localhost:4000/login\" ) fill_field ( \" # email\" , \"test@example.com\" ) fill_field ( \" # password\" , \"password\" ) click ( \" # login-btn\" ) assert_title ( \"P\u00e1gina de inicio\" ) end end","title":"Pruebas de integraci\u00f3n con Hound"},{"location":"phoenix/mid/pruebas_en_phoenix/#ejercicios-practicos","text":"Realiza pruebas unitarias para una funci\u00f3n que calcule el \u00e1rea de un tri\u00e1ngulo. Implementa pruebas de integraci\u00f3n para un formulario de registro en tu aplicaci\u00f3n.","title":"Ejercicios pr\u00e1cticos"},{"location":"phoenix/mid/pruebas_en_phoenix/#consejos-o-mejores-practicas","text":"Es importante tener una buena cobertura de pruebas, pero no es necesario probar absolutamente cada l\u00ednea de c\u00f3digo. Enf\u00f3cate en las partes cr\u00edticas y en las funcionalidades m\u00e1s complejas. Utiliza nombres descriptivos para tus pruebas, esto te ayudar\u00e1 a entender r\u00e1pidamente qu\u00e9 se est\u00e1 probando. No te olvides de actualizar tus pruebas cuando hagas cambios en el c\u00f3digo. De lo contrario, podr\u00edas estar probando funcionalidades que ya no existen o introduciendo nuevos errores. Utiliza herramientas de an\u00e1lisis de cobertura de pruebas para asegurarte de que no hay partes de tu c\u00f3digo que no est\u00e1n siendo probadas. Siempre piensa en los casos de prueba m\u00e1s extremos y en los posibles errores que pueden ocurrir. No tengas miedo de refactorizar tus pruebas si el c\u00f3digo cambia y se vuelve m\u00e1s f\u00e1cil de probar. Las pruebas tambi\u00e9n deben evolucionar junto con el c\u00f3digo.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix/mid/seguridad_en_phoenix/","text":"Seguridad en Phoenix \u00b6 Introducci\u00f3n \u00b6 La seguridad es un aspecto fundamental en cualquier aplicaci\u00f3n web, ya que la informaci\u00f3n y los datos de los usuarios deben ser protegidos contra posibles ataques y vulnerabilidades. En el caso de las aplicaciones desarrolladas con Phoenix Framework, es importante conocer y aplicar medidas de seguridad para proteger nuestra aplicaci\u00f3n y los datos que maneja. En esta lecci\u00f3n, aprenderemos sobre las principales vulnerabilidades a las que se enfrentan las aplicaciones Phoenix y c\u00f3mo podemos asegurarlas. Teor\u00eda \u00b6 Las aplicaciones Phoenix est\u00e1n construidas con el lenguaje de programaci\u00f3n Elixir, que est\u00e1 basado en el paradigma de programaci\u00f3n funcional. Esto significa que la seguridad es un aspecto inherente al c\u00f3digo, ya que el lenguaje est\u00e1 dise\u00f1ado para evitar errores y prevenir vulnerabilidades. Sin embargo, a\u00fan es necesario aplicar medidas de seguridad adicionales para proteger nuestra aplicaci\u00f3n contra posibles ataques. Palabras clave y definiciones \u00b6 XSS (Cross-Site Scripting) : Es una vulnerabilidad que permite a un atacante insertar c\u00f3digo malicioso en una p\u00e1gina web, el cual se ejecutar\u00e1 en el navegador del usuario que acceda a dicha p\u00e1gina. CSRF (Cross-Site Request Forgery) : Es un tipo de ataque en el que un usuario leg\u00edtimo de una aplicaci\u00f3n web realiza acciones no deseadas sin su conocimiento, debido a que un sitio malicioso le env\u00eda solicitudes falsas utilizando su sesi\u00f3n activa en la aplicaci\u00f3n. Token : Es una cadena de caracteres aleatoria que se utiliza para validar la autenticidad de una solicitud. Se pueden implementar tokens para proteger contra ataques CSRF. Autenticaci\u00f3n : Es el proceso de identificar a los usuarios de una aplicaci\u00f3n y verificar que tienen los permisos adecuados para acceder a ciertas funciones o recursos. Autorizaci\u00f3n : Es el proceso de otorgar o denegar acceso a ciertos recursos o funciones a un usuario autenticado. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es XSS y c\u00f3mo puede afectar a una aplicaci\u00f3n Phoenix? \u00bfCu\u00e1l es la diferencia entre autenticaci\u00f3n y autorizaci\u00f3n? \u00bfQu\u00e9 es un token y c\u00f3mo puede ayudar a proteger una aplicaci\u00f3n contra ataques CSRF? Ejemplos de c\u00f3digo \u00b6 Protecci\u00f3n contra XSS \u00b6 En Phoenix, podemos utilizar la funci\u00f3n html_escape/1 para escapar cualquier c\u00f3digo HTML insertado por el usuario en nuestros templates. Por ejemplo: <h1> <%= html_escape ( @title ) %> </h1> Esto asegura que cualquier c\u00f3digo malicioso insertado por el usuario no se ejecute y se muestre como texto plano en lugar de ser interpretado como HTML. Protecci\u00f3n contra CSRF \u00b6 Para proteger nuestra aplicaci\u00f3n contra ataques CSRF, podemos utilizar tokens en nuestros formularios. En el controlador, podemos generar un token aleatorio y pasarlo al template a trav\u00e9s de la funci\u00f3n get_csrf_token/0 : def index(conn, _params) do render(conn, \"index.html\", csrf_token: get_csrf_token()) end Luego, en el template, podemos incluir el token en nuestro formulario: <form action= \"/users\" method= \"post\" > <input type= \"hidden\" name= \"_csrf_token\" value= \" <%= @csrf_token %> \" > ... </form> En el controlador, podemos verificar que el token recibido en la solicitud sea el mismo que el que generamos previamente: def create ( conn , % { \"user\" => user_params }) do case Plug . CSRFProtection . verify_token ( conn , user_params [ \"_csrf_token\" ]) do { : ok , conn } -> # Token v\u00e1lido , procesar la solicitud { : error , conn } -> # Token inv\u00e1lido , mostrar un error o redirigir a una p\u00e1gina de error end end Ejercicios pr\u00e1cticos \u00b6 Implementar la protecci\u00f3n contra XSS en un template de tu aplicaci\u00f3n Phoenix. Crear un formulario que utilice tokens para protegerse contra ataques CSRF. Investigar y utilizar alg\u00fan paquete de seguridad espec\u00edfico para aplicaciones Phoenix, como Guardian o Coherence. Consejos y mejores pr\u00e1cticas \u00b6 Utilizar la funci\u00f3n html_escape/1 en todos los templates para escapar cualquier c\u00f3digo HTML insertado por el usuario. Implementar autenticaci\u00f3n y autorizaci\u00f3n adecuadas para limitar el acceso a ciertas funciones o recursos. Utilizar tokens en formularios para proteger contra ataques CSRF. Mantener la aplicaci\u00f3n y sus dependencias actualizadas para evitar posibles vulnerabilidades conocidas. Realizar pruebas de seguridad peri\u00f3dicas para identificar y corregir posibles vulnerabilidades en la aplicaci\u00f3n.","title":"Seguridad en Phoenix"},{"location":"phoenix/mid/seguridad_en_phoenix/#seguridad-en-phoenix","text":"","title":"Seguridad en Phoenix"},{"location":"phoenix/mid/seguridad_en_phoenix/#introduccion","text":"La seguridad es un aspecto fundamental en cualquier aplicaci\u00f3n web, ya que la informaci\u00f3n y los datos de los usuarios deben ser protegidos contra posibles ataques y vulnerabilidades. En el caso de las aplicaciones desarrolladas con Phoenix Framework, es importante conocer y aplicar medidas de seguridad para proteger nuestra aplicaci\u00f3n y los datos que maneja. En esta lecci\u00f3n, aprenderemos sobre las principales vulnerabilidades a las que se enfrentan las aplicaciones Phoenix y c\u00f3mo podemos asegurarlas.","title":"Introducci\u00f3n"},{"location":"phoenix/mid/seguridad_en_phoenix/#teoria","text":"Las aplicaciones Phoenix est\u00e1n construidas con el lenguaje de programaci\u00f3n Elixir, que est\u00e1 basado en el paradigma de programaci\u00f3n funcional. Esto significa que la seguridad es un aspecto inherente al c\u00f3digo, ya que el lenguaje est\u00e1 dise\u00f1ado para evitar errores y prevenir vulnerabilidades. Sin embargo, a\u00fan es necesario aplicar medidas de seguridad adicionales para proteger nuestra aplicaci\u00f3n contra posibles ataques.","title":"Teor\u00eda"},{"location":"phoenix/mid/seguridad_en_phoenix/#palabras-clave-y-definiciones","text":"XSS (Cross-Site Scripting) : Es una vulnerabilidad que permite a un atacante insertar c\u00f3digo malicioso en una p\u00e1gina web, el cual se ejecutar\u00e1 en el navegador del usuario que acceda a dicha p\u00e1gina. CSRF (Cross-Site Request Forgery) : Es un tipo de ataque en el que un usuario leg\u00edtimo de una aplicaci\u00f3n web realiza acciones no deseadas sin su conocimiento, debido a que un sitio malicioso le env\u00eda solicitudes falsas utilizando su sesi\u00f3n activa en la aplicaci\u00f3n. Token : Es una cadena de caracteres aleatoria que se utiliza para validar la autenticidad de una solicitud. Se pueden implementar tokens para proteger contra ataques CSRF. Autenticaci\u00f3n : Es el proceso de identificar a los usuarios de una aplicaci\u00f3n y verificar que tienen los permisos adecuados para acceder a ciertas funciones o recursos. Autorizaci\u00f3n : Es el proceso de otorgar o denegar acceso a ciertos recursos o funciones a un usuario autenticado.","title":"Palabras clave y definiciones"},{"location":"phoenix/mid/seguridad_en_phoenix/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es XSS y c\u00f3mo puede afectar a una aplicaci\u00f3n Phoenix? \u00bfCu\u00e1l es la diferencia entre autenticaci\u00f3n y autorizaci\u00f3n? \u00bfQu\u00e9 es un token y c\u00f3mo puede ayudar a proteger una aplicaci\u00f3n contra ataques CSRF?","title":"Preguntas de repaso"},{"location":"phoenix/mid/seguridad_en_phoenix/#ejemplos-de-codigo","text":"","title":"Ejemplos de c\u00f3digo"},{"location":"phoenix/mid/seguridad_en_phoenix/#proteccion-contra-xss","text":"En Phoenix, podemos utilizar la funci\u00f3n html_escape/1 para escapar cualquier c\u00f3digo HTML insertado por el usuario en nuestros templates. Por ejemplo: <h1> <%= html_escape ( @title ) %> </h1> Esto asegura que cualquier c\u00f3digo malicioso insertado por el usuario no se ejecute y se muestre como texto plano en lugar de ser interpretado como HTML.","title":"Protecci\u00f3n contra XSS"},{"location":"phoenix/mid/seguridad_en_phoenix/#proteccion-contra-csrf","text":"Para proteger nuestra aplicaci\u00f3n contra ataques CSRF, podemos utilizar tokens en nuestros formularios. En el controlador, podemos generar un token aleatorio y pasarlo al template a trav\u00e9s de la funci\u00f3n get_csrf_token/0 : def index(conn, _params) do render(conn, \"index.html\", csrf_token: get_csrf_token()) end Luego, en el template, podemos incluir el token en nuestro formulario: <form action= \"/users\" method= \"post\" > <input type= \"hidden\" name= \"_csrf_token\" value= \" <%= @csrf_token %> \" > ... </form> En el controlador, podemos verificar que el token recibido en la solicitud sea el mismo que el que generamos previamente: def create ( conn , % { \"user\" => user_params }) do case Plug . CSRFProtection . verify_token ( conn , user_params [ \"_csrf_token\" ]) do { : ok , conn } -> # Token v\u00e1lido , procesar la solicitud { : error , conn } -> # Token inv\u00e1lido , mostrar un error o redirigir a una p\u00e1gina de error end end","title":"Protecci\u00f3n contra CSRF"},{"location":"phoenix/mid/seguridad_en_phoenix/#ejercicios-practicos","text":"Implementar la protecci\u00f3n contra XSS en un template de tu aplicaci\u00f3n Phoenix. Crear un formulario que utilice tokens para protegerse contra ataques CSRF. Investigar y utilizar alg\u00fan paquete de seguridad espec\u00edfico para aplicaciones Phoenix, como Guardian o Coherence.","title":"Ejercicios pr\u00e1cticos"},{"location":"phoenix/mid/seguridad_en_phoenix/#consejos-y-mejores-practicas","text":"Utilizar la funci\u00f3n html_escape/1 en todos los templates para escapar cualquier c\u00f3digo HTML insertado por el usuario. Implementar autenticaci\u00f3n y autorizaci\u00f3n adecuadas para limitar el acceso a ciertas funciones o recursos. Utilizar tokens en formularios para proteger contra ataques CSRF. Mantener la aplicaci\u00f3n y sus dependencias actualizadas para evitar posibles vulnerabilidades conocidas. Realizar pruebas de seguridad peri\u00f3dicas para identificar y corregir posibles vulnerabilidades en la aplicaci\u00f3n.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"phoenix/sr/","text":"Phoenix - Nivel Senior \u00b6 \u00a1Bienvenido/a al nivel Senior del curso de Phoenix! Aqu\u00ed encontrar\u00e1s temas de experto: Internals de Phoenix Extensibilidad de Phoenix Debugging y troubleshooting Phoenix sin servidor Profundizando en Ecto Migraci\u00f3n de una aplicaci\u00f3n existente a Phoenix Contribuyendo a Phoenix","title":"Phoenix - Nivel Senior"},{"location":"phoenix/sr/#phoenix-nivel-senior","text":"\u00a1Bienvenido/a al nivel Senior del curso de Phoenix! Aqu\u00ed encontrar\u00e1s temas de experto: Internals de Phoenix Extensibilidad de Phoenix Debugging y troubleshooting Phoenix sin servidor Profundizando en Ecto Migraci\u00f3n de una aplicaci\u00f3n existente a Phoenix Contribuyendo a Phoenix","title":"Phoenix - Nivel Senior"},{"location":"phoenix/sr/contribuyendo_a_phoenix/","text":"Contribuyendo a Phoenix \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 Phoenix Framework es un framework web de c\u00f3digo abierto escrito en el lenguaje de programaci\u00f3n Elixir. Fue dise\u00f1ado para crear aplicaciones web escalables y de alto rendimiento utilizando el patr\u00f3n de arquitectura Modelo-Vista-Controlador (MVC). Phoenix se basa en la plataforma de c\u00f3digo abierto Erlang y se ejecuta en la m\u00e1quina virtual de Erlang (BEAM). Uno de los principales beneficios de utilizar Phoenix es su enfoque en la productividad y el rendimiento. El framework utiliza el modelo de concurrencia de Erlang, lo que significa que puede manejar miles de solicitudes simult\u00e1neas sin afectar el rendimiento. Adem\u00e1s, Phoenix proporciona una estructura de proyecto bien definida y herramientas para facilitar el desarrollo de aplicaciones web. La comunidad de Phoenix es muy activa y acogedora, y siempre est\u00e1 buscando formas de mejorar y hacer crecer el framework. Esto significa que cualquiera puede contribuir al desarrollo de Phoenix y ayudar a la comunidad a mejorar la plataforma para todos. Palabras clave y su definici\u00f3n \u00b6 Phoenix Framework: un framework web escrito en Elixir que se basa en Erlang y se ejecuta en la m\u00e1quina virtual de Erlang (BEAM). Elixir: un lenguaje de programaci\u00f3n funcional din\u00e1mico dise\u00f1ado para crear aplicaciones escalables y de alta disponibilidad. Erlang: un lenguaje de programaci\u00f3n dise\u00f1ado para crear sistemas distribuidos y tolerantes a fallos. BEAM: m\u00e1quina virtual de Erlang que ejecuta el c\u00f3digo Elixir. Modelo-Vista-Controlador (MVC): un patr\u00f3n de arquitectura utilizado para separar la l\u00f3gica de negocio, la presentaci\u00f3n y la interacci\u00f3n con los datos en una aplicaci\u00f3n. Concurrency: la capacidad de un sistema para realizar m\u00faltiples tareas simult\u00e1neamente. Comunidad de Phoenix: un grupo de desarrolladores y usuarios que trabajan juntos para mejorar y hacer crecer el framework. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es Phoenix Framework y en qu\u00e9 lenguaje est\u00e1 escrito? \u00bfQu\u00e9 modelo de arquitectura utiliza Phoenix? \u00bfCu\u00e1l es uno de los principales beneficios de utilizar Phoenix? \u00bfEn qu\u00e9 m\u00e1quina virtual se ejecuta Phoenix? \u00bfQu\u00e9 es la comunidad de Phoenix y por qu\u00e9 es importante para el desarrollo del framework? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 # Definir una ruta en Phoenix get \"/hello\" , HelloController , :index # Crear un nuevo controlador en Phoenix defmodule HelloController do use Phoenix.Controller def index ( conn , _params ) do render ( conn , \"index.html\" ) end end # Crear una vista en Phoenix defmodule HelloView do use Phoenix.View , root : \"web/templates\" def render ( \"index.html\" , _assigns ) do \"\u00a1Hola Mundo!\" end end Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 1) Crea una nueva ruta en Phoenix que se llame \"about\" y que renderee una vista llamada \"about.html\". 2) Agrega un enlace a la ruta \"about\" en una p\u00e1gina existente en tu aplicaci\u00f3n. 3) Crea un nuevo controlador llamado \"UserController\" con una acci\u00f3n \"index\" que renderice una vista llamada \"users.html\". 4) En la vista \"users.html\", utiliza una funci\u00f3n de Phoenix para generar una tabla con los datos de usuarios almacenados en una base de datos. 5) Agrega un bot\u00f3n en la vista \"users.html\" que permita a los usuarios eliminar un usuario espec\u00edfico de la base de datos. Consejos o mejores pr\u00e1cticas \u00b6 \u00danete a la comunidad de Phoenix y participa en los foros, chats y eventos para aprender y compartir conocimientos. Lee la documentaci\u00f3n oficial de Phoenix para familiarizarte con la estructura y las herramientas del framework. Utiliza el sistema de control de versiones Git y la plataforma de colaboraci\u00f3n GitHub para contribuir al c\u00f3digo de Phoenix. Comunica tus ideas y sugerencias de mejora en la comunidad y colabora con otros desarrolladores para implementarlas. Mant\u00e9n tu c\u00f3digo limpio y bien documentado para facilitar su revisi\u00f3n y contribuci\u00f3n a la comunidad. Aseg\u00farate de seguir las mejores pr\u00e1cticas y est\u00e1ndares de codificaci\u00f3n de Phoenix para mantener la consistencia en el c\u00f3digo de la comunidad. Contribuye con pruebas y documentaci\u00f3n para garantizar un c\u00f3digo de alta calidad y f\u00e1cil de mantener.","title":"Contribuyendo a phoenix"},{"location":"phoenix/sr/contribuyendo_a_phoenix/#contribuyendo-a-phoenix","text":"","title":"Contribuyendo a Phoenix"},{"location":"phoenix/sr/contribuyendo_a_phoenix/#explicacion-teorica","text":"Phoenix Framework es un framework web de c\u00f3digo abierto escrito en el lenguaje de programaci\u00f3n Elixir. Fue dise\u00f1ado para crear aplicaciones web escalables y de alto rendimiento utilizando el patr\u00f3n de arquitectura Modelo-Vista-Controlador (MVC). Phoenix se basa en la plataforma de c\u00f3digo abierto Erlang y se ejecuta en la m\u00e1quina virtual de Erlang (BEAM). Uno de los principales beneficios de utilizar Phoenix es su enfoque en la productividad y el rendimiento. El framework utiliza el modelo de concurrencia de Erlang, lo que significa que puede manejar miles de solicitudes simult\u00e1neas sin afectar el rendimiento. Adem\u00e1s, Phoenix proporciona una estructura de proyecto bien definida y herramientas para facilitar el desarrollo de aplicaciones web. La comunidad de Phoenix es muy activa y acogedora, y siempre est\u00e1 buscando formas de mejorar y hacer crecer el framework. Esto significa que cualquiera puede contribuir al desarrollo de Phoenix y ayudar a la comunidad a mejorar la plataforma para todos.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix/sr/contribuyendo_a_phoenix/#palabras-clave-y-su-definicion","text":"Phoenix Framework: un framework web escrito en Elixir que se basa en Erlang y se ejecuta en la m\u00e1quina virtual de Erlang (BEAM). Elixir: un lenguaje de programaci\u00f3n funcional din\u00e1mico dise\u00f1ado para crear aplicaciones escalables y de alta disponibilidad. Erlang: un lenguaje de programaci\u00f3n dise\u00f1ado para crear sistemas distribuidos y tolerantes a fallos. BEAM: m\u00e1quina virtual de Erlang que ejecuta el c\u00f3digo Elixir. Modelo-Vista-Controlador (MVC): un patr\u00f3n de arquitectura utilizado para separar la l\u00f3gica de negocio, la presentaci\u00f3n y la interacci\u00f3n con los datos en una aplicaci\u00f3n. Concurrency: la capacidad de un sistema para realizar m\u00faltiples tareas simult\u00e1neamente. Comunidad de Phoenix: un grupo de desarrolladores y usuarios que trabajan juntos para mejorar y hacer crecer el framework.","title":"Palabras clave y su definici\u00f3n"},{"location":"phoenix/sr/contribuyendo_a_phoenix/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Phoenix Framework y en qu\u00e9 lenguaje est\u00e1 escrito? \u00bfQu\u00e9 modelo de arquitectura utiliza Phoenix? \u00bfCu\u00e1l es uno de los principales beneficios de utilizar Phoenix? \u00bfEn qu\u00e9 m\u00e1quina virtual se ejecuta Phoenix? \u00bfQu\u00e9 es la comunidad de Phoenix y por qu\u00e9 es importante para el desarrollo del framework?","title":"Preguntas de repaso"},{"location":"phoenix/sr/contribuyendo_a_phoenix/#ejemplos-de-codigo-en-phoenix-framework","text":"# Definir una ruta en Phoenix get \"/hello\" , HelloController , :index # Crear un nuevo controlador en Phoenix defmodule HelloController do use Phoenix.Controller def index ( conn , _params ) do render ( conn , \"index.html\" ) end end # Crear una vista en Phoenix defmodule HelloView do use Phoenix.View , root : \"web/templates\" def render ( \"index.html\" , _assigns ) do \"\u00a1Hola Mundo!\" end end","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix/sr/contribuyendo_a_phoenix/#ejercicios-practicos-con-instrucciones-claras","text":"1) Crea una nueva ruta en Phoenix que se llame \"about\" y que renderee una vista llamada \"about.html\". 2) Agrega un enlace a la ruta \"about\" en una p\u00e1gina existente en tu aplicaci\u00f3n. 3) Crea un nuevo controlador llamado \"UserController\" con una acci\u00f3n \"index\" que renderice una vista llamada \"users.html\". 4) En la vista \"users.html\", utiliza una funci\u00f3n de Phoenix para generar una tabla con los datos de usuarios almacenados en una base de datos. 5) Agrega un bot\u00f3n en la vista \"users.html\" que permita a los usuarios eliminar un usuario espec\u00edfico de la base de datos.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"phoenix/sr/contribuyendo_a_phoenix/#consejos-o-mejores-practicas","text":"\u00danete a la comunidad de Phoenix y participa en los foros, chats y eventos para aprender y compartir conocimientos. Lee la documentaci\u00f3n oficial de Phoenix para familiarizarte con la estructura y las herramientas del framework. Utiliza el sistema de control de versiones Git y la plataforma de colaboraci\u00f3n GitHub para contribuir al c\u00f3digo de Phoenix. Comunica tus ideas y sugerencias de mejora en la comunidad y colabora con otros desarrolladores para implementarlas. Mant\u00e9n tu c\u00f3digo limpio y bien documentado para facilitar su revisi\u00f3n y contribuci\u00f3n a la comunidad. Aseg\u00farate de seguir las mejores pr\u00e1cticas y est\u00e1ndares de codificaci\u00f3n de Phoenix para mantener la consistencia en el c\u00f3digo de la comunidad. Contribuye con pruebas y documentaci\u00f3n para garantizar un c\u00f3digo de alta calidad y f\u00e1cil de mantener.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix/sr/debugging_y_troubleshooting/","text":"Debugging y troubleshooting en Phoenix Framework \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En este m\u00f3dulo aprender\u00e1s sobre herramientas y t\u00e9cnicas avanzadas para identificar y solucionar problemas en una aplicaci\u00f3n Phoenix. Aprender\u00e1s a utilizar herramientas de depuraci\u00f3n, monitoreo y registro para encontrar y solucionar errores en tu c\u00f3digo. Tambi\u00e9n explorar\u00e1s t\u00e9cnicas para identificar y resolver problemas de rendimiento en tu aplicaci\u00f3n Phoenix. Explicaci\u00f3n te\u00f3rica \u00b6 Debugging y troubleshooting son dos habilidades esenciales para cualquier desarrollador, ya que son fundamentales para identificar y solucionar problemas en una aplicaci\u00f3n. En el contexto de Phoenix Framework, debugging se refiere al proceso de encontrar y corregir errores en el c\u00f3digo, mientras que troubleshooting se enfoca en identificar y resolver problemas de rendimiento y otros problemas t\u00e9cnicos. En Phoenix, el proceso de debugging y troubleshooting se vuelve mucho m\u00e1s f\u00e1cil gracias a las herramientas y caracter\u00edsticas integradas en el framework. Algunas de estas herramientas incluyen el c\u00f3digo de error detallado, el registro de errores y eventos, y el uso de la consola de Erlang para inspeccionar y depurar el c\u00f3digo en tiempo de ejecuci\u00f3n. Palabras clave y su definici\u00f3n \u00b6 Debugging: Proceso de encontrar y corregir errores en el c\u00f3digo de una aplicaci\u00f3n. Troubleshooting: Proceso de identificar y resolver problemas t\u00e9cnicos y de rendimiento en una aplicaci\u00f3n. Registro (logging): Proceso de registrar eventos y errores en una aplicaci\u00f3n para su posterior an\u00e1lisis. Depurador (debugger): Herramienta que permite inspeccionar y ejecutar c\u00f3digo en tiempo de ejecuci\u00f3n para encontrar errores. Consola de Erlang: Interfaz de l\u00ednea de comandos que permite interactuar con una aplicaci\u00f3n Phoenix en tiempo de ejecuci\u00f3n. An\u00e1lisis de rendimiento: Proceso de identificar y solucionar problemas relacionados con el rendimiento de una aplicaci\u00f3n. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es debugging y troubleshooting en el contexto de Phoenix Framework? \u00bfCu\u00e1les son algunas de las herramientas integradas en Phoenix para facilitar el proceso de debugging y troubleshooting? \u00bfQu\u00e9 es el registro (logging) y c\u00f3mo puede ayudar en el proceso de troubleshooting? \u00bfQu\u00e9 es un depurador (debugger) y c\u00f3mo se utiliza en Phoenix? \u00bfQu\u00e9 es la consola de Erlang y c\u00f3mo se puede utilizar en una aplicaci\u00f3n Phoenix? \u00bfQu\u00e9 es el an\u00e1lisis de rendimiento y por qu\u00e9 es importante en una aplicaci\u00f3n Phoenix? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 Registro de errores \u00b6 Phoenix incluye un sistema de registro de errores integrado que registra los errores y eventos en un archivo de registro. Puedes utilizar la funci\u00f3n Logger.error/2 para registrar un mensaje de error en el archivo de registro: # En un controlador, modelo o vista de Phoenix Logger.error(\"Error al realizar la acci\u00f3n: #{error.message}\", error) Depuraci\u00f3n en tiempo de ejecuci\u00f3n \u00b6 La consola de Erlang es una herramienta poderosa para depurar y ejecutar c\u00f3digo en tiempo de ejecuci\u00f3n en una aplicaci\u00f3n Phoenix. Puedes utilizarla para inspeccionar variables, ejecutar funciones y encontrar errores en tu c\u00f3digo. Por ejemplo, si quieres inspeccionar una variable user en tu controlador: iex> user ** (CompileError) iex:1: undefined function user/0 La consola de Erlang te informar\u00e1 que la funci\u00f3n user/0 no est\u00e1 definida, lo que te ayudar\u00e1 a identificar y solucionar el error en tu c\u00f3digo. Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Utiliza el sistema de registro de errores de Phoenix para registrar un mensaje de error en tu aplicaci\u00f3n. Prueba la funci\u00f3n Logger.debug/2 en tu aplicaci\u00f3n y observa c\u00f3mo se registra el mensaje de depuraci\u00f3n en el archivo de registro. Utiliza la consola de Erlang para inspeccionar una variable en tu aplicaci\u00f3n y resolver un error en tu c\u00f3digo. Crea una funci\u00f3n de an\u00e1lisis de rendimiento que te permita identificar y solucionar problemas relacionados con el rendimiento en tu aplicaci\u00f3n. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza el sistema de registro de errores de Phoenix como una herramienta de soluci\u00f3n de problemas, ya que te permitir\u00e1 identificar y solucionar errores en tu c\u00f3digo. Utiliza la consola de Erlang para depurar y ejecutar c\u00f3digo en tiempo de ejecuci\u00f3n, lo que te ayudar\u00e1 a encontrar y solucionar errores de manera m\u00e1s eficiente. Crea una funci\u00f3n de an\u00e1lisis de rendimiento para identificar y solucionar problemas de rendimiento en tu aplicaci\u00f3n de manera proactiva.","title":"Debugging y troubleshooting en Phoenix Framework"},{"location":"phoenix/sr/debugging_y_troubleshooting/#debugging-y-troubleshooting-en-phoenix-framework","text":"","title":"Debugging y troubleshooting en Phoenix Framework"},{"location":"phoenix/sr/debugging_y_troubleshooting/#descripcion-del-modulo","text":"En este m\u00f3dulo aprender\u00e1s sobre herramientas y t\u00e9cnicas avanzadas para identificar y solucionar problemas en una aplicaci\u00f3n Phoenix. Aprender\u00e1s a utilizar herramientas de depuraci\u00f3n, monitoreo y registro para encontrar y solucionar errores en tu c\u00f3digo. Tambi\u00e9n explorar\u00e1s t\u00e9cnicas para identificar y resolver problemas de rendimiento en tu aplicaci\u00f3n Phoenix.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"phoenix/sr/debugging_y_troubleshooting/#explicacion-teorica","text":"Debugging y troubleshooting son dos habilidades esenciales para cualquier desarrollador, ya que son fundamentales para identificar y solucionar problemas en una aplicaci\u00f3n. En el contexto de Phoenix Framework, debugging se refiere al proceso de encontrar y corregir errores en el c\u00f3digo, mientras que troubleshooting se enfoca en identificar y resolver problemas de rendimiento y otros problemas t\u00e9cnicos. En Phoenix, el proceso de debugging y troubleshooting se vuelve mucho m\u00e1s f\u00e1cil gracias a las herramientas y caracter\u00edsticas integradas en el framework. Algunas de estas herramientas incluyen el c\u00f3digo de error detallado, el registro de errores y eventos, y el uso de la consola de Erlang para inspeccionar y depurar el c\u00f3digo en tiempo de ejecuci\u00f3n.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix/sr/debugging_y_troubleshooting/#palabras-clave-y-su-definicion","text":"Debugging: Proceso de encontrar y corregir errores en el c\u00f3digo de una aplicaci\u00f3n. Troubleshooting: Proceso de identificar y resolver problemas t\u00e9cnicos y de rendimiento en una aplicaci\u00f3n. Registro (logging): Proceso de registrar eventos y errores en una aplicaci\u00f3n para su posterior an\u00e1lisis. Depurador (debugger): Herramienta que permite inspeccionar y ejecutar c\u00f3digo en tiempo de ejecuci\u00f3n para encontrar errores. Consola de Erlang: Interfaz de l\u00ednea de comandos que permite interactuar con una aplicaci\u00f3n Phoenix en tiempo de ejecuci\u00f3n. An\u00e1lisis de rendimiento: Proceso de identificar y solucionar problemas relacionados con el rendimiento de una aplicaci\u00f3n.","title":"Palabras clave y su definici\u00f3n"},{"location":"phoenix/sr/debugging_y_troubleshooting/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es debugging y troubleshooting en el contexto de Phoenix Framework? \u00bfCu\u00e1les son algunas de las herramientas integradas en Phoenix para facilitar el proceso de debugging y troubleshooting? \u00bfQu\u00e9 es el registro (logging) y c\u00f3mo puede ayudar en el proceso de troubleshooting? \u00bfQu\u00e9 es un depurador (debugger) y c\u00f3mo se utiliza en Phoenix? \u00bfQu\u00e9 es la consola de Erlang y c\u00f3mo se puede utilizar en una aplicaci\u00f3n Phoenix? \u00bfQu\u00e9 es el an\u00e1lisis de rendimiento y por qu\u00e9 es importante en una aplicaci\u00f3n Phoenix?","title":"Preguntas de repaso"},{"location":"phoenix/sr/debugging_y_troubleshooting/#ejemplos-de-codigo-en-phoenix-framework","text":"","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix/sr/debugging_y_troubleshooting/#registro-de-errores","text":"Phoenix incluye un sistema de registro de errores integrado que registra los errores y eventos en un archivo de registro. Puedes utilizar la funci\u00f3n Logger.error/2 para registrar un mensaje de error en el archivo de registro: # En un controlador, modelo o vista de Phoenix Logger.error(\"Error al realizar la acci\u00f3n: #{error.message}\", error)","title":"Registro de errores"},{"location":"phoenix/sr/debugging_y_troubleshooting/#depuracion-en-tiempo-de-ejecucion","text":"La consola de Erlang es una herramienta poderosa para depurar y ejecutar c\u00f3digo en tiempo de ejecuci\u00f3n en una aplicaci\u00f3n Phoenix. Puedes utilizarla para inspeccionar variables, ejecutar funciones y encontrar errores en tu c\u00f3digo. Por ejemplo, si quieres inspeccionar una variable user en tu controlador: iex> user ** (CompileError) iex:1: undefined function user/0 La consola de Erlang te informar\u00e1 que la funci\u00f3n user/0 no est\u00e1 definida, lo que te ayudar\u00e1 a identificar y solucionar el error en tu c\u00f3digo.","title":"Depuraci\u00f3n en tiempo de ejecuci\u00f3n"},{"location":"phoenix/sr/debugging_y_troubleshooting/#ejercicios-practicos-con-instrucciones-claras","text":"Utiliza el sistema de registro de errores de Phoenix para registrar un mensaje de error en tu aplicaci\u00f3n. Prueba la funci\u00f3n Logger.debug/2 en tu aplicaci\u00f3n y observa c\u00f3mo se registra el mensaje de depuraci\u00f3n en el archivo de registro. Utiliza la consola de Erlang para inspeccionar una variable en tu aplicaci\u00f3n y resolver un error en tu c\u00f3digo. Crea una funci\u00f3n de an\u00e1lisis de rendimiento que te permita identificar y solucionar problemas relacionados con el rendimiento en tu aplicaci\u00f3n.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"phoenix/sr/debugging_y_troubleshooting/#consejos-o-mejores-practicas","text":"Utiliza el sistema de registro de errores de Phoenix como una herramienta de soluci\u00f3n de problemas, ya que te permitir\u00e1 identificar y solucionar errores en tu c\u00f3digo. Utiliza la consola de Erlang para depurar y ejecutar c\u00f3digo en tiempo de ejecuci\u00f3n, lo que te ayudar\u00e1 a encontrar y solucionar errores de manera m\u00e1s eficiente. Crea una funci\u00f3n de an\u00e1lisis de rendimiento para identificar y solucionar problemas de rendimiento en tu aplicaci\u00f3n de manera proactiva.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix/sr/extensibilidad_de_phoenix/","text":"Extensibilidad de Phoenix \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En este m\u00f3dulo, aprender\u00e1s c\u00f3mo extender y personalizar Phoenix Framework, una herramienta de desarrollo web en Elixir. Aprender\u00e1s a utilizar macros, plug-ins y generadores personalizados para adaptar Phoenix a tus necesidades espec\u00edficas. Explicaci\u00f3n te\u00f3rica \u00b6 Phoenix Framework es una herramienta de desarrollo web que utiliza el lenguaje de programaci\u00f3n funcional Elixir. Una de las ventajas de utilizar Phoenix es su extensibilidad, lo que significa que puedes personalizar y ampliar su funcionalidad para adaptarla a tus necesidades espec\u00edficas. Hay varias formas de extender Phoenix, incluyendo el uso de macros, plug-ins y generadores personalizados. Estos te permiten agregar funcionalidades adicionales o modificar el comportamiento predeterminado de Phoenix. Palabras clave y su definici\u00f3n \u00b6 Macros: son una forma de escribir c\u00f3digo que se compila en tiempo de compilaci\u00f3n y se expande en el c\u00f3digo fuente. En Phoenix, las macros se utilizan para generar c\u00f3digo repetitivo y simplificar la sintaxis. Plug-ins: son m\u00f3dulos de c\u00f3digo que se agregan a una aplicaci\u00f3n de Phoenix para proporcionar funcionalidades adicionales. Estos se pueden instalar y utilizar f\u00e1cilmente a trav\u00e9s de la herramienta de gesti\u00f3n de paquetes Hex. Generadores personalizados: son scripts que crean archivos y c\u00f3digo de forma autom\u00e1tica. En Phoenix, se pueden crear generadores personalizados para generar c\u00f3digo espec\u00edfico para tu aplicaci\u00f3n. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la extensibilidad en Phoenix? \u00bfCu\u00e1les son las formas de extender Phoenix? \u00bfQu\u00e9 son las macros en Phoenix y para qu\u00e9 se utilizan? \u00bfQu\u00e9 son los plug-ins en Phoenix y c\u00f3mo se pueden instalar? \u00bfQu\u00e9 son los generadores personalizados en Phoenix y para qu\u00e9 se utilizan? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 Macros \u00b6 defmodule MyApp.User do use MyApp.Web , :model schema \"users\" do field :username , :string field :email , :string field :age , :integer timestamps () end # Utilizando la macro `changeset` para validar los campos de la tabla def changeset ( user , attrs ) do user |> cast ( attrs , [ :username , :email , :age ]) |> validate_required ([ :username , :email ]) |> validate_number ( :age , greater_than : 0 ) end end Plug-ins \u00b6 # Instalando el plug-in `phoenix_live_dashboard` para agregar una herramienta de monitoreo en tiempo real a la aplicaci\u00f3n mix deps . get mix deps . compile mix phx . gen . live MyApp.Dashboard # Configurando el plug-in en el archivo `router.ex` defmodule MyAppWeb.Router do use MyAppWeb , :router pipeline :dashboard do plug MyAppWeb.Plug.BasicAuth , username : \"admin\" , password : \"secret\" end scope \"/\" do pipe_through :dashboard live_dashboard \"/dashboard\" , MyAppWeb.Dashboard end end Generadores personalizados \u00b6 # Creando un generador personalizado para crear un recurso API con un endpoint espec\u00edfico mix phoenix . gen . json Accounts User users name :string email :string # Configurando el endpoint en el archivo `router.ex` defmodule MyAppWeb.Router do use MyAppWeb , :router scope \"/api\" , MyAppWeb do pipe_through :api resources \"/users\" , UserController , except : [ :new , :edit ] end end Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una macro que genere autom\u00e1ticamente un m\u00f3dulo Ecto para una tabla espec\u00edfica. Instala y configura un plug-in de autenticaci\u00f3n para tu aplicaci\u00f3n Phoenix. Crea un generador personalizado que genere autom\u00e1ticamente un recurso API con endpoints para crear, leer, actualizar y eliminar registros de una tabla determinada. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza macros para simplificar y reducir la cantidad de c\u00f3digo repetitivo en tu aplicaci\u00f3n. Elige plug-ins de confianza y mantenidos activamente por la comunidad. Aseg\u00farate de entender c\u00f3mo funcionan los generadores personalizados antes de utilizarlos en tu proyecto. Considera la posibilidad de crear tus propios plug-ins o generadores personalizados para funcionalidades espec\u00edficas de tu aplicaci\u00f3n.","title":"Extensibilidad de Phoenix"},{"location":"phoenix/sr/extensibilidad_de_phoenix/#extensibilidad-de-phoenix","text":"","title":"Extensibilidad de Phoenix"},{"location":"phoenix/sr/extensibilidad_de_phoenix/#descripcion-del-modulo","text":"En este m\u00f3dulo, aprender\u00e1s c\u00f3mo extender y personalizar Phoenix Framework, una herramienta de desarrollo web en Elixir. Aprender\u00e1s a utilizar macros, plug-ins y generadores personalizados para adaptar Phoenix a tus necesidades espec\u00edficas.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"phoenix/sr/extensibilidad_de_phoenix/#explicacion-teorica","text":"Phoenix Framework es una herramienta de desarrollo web que utiliza el lenguaje de programaci\u00f3n funcional Elixir. Una de las ventajas de utilizar Phoenix es su extensibilidad, lo que significa que puedes personalizar y ampliar su funcionalidad para adaptarla a tus necesidades espec\u00edficas. Hay varias formas de extender Phoenix, incluyendo el uso de macros, plug-ins y generadores personalizados. Estos te permiten agregar funcionalidades adicionales o modificar el comportamiento predeterminado de Phoenix.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix/sr/extensibilidad_de_phoenix/#palabras-clave-y-su-definicion","text":"Macros: son una forma de escribir c\u00f3digo que se compila en tiempo de compilaci\u00f3n y se expande en el c\u00f3digo fuente. En Phoenix, las macros se utilizan para generar c\u00f3digo repetitivo y simplificar la sintaxis. Plug-ins: son m\u00f3dulos de c\u00f3digo que se agregan a una aplicaci\u00f3n de Phoenix para proporcionar funcionalidades adicionales. Estos se pueden instalar y utilizar f\u00e1cilmente a trav\u00e9s de la herramienta de gesti\u00f3n de paquetes Hex. Generadores personalizados: son scripts que crean archivos y c\u00f3digo de forma autom\u00e1tica. En Phoenix, se pueden crear generadores personalizados para generar c\u00f3digo espec\u00edfico para tu aplicaci\u00f3n.","title":"Palabras clave y su definici\u00f3n"},{"location":"phoenix/sr/extensibilidad_de_phoenix/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la extensibilidad en Phoenix? \u00bfCu\u00e1les son las formas de extender Phoenix? \u00bfQu\u00e9 son las macros en Phoenix y para qu\u00e9 se utilizan? \u00bfQu\u00e9 son los plug-ins en Phoenix y c\u00f3mo se pueden instalar? \u00bfQu\u00e9 son los generadores personalizados en Phoenix y para qu\u00e9 se utilizan?","title":"Preguntas de repaso"},{"location":"phoenix/sr/extensibilidad_de_phoenix/#ejemplos-de-codigo-en-phoenix-framework","text":"","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix/sr/extensibilidad_de_phoenix/#macros","text":"defmodule MyApp.User do use MyApp.Web , :model schema \"users\" do field :username , :string field :email , :string field :age , :integer timestamps () end # Utilizando la macro `changeset` para validar los campos de la tabla def changeset ( user , attrs ) do user |> cast ( attrs , [ :username , :email , :age ]) |> validate_required ([ :username , :email ]) |> validate_number ( :age , greater_than : 0 ) end end","title":"Macros"},{"location":"phoenix/sr/extensibilidad_de_phoenix/#plug-ins","text":"# Instalando el plug-in `phoenix_live_dashboard` para agregar una herramienta de monitoreo en tiempo real a la aplicaci\u00f3n mix deps . get mix deps . compile mix phx . gen . live MyApp.Dashboard # Configurando el plug-in en el archivo `router.ex` defmodule MyAppWeb.Router do use MyAppWeb , :router pipeline :dashboard do plug MyAppWeb.Plug.BasicAuth , username : \"admin\" , password : \"secret\" end scope \"/\" do pipe_through :dashboard live_dashboard \"/dashboard\" , MyAppWeb.Dashboard end end","title":"Plug-ins"},{"location":"phoenix/sr/extensibilidad_de_phoenix/#generadores-personalizados","text":"# Creando un generador personalizado para crear un recurso API con un endpoint espec\u00edfico mix phoenix . gen . json Accounts User users name :string email :string # Configurando el endpoint en el archivo `router.ex` defmodule MyAppWeb.Router do use MyAppWeb , :router scope \"/api\" , MyAppWeb do pipe_through :api resources \"/users\" , UserController , except : [ :new , :edit ] end end","title":"Generadores personalizados"},{"location":"phoenix/sr/extensibilidad_de_phoenix/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una macro que genere autom\u00e1ticamente un m\u00f3dulo Ecto para una tabla espec\u00edfica. Instala y configura un plug-in de autenticaci\u00f3n para tu aplicaci\u00f3n Phoenix. Crea un generador personalizado que genere autom\u00e1ticamente un recurso API con endpoints para crear, leer, actualizar y eliminar registros de una tabla determinada.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"phoenix/sr/extensibilidad_de_phoenix/#consejos-o-mejores-practicas","text":"Utiliza macros para simplificar y reducir la cantidad de c\u00f3digo repetitivo en tu aplicaci\u00f3n. Elige plug-ins de confianza y mantenidos activamente por la comunidad. Aseg\u00farate de entender c\u00f3mo funcionan los generadores personalizados antes de utilizarlos en tu proyecto. Considera la posibilidad de crear tus propios plug-ins o generadores personalizados para funcionalidades espec\u00edficas de tu aplicaci\u00f3n.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix/sr/internals_de_phoenix/","text":"Internals de Phoenix \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 Phoenix es un framework de desarrollo web en Elixir que se basa en el patr\u00f3n MVC (Modelo-Vista-Controlador) para estructurar aplicaciones web. Su arquitectura interna se basa en la filosof\u00eda de \"convenci\u00f3n sobre configuraci\u00f3n\", lo que significa que sigue una estructura predefinida para facilitar el desarrollo y la organizaci\u00f3n del c\u00f3digo. En t\u00e9rminos generales, Phoenix consta de cuatro capas principales: el Router, el Controlador, el Modelo y la Vista. El Router es responsable de manejar las solicitudes HTTP y dirigirlas a los controladores adecuados. El Controlador se encarga de procesar las solicitudes y enviar una respuesta al cliente. El Modelo maneja la l\u00f3gica de negocio y la interacci\u00f3n con la base de datos. Y la Vista se encarga de generar la interfaz de usuario y enviarla al cliente. Palabras clave y su definici\u00f3n \u00b6 Phoenix: Framework de desarrollo web en Elixir. MVC: Patr\u00f3n de dise\u00f1o que divide una aplicaci\u00f3n en tres capas: Modelo, Vista y Controlador. Convenci\u00f3n sobre configuraci\u00f3n: Filosof\u00eda de desarrollo que se basa en seguir una estructura predefinida en lugar de configurar cada parte de la aplicaci\u00f3n. Router: Capa encargada de dirigir las solicitudes HTTP a los controladores adecuados. Controlador: Capa encargada de procesar las solicitudes y enviar una respuesta al cliente. Modelo: Capa encargada de manejar la l\u00f3gica de negocio y la interacci\u00f3n con la base de datos. Vista: Capa encargada de generar la interfaz de usuario y enviarla al cliente. Preguntas de repaso \u00b6 \u00bfCu\u00e1l es la filosof\u00eda de desarrollo en la que se basa Phoenix? \u00bfCu\u00e1les son las cuatro capas principales de Phoenix y qu\u00e9 funciones tienen cada una? \u00bfQu\u00e9 es el patr\u00f3n MVC y c\u00f3mo se aplica en Phoenix? \u00bfCu\u00e1l es el papel del Router en una aplicaci\u00f3n Phoenix? \u00bfQu\u00e9 es la convenci\u00f3n sobre configuraci\u00f3n y por qu\u00e9 es importante en el desarrollo con Phoenix? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 # Router scope \"/\", HelloPhoenixWeb do pipe_through :browser get \"/\", PageController, :index end # Controlador defmodule HelloPhoenixWeb.PageController do use HelloPhoenixWeb, :controller def index(conn, _params) do render(conn, \"index.html\") end end # Modelo defmodule HelloPhoenixWeb.User do use Ecto.Schema schema \"users\" do field :name, :string field :email, :string field :age, :integer end end # Vista defmodule HelloPhoenixWeb.PageView do use HelloPhoenixWeb, :view def render(\"index.html\", %{users: users}) do <ul> <%= for user <- users do %> <li> <%= user . name %> </li> <% end %> </ul> end end Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crear una nueva ruta en el Router que dirija a un nuevo controlador llamado UserController. En el controlador UserController, crear una acci\u00f3n llamada \"new\" que renderice una vista con un formulario para crear un nuevo usuario. Crear un modelo User con los campos \"name\", \"email\" y \"age\". En el controlador, crear una acci\u00f3n \"create\" que reciba los datos del formulario y cree un nuevo usuario en la base de datos. En la vista, mostrar una lista de todos los usuarios creados hasta el momento. Agregar validaciones al modelo User para asegurarse de que los campos no est\u00e9n vac\u00edos y que la edad sea mayor de 18 a\u00f1os. Agregar una nueva acci\u00f3n en el controlador para editar los datos de un usuario existente. En la vista, agregar un enlace para editar cada usuario que muestre el formulario de edici\u00f3n correspondiente. Agregar una acci\u00f3n para eliminar usuarios en el controlador y un bot\u00f3n en la vista para borrarlos. Investigar c\u00f3mo agregar estilo CSS a la vista y aplicarlo para mejorar la apariencia de la aplicaci\u00f3n. Consejos o mejores pr\u00e1cticas \u00b6 Sigue la convenci\u00f3n sobre configuraci\u00f3n para mantener una estructura organizada en tu aplicaci\u00f3n. Utiliza buenas pr\u00e1cticas de programaci\u00f3n como separar la l\u00f3gica de la vista y evitar la duplicaci\u00f3n de c\u00f3digo. Aprovecha las herramientas y m\u00f3dulos disponibles en la comunidad de Elixir y Phoenix para facilitar tu trabajo. Familiar\u00edzate con Ecto, el ORM (Mapeo Objeto-Relacional) utilizado en Phoenix, para manejar las operaciones con la base de datos de manera eficiente. Aseg\u00farate de entender los conceptos b\u00e1sicos de Elixir, como las funciones, las listas y las tuplas, ya que son fundamentales en el desarrollo con Phoenix. Practica y experimenta con los diferentes m\u00f3dulos y funcionalidades de Phoenix para mejorar tus habilidades y conocimientos.","title":"Internals de Phoenix"},{"location":"phoenix/sr/internals_de_phoenix/#internals-de-phoenix","text":"","title":"Internals de Phoenix"},{"location":"phoenix/sr/internals_de_phoenix/#explicacion-teorica","text":"Phoenix es un framework de desarrollo web en Elixir que se basa en el patr\u00f3n MVC (Modelo-Vista-Controlador) para estructurar aplicaciones web. Su arquitectura interna se basa en la filosof\u00eda de \"convenci\u00f3n sobre configuraci\u00f3n\", lo que significa que sigue una estructura predefinida para facilitar el desarrollo y la organizaci\u00f3n del c\u00f3digo. En t\u00e9rminos generales, Phoenix consta de cuatro capas principales: el Router, el Controlador, el Modelo y la Vista. El Router es responsable de manejar las solicitudes HTTP y dirigirlas a los controladores adecuados. El Controlador se encarga de procesar las solicitudes y enviar una respuesta al cliente. El Modelo maneja la l\u00f3gica de negocio y la interacci\u00f3n con la base de datos. Y la Vista se encarga de generar la interfaz de usuario y enviarla al cliente.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix/sr/internals_de_phoenix/#palabras-clave-y-su-definicion","text":"Phoenix: Framework de desarrollo web en Elixir. MVC: Patr\u00f3n de dise\u00f1o que divide una aplicaci\u00f3n en tres capas: Modelo, Vista y Controlador. Convenci\u00f3n sobre configuraci\u00f3n: Filosof\u00eda de desarrollo que se basa en seguir una estructura predefinida en lugar de configurar cada parte de la aplicaci\u00f3n. Router: Capa encargada de dirigir las solicitudes HTTP a los controladores adecuados. Controlador: Capa encargada de procesar las solicitudes y enviar una respuesta al cliente. Modelo: Capa encargada de manejar la l\u00f3gica de negocio y la interacci\u00f3n con la base de datos. Vista: Capa encargada de generar la interfaz de usuario y enviarla al cliente.","title":"Palabras clave y su definici\u00f3n"},{"location":"phoenix/sr/internals_de_phoenix/#preguntas-de-repaso","text":"\u00bfCu\u00e1l es la filosof\u00eda de desarrollo en la que se basa Phoenix? \u00bfCu\u00e1les son las cuatro capas principales de Phoenix y qu\u00e9 funciones tienen cada una? \u00bfQu\u00e9 es el patr\u00f3n MVC y c\u00f3mo se aplica en Phoenix? \u00bfCu\u00e1l es el papel del Router en una aplicaci\u00f3n Phoenix? \u00bfQu\u00e9 es la convenci\u00f3n sobre configuraci\u00f3n y por qu\u00e9 es importante en el desarrollo con Phoenix?","title":"Preguntas de repaso"},{"location":"phoenix/sr/internals_de_phoenix/#ejemplos-de-codigo-en-phoenix-framework","text":"# Router scope \"/\", HelloPhoenixWeb do pipe_through :browser get \"/\", PageController, :index end # Controlador defmodule HelloPhoenixWeb.PageController do use HelloPhoenixWeb, :controller def index(conn, _params) do render(conn, \"index.html\") end end # Modelo defmodule HelloPhoenixWeb.User do use Ecto.Schema schema \"users\" do field :name, :string field :email, :string field :age, :integer end end # Vista defmodule HelloPhoenixWeb.PageView do use HelloPhoenixWeb, :view def render(\"index.html\", %{users: users}) do <ul> <%= for user <- users do %> <li> <%= user . name %> </li> <% end %> </ul> end end","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix/sr/internals_de_phoenix/#ejercicios-practicos-con-instrucciones-claras","text":"Crear una nueva ruta en el Router que dirija a un nuevo controlador llamado UserController. En el controlador UserController, crear una acci\u00f3n llamada \"new\" que renderice una vista con un formulario para crear un nuevo usuario. Crear un modelo User con los campos \"name\", \"email\" y \"age\". En el controlador, crear una acci\u00f3n \"create\" que reciba los datos del formulario y cree un nuevo usuario en la base de datos. En la vista, mostrar una lista de todos los usuarios creados hasta el momento. Agregar validaciones al modelo User para asegurarse de que los campos no est\u00e9n vac\u00edos y que la edad sea mayor de 18 a\u00f1os. Agregar una nueva acci\u00f3n en el controlador para editar los datos de un usuario existente. En la vista, agregar un enlace para editar cada usuario que muestre el formulario de edici\u00f3n correspondiente. Agregar una acci\u00f3n para eliminar usuarios en el controlador y un bot\u00f3n en la vista para borrarlos. Investigar c\u00f3mo agregar estilo CSS a la vista y aplicarlo para mejorar la apariencia de la aplicaci\u00f3n.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"phoenix/sr/internals_de_phoenix/#consejos-o-mejores-practicas","text":"Sigue la convenci\u00f3n sobre configuraci\u00f3n para mantener una estructura organizada en tu aplicaci\u00f3n. Utiliza buenas pr\u00e1cticas de programaci\u00f3n como separar la l\u00f3gica de la vista y evitar la duplicaci\u00f3n de c\u00f3digo. Aprovecha las herramientas y m\u00f3dulos disponibles en la comunidad de Elixir y Phoenix para facilitar tu trabajo. Familiar\u00edzate con Ecto, el ORM (Mapeo Objeto-Relacional) utilizado en Phoenix, para manejar las operaciones con la base de datos de manera eficiente. Aseg\u00farate de entender los conceptos b\u00e1sicos de Elixir, como las funciones, las listas y las tuplas, ya que son fundamentales en el desarrollo con Phoenix. Practica y experimenta con los diferentes m\u00f3dulos y funcionalidades de Phoenix para mejorar tus habilidades y conocimientos.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix/sr/migraci%C3%B3n_de_una_aplicaci%C3%B3n_existente_a_phoenix/","text":"Migraci\u00f3n de una aplicaci\u00f3n existente a Phoenix \u00b6 Introducci\u00f3n \u00b6 Phoenix es un framework web de c\u00f3digo abierto escrito en el lenguaje de programaci\u00f3n Elixir. Se basa en el patr\u00f3n de arquitectura Modelo-Vista-Controlador (MVC) y se ejecuta en la m\u00e1quina virtual de Erlang, lo que le brinda un alto rendimiento y escalabilidad. Phoenix es conocido por su rapidez y su capacidad para manejar grandes cantidades de tr\u00e1fico en tiempo real. Si ya tienes una aplicaci\u00f3n web existente y quieres aprovechar las ventajas de Phoenix, es posible que te preguntes c\u00f3mo migrar tu c\u00f3digo existente a este framework. En esta lecci\u00f3n, descubrir\u00e1s los consejos y las mejores pr\u00e1cticas para hacerlo de manera eficiente y efectiva. Palabras clave \u00b6 Phoenix: Framework web escrito en Elixir. Elixir: Lenguaje de programaci\u00f3n funcional que se ejecuta en la m\u00e1quina virtual de Erlang. MVC: Patr\u00f3n de arquitectura Modelo-Vista-Controlador. Erlang: Lenguaje de programaci\u00f3n concurrente y tolerante a fallos. Rendimiento: Capacidad de un sistema para realizar tareas de manera r\u00e1pida y eficiente. Escalabilidad: Capacidad de un sistema para manejar un aumento en el tr\u00e1fico y la cantidad de usuarios. Migraci\u00f3n: Proceso de trasladar una aplicaci\u00f3n existente a una nueva plataforma o framework. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es Phoenix y en qu\u00e9 lenguaje est\u00e1 escrito? \u00bfQu\u00e9 es Elixir y en qu\u00e9 m\u00e1quina virtual se ejecuta? \u00bfCu\u00e1l es el patr\u00f3n de arquitectura que sigue Phoenix? \u00bfCu\u00e1les son las ventajas de usar Phoenix? \u00bfQu\u00e9 significa el t\u00e9rmino \"rendimiento\" en el contexto de un sistema? \u00bfQu\u00e9 es la escalabilidad y por qu\u00e9 es importante en una aplicaci\u00f3n web? \u00bfQu\u00e9 es la migraci\u00f3n y por qu\u00e9 puede ser necesaria para una aplicaci\u00f3n existente? \u00bfQu\u00e9 debes tener en cuenta al migrar una aplicaci\u00f3n a Phoenix? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 A continuaci\u00f3n, se presentan algunos ejemplos de c\u00f3digo en Phoenix que podr\u00edan ser \u00fatiles durante el proceso de migraci\u00f3n. Controladores \u00b6 Los controladores en Phoenix son responsables de manejar las solicitudes HTTP y coordinar con el modelo y la vista correspondientes. A continuaci\u00f3n, se muestra un ejemplo de un controlador que maneja una solicitud GET para mostrar una lista de usuarios: defmodule MyApp.UserController do use MyApp.Web , :controller def index ( conn , _params ) do users = MyApp.Repo . all ( MyApp.User ) render ( conn , \"index.html\" , users : users ) end end Modelos \u00b6 Los modelos en Phoenix son responsables de interactuar con la base de datos y representar los datos en un formato estructurado. A continuaci\u00f3n, se muestra un ejemplo de un modelo que representa a un usuario en la base de datos: defmodule MyApp.User do use Ecto.Schema import Ecto.Changeset schema \"users\" do field :name , :string field :email , :string field :password , :string timestamps () end def changeset ( user , attrs ) do user |> cast ( attrs , [ :name , :email , :password ]) |> validate_required ([ :name , :email , :password ]) |> unique_constraint ( :email ) end end Vistas \u00b6 Las vistas en Phoenix son responsables de renderizar el contenido que se enviar\u00e1 al cliente. A continuaci\u00f3n, se muestra un ejemplo de una vista que muestra la lista de usuarios en formato HTML: defmodule MyApp.UserView do use MyApp.Web , :view def render ( \"index.html\" , %{ users : users }) do ~H \"\"\" <h1>Lista de usuarios</h1> <ul> <%= for user <- users do %> <li><%= user.name %></li> <% end %> </ul> \"\"\" end end Ejercicios pr\u00e1cticos \u00b6 Crea un nuevo proyecto en Phoenix. Crea un modelo y una migraci\u00f3n para una tabla de usuarios. Crea un controlador para mostrar una lista de usuarios. Crea una vista para mostrar la lista de usuarios en formato HTML. Configura las rutas para acceder al controlador y la vista creados. Mueve tu c\u00f3digo existente a los archivos correspondientes en el proyecto de Phoenix. Ejecuta la aplicaci\u00f3n y comprueba que todo funcione correctamente. Consejos y mejores pr\u00e1cticas \u00b6 Antes de iniciar la migraci\u00f3n, aseg\u00farate de tener una copia de seguridad de tu aplicaci\u00f3n existente. Esto te ayudar\u00e1 a revertir cualquier cambio si algo sale mal durante el proceso de migraci\u00f3n. Comienza por migrar una parte de la aplicaci\u00f3n a la vez. Por ejemplo, puedes empezar por el modelo y el controlador de una funcionalidad y luego pasar a la vista correspondiente. Aseg\u00farate de entender bien la estructura y la l\u00f3gica de Phoenix antes de empezar a migrar tu c\u00f3digo. Esto te ayudar\u00e1 a hacer los cambios necesarios de manera efectiva. Utiliza las herramientas de migraci\u00f3n de Phoenix, como los generadores de modelos y controladores, para facilitar el proceso. Revisa y actualiza las dependencias de tu aplicaci\u00f3n para asegurarte de que sean compatibles con Phoenix. Realiza pruebas exhaustivas despu\u00e9s de la migraci\u00f3n para asegurarte de que todo funcione correctamente. Si encuentras problemas durante la migraci\u00f3n, no dudes en buscar ayuda en la documentaci\u00f3n oficial de Phoenix o en la comunidad de Elixir y Phoenix. Una vez que hayas migrado tu aplicaci\u00f3n a Phoenix, considera utilizar otras caracter\u00edsticas del framework, como los canales para manejar comunicaci\u00f3n en tiempo real o el sistema de enrutamiento de Phoenix para mejorar el rendimiento de tu aplicaci\u00f3n. Conclusi\u00f3n \u00b6 Migrar una aplicaci\u00f3n existente a Phoenix puede parecer un proceso complicado, pero con los consejos y las mejores pr\u00e1cticas adecuados, puedes hacerlo de manera efectiva y aprovechar al m\u00e1ximo el potencial de este framework. Recuerda siempre hacer copias de seguridad y realizar pruebas exhaustivas para asegurarte de que todo funcione correctamente. Con un poco de esfuerzo, podr\u00e1s disfrutar de las ventajas de usar Phoenix en tu aplicaci\u00f3n web existente.","title":"Migraci\u00f3n de una aplicaci\u00f3n existente a Phoenix"},{"location":"phoenix/sr/migraci%C3%B3n_de_una_aplicaci%C3%B3n_existente_a_phoenix/#migracion-de-una-aplicacion-existente-a-phoenix","text":"","title":"Migraci\u00f3n de una aplicaci\u00f3n existente a Phoenix"},{"location":"phoenix/sr/migraci%C3%B3n_de_una_aplicaci%C3%B3n_existente_a_phoenix/#introduccion","text":"Phoenix es un framework web de c\u00f3digo abierto escrito en el lenguaje de programaci\u00f3n Elixir. Se basa en el patr\u00f3n de arquitectura Modelo-Vista-Controlador (MVC) y se ejecuta en la m\u00e1quina virtual de Erlang, lo que le brinda un alto rendimiento y escalabilidad. Phoenix es conocido por su rapidez y su capacidad para manejar grandes cantidades de tr\u00e1fico en tiempo real. Si ya tienes una aplicaci\u00f3n web existente y quieres aprovechar las ventajas de Phoenix, es posible que te preguntes c\u00f3mo migrar tu c\u00f3digo existente a este framework. En esta lecci\u00f3n, descubrir\u00e1s los consejos y las mejores pr\u00e1cticas para hacerlo de manera eficiente y efectiva.","title":"Introducci\u00f3n"},{"location":"phoenix/sr/migraci%C3%B3n_de_una_aplicaci%C3%B3n_existente_a_phoenix/#palabras-clave","text":"Phoenix: Framework web escrito en Elixir. Elixir: Lenguaje de programaci\u00f3n funcional que se ejecuta en la m\u00e1quina virtual de Erlang. MVC: Patr\u00f3n de arquitectura Modelo-Vista-Controlador. Erlang: Lenguaje de programaci\u00f3n concurrente y tolerante a fallos. Rendimiento: Capacidad de un sistema para realizar tareas de manera r\u00e1pida y eficiente. Escalabilidad: Capacidad de un sistema para manejar un aumento en el tr\u00e1fico y la cantidad de usuarios. Migraci\u00f3n: Proceso de trasladar una aplicaci\u00f3n existente a una nueva plataforma o framework.","title":"Palabras clave"},{"location":"phoenix/sr/migraci%C3%B3n_de_una_aplicaci%C3%B3n_existente_a_phoenix/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Phoenix y en qu\u00e9 lenguaje est\u00e1 escrito? \u00bfQu\u00e9 es Elixir y en qu\u00e9 m\u00e1quina virtual se ejecuta? \u00bfCu\u00e1l es el patr\u00f3n de arquitectura que sigue Phoenix? \u00bfCu\u00e1les son las ventajas de usar Phoenix? \u00bfQu\u00e9 significa el t\u00e9rmino \"rendimiento\" en el contexto de un sistema? \u00bfQu\u00e9 es la escalabilidad y por qu\u00e9 es importante en una aplicaci\u00f3n web? \u00bfQu\u00e9 es la migraci\u00f3n y por qu\u00e9 puede ser necesaria para una aplicaci\u00f3n existente? \u00bfQu\u00e9 debes tener en cuenta al migrar una aplicaci\u00f3n a Phoenix?","title":"Preguntas de repaso"},{"location":"phoenix/sr/migraci%C3%B3n_de_una_aplicaci%C3%B3n_existente_a_phoenix/#ejemplos-de-codigo-en-phoenix-framework","text":"A continuaci\u00f3n, se presentan algunos ejemplos de c\u00f3digo en Phoenix que podr\u00edan ser \u00fatiles durante el proceso de migraci\u00f3n.","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix/sr/migraci%C3%B3n_de_una_aplicaci%C3%B3n_existente_a_phoenix/#controladores","text":"Los controladores en Phoenix son responsables de manejar las solicitudes HTTP y coordinar con el modelo y la vista correspondientes. A continuaci\u00f3n, se muestra un ejemplo de un controlador que maneja una solicitud GET para mostrar una lista de usuarios: defmodule MyApp.UserController do use MyApp.Web , :controller def index ( conn , _params ) do users = MyApp.Repo . all ( MyApp.User ) render ( conn , \"index.html\" , users : users ) end end","title":"Controladores"},{"location":"phoenix/sr/migraci%C3%B3n_de_una_aplicaci%C3%B3n_existente_a_phoenix/#modelos","text":"Los modelos en Phoenix son responsables de interactuar con la base de datos y representar los datos en un formato estructurado. A continuaci\u00f3n, se muestra un ejemplo de un modelo que representa a un usuario en la base de datos: defmodule MyApp.User do use Ecto.Schema import Ecto.Changeset schema \"users\" do field :name , :string field :email , :string field :password , :string timestamps () end def changeset ( user , attrs ) do user |> cast ( attrs , [ :name , :email , :password ]) |> validate_required ([ :name , :email , :password ]) |> unique_constraint ( :email ) end end","title":"Modelos"},{"location":"phoenix/sr/migraci%C3%B3n_de_una_aplicaci%C3%B3n_existente_a_phoenix/#vistas","text":"Las vistas en Phoenix son responsables de renderizar el contenido que se enviar\u00e1 al cliente. A continuaci\u00f3n, se muestra un ejemplo de una vista que muestra la lista de usuarios en formato HTML: defmodule MyApp.UserView do use MyApp.Web , :view def render ( \"index.html\" , %{ users : users }) do ~H \"\"\" <h1>Lista de usuarios</h1> <ul> <%= for user <- users do %> <li><%= user.name %></li> <% end %> </ul> \"\"\" end end","title":"Vistas"},{"location":"phoenix/sr/migraci%C3%B3n_de_una_aplicaci%C3%B3n_existente_a_phoenix/#ejercicios-practicos","text":"Crea un nuevo proyecto en Phoenix. Crea un modelo y una migraci\u00f3n para una tabla de usuarios. Crea un controlador para mostrar una lista de usuarios. Crea una vista para mostrar la lista de usuarios en formato HTML. Configura las rutas para acceder al controlador y la vista creados. Mueve tu c\u00f3digo existente a los archivos correspondientes en el proyecto de Phoenix. Ejecuta la aplicaci\u00f3n y comprueba que todo funcione correctamente.","title":"Ejercicios pr\u00e1cticos"},{"location":"phoenix/sr/migraci%C3%B3n_de_una_aplicaci%C3%B3n_existente_a_phoenix/#consejos-y-mejores-practicas","text":"Antes de iniciar la migraci\u00f3n, aseg\u00farate de tener una copia de seguridad de tu aplicaci\u00f3n existente. Esto te ayudar\u00e1 a revertir cualquier cambio si algo sale mal durante el proceso de migraci\u00f3n. Comienza por migrar una parte de la aplicaci\u00f3n a la vez. Por ejemplo, puedes empezar por el modelo y el controlador de una funcionalidad y luego pasar a la vista correspondiente. Aseg\u00farate de entender bien la estructura y la l\u00f3gica de Phoenix antes de empezar a migrar tu c\u00f3digo. Esto te ayudar\u00e1 a hacer los cambios necesarios de manera efectiva. Utiliza las herramientas de migraci\u00f3n de Phoenix, como los generadores de modelos y controladores, para facilitar el proceso. Revisa y actualiza las dependencias de tu aplicaci\u00f3n para asegurarte de que sean compatibles con Phoenix. Realiza pruebas exhaustivas despu\u00e9s de la migraci\u00f3n para asegurarte de que todo funcione correctamente. Si encuentras problemas durante la migraci\u00f3n, no dudes en buscar ayuda en la documentaci\u00f3n oficial de Phoenix o en la comunidad de Elixir y Phoenix. Una vez que hayas migrado tu aplicaci\u00f3n a Phoenix, considera utilizar otras caracter\u00edsticas del framework, como los canales para manejar comunicaci\u00f3n en tiempo real o el sistema de enrutamiento de Phoenix para mejorar el rendimiento de tu aplicaci\u00f3n.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"phoenix/sr/migraci%C3%B3n_de_una_aplicaci%C3%B3n_existente_a_phoenix/#conclusion","text":"Migrar una aplicaci\u00f3n existente a Phoenix puede parecer un proceso complicado, pero con los consejos y las mejores pr\u00e1cticas adecuados, puedes hacerlo de manera efectiva y aprovechar al m\u00e1ximo el potencial de este framework. Recuerda siempre hacer copias de seguridad y realizar pruebas exhaustivas para asegurarte de que todo funcione correctamente. Con un poco de esfuerzo, podr\u00e1s disfrutar de las ventajas de usar Phoenix en tu aplicaci\u00f3n web existente.","title":"Conclusi\u00f3n"},{"location":"phoenix/sr/phoenix_sin_servidor/","text":"Phoenix sin servidor \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 Phoenix Framework es un framework web de c\u00f3digo abierto que se basa en el lenguaje de programaci\u00f3n Elixir y est\u00e1 dise\u00f1ado para construir aplicaciones web escalables y de alto rendimiento. Una de las principales ventajas de Phoenix es su capacidad para manejar una gran cantidad de solicitudes simult\u00e1neas de forma eficiente. Sin embargo, al desplegar una aplicaci\u00f3n Phoenix, es com\u00fan utilizar un servidor web como Apache o Nginx para manejar las solicitudes entrantes. Sin embargo, existen opciones para desplegar aplicaciones Phoenix sin la necesidad de un servidor. Una de las formas de hacerlo es utilizando un servicio de computaci\u00f3n en la nube como AWS Lambda. AWS Lambda es un servicio de computaci\u00f3n sin servidor que permite ejecutar c\u00f3digo sin necesidad de administrar servidores. Con AWS Lambda, podemos desplegar nuestra aplicaci\u00f3n Phoenix en un entorno sin servidor, lo que significa que no necesitamos preocuparnos por configurar y mantener un servidor web. Palabras clave y su definici\u00f3n \u00b6 Phoenix Framework: Es un framework web de c\u00f3digo abierto basado en el lenguaje de programaci\u00f3n Elixir. AWS Lambda: Es un servicio de computaci\u00f3n en la nube que permite ejecutar c\u00f3digo sin necesidad de administrar servidores. Sin servidor: Se refiere a la capacidad de ejecutar aplicaciones sin la necesidad de configurar y mantener un servidor web. Computaci\u00f3n en la nube: Se refiere al uso de recursos inform\u00e1ticos, como servidores, almacenamiento y aplicaciones, a trav\u00e9s de internet en lugar de tenerlos localmente en un ordenador personal o servidor. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es Phoenix Framework? \u00bfCu\u00e1l es la principal ventaja de Phoenix Framework? \u00bfQu\u00e9 es AWS Lambda? \u00bfQu\u00e9 significa \"sin servidor\" en el contexto de desplegar aplicaciones? \u00bfQu\u00e9 es la computaci\u00f3n en la nube? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 Para desplegar una aplicaci\u00f3n Phoenix en AWS Lambda, necesitamos realizar los siguientes pasos: Crear un archivo de configuraci\u00f3n lambda.exs en el directorio config de nuestra aplicaci\u00f3n Phoenix. En este archivo, definir la funci\u00f3n MyAppWeb.Lambda.handler que ser\u00e1 el punto de entrada para nuestra aplicaci\u00f3n. En la funci\u00f3n handler , debemos crear una instancia de nuestra aplicaci\u00f3n Phoenix y llamar al m\u00e9todo run para iniciarla. Una vez que nuestra aplicaci\u00f3n se inicie, debemos definir una funci\u00f3n event que recibir\u00e1 las solicitudes entrantes y las procesar\u00e1 utilizando los controladores y enrutadores de nuestra aplicaci\u00f3n Phoenix. Por \u00faltimo, debemos configurar nuestra aplicaci\u00f3n para que utilice el adaptador :cowboy y el puerto 0 para que pueda ser desplegada en AWS Lambda. Un ejemplo de c\u00f3digo para el archivo lambda.exs ser\u00eda el siguiente: defmodule MyAppWeb.Lambda do def handler(event, context) do {:ok, _} = Application.ensure_all_started(:my_app_web) {:ok, _} = MyAppWeb.Endpoint.run([]) event(MyAppWeb.Endpoint, event, context) end end Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea un nuevo proyecto Phoenix utilizando el comando mix phx.new my_app . En el directorio config de tu proyecto, crea un archivo llamado lambda.exs . En este archivo, define la funci\u00f3n MyAppWeb.Lambda.handler como se muestra en el ejemplo de c\u00f3digo anterior. Configura tu aplicaci\u00f3n Phoenix para utilizar el adaptador :cowboy y el puerto 0 en el archivo config/prod.exs . Crea un controlador y un enrutador en tu aplicaci\u00f3n Phoenix. En el controlador, define una acci\u00f3n que responda con un mensaje de \"Hola mundo!\". En el enrutador, define una ruta para esa acci\u00f3n. Despliega tu aplicaci\u00f3n Phoenix en AWS Lambda utilizando el comando mix phx.server y aseg\u00farate de que funciona correctamente. Haz una solicitud HTTP a la URL proporcionada por AWS Lambda y verifica que recibes el mensaje \"Hola mundo!\" en respuesta. \u00a1Felicidades, has desplegado con \u00e9xito tu aplicaci\u00f3n Phoenix sin servidor! Consejos o mejores pr\u00e1cticas \u00b6 Al desplegar una aplicaci\u00f3n Phoenix en AWS Lambda, es importante tener en cuenta el l\u00edmite de tiempo de ejecuci\u00f3n de 15 minutos. Si una solicitud requiere m\u00e1s tiempo para procesarse, es posible que AWS Lambda la interrumpa. Utiliza el adaptador :cowboy en lugar de :plug_cowboy cuando despliegues tu aplicaci\u00f3n en AWS Lambda, ya que el primero es m\u00e1s adecuado para entornos sin servidor. Utiliza una herramienta de despliegue automatizado como Distillery para facilitar el proceso de despliegue en AWS Lambda. Ten en cuenta que AWS Lambda cobra por el tiempo de ejecuci\u00f3n y por el n\u00famero de solicitudes, por lo que es importante optimizar tu c\u00f3digo para que se ejecute de forma eficiente. Si tu aplicaci\u00f3n Phoenix utiliza una base de datos, considera utilizar una base de datos sin servidor como Amazon DynamoDB en lugar de una base de datos tradicional, ya que es m\u00e1s adecuada para entornos sin servidor.","title":"Phoenix sin servidor"},{"location":"phoenix/sr/phoenix_sin_servidor/#phoenix-sin-servidor","text":"","title":"Phoenix sin servidor"},{"location":"phoenix/sr/phoenix_sin_servidor/#explicacion-teorica","text":"Phoenix Framework es un framework web de c\u00f3digo abierto que se basa en el lenguaje de programaci\u00f3n Elixir y est\u00e1 dise\u00f1ado para construir aplicaciones web escalables y de alto rendimiento. Una de las principales ventajas de Phoenix es su capacidad para manejar una gran cantidad de solicitudes simult\u00e1neas de forma eficiente. Sin embargo, al desplegar una aplicaci\u00f3n Phoenix, es com\u00fan utilizar un servidor web como Apache o Nginx para manejar las solicitudes entrantes. Sin embargo, existen opciones para desplegar aplicaciones Phoenix sin la necesidad de un servidor. Una de las formas de hacerlo es utilizando un servicio de computaci\u00f3n en la nube como AWS Lambda. AWS Lambda es un servicio de computaci\u00f3n sin servidor que permite ejecutar c\u00f3digo sin necesidad de administrar servidores. Con AWS Lambda, podemos desplegar nuestra aplicaci\u00f3n Phoenix en un entorno sin servidor, lo que significa que no necesitamos preocuparnos por configurar y mantener un servidor web.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix/sr/phoenix_sin_servidor/#palabras-clave-y-su-definicion","text":"Phoenix Framework: Es un framework web de c\u00f3digo abierto basado en el lenguaje de programaci\u00f3n Elixir. AWS Lambda: Es un servicio de computaci\u00f3n en la nube que permite ejecutar c\u00f3digo sin necesidad de administrar servidores. Sin servidor: Se refiere a la capacidad de ejecutar aplicaciones sin la necesidad de configurar y mantener un servidor web. Computaci\u00f3n en la nube: Se refiere al uso de recursos inform\u00e1ticos, como servidores, almacenamiento y aplicaciones, a trav\u00e9s de internet en lugar de tenerlos localmente en un ordenador personal o servidor.","title":"Palabras clave y su definici\u00f3n"},{"location":"phoenix/sr/phoenix_sin_servidor/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Phoenix Framework? \u00bfCu\u00e1l es la principal ventaja de Phoenix Framework? \u00bfQu\u00e9 es AWS Lambda? \u00bfQu\u00e9 significa \"sin servidor\" en el contexto de desplegar aplicaciones? \u00bfQu\u00e9 es la computaci\u00f3n en la nube?","title":"Preguntas de repaso"},{"location":"phoenix/sr/phoenix_sin_servidor/#ejemplos-de-codigo-en-phoenix-framework","text":"Para desplegar una aplicaci\u00f3n Phoenix en AWS Lambda, necesitamos realizar los siguientes pasos: Crear un archivo de configuraci\u00f3n lambda.exs en el directorio config de nuestra aplicaci\u00f3n Phoenix. En este archivo, definir la funci\u00f3n MyAppWeb.Lambda.handler que ser\u00e1 el punto de entrada para nuestra aplicaci\u00f3n. En la funci\u00f3n handler , debemos crear una instancia de nuestra aplicaci\u00f3n Phoenix y llamar al m\u00e9todo run para iniciarla. Una vez que nuestra aplicaci\u00f3n se inicie, debemos definir una funci\u00f3n event que recibir\u00e1 las solicitudes entrantes y las procesar\u00e1 utilizando los controladores y enrutadores de nuestra aplicaci\u00f3n Phoenix. Por \u00faltimo, debemos configurar nuestra aplicaci\u00f3n para que utilice el adaptador :cowboy y el puerto 0 para que pueda ser desplegada en AWS Lambda. Un ejemplo de c\u00f3digo para el archivo lambda.exs ser\u00eda el siguiente: defmodule MyAppWeb.Lambda do def handler(event, context) do {:ok, _} = Application.ensure_all_started(:my_app_web) {:ok, _} = MyAppWeb.Endpoint.run([]) event(MyAppWeb.Endpoint, event, context) end end","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix/sr/phoenix_sin_servidor/#ejercicios-practicos-con-instrucciones-claras","text":"Crea un nuevo proyecto Phoenix utilizando el comando mix phx.new my_app . En el directorio config de tu proyecto, crea un archivo llamado lambda.exs . En este archivo, define la funci\u00f3n MyAppWeb.Lambda.handler como se muestra en el ejemplo de c\u00f3digo anterior. Configura tu aplicaci\u00f3n Phoenix para utilizar el adaptador :cowboy y el puerto 0 en el archivo config/prod.exs . Crea un controlador y un enrutador en tu aplicaci\u00f3n Phoenix. En el controlador, define una acci\u00f3n que responda con un mensaje de \"Hola mundo!\". En el enrutador, define una ruta para esa acci\u00f3n. Despliega tu aplicaci\u00f3n Phoenix en AWS Lambda utilizando el comando mix phx.server y aseg\u00farate de que funciona correctamente. Haz una solicitud HTTP a la URL proporcionada por AWS Lambda y verifica que recibes el mensaje \"Hola mundo!\" en respuesta. \u00a1Felicidades, has desplegado con \u00e9xito tu aplicaci\u00f3n Phoenix sin servidor!","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"phoenix/sr/phoenix_sin_servidor/#consejos-o-mejores-practicas","text":"Al desplegar una aplicaci\u00f3n Phoenix en AWS Lambda, es importante tener en cuenta el l\u00edmite de tiempo de ejecuci\u00f3n de 15 minutos. Si una solicitud requiere m\u00e1s tiempo para procesarse, es posible que AWS Lambda la interrumpa. Utiliza el adaptador :cowboy en lugar de :plug_cowboy cuando despliegues tu aplicaci\u00f3n en AWS Lambda, ya que el primero es m\u00e1s adecuado para entornos sin servidor. Utiliza una herramienta de despliegue automatizado como Distillery para facilitar el proceso de despliegue en AWS Lambda. Ten en cuenta que AWS Lambda cobra por el tiempo de ejecuci\u00f3n y por el n\u00famero de solicitudes, por lo que es importante optimizar tu c\u00f3digo para que se ejecute de forma eficiente. Si tu aplicaci\u00f3n Phoenix utiliza una base de datos, considera utilizar una base de datos sin servidor como Amazon DynamoDB en lugar de una base de datos tradicional, ya que es m\u00e1s adecuada para entornos sin servidor.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix/sr/profundizando_en_ecto/","text":"Profundizando en Ecto \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 Ecto es una librer\u00eda de mapeo de objetos relacional (ORM) utilizada en el framework Phoenix para interactuar con la base de datos. Su funci\u00f3n principal es facilitar la manipulaci\u00f3n y consulta de datos en la base de datos, evitando la necesidad de escribir consultas SQL directamente. Ecto se basa en tres conceptos fundamentales: modelos, cambiosets y repositorios. Los modelos representan una tabla en la base de datos y sus relaciones con otras tablas. Los cambiosets son estructuras que se utilizan para validar y manipular los datos antes de ser guardados en la base de datos. Los repositorios son responsables de ejecutar consultas y almacenar los resultados en el modelo correspondiente. Palabras clave y su definici\u00f3n \u00b6 ORM: siglas de Object-Relational Mapping, que se refiere a la t\u00e9cnica de mapear objetos de una aplicaci\u00f3n a tablas de una base de datos relacional. Modelo: representa una tabla en la base de datos y sus relaciones con otras tablas. Cambioset: estructura utilizada para validar y manipular los datos antes de ser guardados en la base de datos. Repositorio: responsable de ejecutar consultas y almacenar los resultados en el modelo correspondiente. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es Ecto y cu\u00e1l es su funci\u00f3n en el framework Phoenix? \u00bfCu\u00e1les son los tres conceptos fundamentales en los que se basa Ecto? \u00bfQu\u00e9 es un modelo en Ecto? \u00bfPara qu\u00e9 se utilizan los cambiosets en Ecto? \u00bfCu\u00e1l es la funci\u00f3n de los repositorios en Ecto? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 Ejemplo de definici\u00f3n de un modelo en Ecto: defmodule Post do use Ecto . Schema import Ecto.Changeset schema \"posts\" do field : title , : string field : content , : string has_many : comments , Comment end def changeset ( post , attrs ) do post |> cast ( attrs , [: title , : content ]) |> validate_required ([: title , : content ]) |> validate_length (: content , min : 10 ) end end Ejemplo de consulta utilizando Ecto: # Buscar todos los posts con m\u00e1s de 10 comentarios y ordenarlos por fecha de creaci\u00f3n posts = Repo.all(from p in Post, join: c in assoc(p, :comments), where: c.id > 10, order_by: [desc: p.inserted_at] ) Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea un modelo de Ecto llamado \"User\" con los campos \"name\", \"email\" y \"password\". Implementa un cambioset para validar que el campo \"email\" sea \u00fanico. Crea una consulta utilizando Ecto para obtener los usuarios ordenados alfab\u00e9ticamente por su nombre. Crea una migraci\u00f3n de base de datos para agregar un campo \"role\" al modelo \"User\". Modifica el cambioset para validar que el campo \"role\" sea uno de los valores permitidos: \"admin\", \"editor\" o \"viewer\". Consejos o mejores pr\u00e1cticas \u00b6 Utiliza alias para acortar el nombre de los m\u00f3dulos de Ecto en tus consultas y cambiosets. Aprovecha las asociaciones en tus modelos para simplificar tus consultas. Utiliza transacciones para asegurar la consistencia de tus datos en operaciones complejas. Utiliza Ecto.Multi para realizar operaciones en lotes de forma eficiente. Utiliza Ecto.Repo.insert_all para insertar m\u00faltiples registros en una sola consulta. Utiliza Ecto.Query.preload para cargar datos relacionados en una sola consulta. Utiliza Ecto.Query.paginate para paginar tus resultados de forma eficiente. Siempre utiliza Ecto.Changeset para validar y manipular los datos antes de guardarlos en la base de datos. Utiliza Ecto.Schema para definir tus modelos y sus relaciones de manera clara y sencilla. Sigue las convenciones de nomenclatura de Ecto para evitar errores y facilitar el mantenimiento de tu c\u00f3digo.","title":"Profundizando en Ecto"},{"location":"phoenix/sr/profundizando_en_ecto/#profundizando-en-ecto","text":"","title":"Profundizando en Ecto"},{"location":"phoenix/sr/profundizando_en_ecto/#explicacion-teorica","text":"Ecto es una librer\u00eda de mapeo de objetos relacional (ORM) utilizada en el framework Phoenix para interactuar con la base de datos. Su funci\u00f3n principal es facilitar la manipulaci\u00f3n y consulta de datos en la base de datos, evitando la necesidad de escribir consultas SQL directamente. Ecto se basa en tres conceptos fundamentales: modelos, cambiosets y repositorios. Los modelos representan una tabla en la base de datos y sus relaciones con otras tablas. Los cambiosets son estructuras que se utilizan para validar y manipular los datos antes de ser guardados en la base de datos. Los repositorios son responsables de ejecutar consultas y almacenar los resultados en el modelo correspondiente.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix/sr/profundizando_en_ecto/#palabras-clave-y-su-definicion","text":"ORM: siglas de Object-Relational Mapping, que se refiere a la t\u00e9cnica de mapear objetos de una aplicaci\u00f3n a tablas de una base de datos relacional. Modelo: representa una tabla en la base de datos y sus relaciones con otras tablas. Cambioset: estructura utilizada para validar y manipular los datos antes de ser guardados en la base de datos. Repositorio: responsable de ejecutar consultas y almacenar los resultados en el modelo correspondiente.","title":"Palabras clave y su definici\u00f3n"},{"location":"phoenix/sr/profundizando_en_ecto/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Ecto y cu\u00e1l es su funci\u00f3n en el framework Phoenix? \u00bfCu\u00e1les son los tres conceptos fundamentales en los que se basa Ecto? \u00bfQu\u00e9 es un modelo en Ecto? \u00bfPara qu\u00e9 se utilizan los cambiosets en Ecto? \u00bfCu\u00e1l es la funci\u00f3n de los repositorios en Ecto?","title":"Preguntas de repaso"},{"location":"phoenix/sr/profundizando_en_ecto/#ejemplos-de-codigo-en-phoenix-framework","text":"Ejemplo de definici\u00f3n de un modelo en Ecto: defmodule Post do use Ecto . Schema import Ecto.Changeset schema \"posts\" do field : title , : string field : content , : string has_many : comments , Comment end def changeset ( post , attrs ) do post |> cast ( attrs , [: title , : content ]) |> validate_required ([: title , : content ]) |> validate_length (: content , min : 10 ) end end Ejemplo de consulta utilizando Ecto: # Buscar todos los posts con m\u00e1s de 10 comentarios y ordenarlos por fecha de creaci\u00f3n posts = Repo.all(from p in Post, join: c in assoc(p, :comments), where: c.id > 10, order_by: [desc: p.inserted_at] )","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix/sr/profundizando_en_ecto/#ejercicios-practicos-con-instrucciones-claras","text":"Crea un modelo de Ecto llamado \"User\" con los campos \"name\", \"email\" y \"password\". Implementa un cambioset para validar que el campo \"email\" sea \u00fanico. Crea una consulta utilizando Ecto para obtener los usuarios ordenados alfab\u00e9ticamente por su nombre. Crea una migraci\u00f3n de base de datos para agregar un campo \"role\" al modelo \"User\". Modifica el cambioset para validar que el campo \"role\" sea uno de los valores permitidos: \"admin\", \"editor\" o \"viewer\".","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"phoenix/sr/profundizando_en_ecto/#consejos-o-mejores-practicas","text":"Utiliza alias para acortar el nombre de los m\u00f3dulos de Ecto en tus consultas y cambiosets. Aprovecha las asociaciones en tus modelos para simplificar tus consultas. Utiliza transacciones para asegurar la consistencia de tus datos en operaciones complejas. Utiliza Ecto.Multi para realizar operaciones en lotes de forma eficiente. Utiliza Ecto.Repo.insert_all para insertar m\u00faltiples registros en una sola consulta. Utiliza Ecto.Query.preload para cargar datos relacionados en una sola consulta. Utiliza Ecto.Query.paginate para paginar tus resultados de forma eficiente. Siempre utiliza Ecto.Changeset para validar y manipular los datos antes de guardarlos en la base de datos. Utiliza Ecto.Schema para definir tus modelos y sus relaciones de manera clara y sencilla. Sigue las convenciones de nomenclatura de Ecto para evitar errores y facilitar el mantenimiento de tu c\u00f3digo.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix_2/","text":"Curso de Phoenix 2 \u00b6 \u00a1Bienvenido(a) al segundo curso de Phoenix ! Este material expande tus habilidades con Phoenix a trav\u00e9s de nuevos ejemplos, buenas pr\u00e1cticas y optimizaciones. Est\u00e1 estructurado por niveles: Junior Mid Senior Cada nivel incluye contenidos para reforzar y profundizar en distintos aspectos de desarrollo con Phoenix y Elixir.","title":"Curso de Phoenix 2"},{"location":"phoenix_2/#curso-de-phoenix-2","text":"\u00a1Bienvenido(a) al segundo curso de Phoenix ! Este material expande tus habilidades con Phoenix a trav\u00e9s de nuevos ejemplos, buenas pr\u00e1cticas y optimizaciones. Est\u00e1 estructurado por niveles: Junior Mid Senior Cada nivel incluye contenidos para reforzar y profundizar en distintos aspectos de desarrollo con Phoenix y Elixir.","title":"Curso de Phoenix 2"},{"location":"phoenix_2/jr/","text":"Phoenix 2 - Nivel Junior \u00b6 \u00a1Bienvenido/a al nivel Junior del segundo curso de Phoenix! Retomar\u00e1s y reforzar\u00e1s conceptos b\u00e1sicos para crear aplicaciones web con Phoenix: Introducci\u00f3n a Phoenix Framework Instalaci\u00f3n y configuraci\u00f3n Estructura de una aplicaci\u00f3n Phoenix Creaci\u00f3n de un proyecto b\u00e1sico Rutas y controladores Vistas y templates Modelos y bases de datos Autenticaci\u00f3n y autorizaci\u00f3n Despliegue de una aplicaci\u00f3n Phoenix Tu archivo de \u00edndice es phoenix_jr.json .","title":"Phoenix 2 - Nivel Junior"},{"location":"phoenix_2/jr/#phoenix-2-nivel-junior","text":"\u00a1Bienvenido/a al nivel Junior del segundo curso de Phoenix! Retomar\u00e1s y reforzar\u00e1s conceptos b\u00e1sicos para crear aplicaciones web con Phoenix: Introducci\u00f3n a Phoenix Framework Instalaci\u00f3n y configuraci\u00f3n Estructura de una aplicaci\u00f3n Phoenix Creaci\u00f3n de un proyecto b\u00e1sico Rutas y controladores Vistas y templates Modelos y bases de datos Autenticaci\u00f3n y autorizaci\u00f3n Despliegue de una aplicaci\u00f3n Phoenix Tu archivo de \u00edndice es phoenix_jr.json .","title":"Phoenix 2 - Nivel Junior"},{"location":"phoenix_2/jr/autenticaci%C3%B3n_y_autorizaci%C3%B3n/","text":"Autenticaci\u00f3n y Autorizaci\u00f3n en Phoenix Framework \u00b6 En el desarrollo de aplicaciones web, es esencial implementar mecanismos de autenticaci\u00f3n y autorizaci\u00f3n para garantizar la seguridad y privacidad de los usuarios. En Phoenix Framework, esto se puede lograr a trav\u00e9s de la integraci\u00f3n con Guardian, una librer\u00eda de autenticaci\u00f3n y autorizaci\u00f3n. Explicaci\u00f3n te\u00f3rica \u00b6 La autenticaci\u00f3n se refiere al proceso de verificar la identidad de un usuario, mientras que la autorizaci\u00f3n se refiere al proceso de otorgar o denegar el acceso a recursos o funcionalidades dentro de una aplicaci\u00f3n. En Phoenix, Guardian se encarga de manejar ambos procesos y proporciona una capa de seguridad robusta para nuestras aplicaciones. Palabras clave y definiciones \u00b6 Autenticaci\u00f3n: Proceso de verificar la identidad de un usuario. Autorizaci\u00f3n: Proceso de otorgar o denegar acceso a recursos o funcionalidades a un usuario. Guardian: Librer\u00eda de autenticaci\u00f3n y autorizaci\u00f3n para Phoenix Framework. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la autenticaci\u00f3n en el contexto de una aplicaci\u00f3n web? \u00bfQu\u00e9 es la autorizaci\u00f3n en el contexto de una aplicaci\u00f3n web? \u00bfQu\u00e9 librer\u00eda se utiliza en Phoenix Framework para implementar autenticaci\u00f3n y autorizaci\u00f3n? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 A continuaci\u00f3n, se muestra un ejemplo de c\u00f3mo implementar autenticaci\u00f3n y autorizaci\u00f3n en una aplicaci\u00f3n Phoenix utilizando Guardian: En el archivo config/config.exs , agregamos la configuraci\u00f3n de Guardian: config :my_app , MyApp.Guardian , issuer : \"my_app\" , secret_key : \"my_secret_key\" , ttl : { 30 , :days }, allowed_algos : [ \"HS256\" ], verify_issuer : true , serializer : MyApp.Guardian.Serializer Creamos un m\u00f3dulo MyApp.Guardian que ser\u00e1 responsable de generar y verificar los tokens de autenticaci\u00f3n: defmodule MyApp.Guardian do use Guardian , otp_app : :my_app end Creamos un m\u00f3dulo MyApp.Guardian.Serializer que se encargar\u00e1 de serializar y deserializar los datos del usuario en el token de autenticaci\u00f3n: defmodule MyApp.Guardian.Serializer do def for_token ( user = % User {}), do : { :ok , \"User: #{ user . id } \" } def for_token ( _ ), do : { :error , \"Unknown resource type\" } def from_token ( \"User:\" <> id ), do : { :ok , UserRepo . get! ( id ) } def from_token ( _ ), do : { :error , \"Invalid token\" } end En el m\u00f3dulo MyAppWeb.Router , agregamos las rutas para manejar la autenticaci\u00f3n y autorizaci\u00f3n: defmodule MyAppWeb.Router do use MyAppWeb , :router pipeline :auth do plug Guardian.Plug.VerifyHeader , realm : \"Bearer\" plug Guardian.Plug.VerifySession plug Guardian.Plug.LoadResource , ensure : true end scope \"/auth\" , MyAppWeb do pipe_through :api post \"/login\" , AuthController , :login post \"/register\" , UserController , :create get \"/me\" , UserController , :show end end En el controlador AuthController , manejamos la l\u00f3gica de autenticaci\u00f3n y generamos el token: defmodule MyAppWeb.AuthController do use MyAppWeb , :controller def login ( conn , %{ \"email\" => email , \"password\" => password }) do case MyApp.Auth . login ( email , password ) do { :ok , user } -> token = Guardian . encode_and_sign ( user , :token ) conn |> put_status ( :ok ) |> json (%{ token : token , user : user }) { :error , reason } -> conn |> put_status ( :unauthorized ) |> json (%{ error : reason }) end end end En el controlador UserController , manejamos la l\u00f3gica para crear un nuevo usuario y tambi\u00e9n para mostrar la informaci\u00f3n del usuario autenticado: defmodule MyAppWeb.UserController do use MyAppWeb , :controller import Ecto.Query def create ( conn , %{ \"name\" => name , \"email\" => email , \"password\" => password }) do case MyApp.Auth . register ( name , email , password ) do { :ok , user } -> token = Guardian . encode_and_sign ( user , :token ) conn |> put_status ( :created ) |> json (%{ token : token , user : user }) { :error , reason } -> conn |> put_status ( :unprocessable_entity ) |> json (%{ error : reason }) end end def show ( conn , _ ) do current_user = Guardian.Plug . current_resource ( conn ) user = MyRepo . get ( User , current_user . id ) conn |> put_status ( :ok ) |> json ( user ) end end Ejercicios pr\u00e1cticos \u00b6 Crea un proyecto en Phoenix y configura Guardian para manejar la autenticaci\u00f3n y autorizaci\u00f3n. Crea un modelo User y su respectivo repositorio. Agrega las rutas y controladores necesarios para manejar el registro y la autenticaci\u00f3n de un usuario. Agrega un endpoint que muestre la informaci\u00f3n del usuario autenticado. Agrega un middleware que verifique el token de autenticaci\u00f3n en cada petici\u00f3n. Crea un endpoint que solo pueda ser accedido por usuarios autenticados. Agrega un endpoint que solo pueda ser accedido por usuarios con un cierto rol espec\u00edfico. Consejos y mejores pr\u00e1cticas \u00b6 Utiliza un token JWT (JSON Web Token) para la autenticaci\u00f3n, ya que es m\u00e1s seguro que almacenar la informaci\u00f3n de autenticaci\u00f3n en cookies o en la sesi\u00f3n del usuario. Siempre valida el token de autenticaci\u00f3n en cada petici\u00f3n para garantizar la seguridad de tu aplicaci\u00f3n. Planifica cuidadosamente los roles y permisos de cada usuario para garantizar un sistema de autorizaci\u00f3n robusto y seguro. Utiliza Guardian Hooks para agregar l\u00f3gica adicional antes y despu\u00e9s de la autenticaci\u00f3n y autorizaci\u00f3n. Mant\u00e9n tu c\u00f3digo limpio y modular, separando la l\u00f3gica de autenticaci\u00f3n y autorizaci\u00f3n en m\u00f3dulos espec\u00edficos.","title":"Autenticaci\u00f3n y Autorizaci\u00f3n en Phoenix Framework"},{"location":"phoenix_2/jr/autenticaci%C3%B3n_y_autorizaci%C3%B3n/#autenticacion-y-autorizacion-en-phoenix-framework","text":"En el desarrollo de aplicaciones web, es esencial implementar mecanismos de autenticaci\u00f3n y autorizaci\u00f3n para garantizar la seguridad y privacidad de los usuarios. En Phoenix Framework, esto se puede lograr a trav\u00e9s de la integraci\u00f3n con Guardian, una librer\u00eda de autenticaci\u00f3n y autorizaci\u00f3n.","title":"Autenticaci\u00f3n y Autorizaci\u00f3n en Phoenix Framework"},{"location":"phoenix_2/jr/autenticaci%C3%B3n_y_autorizaci%C3%B3n/#explicacion-teorica","text":"La autenticaci\u00f3n se refiere al proceso de verificar la identidad de un usuario, mientras que la autorizaci\u00f3n se refiere al proceso de otorgar o denegar el acceso a recursos o funcionalidades dentro de una aplicaci\u00f3n. En Phoenix, Guardian se encarga de manejar ambos procesos y proporciona una capa de seguridad robusta para nuestras aplicaciones.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix_2/jr/autenticaci%C3%B3n_y_autorizaci%C3%B3n/#palabras-clave-y-definiciones","text":"Autenticaci\u00f3n: Proceso de verificar la identidad de un usuario. Autorizaci\u00f3n: Proceso de otorgar o denegar acceso a recursos o funcionalidades a un usuario. Guardian: Librer\u00eda de autenticaci\u00f3n y autorizaci\u00f3n para Phoenix Framework.","title":"Palabras clave y definiciones"},{"location":"phoenix_2/jr/autenticaci%C3%B3n_y_autorizaci%C3%B3n/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la autenticaci\u00f3n en el contexto de una aplicaci\u00f3n web? \u00bfQu\u00e9 es la autorizaci\u00f3n en el contexto de una aplicaci\u00f3n web? \u00bfQu\u00e9 librer\u00eda se utiliza en Phoenix Framework para implementar autenticaci\u00f3n y autorizaci\u00f3n?","title":"Preguntas de repaso"},{"location":"phoenix_2/jr/autenticaci%C3%B3n_y_autorizaci%C3%B3n/#ejemplos-de-codigo-en-phoenix-framework","text":"A continuaci\u00f3n, se muestra un ejemplo de c\u00f3mo implementar autenticaci\u00f3n y autorizaci\u00f3n en una aplicaci\u00f3n Phoenix utilizando Guardian: En el archivo config/config.exs , agregamos la configuraci\u00f3n de Guardian: config :my_app , MyApp.Guardian , issuer : \"my_app\" , secret_key : \"my_secret_key\" , ttl : { 30 , :days }, allowed_algos : [ \"HS256\" ], verify_issuer : true , serializer : MyApp.Guardian.Serializer Creamos un m\u00f3dulo MyApp.Guardian que ser\u00e1 responsable de generar y verificar los tokens de autenticaci\u00f3n: defmodule MyApp.Guardian do use Guardian , otp_app : :my_app end Creamos un m\u00f3dulo MyApp.Guardian.Serializer que se encargar\u00e1 de serializar y deserializar los datos del usuario en el token de autenticaci\u00f3n: defmodule MyApp.Guardian.Serializer do def for_token ( user = % User {}), do : { :ok , \"User: #{ user . id } \" } def for_token ( _ ), do : { :error , \"Unknown resource type\" } def from_token ( \"User:\" <> id ), do : { :ok , UserRepo . get! ( id ) } def from_token ( _ ), do : { :error , \"Invalid token\" } end En el m\u00f3dulo MyAppWeb.Router , agregamos las rutas para manejar la autenticaci\u00f3n y autorizaci\u00f3n: defmodule MyAppWeb.Router do use MyAppWeb , :router pipeline :auth do plug Guardian.Plug.VerifyHeader , realm : \"Bearer\" plug Guardian.Plug.VerifySession plug Guardian.Plug.LoadResource , ensure : true end scope \"/auth\" , MyAppWeb do pipe_through :api post \"/login\" , AuthController , :login post \"/register\" , UserController , :create get \"/me\" , UserController , :show end end En el controlador AuthController , manejamos la l\u00f3gica de autenticaci\u00f3n y generamos el token: defmodule MyAppWeb.AuthController do use MyAppWeb , :controller def login ( conn , %{ \"email\" => email , \"password\" => password }) do case MyApp.Auth . login ( email , password ) do { :ok , user } -> token = Guardian . encode_and_sign ( user , :token ) conn |> put_status ( :ok ) |> json (%{ token : token , user : user }) { :error , reason } -> conn |> put_status ( :unauthorized ) |> json (%{ error : reason }) end end end En el controlador UserController , manejamos la l\u00f3gica para crear un nuevo usuario y tambi\u00e9n para mostrar la informaci\u00f3n del usuario autenticado: defmodule MyAppWeb.UserController do use MyAppWeb , :controller import Ecto.Query def create ( conn , %{ \"name\" => name , \"email\" => email , \"password\" => password }) do case MyApp.Auth . register ( name , email , password ) do { :ok , user } -> token = Guardian . encode_and_sign ( user , :token ) conn |> put_status ( :created ) |> json (%{ token : token , user : user }) { :error , reason } -> conn |> put_status ( :unprocessable_entity ) |> json (%{ error : reason }) end end def show ( conn , _ ) do current_user = Guardian.Plug . current_resource ( conn ) user = MyRepo . get ( User , current_user . id ) conn |> put_status ( :ok ) |> json ( user ) end end","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix_2/jr/autenticaci%C3%B3n_y_autorizaci%C3%B3n/#ejercicios-practicos","text":"Crea un proyecto en Phoenix y configura Guardian para manejar la autenticaci\u00f3n y autorizaci\u00f3n. Crea un modelo User y su respectivo repositorio. Agrega las rutas y controladores necesarios para manejar el registro y la autenticaci\u00f3n de un usuario. Agrega un endpoint que muestre la informaci\u00f3n del usuario autenticado. Agrega un middleware que verifique el token de autenticaci\u00f3n en cada petici\u00f3n. Crea un endpoint que solo pueda ser accedido por usuarios autenticados. Agrega un endpoint que solo pueda ser accedido por usuarios con un cierto rol espec\u00edfico.","title":"Ejercicios pr\u00e1cticos"},{"location":"phoenix_2/jr/autenticaci%C3%B3n_y_autorizaci%C3%B3n/#consejos-y-mejores-practicas","text":"Utiliza un token JWT (JSON Web Token) para la autenticaci\u00f3n, ya que es m\u00e1s seguro que almacenar la informaci\u00f3n de autenticaci\u00f3n en cookies o en la sesi\u00f3n del usuario. Siempre valida el token de autenticaci\u00f3n en cada petici\u00f3n para garantizar la seguridad de tu aplicaci\u00f3n. Planifica cuidadosamente los roles y permisos de cada usuario para garantizar un sistema de autorizaci\u00f3n robusto y seguro. Utiliza Guardian Hooks para agregar l\u00f3gica adicional antes y despu\u00e9s de la autenticaci\u00f3n y autorizaci\u00f3n. Mant\u00e9n tu c\u00f3digo limpio y modular, separando la l\u00f3gica de autenticaci\u00f3n y autorizaci\u00f3n en m\u00f3dulos espec\u00edficos.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"phoenix_2/jr/creaci%C3%B3n_de_un_proyecto_b%C3%A1sico/","text":"Creaci\u00f3n de un proyecto b\u00e1sico en Phoenix Framework \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 Phoenix Framework es un framework de aplicaciones web escrito en el lenguaje de programaci\u00f3n Elixir. Fue dise\u00f1ado para ser r\u00e1pido, escalable y productivo, permitiendo a los desarrolladores crear aplicaciones web complejas de manera eficiente. La creaci\u00f3n de un proyecto b\u00e1sico en Phoenix es el primer paso para comenzar a trabajar con este framework. Este proceso implica la instalaci\u00f3n de Phoenix, la creaci\u00f3n de un nuevo proyecto y la ejecuci\u00f3n del mismo en un servidor local. Palabras clave y su definici\u00f3n \u00b6 Elixir: Lenguaje de programaci\u00f3n funcional y din\u00e1mico que corre sobre la m\u00e1quina virtual Erlang. Framework: Un conjunto de herramientas, bibliotecas y convenciones que proporcionan una estructura para el desarrollo de aplicaciones. Servidor local: Un servidor web que se ejecuta en la m\u00e1quina del usuario para probar y desarrollar aplicaciones web de manera local. Instalaci\u00f3n: Proceso de configurar y preparar un software para su uso. Proyecto: Una colecci\u00f3n de archivos y carpetas que contienen c\u00f3digo fuente y recursos para una aplicaci\u00f3n espec\u00edfica. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es Phoenix Framework y para qu\u00e9 fue dise\u00f1ado? \u00bfCu\u00e1les son los pasos para crear un proyecto b\u00e1sico en Phoenix? \u00bfQu\u00e9 es un servidor local y para qu\u00e9 se utiliza? \u00bfQu\u00e9 es Elixir y en qu\u00e9 se ejecuta? \u00bfCu\u00e1l es la importancia de la instalaci\u00f3n en el proceso de creaci\u00f3n de un proyecto en Phoenix? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 Para crear un nuevo proyecto en Phoenix, se utiliza el comando mix phoenix.new . Este comando crear\u00e1 una estructura b\u00e1sica de archivos y carpetas para el proyecto, incluyendo el archivo mix.exs , que contiene la configuraci\u00f3n del proyecto y las dependencias necesarias. Una vez que el proyecto est\u00e1 creado, se puede ejecutar utilizando el comando mix phoenix.server . Este comando iniciar\u00e1 un servidor local en el puerto 4000 por defecto, y mostrar\u00e1 la aplicaci\u00f3n en el navegador. Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Instala Phoenix Framework en tu sistema siguiendo las instrucciones de la documentaci\u00f3n oficial. Crea un nuevo proyecto en Phoenix utilizando el comando mix phoenix.new y n\u00f3mbralo \"mi_proyecto\". Navega a la carpeta del proyecto y ejecuta el comando mix phoenix.server para iniciar el servidor local. Abre tu navegador y visita la direcci\u00f3n http://localhost:4000 para ver la aplicaci\u00f3n en funcionamiento. Modifica el contenido de la p\u00e1gina principal de tu proyecto y verifica los cambios en el navegador. Consejos o mejores pr\u00e1cticas \u00b6 Es recomendable tener un buen conocimiento de Elixir antes de trabajar con Phoenix. Revisar la documentaci\u00f3n oficial de Phoenix para obtener m\u00e1s informaci\u00f3n sobre la estructura de archivos y carpetas del proyecto. Utilizar un control de versiones para guardar cambios en el c\u00f3digo y revertirlos en caso de ser necesario. Actualizar regularmente las dependencias del proyecto para evitar problemas de compatibilidad.","title":"Creaci\u00f3n de un proyecto b\u00e1sico en Phoenix Framework"},{"location":"phoenix_2/jr/creaci%C3%B3n_de_un_proyecto_b%C3%A1sico/#creacion-de-un-proyecto-basico-en-phoenix-framework","text":"","title":"Creaci\u00f3n de un proyecto b\u00e1sico en Phoenix Framework"},{"location":"phoenix_2/jr/creaci%C3%B3n_de_un_proyecto_b%C3%A1sico/#explicacion-teorica","text":"Phoenix Framework es un framework de aplicaciones web escrito en el lenguaje de programaci\u00f3n Elixir. Fue dise\u00f1ado para ser r\u00e1pido, escalable y productivo, permitiendo a los desarrolladores crear aplicaciones web complejas de manera eficiente. La creaci\u00f3n de un proyecto b\u00e1sico en Phoenix es el primer paso para comenzar a trabajar con este framework. Este proceso implica la instalaci\u00f3n de Phoenix, la creaci\u00f3n de un nuevo proyecto y la ejecuci\u00f3n del mismo en un servidor local.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix_2/jr/creaci%C3%B3n_de_un_proyecto_b%C3%A1sico/#palabras-clave-y-su-definicion","text":"Elixir: Lenguaje de programaci\u00f3n funcional y din\u00e1mico que corre sobre la m\u00e1quina virtual Erlang. Framework: Un conjunto de herramientas, bibliotecas y convenciones que proporcionan una estructura para el desarrollo de aplicaciones. Servidor local: Un servidor web que se ejecuta en la m\u00e1quina del usuario para probar y desarrollar aplicaciones web de manera local. Instalaci\u00f3n: Proceso de configurar y preparar un software para su uso. Proyecto: Una colecci\u00f3n de archivos y carpetas que contienen c\u00f3digo fuente y recursos para una aplicaci\u00f3n espec\u00edfica.","title":"Palabras clave y su definici\u00f3n"},{"location":"phoenix_2/jr/creaci%C3%B3n_de_un_proyecto_b%C3%A1sico/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Phoenix Framework y para qu\u00e9 fue dise\u00f1ado? \u00bfCu\u00e1les son los pasos para crear un proyecto b\u00e1sico en Phoenix? \u00bfQu\u00e9 es un servidor local y para qu\u00e9 se utiliza? \u00bfQu\u00e9 es Elixir y en qu\u00e9 se ejecuta? \u00bfCu\u00e1l es la importancia de la instalaci\u00f3n en el proceso de creaci\u00f3n de un proyecto en Phoenix?","title":"Preguntas de repaso"},{"location":"phoenix_2/jr/creaci%C3%B3n_de_un_proyecto_b%C3%A1sico/#ejemplos-de-codigo-en-phoenix-framework","text":"Para crear un nuevo proyecto en Phoenix, se utiliza el comando mix phoenix.new . Este comando crear\u00e1 una estructura b\u00e1sica de archivos y carpetas para el proyecto, incluyendo el archivo mix.exs , que contiene la configuraci\u00f3n del proyecto y las dependencias necesarias. Una vez que el proyecto est\u00e1 creado, se puede ejecutar utilizando el comando mix phoenix.server . Este comando iniciar\u00e1 un servidor local en el puerto 4000 por defecto, y mostrar\u00e1 la aplicaci\u00f3n en el navegador.","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix_2/jr/creaci%C3%B3n_de_un_proyecto_b%C3%A1sico/#ejercicios-practicos-con-instrucciones-claras","text":"Instala Phoenix Framework en tu sistema siguiendo las instrucciones de la documentaci\u00f3n oficial. Crea un nuevo proyecto en Phoenix utilizando el comando mix phoenix.new y n\u00f3mbralo \"mi_proyecto\". Navega a la carpeta del proyecto y ejecuta el comando mix phoenix.server para iniciar el servidor local. Abre tu navegador y visita la direcci\u00f3n http://localhost:4000 para ver la aplicaci\u00f3n en funcionamiento. Modifica el contenido de la p\u00e1gina principal de tu proyecto y verifica los cambios en el navegador.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"phoenix_2/jr/creaci%C3%B3n_de_un_proyecto_b%C3%A1sico/#consejos-o-mejores-practicas","text":"Es recomendable tener un buen conocimiento de Elixir antes de trabajar con Phoenix. Revisar la documentaci\u00f3n oficial de Phoenix para obtener m\u00e1s informaci\u00f3n sobre la estructura de archivos y carpetas del proyecto. Utilizar un control de versiones para guardar cambios en el c\u00f3digo y revertirlos en caso de ser necesario. Actualizar regularmente las dependencias del proyecto para evitar problemas de compatibilidad.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix_2/jr/despliegue_de_una_aplicaci%C3%B3n_phoenix/","text":"Despliegue de una aplicaci\u00f3n Phoenix \u00b6 El despliegue de una aplicaci\u00f3n Phoenix en un servidor de producci\u00f3n es un proceso clave para que la aplicaci\u00f3n pueda estar disponible para su uso en l\u00ednea. En este m\u00f3dulo, aprenderemos los pasos necesarios para realizar un despliegue exitoso de una aplicaci\u00f3n Phoenix en un entorno de producci\u00f3n. Explicaci\u00f3n te\u00f3rica \u00b6 Antes de comenzar con el proceso de despliegue, es importante comprender los conceptos b\u00e1sicos detr\u00e1s de una aplicaci\u00f3n Phoenix y su estructura. Phoenix es un framework web escrito en el lenguaje de programaci\u00f3n Elixir, que se basa en el patr\u00f3n de arquitectura MVC (Modelo-Vista-Controlador). Esto significa que la aplicaci\u00f3n se divide en tres capas: el modelo, que se encarga de la l\u00f3gica de negocio; la vista, que se encarga de la presentaci\u00f3n de los datos; y el controlador, que act\u00faa como intermediario entre el modelo y la vista. La estructura de una aplicaci\u00f3n Phoenix consta de varios directorios y archivos, cada uno con un prop\u00f3sito espec\u00edfico. El directorio lib contiene el c\u00f3digo fuente de la aplicaci\u00f3n, mientras que el directorio test contiene las pruebas automatizadas. El archivo mix.exs es el encargado de manejar las dependencias y la configuraci\u00f3n de la aplicaci\u00f3n. Por \u00faltimo, el archivo config.exs contiene la configuraci\u00f3n de la aplicaci\u00f3n, como la base de datos y las rutas de la aplicaci\u00f3n. Palabras clave y su definici\u00f3n \u00b6 Phoenix: Framework web escrito en el lenguaje de programaci\u00f3n Elixir. Elixir: Lenguaje de programaci\u00f3n funcional basado en Erlang. MVC: Patr\u00f3n de arquitectura Modelo-Vista-Controlador. Modelo: Capa encargada de la l\u00f3gica de negocio. Vista: Capa encargada de la presentaci\u00f3n de los datos. Controlador: Capa encargada de actuar como intermediario entre el modelo y la vista. mix.exs: Archivo encargado de manejar las dependencias y la configuraci\u00f3n de la aplicaci\u00f3n. config.exs: Archivo encargado de contener la configuraci\u00f3n de la aplicaci\u00f3n. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es Phoenix y en qu\u00e9 lenguaje de programaci\u00f3n est\u00e1 escrito? \u00bfCu\u00e1l es la estructura de una aplicaci\u00f3n Phoenix? \u00bfCu\u00e1l es la funci\u00f3n del archivo mix.exs? \u00bfQu\u00e9 es el patr\u00f3n MVC y c\u00f3mo se divide una aplicaci\u00f3n Phoenix en este patr\u00f3n? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 A continuaci\u00f3n, se muestran algunos ejemplos de c\u00f3digo en Phoenix que son relevantes para el proceso de despliegue de una aplicaci\u00f3n: Crear una nueva aplicaci\u00f3n Phoenix con el comando mix phx.new <nombre de la aplicaci\u00f3n> . Configurar la base de datos en el archivo config.exs : config : my_app , MyApp . Repo , username : \"username\" , password : \"password\" , database : \"my_app_prod\" , hostname : \"localhost\" , pool_size : 20 Generar una migraci\u00f3n de base de datos con el comando mix ecto.gen.migration <nombre de la migraci\u00f3n> . Ejecutar la migraci\u00f3n con el comando mix ecto.migrate . Crear una nueva ruta en el archivo router.ex : get \"/\", PageController, :index Crear un controlador para la ruta con el comando mix phx.gen.html <nombre del controlador> <nombre del modelo> <campos del modelo> . Configurar la aplicaci\u00f3n para que se ejecute en modo producci\u00f3n en el archivo config/prod.exs : config : my_app , MyApp . Endpoint , url : [ scheme : \"https\" , host : \"myapp.com\" , port : 443 ], cache_static_manifest : \"priv/static/cache_manifest.json\" , secret_key_base : System . get_env ( \"SECRET_KEY_BASE\" ) Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crear una nueva aplicaci\u00f3n Phoenix con el nombre de \"my_app\". Configurar la base de datos en el archivo config.exs con los siguientes valores: username: \"admin\", password: \"123456\", database: \"my_app_prod\", hostname: \"localhost\", pool_size: 10. Generar una migraci\u00f3n de base de datos con el nombre de \"create_users\" que contenga los campos \"name\", \"email\" y \"password\". Ejecutar la migraci\u00f3n. Crear una nueva ruta en el archivo router.ex que apunte a la acci\u00f3n \"index\" del controlador \"PageController\". Crear un controlador con el nombre de \"PageController\" y la acci\u00f3n \"index\". Configurar la aplicaci\u00f3n para que se ejecute en modo producci\u00f3n en el archivo config/prod.exs con la url \"https://myapp.com\" y una clave secreta generada. Ejecutar la aplicaci\u00f3n en modo producci\u00f3n con el comando MIX_ENV=prod mix phx.server . Probar la aplicaci\u00f3n en l\u00ednea en la direcci\u00f3n \"https://myapp.com\". Consejos o mejores pr\u00e1cticas \u00b6 Realizar pruebas exhaustivas antes de realizar el despliegue en un servidor de producci\u00f3n. Utilizar un sistema de control de versiones para mantener un historial de los cambios en la aplicaci\u00f3n. Asegurarse de tener una copia de seguridad de la base de datos antes de realizar el despliegue. Utilizar herramientas de automatizaci\u00f3n de despliegue, como Capistrano o edeliver, para facilitar el proceso. Configurar un sistema de monitoreo para detectar cualquier problema en la aplicaci\u00f3n en tiempo real. Realizar actualizaciones de forma regular para mantener la seguridad y el rendimiento de la aplicaci\u00f3n. Documentar el proceso de despliegue para facilitar futuras actualizaciones o para otros miembros del equipo que puedan realizar el despliegue en el futuro.","title":"Despliegue de una aplicaci\u00f3n Phoenix"},{"location":"phoenix_2/jr/despliegue_de_una_aplicaci%C3%B3n_phoenix/#despliegue-de-una-aplicacion-phoenix","text":"El despliegue de una aplicaci\u00f3n Phoenix en un servidor de producci\u00f3n es un proceso clave para que la aplicaci\u00f3n pueda estar disponible para su uso en l\u00ednea. En este m\u00f3dulo, aprenderemos los pasos necesarios para realizar un despliegue exitoso de una aplicaci\u00f3n Phoenix en un entorno de producci\u00f3n.","title":"Despliegue de una aplicaci\u00f3n Phoenix"},{"location":"phoenix_2/jr/despliegue_de_una_aplicaci%C3%B3n_phoenix/#explicacion-teorica","text":"Antes de comenzar con el proceso de despliegue, es importante comprender los conceptos b\u00e1sicos detr\u00e1s de una aplicaci\u00f3n Phoenix y su estructura. Phoenix es un framework web escrito en el lenguaje de programaci\u00f3n Elixir, que se basa en el patr\u00f3n de arquitectura MVC (Modelo-Vista-Controlador). Esto significa que la aplicaci\u00f3n se divide en tres capas: el modelo, que se encarga de la l\u00f3gica de negocio; la vista, que se encarga de la presentaci\u00f3n de los datos; y el controlador, que act\u00faa como intermediario entre el modelo y la vista. La estructura de una aplicaci\u00f3n Phoenix consta de varios directorios y archivos, cada uno con un prop\u00f3sito espec\u00edfico. El directorio lib contiene el c\u00f3digo fuente de la aplicaci\u00f3n, mientras que el directorio test contiene las pruebas automatizadas. El archivo mix.exs es el encargado de manejar las dependencias y la configuraci\u00f3n de la aplicaci\u00f3n. Por \u00faltimo, el archivo config.exs contiene la configuraci\u00f3n de la aplicaci\u00f3n, como la base de datos y las rutas de la aplicaci\u00f3n.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix_2/jr/despliegue_de_una_aplicaci%C3%B3n_phoenix/#palabras-clave-y-su-definicion","text":"Phoenix: Framework web escrito en el lenguaje de programaci\u00f3n Elixir. Elixir: Lenguaje de programaci\u00f3n funcional basado en Erlang. MVC: Patr\u00f3n de arquitectura Modelo-Vista-Controlador. Modelo: Capa encargada de la l\u00f3gica de negocio. Vista: Capa encargada de la presentaci\u00f3n de los datos. Controlador: Capa encargada de actuar como intermediario entre el modelo y la vista. mix.exs: Archivo encargado de manejar las dependencias y la configuraci\u00f3n de la aplicaci\u00f3n. config.exs: Archivo encargado de contener la configuraci\u00f3n de la aplicaci\u00f3n.","title":"Palabras clave y su definici\u00f3n"},{"location":"phoenix_2/jr/despliegue_de_una_aplicaci%C3%B3n_phoenix/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Phoenix y en qu\u00e9 lenguaje de programaci\u00f3n est\u00e1 escrito? \u00bfCu\u00e1l es la estructura de una aplicaci\u00f3n Phoenix? \u00bfCu\u00e1l es la funci\u00f3n del archivo mix.exs? \u00bfQu\u00e9 es el patr\u00f3n MVC y c\u00f3mo se divide una aplicaci\u00f3n Phoenix en este patr\u00f3n?","title":"Preguntas de repaso"},{"location":"phoenix_2/jr/despliegue_de_una_aplicaci%C3%B3n_phoenix/#ejemplos-de-codigo-en-phoenix-framework","text":"A continuaci\u00f3n, se muestran algunos ejemplos de c\u00f3digo en Phoenix que son relevantes para el proceso de despliegue de una aplicaci\u00f3n: Crear una nueva aplicaci\u00f3n Phoenix con el comando mix phx.new <nombre de la aplicaci\u00f3n> . Configurar la base de datos en el archivo config.exs : config : my_app , MyApp . Repo , username : \"username\" , password : \"password\" , database : \"my_app_prod\" , hostname : \"localhost\" , pool_size : 20 Generar una migraci\u00f3n de base de datos con el comando mix ecto.gen.migration <nombre de la migraci\u00f3n> . Ejecutar la migraci\u00f3n con el comando mix ecto.migrate . Crear una nueva ruta en el archivo router.ex : get \"/\", PageController, :index Crear un controlador para la ruta con el comando mix phx.gen.html <nombre del controlador> <nombre del modelo> <campos del modelo> . Configurar la aplicaci\u00f3n para que se ejecute en modo producci\u00f3n en el archivo config/prod.exs : config : my_app , MyApp . Endpoint , url : [ scheme : \"https\" , host : \"myapp.com\" , port : 443 ], cache_static_manifest : \"priv/static/cache_manifest.json\" , secret_key_base : System . get_env ( \"SECRET_KEY_BASE\" )","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix_2/jr/despliegue_de_una_aplicaci%C3%B3n_phoenix/#ejercicios-practicos-con-instrucciones-claras","text":"Crear una nueva aplicaci\u00f3n Phoenix con el nombre de \"my_app\". Configurar la base de datos en el archivo config.exs con los siguientes valores: username: \"admin\", password: \"123456\", database: \"my_app_prod\", hostname: \"localhost\", pool_size: 10. Generar una migraci\u00f3n de base de datos con el nombre de \"create_users\" que contenga los campos \"name\", \"email\" y \"password\". Ejecutar la migraci\u00f3n. Crear una nueva ruta en el archivo router.ex que apunte a la acci\u00f3n \"index\" del controlador \"PageController\". Crear un controlador con el nombre de \"PageController\" y la acci\u00f3n \"index\". Configurar la aplicaci\u00f3n para que se ejecute en modo producci\u00f3n en el archivo config/prod.exs con la url \"https://myapp.com\" y una clave secreta generada. Ejecutar la aplicaci\u00f3n en modo producci\u00f3n con el comando MIX_ENV=prod mix phx.server . Probar la aplicaci\u00f3n en l\u00ednea en la direcci\u00f3n \"https://myapp.com\".","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"phoenix_2/jr/despliegue_de_una_aplicaci%C3%B3n_phoenix/#consejos-o-mejores-practicas","text":"Realizar pruebas exhaustivas antes de realizar el despliegue en un servidor de producci\u00f3n. Utilizar un sistema de control de versiones para mantener un historial de los cambios en la aplicaci\u00f3n. Asegurarse de tener una copia de seguridad de la base de datos antes de realizar el despliegue. Utilizar herramientas de automatizaci\u00f3n de despliegue, como Capistrano o edeliver, para facilitar el proceso. Configurar un sistema de monitoreo para detectar cualquier problema en la aplicaci\u00f3n en tiempo real. Realizar actualizaciones de forma regular para mantener la seguridad y el rendimiento de la aplicaci\u00f3n. Documentar el proceso de despliegue para facilitar futuras actualizaciones o para otros miembros del equipo que puedan realizar el despliegue en el futuro.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix_2/jr/estructura_de_una_aplicaci%C3%B3n_phoenix/","text":"Estructura de una aplicaci\u00f3n Phoenix \u00b6 Una aplicaci\u00f3n Phoenix est\u00e1 basada en el patr\u00f3n de arquitectura MVC (Modelo-Vista-Controlador) y sigue una estructura jer\u00e1rquica bien definida, lo que facilita su mantenimiento y escalabilidad. Explicaci\u00f3n te\u00f3rica \u00b6 La estructura de una aplicaci\u00f3n Phoenix consta de varios directorios y archivos importantes que desempe\u00f1an un papel clave en su funcionamiento. A continuaci\u00f3n, se explican brevemente cada uno de ellos: config : Este directorio contiene todos los archivos de configuraci\u00f3n de la aplicaci\u00f3n, como por ejemplo config.exs , que contiene la configuraci\u00f3n general de la aplicaci\u00f3n, y dev.exs y prod.exs , que contienen la configuraci\u00f3n espec\u00edfica para el entorno de desarrollo y producci\u00f3n respectivamente. lib : En este directorio se encuentran los m\u00f3dulos de la aplicaci\u00f3n, que contienen la l\u00f3gica de negocio y la manipulaci\u00f3n de datos. test : Aqu\u00ed se encuentran los tests de la aplicaci\u00f3n, escritos en el framework de testing ExUnit. web : Este directorio es el coraz\u00f3n de la aplicaci\u00f3n Phoenix y contiene todos los archivos relacionados con la interfaz web. A su vez, se divide en subdirectorios: controllers : Contiene los controladores de la aplicaci\u00f3n, que se encargan de recibir las solicitudes HTTP y enviar las respuestas correspondientes. models : En este directorio se encuentran los modelos de la aplicaci\u00f3n, que representan las entidades de la base de datos y contienen la l\u00f3gica de acceso a los datos. views : Aqu\u00ed se encuentran las vistas de la aplicaci\u00f3n, que son responsables de presentar los datos al usuario en formato HTML o alg\u00fan otro formato. templates : Contiene los archivos de plantilla utilizados para generar las vistas de la aplicaci\u00f3n. channels : Este directorio contiene los canales de comunicaci\u00f3n en tiempo real, que permiten la interacci\u00f3n en tiempo real entre el servidor y los clientes a trav\u00e9s de WebSockets. static : Aqu\u00ed se encuentran los archivos est\u00e1ticos de la aplicaci\u00f3n, como hojas de estilo, im\u00e1genes y archivos JavaScript. errors : Contiene los archivos de error personalizados, que se muestran cuando ocurre un error en la aplicaci\u00f3n. Palabras clave y su definici\u00f3n \u00b6 MVC : Acr\u00f3nimo de Modelo-Vista-Controlador, es un patr\u00f3n de arquitectura de software que divide una aplicaci\u00f3n en tres componentes principales: el Modelo, que se encarga de la l\u00f3gica de negocio y la manipulaci\u00f3n de datos; la Vista, que se encarga de presentar los datos al usuario; y el Controlador, que se encarga de recibir las solicitudes del usuario y enviar las respuestas correspondientes. Interfaz web : Es la parte de una aplicaci\u00f3n que interact\u00faa con el usuario a trav\u00e9s del navegador web. Framework de testing : Es una herramienta que proporciona un conjunto de funciones y m\u00e9todos para facilitar la creaci\u00f3n y ejecuci\u00f3n de tests automatizados. ExUnit : Es el framework de testing utilizado en Phoenix Framework, que permite escribir tests en un estilo simple y declarativo. WebSockets : Son un protocolo de comunicaci\u00f3n bidireccional entre un navegador web y un servidor, que permite la comunicaci\u00f3n en tiempo real. Preguntas de repaso \u00b6 \u00bfQu\u00e9 patr\u00f3n de arquitectura sigue una aplicaci\u00f3n Phoenix? \u00bfQu\u00e9 directorio contiene los controladores de la aplicaci\u00f3n? \u00bfQu\u00e9 funci\u00f3n tienen los archivos de configuraci\u00f3n en una aplicaci\u00f3n Phoenix? \u00bfQu\u00e9 es un framework de testing? \u00bfQu\u00e9 es un WebSockets y para qu\u00e9 se utiliza en una aplicaci\u00f3n Phoenix? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 Controlador \u00b6 defmodule MyApp.UserController do use MyApp.Web , :controller def index ( conn , _params ) do users = MyApp.User |> MyApp.Repo . all render ( conn , \"index.html\" , users : users ) end def show ( conn , %{ \"id\" => id }) do user = MyApp.User |> MyApp.Repo . get! ( id ) render ( conn , \"show.html\" , user : user ) end end Vista \u00b6 defmodule MyApp.UserView do use MyApp.Web , :view def render ( \"index.html\" , %{ users : users }) do ~H \"\"\" <ul> <%= for user <- users do %> <li><%= user.name %></li> <% end %> </ul> \"\"\" end def render ( \"show.html\" , %{ user : user }) do ~H \"\"\" <h1><%= user.name %></h1> <p><%= user.email %></p> \"\"\" end end Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una nueva aplicaci\u00f3n Phoenix con el nombre \"MyApp\". Agrega un nuevo modelo llamado \"Task\", con los campos \"title\", \"description\" y \"completed\". Genera un controlador para el modelo Task con las acciones de \u00edndice y mostrar. Actualiza el archivo router.ex para agregar las rutas correspondientes a las acciones del controlador. Crea una vista para el modelo Task, que muestre una lista de tareas en la acci\u00f3n de \u00edndice y los detalles de una tarea en la acci\u00f3n de mostrar. Crea una plantilla de error personalizada para el error 404. Ejecuta la aplicaci\u00f3n y comprueba que todo funcione correctamente. Consejos o mejores pr\u00e1cticas \u00b6 Sigue la convenci\u00f3n de nombres de Phoenix para mantener una estructura coherente en tu aplicaci\u00f3n. Utiliza los subdirectorios de web para organizar tu c\u00f3digo de manera l\u00f3gica y f\u00e1cilmente mantenible. Utiliza los archivos config.exs , dev.exs y prod.exs para separar la configuraci\u00f3n general de la espec\u00edfica para cada entorno. Utiliza el framework de testing ExUnit para escribir tests automatizados y asegurarte de que tu aplicaci\u00f3n funciona correctamente. Aprovecha las facilidades que ofrece Phoenix, como la generaci\u00f3n autom\u00e1tica de c\u00f3digo y la recarga autom\u00e1tica en desarrollo, para aumentar tu productividad.","title":"Estructura de una aplicaci\u00f3n Phoenix"},{"location":"phoenix_2/jr/estructura_de_una_aplicaci%C3%B3n_phoenix/#estructura-de-una-aplicacion-phoenix","text":"Una aplicaci\u00f3n Phoenix est\u00e1 basada en el patr\u00f3n de arquitectura MVC (Modelo-Vista-Controlador) y sigue una estructura jer\u00e1rquica bien definida, lo que facilita su mantenimiento y escalabilidad.","title":"Estructura de una aplicaci\u00f3n Phoenix"},{"location":"phoenix_2/jr/estructura_de_una_aplicaci%C3%B3n_phoenix/#explicacion-teorica","text":"La estructura de una aplicaci\u00f3n Phoenix consta de varios directorios y archivos importantes que desempe\u00f1an un papel clave en su funcionamiento. A continuaci\u00f3n, se explican brevemente cada uno de ellos: config : Este directorio contiene todos los archivos de configuraci\u00f3n de la aplicaci\u00f3n, como por ejemplo config.exs , que contiene la configuraci\u00f3n general de la aplicaci\u00f3n, y dev.exs y prod.exs , que contienen la configuraci\u00f3n espec\u00edfica para el entorno de desarrollo y producci\u00f3n respectivamente. lib : En este directorio se encuentran los m\u00f3dulos de la aplicaci\u00f3n, que contienen la l\u00f3gica de negocio y la manipulaci\u00f3n de datos. test : Aqu\u00ed se encuentran los tests de la aplicaci\u00f3n, escritos en el framework de testing ExUnit. web : Este directorio es el coraz\u00f3n de la aplicaci\u00f3n Phoenix y contiene todos los archivos relacionados con la interfaz web. A su vez, se divide en subdirectorios: controllers : Contiene los controladores de la aplicaci\u00f3n, que se encargan de recibir las solicitudes HTTP y enviar las respuestas correspondientes. models : En este directorio se encuentran los modelos de la aplicaci\u00f3n, que representan las entidades de la base de datos y contienen la l\u00f3gica de acceso a los datos. views : Aqu\u00ed se encuentran las vistas de la aplicaci\u00f3n, que son responsables de presentar los datos al usuario en formato HTML o alg\u00fan otro formato. templates : Contiene los archivos de plantilla utilizados para generar las vistas de la aplicaci\u00f3n. channels : Este directorio contiene los canales de comunicaci\u00f3n en tiempo real, que permiten la interacci\u00f3n en tiempo real entre el servidor y los clientes a trav\u00e9s de WebSockets. static : Aqu\u00ed se encuentran los archivos est\u00e1ticos de la aplicaci\u00f3n, como hojas de estilo, im\u00e1genes y archivos JavaScript. errors : Contiene los archivos de error personalizados, que se muestran cuando ocurre un error en la aplicaci\u00f3n.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix_2/jr/estructura_de_una_aplicaci%C3%B3n_phoenix/#palabras-clave-y-su-definicion","text":"MVC : Acr\u00f3nimo de Modelo-Vista-Controlador, es un patr\u00f3n de arquitectura de software que divide una aplicaci\u00f3n en tres componentes principales: el Modelo, que se encarga de la l\u00f3gica de negocio y la manipulaci\u00f3n de datos; la Vista, que se encarga de presentar los datos al usuario; y el Controlador, que se encarga de recibir las solicitudes del usuario y enviar las respuestas correspondientes. Interfaz web : Es la parte de una aplicaci\u00f3n que interact\u00faa con el usuario a trav\u00e9s del navegador web. Framework de testing : Es una herramienta que proporciona un conjunto de funciones y m\u00e9todos para facilitar la creaci\u00f3n y ejecuci\u00f3n de tests automatizados. ExUnit : Es el framework de testing utilizado en Phoenix Framework, que permite escribir tests en un estilo simple y declarativo. WebSockets : Son un protocolo de comunicaci\u00f3n bidireccional entre un navegador web y un servidor, que permite la comunicaci\u00f3n en tiempo real.","title":"Palabras clave y su definici\u00f3n"},{"location":"phoenix_2/jr/estructura_de_una_aplicaci%C3%B3n_phoenix/#preguntas-de-repaso","text":"\u00bfQu\u00e9 patr\u00f3n de arquitectura sigue una aplicaci\u00f3n Phoenix? \u00bfQu\u00e9 directorio contiene los controladores de la aplicaci\u00f3n? \u00bfQu\u00e9 funci\u00f3n tienen los archivos de configuraci\u00f3n en una aplicaci\u00f3n Phoenix? \u00bfQu\u00e9 es un framework de testing? \u00bfQu\u00e9 es un WebSockets y para qu\u00e9 se utiliza en una aplicaci\u00f3n Phoenix?","title":"Preguntas de repaso"},{"location":"phoenix_2/jr/estructura_de_una_aplicaci%C3%B3n_phoenix/#ejemplos-de-codigo-en-phoenix-framework","text":"","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix_2/jr/estructura_de_una_aplicaci%C3%B3n_phoenix/#controlador","text":"defmodule MyApp.UserController do use MyApp.Web , :controller def index ( conn , _params ) do users = MyApp.User |> MyApp.Repo . all render ( conn , \"index.html\" , users : users ) end def show ( conn , %{ \"id\" => id }) do user = MyApp.User |> MyApp.Repo . get! ( id ) render ( conn , \"show.html\" , user : user ) end end","title":"Controlador"},{"location":"phoenix_2/jr/estructura_de_una_aplicaci%C3%B3n_phoenix/#vista","text":"defmodule MyApp.UserView do use MyApp.Web , :view def render ( \"index.html\" , %{ users : users }) do ~H \"\"\" <ul> <%= for user <- users do %> <li><%= user.name %></li> <% end %> </ul> \"\"\" end def render ( \"show.html\" , %{ user : user }) do ~H \"\"\" <h1><%= user.name %></h1> <p><%= user.email %></p> \"\"\" end end","title":"Vista"},{"location":"phoenix_2/jr/estructura_de_una_aplicaci%C3%B3n_phoenix/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una nueva aplicaci\u00f3n Phoenix con el nombre \"MyApp\". Agrega un nuevo modelo llamado \"Task\", con los campos \"title\", \"description\" y \"completed\". Genera un controlador para el modelo Task con las acciones de \u00edndice y mostrar. Actualiza el archivo router.ex para agregar las rutas correspondientes a las acciones del controlador. Crea una vista para el modelo Task, que muestre una lista de tareas en la acci\u00f3n de \u00edndice y los detalles de una tarea en la acci\u00f3n de mostrar. Crea una plantilla de error personalizada para el error 404. Ejecuta la aplicaci\u00f3n y comprueba que todo funcione correctamente.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"phoenix_2/jr/estructura_de_una_aplicaci%C3%B3n_phoenix/#consejos-o-mejores-practicas","text":"Sigue la convenci\u00f3n de nombres de Phoenix para mantener una estructura coherente en tu aplicaci\u00f3n. Utiliza los subdirectorios de web para organizar tu c\u00f3digo de manera l\u00f3gica y f\u00e1cilmente mantenible. Utiliza los archivos config.exs , dev.exs y prod.exs para separar la configuraci\u00f3n general de la espec\u00edfica para cada entorno. Utiliza el framework de testing ExUnit para escribir tests automatizados y asegurarte de que tu aplicaci\u00f3n funciona correctamente. Aprovecha las facilidades que ofrece Phoenix, como la generaci\u00f3n autom\u00e1tica de c\u00f3digo y la recarga autom\u00e1tica en desarrollo, para aumentar tu productividad.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix_2/jr/instalaci%C3%B3n_y_configuraci%C3%B3n/","text":"Instalaci\u00f3n y configuraci\u00f3n de Phoenix Framework \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 Phoenix Framework es un framework de desarrollo web para el lenguaje de programaci\u00f3n Elixir. Fue lanzado en 2015 y se basa en el modelo de arquitectura MVC (Modelo-Vista-Controlador) para el desarrollo de aplicaciones web. Phoenix se destaca por ser r\u00e1pido, escalable y por su capacidad para manejar grandes cantidades de tr\u00e1fico en tiempo real. Para poder utilizar Phoenix Framework, es necesario instalar y configurar algunas herramientas como Elixir, Erlang y Node.js. Una vez que estos requisitos est\u00e9n satisfechos, se puede proceder con la instalaci\u00f3n de Phoenix. Palabras clave y su definici\u00f3n \u00b6 Elixir: Es un lenguaje de programaci\u00f3n funcional creado en 2012 por Jos\u00e9 Valim. Se ejecuta sobre la m\u00e1quina virtual de Erlang (BEAM) y se basa en el paradigma de programaci\u00f3n funcional y concurrencia. Erlang: Es una plataforma de desarrollo creada por Ericsson en 1986. Es altamente escalable y est\u00e1 dise\u00f1ada para manejar aplicaciones distribuidas y concurrentes. Node.js: Es un entorno de ejecuci\u00f3n de JavaScript construido sobre el motor V8 de Google Chrome. Se utiliza principalmente para crear aplicaciones de red y servidores web. MVC: Es un patr\u00f3n de arquitectura de software que separa la aplicaci\u00f3n en tres componentes principales: modelo, vista y controlador. El modelo se encarga de la l\u00f3gica de negocio y la persistencia de datos, la vista muestra la informaci\u00f3n al usuario y el controlador maneja las solicitudes del usuario y coordina la comunicaci\u00f3n entre el modelo y la vista. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es Phoenix Framework? \u00bfEn qu\u00e9 lenguaje de programaci\u00f3n est\u00e1 escrito Phoenix? \u00bfQu\u00e9 es Elixir? \u00bfCu\u00e1l es la plataforma de desarrollo en la que se ejecuta Elixir? \u00bfPara qu\u00e9 se utiliza Node.js? \u00bfQu\u00e9 es el patr\u00f3n de arquitectura MVC? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 A continuaci\u00f3n, se muestran ejemplos de c\u00f3digo en Phoenix Framework para crear una aplicaci\u00f3n simple y mostrar un mensaje de bienvenida. Creaci\u00f3n de una aplicaci\u00f3n Phoenix \u00b6 Para crear una aplicaci\u00f3n Phoenix, se utiliza el comando mix phx.new <nombre de la aplicaci\u00f3n> . Esto generar\u00e1 una estructura de archivos para la aplicaci\u00f3n, incluyendo el archivo mix.exs que contiene las dependencias y la configuraci\u00f3n de la aplicaci\u00f3n. Definici\u00f3n de una ruta y controlador \u00b6 En el archivo router.ex , se definen las rutas de la aplicaci\u00f3n. Por ejemplo, para crear una ruta que muestre un mensaje de bienvenida, se puede agregar el siguiente c\u00f3digo: get \"/\", PageController, :index Esto indica que cuando se recibe una solicitud GET en la ruta \"/\", se debe llamar al controlador PageController y al m\u00e9todo index . Creaci\u00f3n de un controlador \u00b6 En el archivo page_controller.ex , se define el controlador PageController y el m\u00e9todo index que devuelve el mensaje de bienvenida: defmodule MyApp.PageController do use MyApp, :controller def index(conn, _params) do render(conn, \"index.html\", message: \"\u00a1Bienvenido a mi aplicaci\u00f3n Phoenix!\") end end Creaci\u00f3n de una vista \u00b6 En el archivo index.html.eex , se define la vista que mostrar\u00e1 el mensaje de bienvenida: <h1> <%= @message %> </h1> Iniciar el servidor \u00b6 Para iniciar el servidor y ver la aplicaci\u00f3n en el navegador, se utiliza el comando mix phx.server . Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Instala Elixir, Erlang y Node.js en tu sistema. Crea una aplicaci\u00f3n Phoenix utilizando el comando mix phx.new . Define una ruta y un controlador que muestren un mensaje de bienvenida. Crea una vista para mostrar el mensaje. Inicia el servidor y verifica que la aplicaci\u00f3n funcione correctamente en el navegador. Consejos o mejores pr\u00e1cticas \u00b6 Es recomendable seguir la estructura de archivos y convenciones de nomenclatura utilizadas por Phoenix Framework para una mejor organizaci\u00f3n y legibilidad del c\u00f3digo. Utiliza el archivo mix.exs para agregar dependencias y configurar tu aplicaci\u00f3n. Aseg\u00farate de tener conocimientos b\u00e1sicos de Elixir y su sintaxis antes de comenzar a trabajar con Phoenix. Utiliza el m\u00f3dulo Plug para manejar las solicitudes HTTP y para crear middleware personalizado. Comienza con una aplicaci\u00f3n simple y ve agregando funcionalidades a medida que te familiarices con el framework.","title":"Instalaci\u00f3n y configuraci\u00f3n de Phoenix Framework"},{"location":"phoenix_2/jr/instalaci%C3%B3n_y_configuraci%C3%B3n/#instalacion-y-configuracion-de-phoenix-framework","text":"","title":"Instalaci\u00f3n y configuraci\u00f3n de Phoenix Framework"},{"location":"phoenix_2/jr/instalaci%C3%B3n_y_configuraci%C3%B3n/#explicacion-teorica","text":"Phoenix Framework es un framework de desarrollo web para el lenguaje de programaci\u00f3n Elixir. Fue lanzado en 2015 y se basa en el modelo de arquitectura MVC (Modelo-Vista-Controlador) para el desarrollo de aplicaciones web. Phoenix se destaca por ser r\u00e1pido, escalable y por su capacidad para manejar grandes cantidades de tr\u00e1fico en tiempo real. Para poder utilizar Phoenix Framework, es necesario instalar y configurar algunas herramientas como Elixir, Erlang y Node.js. Una vez que estos requisitos est\u00e9n satisfechos, se puede proceder con la instalaci\u00f3n de Phoenix.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix_2/jr/instalaci%C3%B3n_y_configuraci%C3%B3n/#palabras-clave-y-su-definicion","text":"Elixir: Es un lenguaje de programaci\u00f3n funcional creado en 2012 por Jos\u00e9 Valim. Se ejecuta sobre la m\u00e1quina virtual de Erlang (BEAM) y se basa en el paradigma de programaci\u00f3n funcional y concurrencia. Erlang: Es una plataforma de desarrollo creada por Ericsson en 1986. Es altamente escalable y est\u00e1 dise\u00f1ada para manejar aplicaciones distribuidas y concurrentes. Node.js: Es un entorno de ejecuci\u00f3n de JavaScript construido sobre el motor V8 de Google Chrome. Se utiliza principalmente para crear aplicaciones de red y servidores web. MVC: Es un patr\u00f3n de arquitectura de software que separa la aplicaci\u00f3n en tres componentes principales: modelo, vista y controlador. El modelo se encarga de la l\u00f3gica de negocio y la persistencia de datos, la vista muestra la informaci\u00f3n al usuario y el controlador maneja las solicitudes del usuario y coordina la comunicaci\u00f3n entre el modelo y la vista.","title":"Palabras clave y su definici\u00f3n"},{"location":"phoenix_2/jr/instalaci%C3%B3n_y_configuraci%C3%B3n/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Phoenix Framework? \u00bfEn qu\u00e9 lenguaje de programaci\u00f3n est\u00e1 escrito Phoenix? \u00bfQu\u00e9 es Elixir? \u00bfCu\u00e1l es la plataforma de desarrollo en la que se ejecuta Elixir? \u00bfPara qu\u00e9 se utiliza Node.js? \u00bfQu\u00e9 es el patr\u00f3n de arquitectura MVC?","title":"Preguntas de repaso"},{"location":"phoenix_2/jr/instalaci%C3%B3n_y_configuraci%C3%B3n/#ejemplos-de-codigo-en-phoenix-framework","text":"A continuaci\u00f3n, se muestran ejemplos de c\u00f3digo en Phoenix Framework para crear una aplicaci\u00f3n simple y mostrar un mensaje de bienvenida.","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix_2/jr/instalaci%C3%B3n_y_configuraci%C3%B3n/#creacion-de-una-aplicacion-phoenix","text":"Para crear una aplicaci\u00f3n Phoenix, se utiliza el comando mix phx.new <nombre de la aplicaci\u00f3n> . Esto generar\u00e1 una estructura de archivos para la aplicaci\u00f3n, incluyendo el archivo mix.exs que contiene las dependencias y la configuraci\u00f3n de la aplicaci\u00f3n.","title":"Creaci\u00f3n de una aplicaci\u00f3n Phoenix"},{"location":"phoenix_2/jr/instalaci%C3%B3n_y_configuraci%C3%B3n/#definicion-de-una-ruta-y-controlador","text":"En el archivo router.ex , se definen las rutas de la aplicaci\u00f3n. Por ejemplo, para crear una ruta que muestre un mensaje de bienvenida, se puede agregar el siguiente c\u00f3digo: get \"/\", PageController, :index Esto indica que cuando se recibe una solicitud GET en la ruta \"/\", se debe llamar al controlador PageController y al m\u00e9todo index .","title":"Definici\u00f3n de una ruta y controlador"},{"location":"phoenix_2/jr/instalaci%C3%B3n_y_configuraci%C3%B3n/#creacion-de-un-controlador","text":"En el archivo page_controller.ex , se define el controlador PageController y el m\u00e9todo index que devuelve el mensaje de bienvenida: defmodule MyApp.PageController do use MyApp, :controller def index(conn, _params) do render(conn, \"index.html\", message: \"\u00a1Bienvenido a mi aplicaci\u00f3n Phoenix!\") end end","title":"Creaci\u00f3n de un controlador"},{"location":"phoenix_2/jr/instalaci%C3%B3n_y_configuraci%C3%B3n/#creacion-de-una-vista","text":"En el archivo index.html.eex , se define la vista que mostrar\u00e1 el mensaje de bienvenida: <h1> <%= @message %> </h1>","title":"Creaci\u00f3n de una vista"},{"location":"phoenix_2/jr/instalaci%C3%B3n_y_configuraci%C3%B3n/#iniciar-el-servidor","text":"Para iniciar el servidor y ver la aplicaci\u00f3n en el navegador, se utiliza el comando mix phx.server .","title":"Iniciar el servidor"},{"location":"phoenix_2/jr/instalaci%C3%B3n_y_configuraci%C3%B3n/#ejercicios-practicos-con-instrucciones-claras","text":"Instala Elixir, Erlang y Node.js en tu sistema. Crea una aplicaci\u00f3n Phoenix utilizando el comando mix phx.new . Define una ruta y un controlador que muestren un mensaje de bienvenida. Crea una vista para mostrar el mensaje. Inicia el servidor y verifica que la aplicaci\u00f3n funcione correctamente en el navegador.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"phoenix_2/jr/instalaci%C3%B3n_y_configuraci%C3%B3n/#consejos-o-mejores-practicas","text":"Es recomendable seguir la estructura de archivos y convenciones de nomenclatura utilizadas por Phoenix Framework para una mejor organizaci\u00f3n y legibilidad del c\u00f3digo. Utiliza el archivo mix.exs para agregar dependencias y configurar tu aplicaci\u00f3n. Aseg\u00farate de tener conocimientos b\u00e1sicos de Elixir y su sintaxis antes de comenzar a trabajar con Phoenix. Utiliza el m\u00f3dulo Plug para manejar las solicitudes HTTP y para crear middleware personalizado. Comienza con una aplicaci\u00f3n simple y ve agregando funcionalidades a medida que te familiarices con el framework.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix_2/jr/introducci%C3%B3n_a_phoenix_framework/","text":"Introducci\u00f3n a Phoenix Framework \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En este m\u00f3dulo, exploraremos Phoenix Framework, un framework de desarrollo web escrito en el lenguaje de programaci\u00f3n Elixir. A lo largo de la lecci\u00f3n, aprender\u00e1s sobre la historia y caracter\u00edsticas de Phoenix Framework, as\u00ed como tambi\u00e9n su uso y ventajas en el desarrollo de aplicaciones web. Explicaci\u00f3n te\u00f3rica \u00b6 Phoenix Framework fue creado por Chris McCord en 2014 como una alternativa al popular framework de Ruby on Rails. Est\u00e1 basado en el patr\u00f3n de dise\u00f1o Modelo-Vista-Controlador (MVC) y utiliza el lenguaje de programaci\u00f3n funcional Elixir, que se ejecuta en la m\u00e1quina virtual de Erlang. Phoenix se ha convertido en una opci\u00f3n popular para el desarrollo de aplicaciones web en Elixir debido a su rendimiento, escalabilidad y facilidad de uso. Phoenix Framework fue dise\u00f1ado para ser un framework de desarrollo web de alta productividad, lo que significa que permite a los desarrolladores crear aplicaciones r\u00e1pidamente con un m\u00ednimo de c\u00f3digo repetitivo. Esto se logra a trav\u00e9s de la utilizaci\u00f3n de convenciones y herramientas integradas, lo que permite a los desarrolladores centrarse en la l\u00f3gica de la aplicaci\u00f3n en lugar de en la configuraci\u00f3n y la infraestructura. Palabras clave y su definici\u00f3n \u00b6 Framework: Un conjunto de herramientas, bibliotecas y patrones de dise\u00f1o que se utilizan para facilitar el desarrollo de aplicaciones. Elixir: Un lenguaje de programaci\u00f3n funcional que se ejecuta en la m\u00e1quina virtual de Erlang. Modelo-Vista-Controlador (MVC): Un patr\u00f3n de dise\u00f1o de software que separa la l\u00f3gica de una aplicaci\u00f3n en tres componentes: Modelo, Vista y Controlador. Rendimiento: La capacidad de una aplicaci\u00f3n para procesar y responder a las solicitudes de manera eficiente. Escalabilidad: La capacidad de una aplicaci\u00f3n para manejar un aumento en la cantidad de usuarios o datos sin afectar su rendimiento. Productividad: La eficiencia y rapidez con la que se pueden desarrollar aplicaciones. Preguntas de repaso \u00b6 \u00bfQui\u00e9n cre\u00f3 Phoenix Framework y en qu\u00e9 a\u00f1o? \u00bfEn qu\u00e9 lenguaje de programaci\u00f3n est\u00e1 escrito Phoenix Framework? \u00bfQu\u00e9 patr\u00f3n de dise\u00f1o sigue Phoenix Framework? \u00bfPor qu\u00e9 se considera a Phoenix Framework un framework de alta productividad? \u00bfQu\u00e9 es la escalabilidad en el contexto de aplicaciones web? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 A continuaci\u00f3n, se muestra un ejemplo de una acci\u00f3n b\u00e1sica en un controlador de Phoenix Framework que devuelve una vista HTML. defmodule MyApp.PageController do use MyApp.Web , :controller def index ( conn , _params ) do render ( conn , \"index.html\" ) end end Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea un nuevo proyecto de Phoenix Framework siguiendo los pasos de la documentaci\u00f3n oficial. Crea un controlador y una vista que muestre un mensaje de bienvenida en la p\u00e1gina de inicio. Agrega una ruta a tu aplicaci\u00f3n que responda a una solicitud GET con un JSON que contenga un objeto con informaci\u00f3n de un usuario. Implementa una funcionalidad en tu aplicaci\u00f3n que permita a los usuarios registrarse y guardar su informaci\u00f3n en una base de datos. Utiliza la documentaci\u00f3n de Phoenix Framework para agregar validaciones a tu formulario de registro y manejar errores de manera adecuada. Consejos o mejores pr\u00e1cticas \u00b6 Aqu\u00ed hay algunos consejos y mejores pr\u00e1cticas a tener en cuenta al trabajar con Phoenix Framework: Utiliza las convenciones de nomenclatura de Phoenix Framework para mantener una estructura de c\u00f3digo consistente y f\u00e1cil de seguir. Aprovecha las herramientas integradas, como las migraciones de base de datos y el generador de c\u00f3digo, para ahorrar tiempo y esfuerzo. Aprende sobre el patr\u00f3n de dise\u00f1o Modelo-Vista-Controlador y c\u00f3mo se aplica en Phoenix Framework para escribir c\u00f3digo eficiente y escalable. Utiliza la documentaci\u00f3n oficial y la comunidad de Phoenix Framework para obtener ayuda y aprender mejores pr\u00e1cticas de otros desarrolladores. Prueba tu c\u00f3digo regularmente y utiliza herramientas como Ecto para manejar consultas de base de datos de manera segura y eficiente. Conclusi\u00f3n \u00b6 En este m\u00f3dulo, hemos explorado Phoenix Framework, un framework de desarrollo web escrito en Elixir. Aprendiste sobre su historia, caracter\u00edsticas y ventajas, as\u00ed como tambi\u00e9n viste ejemplos de c\u00f3digo y realizaste ejercicios pr\u00e1cticos para poner en pr\u00e1ctica tus conocimientos. Con esta base, est\u00e1s listo para comenzar a desarrollar aplicaciones web con Phoenix Framework y aprovechar su rendimiento, escalabilidad y alta productividad.","title":"Introducci\u00f3n a Phoenix Framework"},{"location":"phoenix_2/jr/introducci%C3%B3n_a_phoenix_framework/#introduccion-a-phoenix-framework","text":"","title":"Introducci\u00f3n a Phoenix Framework"},{"location":"phoenix_2/jr/introducci%C3%B3n_a_phoenix_framework/#descripcion-del-modulo","text":"En este m\u00f3dulo, exploraremos Phoenix Framework, un framework de desarrollo web escrito en el lenguaje de programaci\u00f3n Elixir. A lo largo de la lecci\u00f3n, aprender\u00e1s sobre la historia y caracter\u00edsticas de Phoenix Framework, as\u00ed como tambi\u00e9n su uso y ventajas en el desarrollo de aplicaciones web.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"phoenix_2/jr/introducci%C3%B3n_a_phoenix_framework/#explicacion-teorica","text":"Phoenix Framework fue creado por Chris McCord en 2014 como una alternativa al popular framework de Ruby on Rails. Est\u00e1 basado en el patr\u00f3n de dise\u00f1o Modelo-Vista-Controlador (MVC) y utiliza el lenguaje de programaci\u00f3n funcional Elixir, que se ejecuta en la m\u00e1quina virtual de Erlang. Phoenix se ha convertido en una opci\u00f3n popular para el desarrollo de aplicaciones web en Elixir debido a su rendimiento, escalabilidad y facilidad de uso. Phoenix Framework fue dise\u00f1ado para ser un framework de desarrollo web de alta productividad, lo que significa que permite a los desarrolladores crear aplicaciones r\u00e1pidamente con un m\u00ednimo de c\u00f3digo repetitivo. Esto se logra a trav\u00e9s de la utilizaci\u00f3n de convenciones y herramientas integradas, lo que permite a los desarrolladores centrarse en la l\u00f3gica de la aplicaci\u00f3n en lugar de en la configuraci\u00f3n y la infraestructura.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix_2/jr/introducci%C3%B3n_a_phoenix_framework/#palabras-clave-y-su-definicion","text":"Framework: Un conjunto de herramientas, bibliotecas y patrones de dise\u00f1o que se utilizan para facilitar el desarrollo de aplicaciones. Elixir: Un lenguaje de programaci\u00f3n funcional que se ejecuta en la m\u00e1quina virtual de Erlang. Modelo-Vista-Controlador (MVC): Un patr\u00f3n de dise\u00f1o de software que separa la l\u00f3gica de una aplicaci\u00f3n en tres componentes: Modelo, Vista y Controlador. Rendimiento: La capacidad de una aplicaci\u00f3n para procesar y responder a las solicitudes de manera eficiente. Escalabilidad: La capacidad de una aplicaci\u00f3n para manejar un aumento en la cantidad de usuarios o datos sin afectar su rendimiento. Productividad: La eficiencia y rapidez con la que se pueden desarrollar aplicaciones.","title":"Palabras clave y su definici\u00f3n"},{"location":"phoenix_2/jr/introducci%C3%B3n_a_phoenix_framework/#preguntas-de-repaso","text":"\u00bfQui\u00e9n cre\u00f3 Phoenix Framework y en qu\u00e9 a\u00f1o? \u00bfEn qu\u00e9 lenguaje de programaci\u00f3n est\u00e1 escrito Phoenix Framework? \u00bfQu\u00e9 patr\u00f3n de dise\u00f1o sigue Phoenix Framework? \u00bfPor qu\u00e9 se considera a Phoenix Framework un framework de alta productividad? \u00bfQu\u00e9 es la escalabilidad en el contexto de aplicaciones web?","title":"Preguntas de repaso"},{"location":"phoenix_2/jr/introducci%C3%B3n_a_phoenix_framework/#ejemplos-de-codigo-en-phoenix-framework","text":"A continuaci\u00f3n, se muestra un ejemplo de una acci\u00f3n b\u00e1sica en un controlador de Phoenix Framework que devuelve una vista HTML. defmodule MyApp.PageController do use MyApp.Web , :controller def index ( conn , _params ) do render ( conn , \"index.html\" ) end end","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix_2/jr/introducci%C3%B3n_a_phoenix_framework/#ejercicios-practicos-con-instrucciones-claras","text":"Crea un nuevo proyecto de Phoenix Framework siguiendo los pasos de la documentaci\u00f3n oficial. Crea un controlador y una vista que muestre un mensaje de bienvenida en la p\u00e1gina de inicio. Agrega una ruta a tu aplicaci\u00f3n que responda a una solicitud GET con un JSON que contenga un objeto con informaci\u00f3n de un usuario. Implementa una funcionalidad en tu aplicaci\u00f3n que permita a los usuarios registrarse y guardar su informaci\u00f3n en una base de datos. Utiliza la documentaci\u00f3n de Phoenix Framework para agregar validaciones a tu formulario de registro y manejar errores de manera adecuada.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"phoenix_2/jr/introducci%C3%B3n_a_phoenix_framework/#consejos-o-mejores-practicas","text":"Aqu\u00ed hay algunos consejos y mejores pr\u00e1cticas a tener en cuenta al trabajar con Phoenix Framework: Utiliza las convenciones de nomenclatura de Phoenix Framework para mantener una estructura de c\u00f3digo consistente y f\u00e1cil de seguir. Aprovecha las herramientas integradas, como las migraciones de base de datos y el generador de c\u00f3digo, para ahorrar tiempo y esfuerzo. Aprende sobre el patr\u00f3n de dise\u00f1o Modelo-Vista-Controlador y c\u00f3mo se aplica en Phoenix Framework para escribir c\u00f3digo eficiente y escalable. Utiliza la documentaci\u00f3n oficial y la comunidad de Phoenix Framework para obtener ayuda y aprender mejores pr\u00e1cticas de otros desarrolladores. Prueba tu c\u00f3digo regularmente y utiliza herramientas como Ecto para manejar consultas de base de datos de manera segura y eficiente.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix_2/jr/introducci%C3%B3n_a_phoenix_framework/#conclusion","text":"En este m\u00f3dulo, hemos explorado Phoenix Framework, un framework de desarrollo web escrito en Elixir. Aprendiste sobre su historia, caracter\u00edsticas y ventajas, as\u00ed como tambi\u00e9n viste ejemplos de c\u00f3digo y realizaste ejercicios pr\u00e1cticos para poner en pr\u00e1ctica tus conocimientos. Con esta base, est\u00e1s listo para comenzar a desarrollar aplicaciones web con Phoenix Framework y aprovechar su rendimiento, escalabilidad y alta productividad.","title":"Conclusi\u00f3n"},{"location":"phoenix_2/jr/modelos_y_bases_de_datos/","text":"Modelos y bases de datos \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 En cualquier aplicaci\u00f3n web, el uso de bases de datos es esencial para almacenar y gestionar datos de forma persistente. En el caso de Phoenix Framework, se utiliza Ecto como capa de abstracci\u00f3n para trabajar con bases de datos. Ecto es un ORM (Object-Relational Mapper) que permite mapear objetos de la aplicaci\u00f3n a tablas en la base de datos y realizar operaciones sobre ellos de forma sencilla y eficiente. Para utilizar Ecto en una aplicaci\u00f3n Phoenix, es necesario crear modelos que representen las entidades de la base de datos. Estos modelos se encargan de definir la estructura y relaciones de la tabla correspondiente en la base de datos, as\u00ed como de realizar consultas y modificaciones sobre los datos. Palabras clave y su definici\u00f3n \u00b6 Ecto: Capa de abstracci\u00f3n de bases de datos utilizada en Phoenix Framework. Modelo: Representaci\u00f3n de una entidad en la base de datos, definido en Ecto. ORM: Object-Relational Mapper, herramienta que permite mapear objetos de una aplicaci\u00f3n a tablas en la base de datos. Consulta: Acci\u00f3n que permite obtener datos de la base de datos. Modificaci\u00f3n: Acci\u00f3n que permite actualizar, insertar o eliminar datos en la base de datos. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es Ecto y para qu\u00e9 se utiliza en Phoenix Framework? \u00bfQu\u00e9 es un modelo en el contexto de una aplicaci\u00f3n Phoenix? \u00bfCu\u00e1l es la funci\u00f3n de un ORM? \u00bfQu\u00e9 acciones se pueden realizar sobre los datos de una base de datos utilizando Ecto? \u00bfQu\u00e9 es una consulta en el contexto de una base de datos? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 Para crear un modelo en Phoenix Framework, primero debemos generar una migraci\u00f3n que defina la estructura de la tabla correspondiente en la base de datos. Por ejemplo, si queremos crear un modelo \"User\" con los campos \"name\" y \"email\", podemos ejecutar el siguiente comando en la terminal: mix ecto.gen.migration create_users_table Esto generar\u00e1 un archivo de migraci\u00f3n en la carpeta \"priv/repo/migrations\" con el siguiente contenido: defmodule MyApp . Repo . Migrations . CreateUsersTable do use Ecto . Migration def change do create table ( : users ) do add : name , : string add : email , : string timestamps () end end end Una vez que ejecutemos la migraci\u00f3n, podemos crear el modelo \"User\" en la carpeta \"lib/my_app/models\" con el siguiente contenido: defmodule MyApp . User do use Ecto . Schema import Ecto.Changeset schema \"users\" do field : name , : string field : email , : string timestamps () end @doc false def changeset ( user , attrs ) do user |> cast ( attrs , [: name , : email ]) |> validate_required ([: name , : email ]) end end Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crear un modelo \"Post\" con los campos \"title\", \"content\" y \"author\" en una aplicaci\u00f3n Phoenix. Generar una migraci\u00f3n que a\u00f1ada un campo \"published_at\" al modelo \"Post\". Crear una consulta que obtenga todos los posts publicados por un determinado autor. Crear una modificaci\u00f3n que actualice el contenido de un post existente. A\u00f1adir validaciones al modelo \"Post\" para que el campo \"title\" sea obligatorio y tenga un m\u00e1ximo de 100 caracteres. Consejos o mejores pr\u00e1cticas \u00b6 Utilizar nombres descriptivos y en singular para los modelos. Definir adecuadamente las relaciones entre modelos (uno a uno, uno a muchos, muchos a muchos). Utilizar migraciones para realizar cambios en la estructura de la base de datos. Utilizar transacciones en las modificaciones para asegurar la integridad de los datos. Aprovechar las funcionalidades de Ecto, como los cambiosets, para validar y manipular los datos antes de realizar modificaciones en la base de datos.","title":"Modelos y bases de datos"},{"location":"phoenix_2/jr/modelos_y_bases_de_datos/#modelos-y-bases-de-datos","text":"","title":"Modelos y bases de datos"},{"location":"phoenix_2/jr/modelos_y_bases_de_datos/#explicacion-teorica","text":"En cualquier aplicaci\u00f3n web, el uso de bases de datos es esencial para almacenar y gestionar datos de forma persistente. En el caso de Phoenix Framework, se utiliza Ecto como capa de abstracci\u00f3n para trabajar con bases de datos. Ecto es un ORM (Object-Relational Mapper) que permite mapear objetos de la aplicaci\u00f3n a tablas en la base de datos y realizar operaciones sobre ellos de forma sencilla y eficiente. Para utilizar Ecto en una aplicaci\u00f3n Phoenix, es necesario crear modelos que representen las entidades de la base de datos. Estos modelos se encargan de definir la estructura y relaciones de la tabla correspondiente en la base de datos, as\u00ed como de realizar consultas y modificaciones sobre los datos.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix_2/jr/modelos_y_bases_de_datos/#palabras-clave-y-su-definicion","text":"Ecto: Capa de abstracci\u00f3n de bases de datos utilizada en Phoenix Framework. Modelo: Representaci\u00f3n de una entidad en la base de datos, definido en Ecto. ORM: Object-Relational Mapper, herramienta que permite mapear objetos de una aplicaci\u00f3n a tablas en la base de datos. Consulta: Acci\u00f3n que permite obtener datos de la base de datos. Modificaci\u00f3n: Acci\u00f3n que permite actualizar, insertar o eliminar datos en la base de datos.","title":"Palabras clave y su definici\u00f3n"},{"location":"phoenix_2/jr/modelos_y_bases_de_datos/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Ecto y para qu\u00e9 se utiliza en Phoenix Framework? \u00bfQu\u00e9 es un modelo en el contexto de una aplicaci\u00f3n Phoenix? \u00bfCu\u00e1l es la funci\u00f3n de un ORM? \u00bfQu\u00e9 acciones se pueden realizar sobre los datos de una base de datos utilizando Ecto? \u00bfQu\u00e9 es una consulta en el contexto de una base de datos?","title":"Preguntas de repaso"},{"location":"phoenix_2/jr/modelos_y_bases_de_datos/#ejemplos-de-codigo-en-phoenix-framework","text":"Para crear un modelo en Phoenix Framework, primero debemos generar una migraci\u00f3n que defina la estructura de la tabla correspondiente en la base de datos. Por ejemplo, si queremos crear un modelo \"User\" con los campos \"name\" y \"email\", podemos ejecutar el siguiente comando en la terminal: mix ecto.gen.migration create_users_table Esto generar\u00e1 un archivo de migraci\u00f3n en la carpeta \"priv/repo/migrations\" con el siguiente contenido: defmodule MyApp . Repo . Migrations . CreateUsersTable do use Ecto . Migration def change do create table ( : users ) do add : name , : string add : email , : string timestamps () end end end Una vez que ejecutemos la migraci\u00f3n, podemos crear el modelo \"User\" en la carpeta \"lib/my_app/models\" con el siguiente contenido: defmodule MyApp . User do use Ecto . Schema import Ecto.Changeset schema \"users\" do field : name , : string field : email , : string timestamps () end @doc false def changeset ( user , attrs ) do user |> cast ( attrs , [: name , : email ]) |> validate_required ([: name , : email ]) end end","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix_2/jr/modelos_y_bases_de_datos/#ejercicios-practicos-con-instrucciones-claras","text":"Crear un modelo \"Post\" con los campos \"title\", \"content\" y \"author\" en una aplicaci\u00f3n Phoenix. Generar una migraci\u00f3n que a\u00f1ada un campo \"published_at\" al modelo \"Post\". Crear una consulta que obtenga todos los posts publicados por un determinado autor. Crear una modificaci\u00f3n que actualice el contenido de un post existente. A\u00f1adir validaciones al modelo \"Post\" para que el campo \"title\" sea obligatorio y tenga un m\u00e1ximo de 100 caracteres.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"phoenix_2/jr/modelos_y_bases_de_datos/#consejos-o-mejores-practicas","text":"Utilizar nombres descriptivos y en singular para los modelos. Definir adecuadamente las relaciones entre modelos (uno a uno, uno a muchos, muchos a muchos). Utilizar migraciones para realizar cambios en la estructura de la base de datos. Utilizar transacciones en las modificaciones para asegurar la integridad de los datos. Aprovechar las funcionalidades de Ecto, como los cambiosets, para validar y manipular los datos antes de realizar modificaciones en la base de datos.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix_2/jr/rutas_y_controladores/","text":"Rutas y controladores en Phoenix Framework \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 En Phoenix Framework, las rutas y los controladores son dos elementos clave en el desarrollo de aplicaciones web. Las rutas son la forma en que se define la estructura de una aplicaci\u00f3n y c\u00f3mo los usuarios pueden acceder a sus diferentes partes, mientras que los controladores son los encargados de recibir las solicitudes de los usuarios y proporcionar una respuesta adecuada. Palabras clave y su definici\u00f3n \u00b6 Rutas: Son las direcciones URL que se utilizan para acceder a diferentes partes de una aplicaci\u00f3n. Controladores: Son los m\u00f3dulos que se encargan de manejar las solicitudes de los usuarios y proporcionar una respuesta adecuada. Endpoint: Es el punto final de una solicitud HTTP, es decir, la ruta y el m\u00e9todo de la solicitud que llega al servidor. Acciones: Son las funciones definidas en los controladores que se ejecutan cuando se recibe una solicitud en una ruta espec\u00edfica. Plug: Son m\u00f3dulos que se utilizan para realizar tareas como autenticaci\u00f3n, autorizaci\u00f3n y manejo de errores antes de que se ejecute una acci\u00f3n en un controlador. Preguntas de repaso \u00b6 \u00bfCu\u00e1l es la funci\u00f3n de las rutas en una aplicaci\u00f3n web desarrollada con Phoenix Framework? \u00bfQu\u00e9 son los controladores y cu\u00e1l es su papel en una aplicaci\u00f3n Phoenix? \u00bfQu\u00e9 es un endpoint y c\u00f3mo se relaciona con las rutas y los controladores? \u00bfQu\u00e9 son los plugs y cu\u00e1l es su utilidad en Phoenix Framework? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 Definici\u00f3n de una ruta \u00b6 get \"/\" , PageController , :index En este ejemplo, se define una ruta que apunta a la ra\u00edz de la aplicaci\u00f3n y utiliza el controlador PageController con la acci\u00f3n :index . Definici\u00f3n de una acci\u00f3n en un controlador \u00b6 def index ( conn , params ) do render ( conn , \"index.html\" ) end En este ejemplo, la acci\u00f3n index recibe una conexi\u00f3n conn y los par\u00e1metros params y utiliza la funci\u00f3n render para renderizar la vista index.html . Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una nueva ruta en tu aplicaci\u00f3n Phoenix llamada \"/about\" que apunte a un controlador llamado AboutController y su acci\u00f3n :show . En el controlador AboutController , crea la acci\u00f3n show que renderice la vista about.html . Agrega un enlace en la vista index.html que redirija a la ruta \"/about\". Crea un plug que se ejecute antes de la acci\u00f3n show y verifique si el usuario est\u00e1 autenticado. Si no lo est\u00e1, redirige a la p\u00e1gina de inicio de sesi\u00f3n. Para practicar m\u00e1s, define otras rutas y acciones en diferentes controladores y utiliza diferentes funciones de renderizado como json o redirect . Consejos o mejores pr\u00e1cticas \u00b6 Utiliza nombres descriptivos para las rutas y los controladores, esto facilitar\u00e1 la comprensi\u00f3n de la estructura de tu aplicaci\u00f3n. Agrupa las rutas relacionadas en un mismo controlador para mantener una estructura m\u00e1s organizada. Utiliza plugs para realizar tareas comunes como autenticaci\u00f3n y autorizaci\u00f3n en lugar de repetir c\u00f3digo en todas las acciones de tus controladores. Utiliza patrones de ruta para definir rutas din\u00e1micas y evitar tener que crear rutas para cada elemento de tu aplicaci\u00f3n. Utiliza la funci\u00f3n plug en tu controlador para ejecutar plugs espec\u00edficos antes de ciertas acciones, en lugar de utilizarlos en todas las acciones del controlador.","title":"Rutas y controladores"},{"location":"phoenix_2/jr/rutas_y_controladores/#rutas-y-controladores-en-phoenix-framework","text":"","title":"Rutas y controladores en Phoenix Framework"},{"location":"phoenix_2/jr/rutas_y_controladores/#explicacion-teorica","text":"En Phoenix Framework, las rutas y los controladores son dos elementos clave en el desarrollo de aplicaciones web. Las rutas son la forma en que se define la estructura de una aplicaci\u00f3n y c\u00f3mo los usuarios pueden acceder a sus diferentes partes, mientras que los controladores son los encargados de recibir las solicitudes de los usuarios y proporcionar una respuesta adecuada.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix_2/jr/rutas_y_controladores/#palabras-clave-y-su-definicion","text":"Rutas: Son las direcciones URL que se utilizan para acceder a diferentes partes de una aplicaci\u00f3n. Controladores: Son los m\u00f3dulos que se encargan de manejar las solicitudes de los usuarios y proporcionar una respuesta adecuada. Endpoint: Es el punto final de una solicitud HTTP, es decir, la ruta y el m\u00e9todo de la solicitud que llega al servidor. Acciones: Son las funciones definidas en los controladores que se ejecutan cuando se recibe una solicitud en una ruta espec\u00edfica. Plug: Son m\u00f3dulos que se utilizan para realizar tareas como autenticaci\u00f3n, autorizaci\u00f3n y manejo de errores antes de que se ejecute una acci\u00f3n en un controlador.","title":"Palabras clave y su definici\u00f3n"},{"location":"phoenix_2/jr/rutas_y_controladores/#preguntas-de-repaso","text":"\u00bfCu\u00e1l es la funci\u00f3n de las rutas en una aplicaci\u00f3n web desarrollada con Phoenix Framework? \u00bfQu\u00e9 son los controladores y cu\u00e1l es su papel en una aplicaci\u00f3n Phoenix? \u00bfQu\u00e9 es un endpoint y c\u00f3mo se relaciona con las rutas y los controladores? \u00bfQu\u00e9 son los plugs y cu\u00e1l es su utilidad en Phoenix Framework?","title":"Preguntas de repaso"},{"location":"phoenix_2/jr/rutas_y_controladores/#ejemplos-de-codigo-en-phoenix-framework","text":"","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix_2/jr/rutas_y_controladores/#definicion-de-una-ruta","text":"get \"/\" , PageController , :index En este ejemplo, se define una ruta que apunta a la ra\u00edz de la aplicaci\u00f3n y utiliza el controlador PageController con la acci\u00f3n :index .","title":"Definici\u00f3n de una ruta"},{"location":"phoenix_2/jr/rutas_y_controladores/#definicion-de-una-accion-en-un-controlador","text":"def index ( conn , params ) do render ( conn , \"index.html\" ) end En este ejemplo, la acci\u00f3n index recibe una conexi\u00f3n conn y los par\u00e1metros params y utiliza la funci\u00f3n render para renderizar la vista index.html .","title":"Definici\u00f3n de una acci\u00f3n en un controlador"},{"location":"phoenix_2/jr/rutas_y_controladores/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una nueva ruta en tu aplicaci\u00f3n Phoenix llamada \"/about\" que apunte a un controlador llamado AboutController y su acci\u00f3n :show . En el controlador AboutController , crea la acci\u00f3n show que renderice la vista about.html . Agrega un enlace en la vista index.html que redirija a la ruta \"/about\". Crea un plug que se ejecute antes de la acci\u00f3n show y verifique si el usuario est\u00e1 autenticado. Si no lo est\u00e1, redirige a la p\u00e1gina de inicio de sesi\u00f3n. Para practicar m\u00e1s, define otras rutas y acciones en diferentes controladores y utiliza diferentes funciones de renderizado como json o redirect .","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"phoenix_2/jr/rutas_y_controladores/#consejos-o-mejores-practicas","text":"Utiliza nombres descriptivos para las rutas y los controladores, esto facilitar\u00e1 la comprensi\u00f3n de la estructura de tu aplicaci\u00f3n. Agrupa las rutas relacionadas en un mismo controlador para mantener una estructura m\u00e1s organizada. Utiliza plugs para realizar tareas comunes como autenticaci\u00f3n y autorizaci\u00f3n en lugar de repetir c\u00f3digo en todas las acciones de tus controladores. Utiliza patrones de ruta para definir rutas din\u00e1micas y evitar tener que crear rutas para cada elemento de tu aplicaci\u00f3n. Utiliza la funci\u00f3n plug en tu controlador para ejecutar plugs espec\u00edficos antes de ciertas acciones, en lugar de utilizarlos en todas las acciones del controlador.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix_2/jr/vistas_y_templates/","text":"Vistas y templates en Phoenix Framework \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 En Phoenix Framework, las vistas y templates son elementos fundamentales para la creaci\u00f3n de aplicaciones web. Una vista es una representaci\u00f3n visual de los datos que se deben mostrar en una p\u00e1gina web, mientras que un template es un archivo que define la estructura y el contenido de una vista. En esencia, las vistas y templates son los encargados de convertir los datos que se generan en el backend en una p\u00e1gina web que pueda ser visualizada por el usuario. La separaci\u00f3n de la l\u00f3gica de negocio y la presentaci\u00f3n es una de las principales ventajas de utilizar vistas y templates en una aplicaci\u00f3n web, ya que permite un desarrollo m\u00e1s modular y mantenible. Palabras clave y su definici\u00f3n \u00b6 Vista: Representaci\u00f3n visual de los datos que se muestran en una p\u00e1gina web. Template: Archivo que define la estructura y contenido de una vista. Renderizar: Proceso de convertir datos en una p\u00e1gina web para su visualizaci\u00f3n. Layout: Plantilla base que define la estructura com\u00fan de todas las vistas de una aplicaci\u00f3n web. Partial: Porci\u00f3n de c\u00f3digo HTML reutilizable que se puede incluir en diferentes vistas. EEx: Embedded Elixir, lenguaje de plantillas utilizado en Phoenix Framework. Plugs: Funciones que se ejecutan antes o despu\u00e9s de la renderizaci\u00f3n de una vista para realizar tareas adicionales. Helpers: Funciones auxiliares que se pueden utilizar en las vistas para simplificar su c\u00f3digo. Preguntas de repaso \u00b6 \u00bfQu\u00e9 son las vistas y templates en Phoenix Framework? \u00bfCu\u00e1l es la diferencia entre una vista y un template? \u00bfPor qu\u00e9 es importante separar la l\u00f3gica de negocio y la presentaci\u00f3n en una aplicaci\u00f3n web? \u00bfQu\u00e9 es un layout en Phoenix Framework? \u00bfQu\u00e9 es un partial y para qu\u00e9 se utiliza? \u00bfQu\u00e9 es EEx? \u00bfQu\u00e9 son los plugs en Phoenix Framework? \u00bfCu\u00e1l es la funci\u00f3n de los helpers en las vistas? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 Ejemplo de una vista b\u00e1sica en Phoenix Framework: defmodule MyApp.HomeView do use MyApp.Web , :view def render ( \"index.html\" , assigns ) do ~H \"\"\" <html> <head> <title>Bienvenido a mi aplicaci\u00f3n</title> </head> <body> <h1>Hola <%= assigns[:name] %></h1> </body> </html> \"\"\" end end Ejemplo de un template en Phoenix Framework: <!DOCTYPE html> < html > < head > < title > < %= @title %> - Mi aplicaci\u00f3n </ title > </ head > < body > < %= render @view_module, @view_template, assigns %> </ body > </ html > Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una vista llamada \"about\" que muestre informaci\u00f3n sobre tu aplicaci\u00f3n. Crea un template llamado \"default\" que sirva como layout base para todas las vistas de tu aplicaci\u00f3n. Utiliza un partial para mostrar un men\u00fa de navegaci\u00f3n en todas las vistas de tu aplicaci\u00f3n. Crea un helper que formatee una fecha en un formato espec\u00edfico y \u00fasalo en una vista. Crea un plug que redirija a los usuarios a la p\u00e1gina de inicio si intentan acceder a una vista sin estar autenticados. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza un layout base para todas las vistas de tu aplicaci\u00f3n para mantener una estructura consistente. Divide tus vistas en archivos separados para una mayor organizaci\u00f3n. Utiliza partials para reutilizar c\u00f3digo HTML en diferentes vistas. Utiliza helpers para simplificar el c\u00f3digo de tus vistas y evitar la repetici\u00f3n. Utiliza plugs para ejecutar tareas adicionales antes o despu\u00e9s de la renderizaci\u00f3n de una vista. Utiliza EEx para escribir plantillas m\u00e1s legibles y din\u00e1micas. Utiliza la convenci\u00f3n de nombres de Phoenix para tus vistas y templates (ej: \"home_view.ex\" y \"home.html.eex\"). Utiliza los m\u00f3dulos de ayuda en Phoenix para obtener m\u00e1s informaci\u00f3n sobre c\u00f3mo trabajar con vistas y templates.","title":"Vistas y templates en Phoenix Framework"},{"location":"phoenix_2/jr/vistas_y_templates/#vistas-y-templates-en-phoenix-framework","text":"","title":"Vistas y templates en Phoenix Framework"},{"location":"phoenix_2/jr/vistas_y_templates/#explicacion-teorica","text":"En Phoenix Framework, las vistas y templates son elementos fundamentales para la creaci\u00f3n de aplicaciones web. Una vista es una representaci\u00f3n visual de los datos que se deben mostrar en una p\u00e1gina web, mientras que un template es un archivo que define la estructura y el contenido de una vista. En esencia, las vistas y templates son los encargados de convertir los datos que se generan en el backend en una p\u00e1gina web que pueda ser visualizada por el usuario. La separaci\u00f3n de la l\u00f3gica de negocio y la presentaci\u00f3n es una de las principales ventajas de utilizar vistas y templates en una aplicaci\u00f3n web, ya que permite un desarrollo m\u00e1s modular y mantenible.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix_2/jr/vistas_y_templates/#palabras-clave-y-su-definicion","text":"Vista: Representaci\u00f3n visual de los datos que se muestran en una p\u00e1gina web. Template: Archivo que define la estructura y contenido de una vista. Renderizar: Proceso de convertir datos en una p\u00e1gina web para su visualizaci\u00f3n. Layout: Plantilla base que define la estructura com\u00fan de todas las vistas de una aplicaci\u00f3n web. Partial: Porci\u00f3n de c\u00f3digo HTML reutilizable que se puede incluir en diferentes vistas. EEx: Embedded Elixir, lenguaje de plantillas utilizado en Phoenix Framework. Plugs: Funciones que se ejecutan antes o despu\u00e9s de la renderizaci\u00f3n de una vista para realizar tareas adicionales. Helpers: Funciones auxiliares que se pueden utilizar en las vistas para simplificar su c\u00f3digo.","title":"Palabras clave y su definici\u00f3n"},{"location":"phoenix_2/jr/vistas_y_templates/#preguntas-de-repaso","text":"\u00bfQu\u00e9 son las vistas y templates en Phoenix Framework? \u00bfCu\u00e1l es la diferencia entre una vista y un template? \u00bfPor qu\u00e9 es importante separar la l\u00f3gica de negocio y la presentaci\u00f3n en una aplicaci\u00f3n web? \u00bfQu\u00e9 es un layout en Phoenix Framework? \u00bfQu\u00e9 es un partial y para qu\u00e9 se utiliza? \u00bfQu\u00e9 es EEx? \u00bfQu\u00e9 son los plugs en Phoenix Framework? \u00bfCu\u00e1l es la funci\u00f3n de los helpers en las vistas?","title":"Preguntas de repaso"},{"location":"phoenix_2/jr/vistas_y_templates/#ejemplos-de-codigo-en-phoenix-framework","text":"Ejemplo de una vista b\u00e1sica en Phoenix Framework: defmodule MyApp.HomeView do use MyApp.Web , :view def render ( \"index.html\" , assigns ) do ~H \"\"\" <html> <head> <title>Bienvenido a mi aplicaci\u00f3n</title> </head> <body> <h1>Hola <%= assigns[:name] %></h1> </body> </html> \"\"\" end end Ejemplo de un template en Phoenix Framework: <!DOCTYPE html> < html > < head > < title > < %= @title %> - Mi aplicaci\u00f3n </ title > </ head > < body > < %= render @view_module, @view_template, assigns %> </ body > </ html >","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix_2/jr/vistas_y_templates/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una vista llamada \"about\" que muestre informaci\u00f3n sobre tu aplicaci\u00f3n. Crea un template llamado \"default\" que sirva como layout base para todas las vistas de tu aplicaci\u00f3n. Utiliza un partial para mostrar un men\u00fa de navegaci\u00f3n en todas las vistas de tu aplicaci\u00f3n. Crea un helper que formatee una fecha en un formato espec\u00edfico y \u00fasalo en una vista. Crea un plug que redirija a los usuarios a la p\u00e1gina de inicio si intentan acceder a una vista sin estar autenticados.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"phoenix_2/jr/vistas_y_templates/#consejos-o-mejores-practicas","text":"Utiliza un layout base para todas las vistas de tu aplicaci\u00f3n para mantener una estructura consistente. Divide tus vistas en archivos separados para una mayor organizaci\u00f3n. Utiliza partials para reutilizar c\u00f3digo HTML en diferentes vistas. Utiliza helpers para simplificar el c\u00f3digo de tus vistas y evitar la repetici\u00f3n. Utiliza plugs para ejecutar tareas adicionales antes o despu\u00e9s de la renderizaci\u00f3n de una vista. Utiliza EEx para escribir plantillas m\u00e1s legibles y din\u00e1micas. Utiliza la convenci\u00f3n de nombres de Phoenix para tus vistas y templates (ej: \"home_view.ex\" y \"home.html.eex\"). Utiliza los m\u00f3dulos de ayuda en Phoenix para obtener m\u00e1s informaci\u00f3n sobre c\u00f3mo trabajar con vistas y templates.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix_2/mid/","text":"Phoenix 2 - Nivel Mid \u00b6 \u00a1Bienvenido/a al nivel Mid del segundo curso de Phoenix! Conoce caracter\u00edsticas adicionales y pr\u00e1cticas m\u00e1s avanzadas: APIs en Phoenix Endpoints y canales Middlewares y Plug Seguridad en Phoenix Pruebas en Phoenix Optimizaci\u00f3n de rendimiento Integraci\u00f3n con otras tecnolog\u00edas Revisa phoenix_mid.json para la lista completa.","title":"Phoenix 2 - Nivel Mid"},{"location":"phoenix_2/mid/#phoenix-2-nivel-mid","text":"\u00a1Bienvenido/a al nivel Mid del segundo curso de Phoenix! Conoce caracter\u00edsticas adicionales y pr\u00e1cticas m\u00e1s avanzadas: APIs en Phoenix Endpoints y canales Middlewares y Plug Seguridad en Phoenix Pruebas en Phoenix Optimizaci\u00f3n de rendimiento Integraci\u00f3n con otras tecnolog\u00edas Revisa phoenix_mid.json para la lista completa.","title":"Phoenix 2 - Nivel Mid"},{"location":"phoenix_2/mid/apis_en_phoenix/","text":"APIs en Phoenix \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En la era actual de la tecnolog\u00eda, las APIs (Application Programming Interfaces) juegan un papel crucial en la interconexi\u00f3n de aplicaciones y sistemas. Las APIs permiten una comunicaci\u00f3n eficiente entre diferentes plataformas, lo que facilita el intercambio de datos y la creaci\u00f3n de nuevas funcionalidades. En este m\u00f3dulo, aprender\u00e1s c\u00f3mo crear y documentar una API en Phoenix Framework, un popular framework de desarrollo web para el lenguaje de programaci\u00f3n Elixir. Aprender\u00e1s a utilizar herramientas como Swagger y ExDoc para documentar y probar tu API, lo que te ayudar\u00e1 a garantizar su calidad y facilitar\u00e1 su uso por parte de otros desarrolladores. Palabras clave y definiciones \u00b6 API: Interfaz de programaci\u00f3n de aplicaciones, un conjunto de reglas y protocolos que permiten la comunicaci\u00f3n entre diferentes aplicaciones o sistemas. Phoenix Framework: Un framework de desarrollo web para Elixir que sigue el patr\u00f3n de arquitectura MVC (Modelo-Vista-Controlador) y es conocido por su rendimiento y escalabilidad. Swagger: Una herramienta de c\u00f3digo abierto para documentar y probar APIs de forma sencilla y automatizada. ExDoc: Una herramienta de documentaci\u00f3n para Elixir que permite generar documentaci\u00f3n en formato HTML y Markdown a partir del c\u00f3digo fuente. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es una API y para qu\u00e9 se utiliza? \u00bfQu\u00e9 es Phoenix Framework y cu\u00e1l es su arquitectura? \u00bfQu\u00e9 es Swagger y c\u00f3mo puede ayudar a documentar una API? \u00bfQu\u00e9 es ExDoc y c\u00f3mo se utiliza en Phoenix Framework? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 A continuaci\u00f3n, se muestra un ejemplo de c\u00f3mo se puede definir una API en Phoenix Framework utilizando el m\u00f3dulo plug : defmodule MyApp.API do use Plug.Router # Definir ruta para obtener una lista de usuarios get \"/users\" do users = MyApp.User . list_users () json ( conn , users ) end # Definir ruta para crear un nuevo usuario post \"/users\" do user_params = Plug.Conn . fetch_params ( conn ) case MyApp.User . create_user ( user_params ) do { :ok , user } -> conn |> put_resp_content_type ( \"application/json\" ) |> send_resp ( 201 , Poison . encode! ( user )) { :error , errors } -> conn |> put_resp_content_type ( \"application/json\" ) |> send_resp ( 422 , Poison . encode! ( errors )) end end end En el ejemplo anterior, se definen dos rutas: una para obtener una lista de usuarios y otra para crear un nuevo usuario. Se utiliza el m\u00f3dulo plug para manejar las solicitudes HTTP y se devuelve una respuesta en formato JSON utilizando la librer\u00eda Poison . Ejercicios pr\u00e1cticos \u00b6 Crea una nueva ruta en tu API de Phoenix para obtener un usuario espec\u00edfico a partir de su ID. Utiliza Swagger para documentar tu API y probar las distintas rutas. Implementa una funci\u00f3n en tu API que permita actualizar la informaci\u00f3n de un usuario existente. Utiliza ExDoc para generar documentaci\u00f3n a partir del c\u00f3digo fuente de tu API. Consejos y mejores pr\u00e1cticas \u00b6 Utiliza un enfoque RESTful al dise\u00f1ar tu API, lo que facilitar\u00e1 su uso y comprensi\u00f3n por parte de otros desarrolladores. Aseg\u00farate de documentar correctamente cada ruta, incluyendo los par\u00e1metros esperados y las respuestas posibles. Utiliza herramientas como Swagger y ExDoc para automatizar la documentaci\u00f3n y pruebas de tu API, lo que te ahorrar\u00e1 tiempo y ayudar\u00e1 a mantener la consistencia. Considera la seguridad al dise\u00f1ar tu API, implementando autenticaci\u00f3n y autorizaci\u00f3n adecuadas para proteger los datos sensibles. Realiza pruebas exhaustivas en tu API antes de publicarla, asegur\u00e1ndote de que funcione correctamente en diferentes escenarios y con distintos tipos de solicitudes. Conclusi\u00f3n \u00b6 En este m\u00f3dulo, has aprendido c\u00f3mo crear y documentar una API en Phoenix Framework utilizando herramientas como Swagger y ExDoc. Ahora tienes los conocimientos necesarios para desarrollar una API robusta y bien documentada, lo que te permitir\u00e1 conectar tus aplicaciones con otras plataformas y promover su uso por parte de otros desarrolladores. Sigue practicando y explorando nuevas herramientas y t\u00e9cnicas para mejorar tus habilidades en el desarrollo de APIs en Phoenix.","title":"APIs en Phoenix"},{"location":"phoenix_2/mid/apis_en_phoenix/#apis-en-phoenix","text":"","title":"APIs en Phoenix"},{"location":"phoenix_2/mid/apis_en_phoenix/#descripcion-del-modulo","text":"En la era actual de la tecnolog\u00eda, las APIs (Application Programming Interfaces) juegan un papel crucial en la interconexi\u00f3n de aplicaciones y sistemas. Las APIs permiten una comunicaci\u00f3n eficiente entre diferentes plataformas, lo que facilita el intercambio de datos y la creaci\u00f3n de nuevas funcionalidades. En este m\u00f3dulo, aprender\u00e1s c\u00f3mo crear y documentar una API en Phoenix Framework, un popular framework de desarrollo web para el lenguaje de programaci\u00f3n Elixir. Aprender\u00e1s a utilizar herramientas como Swagger y ExDoc para documentar y probar tu API, lo que te ayudar\u00e1 a garantizar su calidad y facilitar\u00e1 su uso por parte de otros desarrolladores.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"phoenix_2/mid/apis_en_phoenix/#palabras-clave-y-definiciones","text":"API: Interfaz de programaci\u00f3n de aplicaciones, un conjunto de reglas y protocolos que permiten la comunicaci\u00f3n entre diferentes aplicaciones o sistemas. Phoenix Framework: Un framework de desarrollo web para Elixir que sigue el patr\u00f3n de arquitectura MVC (Modelo-Vista-Controlador) y es conocido por su rendimiento y escalabilidad. Swagger: Una herramienta de c\u00f3digo abierto para documentar y probar APIs de forma sencilla y automatizada. ExDoc: Una herramienta de documentaci\u00f3n para Elixir que permite generar documentaci\u00f3n en formato HTML y Markdown a partir del c\u00f3digo fuente.","title":"Palabras clave y definiciones"},{"location":"phoenix_2/mid/apis_en_phoenix/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es una API y para qu\u00e9 se utiliza? \u00bfQu\u00e9 es Phoenix Framework y cu\u00e1l es su arquitectura? \u00bfQu\u00e9 es Swagger y c\u00f3mo puede ayudar a documentar una API? \u00bfQu\u00e9 es ExDoc y c\u00f3mo se utiliza en Phoenix Framework?","title":"Preguntas de repaso"},{"location":"phoenix_2/mid/apis_en_phoenix/#ejemplos-de-codigo-en-phoenix-framework","text":"A continuaci\u00f3n, se muestra un ejemplo de c\u00f3mo se puede definir una API en Phoenix Framework utilizando el m\u00f3dulo plug : defmodule MyApp.API do use Plug.Router # Definir ruta para obtener una lista de usuarios get \"/users\" do users = MyApp.User . list_users () json ( conn , users ) end # Definir ruta para crear un nuevo usuario post \"/users\" do user_params = Plug.Conn . fetch_params ( conn ) case MyApp.User . create_user ( user_params ) do { :ok , user } -> conn |> put_resp_content_type ( \"application/json\" ) |> send_resp ( 201 , Poison . encode! ( user )) { :error , errors } -> conn |> put_resp_content_type ( \"application/json\" ) |> send_resp ( 422 , Poison . encode! ( errors )) end end end En el ejemplo anterior, se definen dos rutas: una para obtener una lista de usuarios y otra para crear un nuevo usuario. Se utiliza el m\u00f3dulo plug para manejar las solicitudes HTTP y se devuelve una respuesta en formato JSON utilizando la librer\u00eda Poison .","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix_2/mid/apis_en_phoenix/#ejercicios-practicos","text":"Crea una nueva ruta en tu API de Phoenix para obtener un usuario espec\u00edfico a partir de su ID. Utiliza Swagger para documentar tu API y probar las distintas rutas. Implementa una funci\u00f3n en tu API que permita actualizar la informaci\u00f3n de un usuario existente. Utiliza ExDoc para generar documentaci\u00f3n a partir del c\u00f3digo fuente de tu API.","title":"Ejercicios pr\u00e1cticos"},{"location":"phoenix_2/mid/apis_en_phoenix/#consejos-y-mejores-practicas","text":"Utiliza un enfoque RESTful al dise\u00f1ar tu API, lo que facilitar\u00e1 su uso y comprensi\u00f3n por parte de otros desarrolladores. Aseg\u00farate de documentar correctamente cada ruta, incluyendo los par\u00e1metros esperados y las respuestas posibles. Utiliza herramientas como Swagger y ExDoc para automatizar la documentaci\u00f3n y pruebas de tu API, lo que te ahorrar\u00e1 tiempo y ayudar\u00e1 a mantener la consistencia. Considera la seguridad al dise\u00f1ar tu API, implementando autenticaci\u00f3n y autorizaci\u00f3n adecuadas para proteger los datos sensibles. Realiza pruebas exhaustivas en tu API antes de publicarla, asegur\u00e1ndote de que funcione correctamente en diferentes escenarios y con distintos tipos de solicitudes.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"phoenix_2/mid/apis_en_phoenix/#conclusion","text":"En este m\u00f3dulo, has aprendido c\u00f3mo crear y documentar una API en Phoenix Framework utilizando herramientas como Swagger y ExDoc. Ahora tienes los conocimientos necesarios para desarrollar una API robusta y bien documentada, lo que te permitir\u00e1 conectar tus aplicaciones con otras plataformas y promover su uso por parte de otros desarrolladores. Sigue practicando y explorando nuevas herramientas y t\u00e9cnicas para mejorar tus habilidades en el desarrollo de APIs en Phoenix.","title":"Conclusi\u00f3n"},{"location":"phoenix_2/mid/endpoints_y_canales/","text":"Endpoints y canales en Phoenix Framework \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En este m\u00f3dulo aprender\u00e1s sobre los endpoints y canales en Phoenix Framework, una herramienta poderosa para construir aplicaciones en tiempo real. A trav\u00e9s de la teor\u00eda y ejemplos pr\u00e1cticos, entender\u00e1s c\u00f3mo funcionan y c\u00f3mo utilizarlos en tus proyectos. Explicaci\u00f3n te\u00f3rica \u00b6 Los endpoints y canales son dos conceptos importantes en Phoenix Framework. Los endpoints son responsables de manejar las solicitudes HTTP y enviar las respuestas correspondientes. Por otro lado, los canales son una forma de establecer una conexi\u00f3n bidireccional entre el servidor y el cliente, lo que permite la comunicaci\u00f3n en tiempo real. Los endpoints en Phoenix se definen en el archivo router.ex y se encargan de analizar las solicitudes entrantes y enrutarlas a la funci\u00f3n correspondiente. Estas funciones pueden ser controladores, vistas o canales. Los endpoints tambi\u00e9n se utilizan para configurar la autenticaci\u00f3n y autorizaci\u00f3n en la aplicaci\u00f3n. Los canales, por otro lado, son una forma de establecer una conexi\u00f3n persistente entre el servidor y el cliente. Esto se logra a trav\u00e9s del protocolo WebSocket, que permite una comunicaci\u00f3n bidireccional entre el navegador y el servidor. Los canales pueden ser utilizados para enviar y recibir mensajes en tiempo real, lo que los hace ideales para aplicaciones de chat, notificaciones en tiempo real, juegos en l\u00ednea, entre otros. Para establecer una conexi\u00f3n de canal en Phoenix, se debe definir un m\u00f3dulo de canal que implemente la funci\u00f3n handle_in para recibir mensajes del cliente y la funci\u00f3n handle_out para enviar mensajes al cliente. Adem\u00e1s, se debe definir un m\u00f3dulo de transporte que especifica c\u00f3mo se enviar\u00e1n y recibir\u00e1n los mensajes, como por ejemplo en formato JSON. Palabras clave y definiciones \u00b6 Endpoints: son responsables de manejar las solicitudes HTTP y enviar las respuestas correspondientes en Phoenix Framework. Canales: son una forma de establecer una conexi\u00f3n bidireccional entre el servidor y el cliente, permitiendo la comunicaci\u00f3n en tiempo real. Autenticaci\u00f3n: proceso de verificaci\u00f3n de identidad de un usuario en una aplicaci\u00f3n. Autorizaci\u00f3n: proceso de otorgar permisos a un usuario para acceder a ciertas partes de una aplicaci\u00f3n. Preguntas de repaso \u00b6 \u00bfQu\u00e9 son los endpoints y cu\u00e1l es su funci\u00f3n en Phoenix Framework? \u00bfQu\u00e9 es un canal y para qu\u00e9 se utiliza en una aplicaci\u00f3n Phoenix? \u00bfC\u00f3mo se establece una conexi\u00f3n de canal en Phoenix? \u00bfQu\u00e9 es la autenticaci\u00f3n y autorizaci\u00f3n en una aplicaci\u00f3n web? \u00bfCu\u00e1l es la diferencia entre una solicitud HTTP y una conexi\u00f3n de canal en Phoenix? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 Definici\u00f3n de un endpoint en el archivo router.ex \u00b6 # en router.ex scope \"/\" , MyApp do pipe_through :browser # definir un endpoint para la p\u00e1gina de inicio get \"/\" , PageController , :index # definir un endpoint para una ruta con par\u00e1metros get \"/users/:id\" , UserController , :show end Definici\u00f3n de un m\u00f3dulo de canal en Phoenix \u00b6 defmodule MyApp.ChatChannel do use Phoenix.Channel # se define la funci\u00f3n handle_in para recibir mensajes del cliente def handle_in ( \"new_msg\" , %{ \"body\" => body }, socket ) do broadcast! socket , \"new_msg\" , %{ body : body } { :noreply , socket } end # se define la funci\u00f3n handle_out para enviar mensajes al cliente def handle_out ( \"new_msg\" , %{ body : body }, socket ) do push socket , \"new_msg\" , %{ body : body } { :noreply , socket } end end Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea un nuevo proyecto Phoenix y agrega un endpoint para la p\u00e1gina de inicio. Define un canal para una aplicaci\u00f3n de chat que permita enviar y recibir mensajes en tiempo real. Utiliza la autenticaci\u00f3n y autorizaci\u00f3n en tu aplicaci\u00f3n para restringir el acceso a ciertas rutas. Agrega un m\u00f3dulo de transporte a tu canal para especificar el formato de los mensajes enviados y recibidos. Implementa la funcionalidad de env\u00edo de archivos en tu canal para que los usuarios puedan compartir im\u00e1genes y otros archivos en el chat. Consejos y mejores pr\u00e1cticas \u00b6 Utiliza endpoints para manejar las solicitudes HTTP y canales para aplicaciones en tiempo real. Planifica bien la estructura de tus endpoints y canales para facilitar su mantenimiento y escalabilidad. Utiliza la autenticaci\u00f3n y autorizaci\u00f3n para proteger tu aplicaci\u00f3n de posibles vulnerabilidades. Aprovecha las funciones de transporte para especificar el formato de los mensajes enviados y recibidos en tus canales. Experimenta con diferentes funcionalidades en tus canales, como el env\u00edo de archivos o la integraci\u00f3n con servicios externos, para mejorar la experiencia de usuario en tu aplicaci\u00f3n. Conclusiones \u00b6 Los endpoints y canales son dos conceptos esenciales en Phoenix Framework para construir aplicaciones web en tiempo real. Con este m\u00f3dulo, has aprendido c\u00f3mo funcionan y c\u00f3mo utilizarlos en tus proyectos. Recuerda planificar bien la estructura de tus endpoints y canales, y aprovecha las funcionalidades que ofrecen para mejorar la experiencia de usuario en tu aplicaci\u00f3n. \u00a1Sigue explorando y experimentando con Phoenix para construir aplicaciones web poderosas y escalables!","title":"Endpoints y canales en Phoenix Framework"},{"location":"phoenix_2/mid/endpoints_y_canales/#endpoints-y-canales-en-phoenix-framework","text":"","title":"Endpoints y canales en Phoenix Framework"},{"location":"phoenix_2/mid/endpoints_y_canales/#descripcion-del-modulo","text":"En este m\u00f3dulo aprender\u00e1s sobre los endpoints y canales en Phoenix Framework, una herramienta poderosa para construir aplicaciones en tiempo real. A trav\u00e9s de la teor\u00eda y ejemplos pr\u00e1cticos, entender\u00e1s c\u00f3mo funcionan y c\u00f3mo utilizarlos en tus proyectos.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"phoenix_2/mid/endpoints_y_canales/#explicacion-teorica","text":"Los endpoints y canales son dos conceptos importantes en Phoenix Framework. Los endpoints son responsables de manejar las solicitudes HTTP y enviar las respuestas correspondientes. Por otro lado, los canales son una forma de establecer una conexi\u00f3n bidireccional entre el servidor y el cliente, lo que permite la comunicaci\u00f3n en tiempo real. Los endpoints en Phoenix se definen en el archivo router.ex y se encargan de analizar las solicitudes entrantes y enrutarlas a la funci\u00f3n correspondiente. Estas funciones pueden ser controladores, vistas o canales. Los endpoints tambi\u00e9n se utilizan para configurar la autenticaci\u00f3n y autorizaci\u00f3n en la aplicaci\u00f3n. Los canales, por otro lado, son una forma de establecer una conexi\u00f3n persistente entre el servidor y el cliente. Esto se logra a trav\u00e9s del protocolo WebSocket, que permite una comunicaci\u00f3n bidireccional entre el navegador y el servidor. Los canales pueden ser utilizados para enviar y recibir mensajes en tiempo real, lo que los hace ideales para aplicaciones de chat, notificaciones en tiempo real, juegos en l\u00ednea, entre otros. Para establecer una conexi\u00f3n de canal en Phoenix, se debe definir un m\u00f3dulo de canal que implemente la funci\u00f3n handle_in para recibir mensajes del cliente y la funci\u00f3n handle_out para enviar mensajes al cliente. Adem\u00e1s, se debe definir un m\u00f3dulo de transporte que especifica c\u00f3mo se enviar\u00e1n y recibir\u00e1n los mensajes, como por ejemplo en formato JSON.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix_2/mid/endpoints_y_canales/#palabras-clave-y-definiciones","text":"Endpoints: son responsables de manejar las solicitudes HTTP y enviar las respuestas correspondientes en Phoenix Framework. Canales: son una forma de establecer una conexi\u00f3n bidireccional entre el servidor y el cliente, permitiendo la comunicaci\u00f3n en tiempo real. Autenticaci\u00f3n: proceso de verificaci\u00f3n de identidad de un usuario en una aplicaci\u00f3n. Autorizaci\u00f3n: proceso de otorgar permisos a un usuario para acceder a ciertas partes de una aplicaci\u00f3n.","title":"Palabras clave y definiciones"},{"location":"phoenix_2/mid/endpoints_y_canales/#preguntas-de-repaso","text":"\u00bfQu\u00e9 son los endpoints y cu\u00e1l es su funci\u00f3n en Phoenix Framework? \u00bfQu\u00e9 es un canal y para qu\u00e9 se utiliza en una aplicaci\u00f3n Phoenix? \u00bfC\u00f3mo se establece una conexi\u00f3n de canal en Phoenix? \u00bfQu\u00e9 es la autenticaci\u00f3n y autorizaci\u00f3n en una aplicaci\u00f3n web? \u00bfCu\u00e1l es la diferencia entre una solicitud HTTP y una conexi\u00f3n de canal en Phoenix?","title":"Preguntas de repaso"},{"location":"phoenix_2/mid/endpoints_y_canales/#ejemplos-de-codigo-en-phoenix-framework","text":"","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix_2/mid/endpoints_y_canales/#definicion-de-un-endpoint-en-el-archivo-routerex","text":"# en router.ex scope \"/\" , MyApp do pipe_through :browser # definir un endpoint para la p\u00e1gina de inicio get \"/\" , PageController , :index # definir un endpoint para una ruta con par\u00e1metros get \"/users/:id\" , UserController , :show end","title":"Definici\u00f3n de un endpoint en el archivo router.ex"},{"location":"phoenix_2/mid/endpoints_y_canales/#definicion-de-un-modulo-de-canal-en-phoenix","text":"defmodule MyApp.ChatChannel do use Phoenix.Channel # se define la funci\u00f3n handle_in para recibir mensajes del cliente def handle_in ( \"new_msg\" , %{ \"body\" => body }, socket ) do broadcast! socket , \"new_msg\" , %{ body : body } { :noreply , socket } end # se define la funci\u00f3n handle_out para enviar mensajes al cliente def handle_out ( \"new_msg\" , %{ body : body }, socket ) do push socket , \"new_msg\" , %{ body : body } { :noreply , socket } end end","title":"Definici\u00f3n de un m\u00f3dulo de canal en Phoenix"},{"location":"phoenix_2/mid/endpoints_y_canales/#ejercicios-practicos-con-instrucciones-claras","text":"Crea un nuevo proyecto Phoenix y agrega un endpoint para la p\u00e1gina de inicio. Define un canal para una aplicaci\u00f3n de chat que permita enviar y recibir mensajes en tiempo real. Utiliza la autenticaci\u00f3n y autorizaci\u00f3n en tu aplicaci\u00f3n para restringir el acceso a ciertas rutas. Agrega un m\u00f3dulo de transporte a tu canal para especificar el formato de los mensajes enviados y recibidos. Implementa la funcionalidad de env\u00edo de archivos en tu canal para que los usuarios puedan compartir im\u00e1genes y otros archivos en el chat.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"phoenix_2/mid/endpoints_y_canales/#consejos-y-mejores-practicas","text":"Utiliza endpoints para manejar las solicitudes HTTP y canales para aplicaciones en tiempo real. Planifica bien la estructura de tus endpoints y canales para facilitar su mantenimiento y escalabilidad. Utiliza la autenticaci\u00f3n y autorizaci\u00f3n para proteger tu aplicaci\u00f3n de posibles vulnerabilidades. Aprovecha las funciones de transporte para especificar el formato de los mensajes enviados y recibidos en tus canales. Experimenta con diferentes funcionalidades en tus canales, como el env\u00edo de archivos o la integraci\u00f3n con servicios externos, para mejorar la experiencia de usuario en tu aplicaci\u00f3n.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"phoenix_2/mid/endpoints_y_canales/#conclusiones","text":"Los endpoints y canales son dos conceptos esenciales en Phoenix Framework para construir aplicaciones web en tiempo real. Con este m\u00f3dulo, has aprendido c\u00f3mo funcionan y c\u00f3mo utilizarlos en tus proyectos. Recuerda planificar bien la estructura de tus endpoints y canales, y aprovecha las funcionalidades que ofrecen para mejorar la experiencia de usuario en tu aplicaci\u00f3n. \u00a1Sigue explorando y experimentando con Phoenix para construir aplicaciones web poderosas y escalables!","title":"Conclusiones"},{"location":"phoenix_2/mid/integraci%C3%B3n_con_otras_tecnolog%C3%ADas/","text":"Integraci\u00f3n con otras tecnolog\u00edas en Phoenix Framework \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En este m\u00f3dulo, aprenderemos c\u00f3mo integrar Phoenix Framework con otras tecnolog\u00edas para construir aplicaciones m\u00e1s robustas. Phoenix es una plataforma de desarrollo web escrita en el lenguaje de programaci\u00f3n Elixir, que se basa en el paradigma de programaci\u00f3n funcional y utiliza el patr\u00f3n de arquitectura de software Modelo-Vista-Controlador (MVC). Al integrar Phoenix con otras tecnolog\u00edas, podemos aprovechar sus fortalezas y crear aplicaciones m\u00e1s eficientes y escalables. Explicaci\u00f3n te\u00f3rica \u00b6 Phoenix es una plataforma altamente extensible gracias a su arquitectura basada en Plug y su sistema de enrutamiento flexible. Esto permite integrar f\u00e1cilmente otras tecnolog\u00edas en nuestra aplicaci\u00f3n de Phoenix. A continuaci\u00f3n, veremos algunas de las tecnolog\u00edas m\u00e1s comunes que se pueden integrar con Phoenix y c\u00f3mo hacerlo. React \u00b6 React es una biblioteca de JavaScript para construir interfaces de usuario. Es muy popular por su rendimiento y su capacidad para crear aplicaciones de una sola p\u00e1gina (SPA). Integrar React con Phoenix nos permite crear interfaces de usuario interactivas y din\u00e1micas en nuestra aplicaci\u00f3n web. Para hacerlo, podemos utilizar la biblioteca Phoenix LiveView, que nos permite renderizar componentes de React en nuestras vistas de Phoenix. GraphQL \u00b6 GraphQL es un lenguaje de consulta y una especificaci\u00f3n para APIs. Al integrar GraphQL con Phoenix, podemos crear una capa de API m\u00e1s eficiente y flexible para nuestra aplicaci\u00f3n. Esto nos permite obtener solo los datos que necesitamos en cada solicitud, en lugar de recibir una respuesta completa como lo har\u00edamos con una API REST tradicional. Para integrar GraphQL con Phoenix, podemos utilizar la biblioteca Absinthe, que facilita la creaci\u00f3n de esquemas y resolvers en Elixir. Elasticsearch \u00b6 Elasticsearch es un motor de b\u00fasqueda y an\u00e1lisis de texto completo. Al integrarlo con Phoenix, podemos agregar funciones de b\u00fasqueda avanzadas a nuestra aplicaci\u00f3n. Esto es especialmente \u00fatil para aplicaciones con grandes cantidades de datos, ya que Elasticsearch es altamente escalable y eficiente. Para integrar Elasticsearch con Phoenix, podemos utilizar la biblioteca Tirexs, que proporciona una capa de abstracci\u00f3n para interactuar con Elasticsearch en Elixir. Palabras clave y su definici\u00f3n \u00b6 Phoenix Framework: Una plataforma de desarrollo web escrita en Elixir, basada en el patr\u00f3n de arquitectura MVC y Plug. Integraci\u00f3n: La acci\u00f3n de combinar diferentes tecnolog\u00edas para crear una aplicaci\u00f3n m\u00e1s completa y eficiente. React: Una biblioteca de JavaScript para construir interfaces de usuario. GraphQL: Un lenguaje de consulta y una especificaci\u00f3n para APIs. Elasticsearch: Un motor de b\u00fasqueda y an\u00e1lisis de texto completo. Plug: Una especificaci\u00f3n y una biblioteca para construir aplicaciones web en Elixir. MVC: Modelo-Vista-Controlador, un patr\u00f3n de arquitectura de software para separar la l\u00f3gica de la aplicaci\u00f3n en tres componentes: modelo, vista y controlador. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es Phoenix Framework? \u00bfCu\u00e1l es la ventaja de integrar React con Phoenix? \u00bfQu\u00e9 es GraphQL y c\u00f3mo se integra con Phoenix? \u00bfQu\u00e9 es Elasticsearch y c\u00f3mo se puede integrar con Phoenix? \u00bfQu\u00e9 es Plug en el contexto de Phoenix Framework? \u00bfQu\u00e9 es el patr\u00f3n de arquitectura MVC y c\u00f3mo se aplica en Phoenix? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 Integraci\u00f3n de React con Phoenix LiveView \u00b6 En nuestro archivo de vista de Phoenix, podemos utilizar la funci\u00f3n live_render para renderizar un componente de React en nuestra vista: <%= live_render @conn , MyReactComponent , prop1 : @prop1 , prop2 : @prop2 %> Luego, en nuestro archivo de controlador, podemos definir el componente de React y sus propiedades: def index(conn, _params) do render(conn, \"index.html\", prop1: \"Valor 1\", prop2: \"Valor 2\" ) end Integraci\u00f3n de GraphQL con Absinthe \u00b6 Primero, debemos definir nuestro esquema de GraphQL en un archivo schema.ex : defmodule MyApp . Schema do use Absinthe . Schema query do field : users , list_of ( : user ) do resolve fn _args , _info -> MyApp . Users . get_users () end end end object : user do field : id , : id field : name , : string field : email , : string end end Luego, en nuestro archivo de enrutamiento, podemos definir una ruta para nuestra API GraphQL: forward \"/api\", Absinthe.Plug, schema: MyApp.Schema Integraci\u00f3n de Elasticsearch con Tirexs \u00b6 En nuestro archivo de modelo de Ecto, podemos definir un \u00edndice de Elasticsearch para nuestro modelo: defmodule MyApp . User do use Ecto . Schema use Tirexs . Ecto @es_index \"users_index\" schema \"users\" do field : name , : string field : email , : string end end Luego, en nuestro archivo de controlador, podemos realizar una consulta a Elasticsearch utilizando la biblioteca Tirexs: def index(conn, _params) do users = Tirexs.search(MyApp.User, %{query: %{match: %{name: \"John\"}}}) render(conn, \"index.html\", users: users) end Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Cree una aplicaci\u00f3n de Phoenix con una vista que renderice un componente de React. Implemente una API GraphQL en su aplicaci\u00f3n de Phoenix utilizando la biblioteca Absinthe. Agregue la funci\u00f3n de b\u00fasqueda de Elasticsearch a su aplicaci\u00f3n de Phoenix utilizando la biblioteca Tirexs. Consejos o mejores pr\u00e1cticas \u00b6 Al integrar tecnolog\u00edas con Phoenix, es importante tener en cuenta el rendimiento y la escalabilidad de la aplicaci\u00f3n. Aseg\u00farese de elegir tecnolog\u00edas que se complementen bien con Phoenix y que no afecten el rendimiento de la aplicaci\u00f3n. Utilice bibliotecas de terceros para facilitar la integraci\u00f3n de tecnolog\u00edas en su aplicaci\u00f3n de Phoenix. Aseg\u00farese de comprender bien c\u00f3mo funcionan las tecnolog\u00edas que est\u00e1 integrando con Phoenix. Esto le ayudar\u00e1 a solucionar problemas y mejorar su aplicaci\u00f3n en el futuro.","title":"Integraci\u00f3n con otras tecnolog\u00edas en Phoenix Framework"},{"location":"phoenix_2/mid/integraci%C3%B3n_con_otras_tecnolog%C3%ADas/#integracion-con-otras-tecnologias-en-phoenix-framework","text":"","title":"Integraci\u00f3n con otras tecnolog\u00edas en Phoenix Framework"},{"location":"phoenix_2/mid/integraci%C3%B3n_con_otras_tecnolog%C3%ADas/#descripcion-del-modulo","text":"En este m\u00f3dulo, aprenderemos c\u00f3mo integrar Phoenix Framework con otras tecnolog\u00edas para construir aplicaciones m\u00e1s robustas. Phoenix es una plataforma de desarrollo web escrita en el lenguaje de programaci\u00f3n Elixir, que se basa en el paradigma de programaci\u00f3n funcional y utiliza el patr\u00f3n de arquitectura de software Modelo-Vista-Controlador (MVC). Al integrar Phoenix con otras tecnolog\u00edas, podemos aprovechar sus fortalezas y crear aplicaciones m\u00e1s eficientes y escalables.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"phoenix_2/mid/integraci%C3%B3n_con_otras_tecnolog%C3%ADas/#explicacion-teorica","text":"Phoenix es una plataforma altamente extensible gracias a su arquitectura basada en Plug y su sistema de enrutamiento flexible. Esto permite integrar f\u00e1cilmente otras tecnolog\u00edas en nuestra aplicaci\u00f3n de Phoenix. A continuaci\u00f3n, veremos algunas de las tecnolog\u00edas m\u00e1s comunes que se pueden integrar con Phoenix y c\u00f3mo hacerlo.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix_2/mid/integraci%C3%B3n_con_otras_tecnolog%C3%ADas/#react","text":"React es una biblioteca de JavaScript para construir interfaces de usuario. Es muy popular por su rendimiento y su capacidad para crear aplicaciones de una sola p\u00e1gina (SPA). Integrar React con Phoenix nos permite crear interfaces de usuario interactivas y din\u00e1micas en nuestra aplicaci\u00f3n web. Para hacerlo, podemos utilizar la biblioteca Phoenix LiveView, que nos permite renderizar componentes de React en nuestras vistas de Phoenix.","title":"React"},{"location":"phoenix_2/mid/integraci%C3%B3n_con_otras_tecnolog%C3%ADas/#graphql","text":"GraphQL es un lenguaje de consulta y una especificaci\u00f3n para APIs. Al integrar GraphQL con Phoenix, podemos crear una capa de API m\u00e1s eficiente y flexible para nuestra aplicaci\u00f3n. Esto nos permite obtener solo los datos que necesitamos en cada solicitud, en lugar de recibir una respuesta completa como lo har\u00edamos con una API REST tradicional. Para integrar GraphQL con Phoenix, podemos utilizar la biblioteca Absinthe, que facilita la creaci\u00f3n de esquemas y resolvers en Elixir.","title":"GraphQL"},{"location":"phoenix_2/mid/integraci%C3%B3n_con_otras_tecnolog%C3%ADas/#elasticsearch","text":"Elasticsearch es un motor de b\u00fasqueda y an\u00e1lisis de texto completo. Al integrarlo con Phoenix, podemos agregar funciones de b\u00fasqueda avanzadas a nuestra aplicaci\u00f3n. Esto es especialmente \u00fatil para aplicaciones con grandes cantidades de datos, ya que Elasticsearch es altamente escalable y eficiente. Para integrar Elasticsearch con Phoenix, podemos utilizar la biblioteca Tirexs, que proporciona una capa de abstracci\u00f3n para interactuar con Elasticsearch en Elixir.","title":"Elasticsearch"},{"location":"phoenix_2/mid/integraci%C3%B3n_con_otras_tecnolog%C3%ADas/#palabras-clave-y-su-definicion","text":"Phoenix Framework: Una plataforma de desarrollo web escrita en Elixir, basada en el patr\u00f3n de arquitectura MVC y Plug. Integraci\u00f3n: La acci\u00f3n de combinar diferentes tecnolog\u00edas para crear una aplicaci\u00f3n m\u00e1s completa y eficiente. React: Una biblioteca de JavaScript para construir interfaces de usuario. GraphQL: Un lenguaje de consulta y una especificaci\u00f3n para APIs. Elasticsearch: Un motor de b\u00fasqueda y an\u00e1lisis de texto completo. Plug: Una especificaci\u00f3n y una biblioteca para construir aplicaciones web en Elixir. MVC: Modelo-Vista-Controlador, un patr\u00f3n de arquitectura de software para separar la l\u00f3gica de la aplicaci\u00f3n en tres componentes: modelo, vista y controlador.","title":"Palabras clave y su definici\u00f3n"},{"location":"phoenix_2/mid/integraci%C3%B3n_con_otras_tecnolog%C3%ADas/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Phoenix Framework? \u00bfCu\u00e1l es la ventaja de integrar React con Phoenix? \u00bfQu\u00e9 es GraphQL y c\u00f3mo se integra con Phoenix? \u00bfQu\u00e9 es Elasticsearch y c\u00f3mo se puede integrar con Phoenix? \u00bfQu\u00e9 es Plug en el contexto de Phoenix Framework? \u00bfQu\u00e9 es el patr\u00f3n de arquitectura MVC y c\u00f3mo se aplica en Phoenix?","title":"Preguntas de repaso"},{"location":"phoenix_2/mid/integraci%C3%B3n_con_otras_tecnolog%C3%ADas/#ejemplos-de-codigo-en-phoenix-framework","text":"","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix_2/mid/integraci%C3%B3n_con_otras_tecnolog%C3%ADas/#integracion-de-react-con-phoenix-liveview","text":"En nuestro archivo de vista de Phoenix, podemos utilizar la funci\u00f3n live_render para renderizar un componente de React en nuestra vista: <%= live_render @conn , MyReactComponent , prop1 : @prop1 , prop2 : @prop2 %> Luego, en nuestro archivo de controlador, podemos definir el componente de React y sus propiedades: def index(conn, _params) do render(conn, \"index.html\", prop1: \"Valor 1\", prop2: \"Valor 2\" ) end","title":"Integraci\u00f3n de React con Phoenix LiveView"},{"location":"phoenix_2/mid/integraci%C3%B3n_con_otras_tecnolog%C3%ADas/#integracion-de-graphql-con-absinthe","text":"Primero, debemos definir nuestro esquema de GraphQL en un archivo schema.ex : defmodule MyApp . Schema do use Absinthe . Schema query do field : users , list_of ( : user ) do resolve fn _args , _info -> MyApp . Users . get_users () end end end object : user do field : id , : id field : name , : string field : email , : string end end Luego, en nuestro archivo de enrutamiento, podemos definir una ruta para nuestra API GraphQL: forward \"/api\", Absinthe.Plug, schema: MyApp.Schema","title":"Integraci\u00f3n de GraphQL con Absinthe"},{"location":"phoenix_2/mid/integraci%C3%B3n_con_otras_tecnolog%C3%ADas/#integracion-de-elasticsearch-con-tirexs","text":"En nuestro archivo de modelo de Ecto, podemos definir un \u00edndice de Elasticsearch para nuestro modelo: defmodule MyApp . User do use Ecto . Schema use Tirexs . Ecto @es_index \"users_index\" schema \"users\" do field : name , : string field : email , : string end end Luego, en nuestro archivo de controlador, podemos realizar una consulta a Elasticsearch utilizando la biblioteca Tirexs: def index(conn, _params) do users = Tirexs.search(MyApp.User, %{query: %{match: %{name: \"John\"}}}) render(conn, \"index.html\", users: users) end","title":"Integraci\u00f3n de Elasticsearch con Tirexs"},{"location":"phoenix_2/mid/integraci%C3%B3n_con_otras_tecnolog%C3%ADas/#ejercicios-practicos-con-instrucciones-claras","text":"Cree una aplicaci\u00f3n de Phoenix con una vista que renderice un componente de React. Implemente una API GraphQL en su aplicaci\u00f3n de Phoenix utilizando la biblioteca Absinthe. Agregue la funci\u00f3n de b\u00fasqueda de Elasticsearch a su aplicaci\u00f3n de Phoenix utilizando la biblioteca Tirexs.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"phoenix_2/mid/integraci%C3%B3n_con_otras_tecnolog%C3%ADas/#consejos-o-mejores-practicas","text":"Al integrar tecnolog\u00edas con Phoenix, es importante tener en cuenta el rendimiento y la escalabilidad de la aplicaci\u00f3n. Aseg\u00farese de elegir tecnolog\u00edas que se complementen bien con Phoenix y que no afecten el rendimiento de la aplicaci\u00f3n. Utilice bibliotecas de terceros para facilitar la integraci\u00f3n de tecnolog\u00edas en su aplicaci\u00f3n de Phoenix. Aseg\u00farese de comprender bien c\u00f3mo funcionan las tecnolog\u00edas que est\u00e1 integrando con Phoenix. Esto le ayudar\u00e1 a solucionar problemas y mejorar su aplicaci\u00f3n en el futuro.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix_2/mid/middlewares_y_plug/","text":"Middlewares y Plug en Phoenix Framework \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 Los middlewares y Plug son dos conceptos fundamentales en el desarrollo de aplicaciones web con Phoenix Framework. Ambos se utilizan para agregar funcionalidades a nuestras aplicaciones de forma modular y reutilizable. Middlewares \u00b6 Los middlewares son funciones que se ejecutan antes o despu\u00e9s de que una solicitud llegue a nuestra aplicaci\u00f3n. Son capas intermedias entre el servidor web y nuestra aplicaci\u00f3n, y nos permiten realizar tareas comunes a todas las solicitudes, como autenticaci\u00f3n, registro de errores, entre otros. En Phoenix, los middlewares se definen en el archivo endpoint.ex , que act\u00faa como punto de entrada de todas las solicitudes. All\u00ed se pueden agregar, modificar o eliminar middlewares seg\u00fan las necesidades de nuestra aplicaci\u00f3n. Plug \u00b6 Plug es un m\u00f3dulo de Phoenix que nos permite crear nuestros propios middlewares. Se basa en el concepto de \"enchufes\" (plugs en ingl\u00e9s), que son funciones que reciben una solicitud y devuelven una respuesta, y pueden ser encadenados para realizar una serie de tareas en secuencia. Con Plug, podemos definir middlewares personalizados para agregar funcionalidades espec\u00edficas a nuestra aplicaci\u00f3n. Adem\u00e1s, tambi\u00e9n podemos utilizar los middlewares ya incluidos en el framework, como por ejemplo Plug.Logger para registrar las solicitudes en el servidor. Palabras clave y su definici\u00f3n \u00b6 Middlewares: Funciones que se ejecutan antes o despu\u00e9s de una solicitud en una aplicaci\u00f3n web. Plug: M\u00f3dulo de Phoenix que nos permite crear middlewares personalizados. Endpoint: Archivo de configuraci\u00f3n en Phoenix donde se definen los middlewares. Enchufes: Funciones que reciben una solicitud y devuelven una respuesta, utilizados en Plug para crear middlewares. Encadenar: Proceso de conectar varios middlewares en secuencia para realizar una serie de tareas. Preguntas de repaso \u00b6 \u00bfQu\u00e9 son los middlewares en Phoenix Framework? \u00bfC\u00f3mo se definen los middlewares en una aplicaci\u00f3n Phoenix? \u00bfQu\u00e9 es Plug y para qu\u00e9 se utiliza? \u00bfQu\u00e9 es un \"enchufe\" en el contexto de Plug? \u00bfQu\u00e9 es encadenar middlewares y para qu\u00e9 se utiliza? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 Definir un middleware en endpoint.ex \u00b6 defmodule MyApp.Endpoint do use Phoenix.Endpoint , otp_app : :my_app # Se define el middleware utilizando el m\u00f3dulo Plug.Logger plug Plug.Logger # Resto de la configuraci\u00f3n del endpoint # ... end Crear un middleware personalizado con Plug \u00b6 defmodule MyApp.CustomMiddleware do # El enchufe recibe la solicitud y devuelve la misma solicitud modificada def init ( opts ), do : opts def call ( conn , _opts ) do # Realizar tareas adicionales con la solicitud # ... # Devolver la solicitud modificada conn end end Encadenar varios middlewares con Plug \u00b6 defmodule MyApp.Endpoint do use Phoenix.Endpoint , otp_app : :my_app # Se encadenan varios middlewares utilizando el operador `|>` plug Plug.Logger |> plug MyApp.CustomMiddleware |> plug Plug.Session # Resto de la configuraci\u00f3n del endpoint # ... end Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea un middleware personalizado que agregue un encabezado X-App-Version a todas las respuestas de tu aplicaci\u00f3n. Encadena el middleware creado en el ejercicio anterior con el middleware Plug.Static para servir archivos est\u00e1ticos solo si la solicitud contiene el encabezado X-App-Version . Agrega un middleware que redireccione todas las solicitudes a una p\u00e1gina de mantenimiento si la aplicaci\u00f3n se encuentra en modo de mantenimiento (definido en una configuraci\u00f3n global). Crea un middleware que registre en una base de datos todas las solicitudes que produzcan un error 500 en el servidor. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza middlewares para realizar tareas comunes en todas las solicitudes, como autenticaci\u00f3n o registro de errores. Crea middlewares personalizados con Plug para agregar funcionalidades espec\u00edficas a tu aplicaci\u00f3n. Encadena middlewares en el orden correcto para realizar tareas en secuencia. Utiliza la documentaci\u00f3n de Plug para conocer m\u00e1s sobre los enchufes disponibles y c\u00f3mo crear tus propios middlewares. No sobrecargues tu aplicaci\u00f3n con demasiados middlewares, ya que pueden afectar el rendimiento. Util\u00edzalos solo cuando sea necesario.","title":"Middlewares y Plug en Phoenix Framework"},{"location":"phoenix_2/mid/middlewares_y_plug/#middlewares-y-plug-en-phoenix-framework","text":"","title":"Middlewares y Plug en Phoenix Framework"},{"location":"phoenix_2/mid/middlewares_y_plug/#explicacion-teorica","text":"Los middlewares y Plug son dos conceptos fundamentales en el desarrollo de aplicaciones web con Phoenix Framework. Ambos se utilizan para agregar funcionalidades a nuestras aplicaciones de forma modular y reutilizable.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix_2/mid/middlewares_y_plug/#middlewares","text":"Los middlewares son funciones que se ejecutan antes o despu\u00e9s de que una solicitud llegue a nuestra aplicaci\u00f3n. Son capas intermedias entre el servidor web y nuestra aplicaci\u00f3n, y nos permiten realizar tareas comunes a todas las solicitudes, como autenticaci\u00f3n, registro de errores, entre otros. En Phoenix, los middlewares se definen en el archivo endpoint.ex , que act\u00faa como punto de entrada de todas las solicitudes. All\u00ed se pueden agregar, modificar o eliminar middlewares seg\u00fan las necesidades de nuestra aplicaci\u00f3n.","title":"Middlewares"},{"location":"phoenix_2/mid/middlewares_y_plug/#plug","text":"Plug es un m\u00f3dulo de Phoenix que nos permite crear nuestros propios middlewares. Se basa en el concepto de \"enchufes\" (plugs en ingl\u00e9s), que son funciones que reciben una solicitud y devuelven una respuesta, y pueden ser encadenados para realizar una serie de tareas en secuencia. Con Plug, podemos definir middlewares personalizados para agregar funcionalidades espec\u00edficas a nuestra aplicaci\u00f3n. Adem\u00e1s, tambi\u00e9n podemos utilizar los middlewares ya incluidos en el framework, como por ejemplo Plug.Logger para registrar las solicitudes en el servidor.","title":"Plug"},{"location":"phoenix_2/mid/middlewares_y_plug/#palabras-clave-y-su-definicion","text":"Middlewares: Funciones que se ejecutan antes o despu\u00e9s de una solicitud en una aplicaci\u00f3n web. Plug: M\u00f3dulo de Phoenix que nos permite crear middlewares personalizados. Endpoint: Archivo de configuraci\u00f3n en Phoenix donde se definen los middlewares. Enchufes: Funciones que reciben una solicitud y devuelven una respuesta, utilizados en Plug para crear middlewares. Encadenar: Proceso de conectar varios middlewares en secuencia para realizar una serie de tareas.","title":"Palabras clave y su definici\u00f3n"},{"location":"phoenix_2/mid/middlewares_y_plug/#preguntas-de-repaso","text":"\u00bfQu\u00e9 son los middlewares en Phoenix Framework? \u00bfC\u00f3mo se definen los middlewares en una aplicaci\u00f3n Phoenix? \u00bfQu\u00e9 es Plug y para qu\u00e9 se utiliza? \u00bfQu\u00e9 es un \"enchufe\" en el contexto de Plug? \u00bfQu\u00e9 es encadenar middlewares y para qu\u00e9 se utiliza?","title":"Preguntas de repaso"},{"location":"phoenix_2/mid/middlewares_y_plug/#ejemplos-de-codigo-en-phoenix-framework","text":"","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix_2/mid/middlewares_y_plug/#definir-un-middleware-en-endpointex","text":"defmodule MyApp.Endpoint do use Phoenix.Endpoint , otp_app : :my_app # Se define el middleware utilizando el m\u00f3dulo Plug.Logger plug Plug.Logger # Resto de la configuraci\u00f3n del endpoint # ... end","title":"Definir un middleware en endpoint.ex"},{"location":"phoenix_2/mid/middlewares_y_plug/#crear-un-middleware-personalizado-con-plug","text":"defmodule MyApp.CustomMiddleware do # El enchufe recibe la solicitud y devuelve la misma solicitud modificada def init ( opts ), do : opts def call ( conn , _opts ) do # Realizar tareas adicionales con la solicitud # ... # Devolver la solicitud modificada conn end end","title":"Crear un middleware personalizado con Plug"},{"location":"phoenix_2/mid/middlewares_y_plug/#encadenar-varios-middlewares-con-plug","text":"defmodule MyApp.Endpoint do use Phoenix.Endpoint , otp_app : :my_app # Se encadenan varios middlewares utilizando el operador `|>` plug Plug.Logger |> plug MyApp.CustomMiddleware |> plug Plug.Session # Resto de la configuraci\u00f3n del endpoint # ... end","title":"Encadenar varios middlewares con Plug"},{"location":"phoenix_2/mid/middlewares_y_plug/#ejercicios-practicos-con-instrucciones-claras","text":"Crea un middleware personalizado que agregue un encabezado X-App-Version a todas las respuestas de tu aplicaci\u00f3n. Encadena el middleware creado en el ejercicio anterior con el middleware Plug.Static para servir archivos est\u00e1ticos solo si la solicitud contiene el encabezado X-App-Version . Agrega un middleware que redireccione todas las solicitudes a una p\u00e1gina de mantenimiento si la aplicaci\u00f3n se encuentra en modo de mantenimiento (definido en una configuraci\u00f3n global). Crea un middleware que registre en una base de datos todas las solicitudes que produzcan un error 500 en el servidor.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"phoenix_2/mid/middlewares_y_plug/#consejos-o-mejores-practicas","text":"Utiliza middlewares para realizar tareas comunes en todas las solicitudes, como autenticaci\u00f3n o registro de errores. Crea middlewares personalizados con Plug para agregar funcionalidades espec\u00edficas a tu aplicaci\u00f3n. Encadena middlewares en el orden correcto para realizar tareas en secuencia. Utiliza la documentaci\u00f3n de Plug para conocer m\u00e1s sobre los enchufes disponibles y c\u00f3mo crear tus propios middlewares. No sobrecargues tu aplicaci\u00f3n con demasiados middlewares, ya que pueden afectar el rendimiento. Util\u00edzalos solo cuando sea necesario.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix_2/mid/optimizaci%C3%B3n_de_rendimiento/","text":"M\u00f3dulo: Optimizaci\u00f3n de rendimiento en Phoenix Framework \u00b6 En este m\u00f3dulo, aprender\u00e1s c\u00f3mo mejorar el rendimiento y la escalabilidad de una aplicaci\u00f3n desarrollada con Phoenix Framework. La optimizaci\u00f3n de rendimiento es una parte crucial en el desarrollo de aplicaciones web, ya que permite que la aplicaci\u00f3n pueda manejar grandes cantidades de tr\u00e1fico y datos sin afectar su velocidad y eficiencia. Explicaci\u00f3n te\u00f3rica \u00b6 La optimizaci\u00f3n de rendimiento en Phoenix Framework se centra en mejorar la velocidad de respuesta de la aplicaci\u00f3n, reducir el consumo de recursos y mejorar la experiencia del usuario. Para lograr esto, es necesario entender c\u00f3mo funciona Phoenix y c\u00f3mo se procesan las solicitudes. Phoenix es un framework de c\u00f3digo abierto basado en el lenguaje de programaci\u00f3n Elixir, que se ejecuta sobre la plataforma Erlang. Esto significa que Phoenix hereda la capacidad de Erlang para manejar grandes cantidades de concurrencia y procesar solicitudes de manera eficiente. Sin embargo, es importante tener en cuenta que, al igual que en cualquier otra aplicaci\u00f3n web, el rendimiento de Phoenix tambi\u00e9n puede verse afectado por varios factores, como el dise\u00f1o de la aplicaci\u00f3n, la l\u00f3gica de negocio y la infraestructura en la que se ejecuta. Para optimizar el rendimiento de una aplicaci\u00f3n Phoenix, es necesario seguir ciertas pr\u00e1cticas y t\u00e9cnicas que ayudar\u00e1n a mejorar la eficiencia y escalabilidad de la misma. A continuaci\u00f3n, se presentan algunas de las principales \u00e1reas en las que se pueden enfocar para optimizar el rendimiento en Phoenix. Dise\u00f1o de la aplicaci\u00f3n \u00b6 El dise\u00f1o de la aplicaci\u00f3n juega un papel importante en su rendimiento. Algunos aspectos a considerar son: Arquitectura de la aplicaci\u00f3n: es importante tener una arquitectura bien definida y escalable para garantizar que la aplicaci\u00f3n pueda manejar un gran n\u00famero de solicitudes sin afectar su rendimiento. Divisi\u00f3n en m\u00f3dulos: dividir la aplicaci\u00f3n en m\u00f3dulos m\u00e1s peque\u00f1os y especializados ayuda a mejorar la escalabilidad y el rendimiento, ya que se pueden escalar cada m\u00f3dulo de manera independiente seg\u00fan sea necesario. Optimizaci\u00f3n de consultas: las consultas a la base de datos pueden ser una de las mayores causas de un rendimiento pobre en una aplicaci\u00f3n. Por lo tanto, es importante optimizar las consultas y asegurarse de que se usen \u00edndices adecuados para mejorar la velocidad de respuesta. Infraestructura \u00b6 La infraestructura en la que se ejecuta la aplicaci\u00f3n tambi\u00e9n juega un papel importante en su rendimiento. Algunos aspectos a considerar son: Escalabilidad horizontal: asegurarse de que la aplicaci\u00f3n se pueda escalar horizontalmente es esencial para manejar un gran n\u00famero de solicitudes. Esto se puede lograr mediante el uso de herramientas como Kubernetes o Docker Swarm. Balanceo de carga: distribuir el tr\u00e1fico a trav\u00e9s de m\u00faltiples servidores o instancias de la aplicaci\u00f3n puede ayudar a mejorar el rendimiento y a evitar que un solo servidor se sobrecargue. Uso de cach\u00e9: implementar una estrategia de cach\u00e9 adecuada puede ayudar a reducir la carga en la base de datos y mejorar el rendimiento de la aplicaci\u00f3n. C\u00f3digo \u00b6 Por \u00faltimo, pero no menos importante, el c\u00f3digo de la aplicaci\u00f3n tambi\u00e9n juega un papel fundamental en su rendimiento. Algunos aspectos a considerar son: C\u00f3digo eficiente: escribir un c\u00f3digo limpio y eficiente es esencial para mejorar el rendimiento de la aplicaci\u00f3n. Esto incluye evitar bucles innecesarios, minimizar el uso de consultas a la base de datos y utilizar algoritmos eficientes. Optimizaci\u00f3n de consultas: como se mencion\u00f3 anteriormente, optimizar las consultas a la base de datos es esencial para mejorar el rendimiento de la aplicaci\u00f3n. Uso de procesos concurrentes: Phoenix se basa en el modelo de concurrencia de Erlang, por lo que aprovechar al m\u00e1ximo este modelo es esencial para mejorar el rendimiento. Esto se puede lograr mediante el uso de procesos concurrentes para manejar solicitudes y tareas en paralelo. Palabras clave y su definici\u00f3n \u00b6 Rendimiento: se refiere a la velocidad y eficiencia con la que una aplicaci\u00f3n puede procesar solicitudes y entregar respuestas. Escalabilidad: se refiere a la capacidad de una aplicaci\u00f3n para manejar un aumento en el volumen de tr\u00e1fico y datos sin afectar su rendimiento. Concurrencia: se refiere a la capacidad de una aplicaci\u00f3n para procesar m\u00faltiples tareas o solicitudes al mismo tiempo. Elixir: lenguaje de programaci\u00f3n funcional utilizado para desarrollar aplicaciones en Phoenix Framework. Erlang: plataforma para construir aplicaciones altamente escalables y concurrentes, en la que se basa Phoenix Framework. Preguntas de repaso \u00b6 \u00bfCu\u00e1l es la importancia de la optimizaci\u00f3n de rendimiento en una aplicaci\u00f3n web? \u00bfQu\u00e9 es Phoenix Framework y en qu\u00e9 plataforma se ejecuta? \u00bfCu\u00e1les son algunas de las principales \u00e1reas en las que se puede enfocar para optimizar el rendimiento en Phoenix? \u00bfQu\u00e9 es la escalabilidad horizontal y por qu\u00e9 es importante? \u00bfCu\u00e1l es una de las mayores causas de un rendimiento pobre en una aplicaci\u00f3n Phoenix? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 C\u00f3digo eficiente \u00b6 # En lugar de esto: for i <- 1 .. 100 do user = Repo . get_by ( User , name : \"John\" ) # L\u00f3gica adicional aqu\u00ed end # Se puede hacer esto: user = Repo . get_by ( User , name : \"John\" ) for i <- 1 .. 100 do # L\u00f3gica adicional aqu\u00ed end Uso de procesos concurrentes \u00b6 # Crear un proceso concurrente con Task task = Task . async ( fn -> do_some_long_task () end ) result = Task . await ( task ) # Crear un proceso concurrente con Task.Supervisor Task.Supervisor . async_nolink ( Task.Supervisor , fn -> do_some_long_task () end ) Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Optimizar una consulta a la base de datos en una aplicaci\u00f3n Phoenix. Instrucciones: Identifica una consulta a la base de datos en tu aplicaci\u00f3n Phoenix que se ejecute con frecuencia. Revisa si la consulta utiliza \u00edndices adecuados y si es posible optimizarla. Implementa la optimizaci\u00f3n y mide la diferencia en el rendimiento. Implementar un sistema de cach\u00e9 en una aplicaci\u00f3n Phoenix. Instrucciones: Identifica un proceso en tu aplicaci\u00f3n que pueda beneficiarse de un sistema de cach\u00e9. Revisa c\u00f3mo implementar un sistema de cach\u00e9 en Phoenix. Implementa el sistema de cach\u00e9 y mide la diferencia en el rendimiento. Consejos o mejores pr\u00e1cticas \u00b6 Realizar pruebas de rendimiento peri\u00f3dicas para identificar posibles cuellos de botella en la aplicaci\u00f3n. Utilizar herramientas de monitoreo para identificar problemas de rendimiento en tiempo real. Seguir las buenas pr\u00e1cticas de Elixir y Phoenix, como evitar bucles innecesarios y utilizar procesos concurrentes. Utilizar herramientas como New Relic para analizar el rendimiento de la aplicaci\u00f3n y detectar posibles problemas. Investigar y aplicar t\u00e9cnicas de optimizaci\u00f3n espec\u00edficas para la base de datos que est\u00e9s utilizando en tu aplicaci\u00f3n Phoenix.","title":"M\u00f3dulo: Optimizaci\u00f3n de rendimiento en Phoenix Framework"},{"location":"phoenix_2/mid/optimizaci%C3%B3n_de_rendimiento/#modulo-optimizacion-de-rendimiento-en-phoenix-framework","text":"En este m\u00f3dulo, aprender\u00e1s c\u00f3mo mejorar el rendimiento y la escalabilidad de una aplicaci\u00f3n desarrollada con Phoenix Framework. La optimizaci\u00f3n de rendimiento es una parte crucial en el desarrollo de aplicaciones web, ya que permite que la aplicaci\u00f3n pueda manejar grandes cantidades de tr\u00e1fico y datos sin afectar su velocidad y eficiencia.","title":"M\u00f3dulo: Optimizaci\u00f3n de rendimiento en Phoenix Framework"},{"location":"phoenix_2/mid/optimizaci%C3%B3n_de_rendimiento/#explicacion-teorica","text":"La optimizaci\u00f3n de rendimiento en Phoenix Framework se centra en mejorar la velocidad de respuesta de la aplicaci\u00f3n, reducir el consumo de recursos y mejorar la experiencia del usuario. Para lograr esto, es necesario entender c\u00f3mo funciona Phoenix y c\u00f3mo se procesan las solicitudes. Phoenix es un framework de c\u00f3digo abierto basado en el lenguaje de programaci\u00f3n Elixir, que se ejecuta sobre la plataforma Erlang. Esto significa que Phoenix hereda la capacidad de Erlang para manejar grandes cantidades de concurrencia y procesar solicitudes de manera eficiente. Sin embargo, es importante tener en cuenta que, al igual que en cualquier otra aplicaci\u00f3n web, el rendimiento de Phoenix tambi\u00e9n puede verse afectado por varios factores, como el dise\u00f1o de la aplicaci\u00f3n, la l\u00f3gica de negocio y la infraestructura en la que se ejecuta. Para optimizar el rendimiento de una aplicaci\u00f3n Phoenix, es necesario seguir ciertas pr\u00e1cticas y t\u00e9cnicas que ayudar\u00e1n a mejorar la eficiencia y escalabilidad de la misma. A continuaci\u00f3n, se presentan algunas de las principales \u00e1reas en las que se pueden enfocar para optimizar el rendimiento en Phoenix.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix_2/mid/optimizaci%C3%B3n_de_rendimiento/#diseno-de-la-aplicacion","text":"El dise\u00f1o de la aplicaci\u00f3n juega un papel importante en su rendimiento. Algunos aspectos a considerar son: Arquitectura de la aplicaci\u00f3n: es importante tener una arquitectura bien definida y escalable para garantizar que la aplicaci\u00f3n pueda manejar un gran n\u00famero de solicitudes sin afectar su rendimiento. Divisi\u00f3n en m\u00f3dulos: dividir la aplicaci\u00f3n en m\u00f3dulos m\u00e1s peque\u00f1os y especializados ayuda a mejorar la escalabilidad y el rendimiento, ya que se pueden escalar cada m\u00f3dulo de manera independiente seg\u00fan sea necesario. Optimizaci\u00f3n de consultas: las consultas a la base de datos pueden ser una de las mayores causas de un rendimiento pobre en una aplicaci\u00f3n. Por lo tanto, es importante optimizar las consultas y asegurarse de que se usen \u00edndices adecuados para mejorar la velocidad de respuesta.","title":"Dise\u00f1o de la aplicaci\u00f3n"},{"location":"phoenix_2/mid/optimizaci%C3%B3n_de_rendimiento/#infraestructura","text":"La infraestructura en la que se ejecuta la aplicaci\u00f3n tambi\u00e9n juega un papel importante en su rendimiento. Algunos aspectos a considerar son: Escalabilidad horizontal: asegurarse de que la aplicaci\u00f3n se pueda escalar horizontalmente es esencial para manejar un gran n\u00famero de solicitudes. Esto se puede lograr mediante el uso de herramientas como Kubernetes o Docker Swarm. Balanceo de carga: distribuir el tr\u00e1fico a trav\u00e9s de m\u00faltiples servidores o instancias de la aplicaci\u00f3n puede ayudar a mejorar el rendimiento y a evitar que un solo servidor se sobrecargue. Uso de cach\u00e9: implementar una estrategia de cach\u00e9 adecuada puede ayudar a reducir la carga en la base de datos y mejorar el rendimiento de la aplicaci\u00f3n.","title":"Infraestructura"},{"location":"phoenix_2/mid/optimizaci%C3%B3n_de_rendimiento/#codigo","text":"Por \u00faltimo, pero no menos importante, el c\u00f3digo de la aplicaci\u00f3n tambi\u00e9n juega un papel fundamental en su rendimiento. Algunos aspectos a considerar son: C\u00f3digo eficiente: escribir un c\u00f3digo limpio y eficiente es esencial para mejorar el rendimiento de la aplicaci\u00f3n. Esto incluye evitar bucles innecesarios, minimizar el uso de consultas a la base de datos y utilizar algoritmos eficientes. Optimizaci\u00f3n de consultas: como se mencion\u00f3 anteriormente, optimizar las consultas a la base de datos es esencial para mejorar el rendimiento de la aplicaci\u00f3n. Uso de procesos concurrentes: Phoenix se basa en el modelo de concurrencia de Erlang, por lo que aprovechar al m\u00e1ximo este modelo es esencial para mejorar el rendimiento. Esto se puede lograr mediante el uso de procesos concurrentes para manejar solicitudes y tareas en paralelo.","title":"C\u00f3digo"},{"location":"phoenix_2/mid/optimizaci%C3%B3n_de_rendimiento/#palabras-clave-y-su-definicion","text":"Rendimiento: se refiere a la velocidad y eficiencia con la que una aplicaci\u00f3n puede procesar solicitudes y entregar respuestas. Escalabilidad: se refiere a la capacidad de una aplicaci\u00f3n para manejar un aumento en el volumen de tr\u00e1fico y datos sin afectar su rendimiento. Concurrencia: se refiere a la capacidad de una aplicaci\u00f3n para procesar m\u00faltiples tareas o solicitudes al mismo tiempo. Elixir: lenguaje de programaci\u00f3n funcional utilizado para desarrollar aplicaciones en Phoenix Framework. Erlang: plataforma para construir aplicaciones altamente escalables y concurrentes, en la que se basa Phoenix Framework.","title":"Palabras clave y su definici\u00f3n"},{"location":"phoenix_2/mid/optimizaci%C3%B3n_de_rendimiento/#preguntas-de-repaso","text":"\u00bfCu\u00e1l es la importancia de la optimizaci\u00f3n de rendimiento en una aplicaci\u00f3n web? \u00bfQu\u00e9 es Phoenix Framework y en qu\u00e9 plataforma se ejecuta? \u00bfCu\u00e1les son algunas de las principales \u00e1reas en las que se puede enfocar para optimizar el rendimiento en Phoenix? \u00bfQu\u00e9 es la escalabilidad horizontal y por qu\u00e9 es importante? \u00bfCu\u00e1l es una de las mayores causas de un rendimiento pobre en una aplicaci\u00f3n Phoenix?","title":"Preguntas de repaso"},{"location":"phoenix_2/mid/optimizaci%C3%B3n_de_rendimiento/#ejemplos-de-codigo-en-phoenix-framework","text":"","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix_2/mid/optimizaci%C3%B3n_de_rendimiento/#codigo-eficiente","text":"# En lugar de esto: for i <- 1 .. 100 do user = Repo . get_by ( User , name : \"John\" ) # L\u00f3gica adicional aqu\u00ed end # Se puede hacer esto: user = Repo . get_by ( User , name : \"John\" ) for i <- 1 .. 100 do # L\u00f3gica adicional aqu\u00ed end","title":"C\u00f3digo eficiente"},{"location":"phoenix_2/mid/optimizaci%C3%B3n_de_rendimiento/#uso-de-procesos-concurrentes","text":"# Crear un proceso concurrente con Task task = Task . async ( fn -> do_some_long_task () end ) result = Task . await ( task ) # Crear un proceso concurrente con Task.Supervisor Task.Supervisor . async_nolink ( Task.Supervisor , fn -> do_some_long_task () end )","title":"Uso de procesos concurrentes"},{"location":"phoenix_2/mid/optimizaci%C3%B3n_de_rendimiento/#ejercicios-practicos-con-instrucciones-claras","text":"Optimizar una consulta a la base de datos en una aplicaci\u00f3n Phoenix. Instrucciones: Identifica una consulta a la base de datos en tu aplicaci\u00f3n Phoenix que se ejecute con frecuencia. Revisa si la consulta utiliza \u00edndices adecuados y si es posible optimizarla. Implementa la optimizaci\u00f3n y mide la diferencia en el rendimiento. Implementar un sistema de cach\u00e9 en una aplicaci\u00f3n Phoenix. Instrucciones: Identifica un proceso en tu aplicaci\u00f3n que pueda beneficiarse de un sistema de cach\u00e9. Revisa c\u00f3mo implementar un sistema de cach\u00e9 en Phoenix. Implementa el sistema de cach\u00e9 y mide la diferencia en el rendimiento.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"phoenix_2/mid/optimizaci%C3%B3n_de_rendimiento/#consejos-o-mejores-practicas","text":"Realizar pruebas de rendimiento peri\u00f3dicas para identificar posibles cuellos de botella en la aplicaci\u00f3n. Utilizar herramientas de monitoreo para identificar problemas de rendimiento en tiempo real. Seguir las buenas pr\u00e1cticas de Elixir y Phoenix, como evitar bucles innecesarios y utilizar procesos concurrentes. Utilizar herramientas como New Relic para analizar el rendimiento de la aplicaci\u00f3n y detectar posibles problemas. Investigar y aplicar t\u00e9cnicas de optimizaci\u00f3n espec\u00edficas para la base de datos que est\u00e9s utilizando en tu aplicaci\u00f3n Phoenix.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix_2/mid/pruebas_en_phoenix/","text":"Pruebas en Phoenix \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 En este m\u00f3dulo, aprenderemos sobre la importancia de realizar pruebas automatizadas en nuestra aplicaci\u00f3n Phoenix y c\u00f3mo utilizar herramientas como ExUnit y Hound para facilitar este proceso. Las pruebas son una parte esencial del desarrollo de software, ya que nos permiten asegurarnos de que nuestro c\u00f3digo funciona correctamente y nos ayudan a detectar y corregir errores antes de que lleguen a producci\u00f3n. Explicaci\u00f3n te\u00f3rica \u00b6 Las pruebas automatizadas son una t\u00e9cnica de desarrollo de software en la que se utilizan herramientas y scripts para ejecutar pruebas en el c\u00f3digo de manera autom\u00e1tica. En Phoenix, estas pruebas se pueden realizar utilizando la herramienta integrada ExUnit, que nos permite escribir pruebas para nuestros controladores, modelos, vistas y otras partes de nuestra aplicaci\u00f3n. Existen varios tipos de pruebas que se pueden realizar en Phoenix, entre las m\u00e1s comunes se encuentran las pruebas unitarias, que se enfocan en probar unidades individuales de c\u00f3digo, y las pruebas de integraci\u00f3n, que se utilizan para probar la interacci\u00f3n entre diferentes partes de la aplicaci\u00f3n. Adem\u00e1s, tambi\u00e9n podemos utilizar herramientas como Hound para realizar pruebas de aceptaci\u00f3n, que simulan interacciones de usuario en nuestra aplicaci\u00f3n. Palabras clave y su definici\u00f3n \u00b6 Pruebas automatizadas: t\u00e9cnica de desarrollo de software en la que se utilizan herramientas y scripts para ejecutar pruebas en el c\u00f3digo de manera autom\u00e1tica. ExUnit: herramienta de pruebas integrada en Phoenix que nos permite escribir y ejecutar pruebas en nuestro c\u00f3digo. Pruebas unitarias: tipo de prueba que se enfoca en probar unidades individuales de c\u00f3digo. Pruebas de integraci\u00f3n: tipo de prueba que se utiliza para probar la interacci\u00f3n entre diferentes partes de la aplicaci\u00f3n. Hound: herramienta de pruebas de aceptaci\u00f3n en Phoenix que simula interacciones de usuario en nuestra aplicaci\u00f3n. Preguntas de repaso \u00b6 \u00bfQu\u00e9 son las pruebas automatizadas y por qu\u00e9 son importantes en el desarrollo de software? \u00bfCu\u00e1l es la herramienta de pruebas integrada en Phoenix y qu\u00e9 tipos de pruebas se pueden realizar con ella? \u00bfEn qu\u00e9 se enfocan las pruebas unitarias y las pruebas de integraci\u00f3n? \u00bfQu\u00e9 es Hound y para qu\u00e9 se utiliza en Phoenix? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 Pruebas unitarias \u00b6 defmodule MyApp . UserTest do use MyApp . DataCase test \"creates a new user\" do user = % User { name : \"John Doe\" , email : \"john@doe.com\" , password : \"password\" } assert {: ok , % User {}} = MyApp . User . create_user ( user ) end end Pruebas de integraci\u00f3n \u00b6 defmodule MyApp.PostControllerTest do use MyApp.ConnCase test \"returns a list of posts\" do conn = get conn, \"/api/posts\" assert json_response(conn, 200) == %{posts: []} end end Pruebas de aceptaci\u00f3n con Hound \u00b6 defmodule MyApp . RegistrationTest do use MyApp . AcceptanceCase test \"registers a new user\" do visit \"/register\" fill_in \"Name\" , with : \"John Doe\" fill_in \"Email\" , with : \"john@doe.com\" fill_in \"Password\" , with : \"password\" click_button \"Register\" assert page_has_content ? ( \"Welcome, John!\" ) end end Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una prueba unitaria que verifique que un usuario se pueda autenticar correctamente en tu aplicaci\u00f3n Phoenix. Escribe una prueba de integraci\u00f3n que verifique que se puedan crear nuevos posts en tu aplicaci\u00f3n. Utilizando Hound, realiza una prueba de aceptaci\u00f3n que simule el proceso de registro de un nuevo usuario en tu aplicaci\u00f3n. Consejos o mejores pr\u00e1cticas \u00b6 Es importante tener una buena cobertura de pruebas en nuestra aplicaci\u00f3n, ya que esto nos ayudar\u00e1 a detectar y corregir errores de manera m\u00e1s eficiente. Utiliza nombres descriptivos para tus pruebas, para que sea m\u00e1s f\u00e1cil entender qu\u00e9 se est\u00e1 probando. Aseg\u00farate de incluir tanto pruebas positivas como negativas en tus suites de pruebas. Utiliza fixtures o factories para crear datos de prueba en lugar de utilizar datos reales de la base de datos. Realiza pruebas de manera regular y no solo al final del desarrollo, esto te ayudar\u00e1 a detectar errores m\u00e1s r\u00e1pido.","title":"Pruebas en Phoenix"},{"location":"phoenix_2/mid/pruebas_en_phoenix/#pruebas-en-phoenix","text":"","title":"Pruebas en Phoenix"},{"location":"phoenix_2/mid/pruebas_en_phoenix/#descripcion-del-modulo","text":"En este m\u00f3dulo, aprenderemos sobre la importancia de realizar pruebas automatizadas en nuestra aplicaci\u00f3n Phoenix y c\u00f3mo utilizar herramientas como ExUnit y Hound para facilitar este proceso. Las pruebas son una parte esencial del desarrollo de software, ya que nos permiten asegurarnos de que nuestro c\u00f3digo funciona correctamente y nos ayudan a detectar y corregir errores antes de que lleguen a producci\u00f3n.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"phoenix_2/mid/pruebas_en_phoenix/#explicacion-teorica","text":"Las pruebas automatizadas son una t\u00e9cnica de desarrollo de software en la que se utilizan herramientas y scripts para ejecutar pruebas en el c\u00f3digo de manera autom\u00e1tica. En Phoenix, estas pruebas se pueden realizar utilizando la herramienta integrada ExUnit, que nos permite escribir pruebas para nuestros controladores, modelos, vistas y otras partes de nuestra aplicaci\u00f3n. Existen varios tipos de pruebas que se pueden realizar en Phoenix, entre las m\u00e1s comunes se encuentran las pruebas unitarias, que se enfocan en probar unidades individuales de c\u00f3digo, y las pruebas de integraci\u00f3n, que se utilizan para probar la interacci\u00f3n entre diferentes partes de la aplicaci\u00f3n. Adem\u00e1s, tambi\u00e9n podemos utilizar herramientas como Hound para realizar pruebas de aceptaci\u00f3n, que simulan interacciones de usuario en nuestra aplicaci\u00f3n.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix_2/mid/pruebas_en_phoenix/#palabras-clave-y-su-definicion","text":"Pruebas automatizadas: t\u00e9cnica de desarrollo de software en la que se utilizan herramientas y scripts para ejecutar pruebas en el c\u00f3digo de manera autom\u00e1tica. ExUnit: herramienta de pruebas integrada en Phoenix que nos permite escribir y ejecutar pruebas en nuestro c\u00f3digo. Pruebas unitarias: tipo de prueba que se enfoca en probar unidades individuales de c\u00f3digo. Pruebas de integraci\u00f3n: tipo de prueba que se utiliza para probar la interacci\u00f3n entre diferentes partes de la aplicaci\u00f3n. Hound: herramienta de pruebas de aceptaci\u00f3n en Phoenix que simula interacciones de usuario en nuestra aplicaci\u00f3n.","title":"Palabras clave y su definici\u00f3n"},{"location":"phoenix_2/mid/pruebas_en_phoenix/#preguntas-de-repaso","text":"\u00bfQu\u00e9 son las pruebas automatizadas y por qu\u00e9 son importantes en el desarrollo de software? \u00bfCu\u00e1l es la herramienta de pruebas integrada en Phoenix y qu\u00e9 tipos de pruebas se pueden realizar con ella? \u00bfEn qu\u00e9 se enfocan las pruebas unitarias y las pruebas de integraci\u00f3n? \u00bfQu\u00e9 es Hound y para qu\u00e9 se utiliza en Phoenix?","title":"Preguntas de repaso"},{"location":"phoenix_2/mid/pruebas_en_phoenix/#ejemplos-de-codigo-en-phoenix-framework","text":"","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix_2/mid/pruebas_en_phoenix/#pruebas-unitarias","text":"defmodule MyApp . UserTest do use MyApp . DataCase test \"creates a new user\" do user = % User { name : \"John Doe\" , email : \"john@doe.com\" , password : \"password\" } assert {: ok , % User {}} = MyApp . User . create_user ( user ) end end","title":"Pruebas unitarias"},{"location":"phoenix_2/mid/pruebas_en_phoenix/#pruebas-de-integracion","text":"defmodule MyApp.PostControllerTest do use MyApp.ConnCase test \"returns a list of posts\" do conn = get conn, \"/api/posts\" assert json_response(conn, 200) == %{posts: []} end end","title":"Pruebas de integraci\u00f3n"},{"location":"phoenix_2/mid/pruebas_en_phoenix/#pruebas-de-aceptacion-con-hound","text":"defmodule MyApp . RegistrationTest do use MyApp . AcceptanceCase test \"registers a new user\" do visit \"/register\" fill_in \"Name\" , with : \"John Doe\" fill_in \"Email\" , with : \"john@doe.com\" fill_in \"Password\" , with : \"password\" click_button \"Register\" assert page_has_content ? ( \"Welcome, John!\" ) end end","title":"Pruebas de aceptaci\u00f3n con Hound"},{"location":"phoenix_2/mid/pruebas_en_phoenix/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una prueba unitaria que verifique que un usuario se pueda autenticar correctamente en tu aplicaci\u00f3n Phoenix. Escribe una prueba de integraci\u00f3n que verifique que se puedan crear nuevos posts en tu aplicaci\u00f3n. Utilizando Hound, realiza una prueba de aceptaci\u00f3n que simule el proceso de registro de un nuevo usuario en tu aplicaci\u00f3n.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"phoenix_2/mid/pruebas_en_phoenix/#consejos-o-mejores-practicas","text":"Es importante tener una buena cobertura de pruebas en nuestra aplicaci\u00f3n, ya que esto nos ayudar\u00e1 a detectar y corregir errores de manera m\u00e1s eficiente. Utiliza nombres descriptivos para tus pruebas, para que sea m\u00e1s f\u00e1cil entender qu\u00e9 se est\u00e1 probando. Aseg\u00farate de incluir tanto pruebas positivas como negativas en tus suites de pruebas. Utiliza fixtures o factories para crear datos de prueba en lugar de utilizar datos reales de la base de datos. Realiza pruebas de manera regular y no solo al final del desarrollo, esto te ayudar\u00e1 a detectar errores m\u00e1s r\u00e1pido.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix_2/mid/seguridad_en_phoenix/","text":"Seguridad en Phoenix \u00b6 En el mundo actual de la inform\u00e1tica, la seguridad es una preocupaci\u00f3n constante para cualquier aplicaci\u00f3n que se desarrolle. Con el aumento de ataques cibern\u00e9ticos y vulnerabilidades de software, es necesario que las aplicaciones est\u00e9n dise\u00f1adas y construidas con medidas de seguridad s\u00f3lidas. Phoenix Framework, al ser un framework de desarrollo web, tambi\u00e9n debe ser consciente de estas preocupaciones de seguridad y proporcionar mecanismos para proteger las aplicaciones desarrolladas en \u00e9l. Explicaci\u00f3n te\u00f3rica \u00b6 La seguridad en Phoenix se refiere a las medidas que se deben tomar para proteger una aplicaci\u00f3n desarrollada en este framework de posibles ataques y vulnerabilidades. Al igual que con cualquier otra aplicaci\u00f3n web, existen dos vulnerabilidades comunes que se deben abordar en Phoenix: el ataque de XSS y el ataque de CSRF. El ataque de XSS (Cross-Site Scripting) es una t\u00e9cnica utilizada por los hackers para insertar c\u00f3digo malicioso en una p\u00e1gina web. Esto puede ocurrir cuando un sitio web no filtra correctamente las entradas del usuario, lo que permite que se inyecte c\u00f3digo malicioso en la p\u00e1gina. Esto puede tener consecuencias graves, como el robo de informaci\u00f3n del usuario o la manipulaci\u00f3n del contenido de la p\u00e1gina. El ataque de CSRF (Cross-Site Request Forgery) es una t\u00e9cnica en la que un atacante enga\u00f1a a un usuario para que realice una acci\u00f3n no deseada en un sitio web en el que ya est\u00e1 autenticado. Esto puede ocurrir cuando un sitio web no valida correctamente las solicitudes de los usuarios, lo que permite que se realicen acciones no autorizadas en nombre del usuario. Palabras clave y su definici\u00f3n \u00b6 XSS (Cross-Site Scripting): Ataque en el que se inserta c\u00f3digo malicioso en una p\u00e1gina web para robar informaci\u00f3n o manipular el contenido. CSRF (Cross-Site Request Forgery): Ataque en el que un atacante enga\u00f1a a un usuario para realizar una acci\u00f3n no deseada en un sitio web en el que ya est\u00e1 autenticado. Validaci\u00f3n: Proceso de asegurarse de que los datos recibidos son correctos y seguros antes de utilizarlos en una aplicaci\u00f3n. Filtro de entrada: Proceso de eliminar o escapar de caracteres maliciosos en los datos recibidos de los usuarios antes de utilizarlos en una aplicaci\u00f3n. Autenticaci\u00f3n: Proceso de verificar la identidad de un usuario para permitir el acceso a una aplicaci\u00f3n o sistema. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es el ataque de XSS y c\u00f3mo puede afectar a una aplicaci\u00f3n Phoenix? \u00bfEn qu\u00e9 consiste el ataque de CSRF y c\u00f3mo se puede prevenir en una aplicaci\u00f3n Phoenix? \u00bfQu\u00e9 es la validaci\u00f3n de datos y por qu\u00e9 es importante en t\u00e9rminos de seguridad? \u00bfQu\u00e9 es la autenticaci\u00f3n y c\u00f3mo se puede implementar en una aplicaci\u00f3n Phoenix? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 Filtro de entrada \u00b6 def create ( conn , params ) do changeset = Post . changeset (% Post {}, params ) case Repo . insert ( changeset ) do {: ok , _ post } -> conn |> put_flash (: info , \"Post creado exitosamente.\" ) |> redirect ( to : post_path ( conn , : index )) {: error , changeset } -> render ( conn , \"new.html\" , changeset : changeset ) end end En este ejemplo, se utiliza la funci\u00f3n changeset/2 para asegurarse de que los datos recibidos en params sean seguros antes de insertarlos en la base de datos. Este proceso de validaci\u00f3n ayuda a prevenir posibles ataques de XSS. Autenticaci\u00f3n \u00b6 def create ( conn , % { \"user\" => user_params }) do case Accounts . register_user ( user_params ) do { : ok , user } -> conn |> put_session ( : current_user , user ) |> put_flash ( : info , \"Cuenta creada exitosamente.\" ) |> redirect ( to: page_path ( conn , : index )) { : error , changeset } -> render ( conn , \"new.html\" , changeset: changeset ) end end En este ejemplo, se utiliza la funci\u00f3n register_user/1 del m\u00f3dulo Accounts para autenticar y registrar a un usuario en la aplicaci\u00f3n. Esta funci\u00f3n utiliza t\u00e9cnicas de cifrado para almacenar de forma segura las credenciales de los usuarios y prevenir posibles ataques de CSRF. Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una nueva aplicaci\u00f3n Phoenix y agrega una p\u00e1gina de inicio de sesi\u00f3n. Implementa una funci\u00f3n de validaci\u00f3n de datos para asegurarte de que solo se acepten correos electr\u00f3nicos v\u00e1lidos en el campo de inicio de sesi\u00f3n. Agrega autenticaci\u00f3n a tu aplicaci\u00f3n utilizando la funci\u00f3n register_user/1 del m\u00f3dulo Accounts . Crea una p\u00e1gina de perfil de usuario y aseg\u00farate de que solo el usuario autenticado pueda acceder a ella. Consejos o mejores pr\u00e1cticas \u00b6 Siempre filtra y valida los datos recibidos de los usuarios antes de utilizarlos en una aplicaci\u00f3n. Utiliza t\u00e9cnicas de cifrado para almacenar de forma segura las credenciales de los usuarios. Implementa medidas de autenticaci\u00f3n y autorizaci\u00f3n para limitar el acceso a ciertas partes de la aplicaci\u00f3n. Mant\u00e9n tu aplicaci\u00f3n Phoenix actualizada con las \u00faltimas versiones, ya que estas pueden incluir mejoras de seguridad.","title":"Seguridad en phoenix"},{"location":"phoenix_2/mid/seguridad_en_phoenix/#seguridad-en-phoenix","text":"En el mundo actual de la inform\u00e1tica, la seguridad es una preocupaci\u00f3n constante para cualquier aplicaci\u00f3n que se desarrolle. Con el aumento de ataques cibern\u00e9ticos y vulnerabilidades de software, es necesario que las aplicaciones est\u00e9n dise\u00f1adas y construidas con medidas de seguridad s\u00f3lidas. Phoenix Framework, al ser un framework de desarrollo web, tambi\u00e9n debe ser consciente de estas preocupaciones de seguridad y proporcionar mecanismos para proteger las aplicaciones desarrolladas en \u00e9l.","title":"Seguridad en Phoenix"},{"location":"phoenix_2/mid/seguridad_en_phoenix/#explicacion-teorica","text":"La seguridad en Phoenix se refiere a las medidas que se deben tomar para proteger una aplicaci\u00f3n desarrollada en este framework de posibles ataques y vulnerabilidades. Al igual que con cualquier otra aplicaci\u00f3n web, existen dos vulnerabilidades comunes que se deben abordar en Phoenix: el ataque de XSS y el ataque de CSRF. El ataque de XSS (Cross-Site Scripting) es una t\u00e9cnica utilizada por los hackers para insertar c\u00f3digo malicioso en una p\u00e1gina web. Esto puede ocurrir cuando un sitio web no filtra correctamente las entradas del usuario, lo que permite que se inyecte c\u00f3digo malicioso en la p\u00e1gina. Esto puede tener consecuencias graves, como el robo de informaci\u00f3n del usuario o la manipulaci\u00f3n del contenido de la p\u00e1gina. El ataque de CSRF (Cross-Site Request Forgery) es una t\u00e9cnica en la que un atacante enga\u00f1a a un usuario para que realice una acci\u00f3n no deseada en un sitio web en el que ya est\u00e1 autenticado. Esto puede ocurrir cuando un sitio web no valida correctamente las solicitudes de los usuarios, lo que permite que se realicen acciones no autorizadas en nombre del usuario.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix_2/mid/seguridad_en_phoenix/#palabras-clave-y-su-definicion","text":"XSS (Cross-Site Scripting): Ataque en el que se inserta c\u00f3digo malicioso en una p\u00e1gina web para robar informaci\u00f3n o manipular el contenido. CSRF (Cross-Site Request Forgery): Ataque en el que un atacante enga\u00f1a a un usuario para realizar una acci\u00f3n no deseada en un sitio web en el que ya est\u00e1 autenticado. Validaci\u00f3n: Proceso de asegurarse de que los datos recibidos son correctos y seguros antes de utilizarlos en una aplicaci\u00f3n. Filtro de entrada: Proceso de eliminar o escapar de caracteres maliciosos en los datos recibidos de los usuarios antes de utilizarlos en una aplicaci\u00f3n. Autenticaci\u00f3n: Proceso de verificar la identidad de un usuario para permitir el acceso a una aplicaci\u00f3n o sistema.","title":"Palabras clave y su definici\u00f3n"},{"location":"phoenix_2/mid/seguridad_en_phoenix/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es el ataque de XSS y c\u00f3mo puede afectar a una aplicaci\u00f3n Phoenix? \u00bfEn qu\u00e9 consiste el ataque de CSRF y c\u00f3mo se puede prevenir en una aplicaci\u00f3n Phoenix? \u00bfQu\u00e9 es la validaci\u00f3n de datos y por qu\u00e9 es importante en t\u00e9rminos de seguridad? \u00bfQu\u00e9 es la autenticaci\u00f3n y c\u00f3mo se puede implementar en una aplicaci\u00f3n Phoenix?","title":"Preguntas de repaso"},{"location":"phoenix_2/mid/seguridad_en_phoenix/#ejemplos-de-codigo-en-phoenix-framework","text":"","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix_2/mid/seguridad_en_phoenix/#filtro-de-entrada","text":"def create ( conn , params ) do changeset = Post . changeset (% Post {}, params ) case Repo . insert ( changeset ) do {: ok , _ post } -> conn |> put_flash (: info , \"Post creado exitosamente.\" ) |> redirect ( to : post_path ( conn , : index )) {: error , changeset } -> render ( conn , \"new.html\" , changeset : changeset ) end end En este ejemplo, se utiliza la funci\u00f3n changeset/2 para asegurarse de que los datos recibidos en params sean seguros antes de insertarlos en la base de datos. Este proceso de validaci\u00f3n ayuda a prevenir posibles ataques de XSS.","title":"Filtro de entrada"},{"location":"phoenix_2/mid/seguridad_en_phoenix/#autenticacion","text":"def create ( conn , % { \"user\" => user_params }) do case Accounts . register_user ( user_params ) do { : ok , user } -> conn |> put_session ( : current_user , user ) |> put_flash ( : info , \"Cuenta creada exitosamente.\" ) |> redirect ( to: page_path ( conn , : index )) { : error , changeset } -> render ( conn , \"new.html\" , changeset: changeset ) end end En este ejemplo, se utiliza la funci\u00f3n register_user/1 del m\u00f3dulo Accounts para autenticar y registrar a un usuario en la aplicaci\u00f3n. Esta funci\u00f3n utiliza t\u00e9cnicas de cifrado para almacenar de forma segura las credenciales de los usuarios y prevenir posibles ataques de CSRF.","title":"Autenticaci\u00f3n"},{"location":"phoenix_2/mid/seguridad_en_phoenix/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una nueva aplicaci\u00f3n Phoenix y agrega una p\u00e1gina de inicio de sesi\u00f3n. Implementa una funci\u00f3n de validaci\u00f3n de datos para asegurarte de que solo se acepten correos electr\u00f3nicos v\u00e1lidos en el campo de inicio de sesi\u00f3n. Agrega autenticaci\u00f3n a tu aplicaci\u00f3n utilizando la funci\u00f3n register_user/1 del m\u00f3dulo Accounts . Crea una p\u00e1gina de perfil de usuario y aseg\u00farate de que solo el usuario autenticado pueda acceder a ella.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"phoenix_2/mid/seguridad_en_phoenix/#consejos-o-mejores-practicas","text":"Siempre filtra y valida los datos recibidos de los usuarios antes de utilizarlos en una aplicaci\u00f3n. Utiliza t\u00e9cnicas de cifrado para almacenar de forma segura las credenciales de los usuarios. Implementa medidas de autenticaci\u00f3n y autorizaci\u00f3n para limitar el acceso a ciertas partes de la aplicaci\u00f3n. Mant\u00e9n tu aplicaci\u00f3n Phoenix actualizada con las \u00faltimas versiones, ya que estas pueden incluir mejoras de seguridad.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix_2/sr/","text":"Phoenix 2 - Nivel Senior \u00b6 \u00a1Bienvenido/a al nivel Senior del segundo curso de Phoenix! Aqu\u00ed encontrar\u00e1s temas para profesionales que buscan exprimir al m\u00e1ximo Phoenix: Internals de Phoenix Extensibilidad de Phoenix Debugging y troubleshooting Phoenix sin servidor Profundizando en Ecto Migraci\u00f3n de una aplicaci\u00f3n existente a Phoenix Contribuyendo a Phoenix Para m\u00e1s detalles, consulta phoenix_sr.json .","title":"Phoenix 2 - Nivel Senior"},{"location":"phoenix_2/sr/#phoenix-2-nivel-senior","text":"\u00a1Bienvenido/a al nivel Senior del segundo curso de Phoenix! Aqu\u00ed encontrar\u00e1s temas para profesionales que buscan exprimir al m\u00e1ximo Phoenix: Internals de Phoenix Extensibilidad de Phoenix Debugging y troubleshooting Phoenix sin servidor Profundizando en Ecto Migraci\u00f3n de una aplicaci\u00f3n existente a Phoenix Contribuyendo a Phoenix Para m\u00e1s detalles, consulta phoenix_sr.json .","title":"Phoenix 2 - Nivel Senior"},{"location":"phoenix_2/sr/contribuyendo_a_phoenix/","text":"Contribuyendo a Phoenix \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 Phoenix es un framework de desarrollo web escrito en el lenguaje de programaci\u00f3n Elixir, basado en el patr\u00f3n de arquitectura MVC (Modelo-Vista-Controlador). Fue creado para ser r\u00e1pido, escalable y confiable, y se ha convertido en una de las herramientas m\u00e1s populares para el desarrollo de aplicaciones web en Elixir. Este m\u00f3dulo se enfoca en c\u00f3mo contribuir al desarrollo de Phoenix y colaborar con la comunidad para mejorar la plataforma. Aprender\u00e1s c\u00f3mo contribuir al c\u00f3digo fuente de Phoenix, c\u00f3mo informar de errores y c\u00f3mo colaborar con otros desarrolladores en la comunidad de Phoenix. Palabras clave y definiciones \u00b6 Contribuci\u00f3n: aportar al desarrollo de una plataforma o proyecto de manera activa y voluntaria. C\u00f3digo fuente: el conjunto de instrucciones escritas en un lenguaje de programaci\u00f3n que conforman un programa o aplicaci\u00f3n. Error: un problema o fallo en el funcionamiento de una aplicaci\u00f3n. Comunidad: grupo de personas que comparten intereses y trabajan juntas en un proyecto o causa com\u00fan. Pull request: una solicitud para que los cambios realizados en el c\u00f3digo fuente sean incorporados al repositorio principal. Fork: una copia del repositorio de c\u00f3digo fuente de un proyecto que se puede modificar y utilizar de manera independiente. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es una contribuci\u00f3n en el contexto de desarrollo de software? \u00bfCu\u00e1l es el lenguaje de programaci\u00f3n en el que est\u00e1 escrito Phoenix? \u00bfCu\u00e1l es el patr\u00f3n de arquitectura en el que se basa Phoenix? \u00bfCu\u00e1les son las caracter\u00edsticas principales de Phoenix? \u00bfQu\u00e9 es un pull request en el contexto de contribuci\u00f3n a Phoenix? \u00bfQu\u00e9 es un fork en el contexto de contribuci\u00f3n a Phoenix? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 Instalaci\u00f3n de Phoenix \u00b6 Para contribuir a Phoenix, primero debes tenerlo instalado en tu sistema. Puedes seguir los siguientes pasos para instalar Phoenix en una m\u00e1quina con Linux o Mac: Instala Elixir en tu sistema. Instala Hex, el administrador de paquetes de Elixir, ejecutando mix local.hex en tu terminal. Instala Phoenix con el comando mix archive.install hex phx_new . Verifica que la instalaci\u00f3n fue exitosa con phx_new -v . Creaci\u00f3n de una nueva aplicaci\u00f3n \u00b6 Una vez que tengas Phoenix instalado, puedes crear una nueva aplicaci\u00f3n para empezar a contribuir. Puedes hacerlo con el siguiente comando: mix phx.new my_app Esto crear\u00e1 una nueva aplicaci\u00f3n llamada my_app en el directorio actual. Agregando una nueva funcionalidad \u00b6 Supongamos que queremos agregar una nueva funcionalidad a nuestra aplicaci\u00f3n que permita a los usuarios autenticarse con Google. Podemos hacerlo siguiendo estos pasos: Instalar la biblioteca oauth2 con mix deps.get . Crear un controlador AuthController con el comando mix phx.gen.controller Auth auth google (reemplaza google con el proveedor de autenticaci\u00f3n que quieras). Agregar la l\u00f3gica de autenticaci\u00f3n en el controlador y las rutas correspondientes en el archivo router.ex . Actualizar las vistas necesarias para mostrar los botones de autenticaci\u00f3n. Modificar el modelo User para almacenar la informaci\u00f3n del usuario autenticado. Realizar pruebas para asegurarse de que la funcionalidad funciona correctamente. Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea un fork del repositorio de Phoenix en GitHub. Realiza los cambios que consideres necesarios en tu fork. Crea un pull request con tus cambios en el repositorio principal. Contribuye a la documentaci\u00f3n de Phoenix en el repositorio oficial o en la wiki de la comunidad. Busca y reporta errores en la aplicaci\u00f3n de ejemplo de Phoenix (disponible en la documentaci\u00f3n oficial). Participa en discusiones y debates en el foro de la comunidad de Phoenix. Consejos o mejores pr\u00e1cticas \u00b6 Antes de contribuir, aseg\u00farate de leer las pautas y recomendaciones de contribuci\u00f3n del proyecto. Siempre incluye pruebas para tus cambios y aseg\u00farate de que todas las pruebas existentes pasen correctamente. Utiliza comentarios y documentaci\u00f3n clara y concisa en tu c\u00f3digo para facilitar la revisi\u00f3n de tu contribuci\u00f3n. Participa en la comunidad de Phoenix, comparte tus conocimientos y aprende de otros desarrolladores. No tengas miedo de pedir ayuda o hacer preguntas si tienes dudas o problemas durante el proceso de contribuci\u00f3n. La comunidad de Phoenix es muy amigable y siempre est\u00e1 dispuesta a ayudar.","title":"Contribuyendo a Phoenix"},{"location":"phoenix_2/sr/contribuyendo_a_phoenix/#contribuyendo-a-phoenix","text":"","title":"Contribuyendo a Phoenix"},{"location":"phoenix_2/sr/contribuyendo_a_phoenix/#descripcion-del-modulo","text":"Phoenix es un framework de desarrollo web escrito en el lenguaje de programaci\u00f3n Elixir, basado en el patr\u00f3n de arquitectura MVC (Modelo-Vista-Controlador). Fue creado para ser r\u00e1pido, escalable y confiable, y se ha convertido en una de las herramientas m\u00e1s populares para el desarrollo de aplicaciones web en Elixir. Este m\u00f3dulo se enfoca en c\u00f3mo contribuir al desarrollo de Phoenix y colaborar con la comunidad para mejorar la plataforma. Aprender\u00e1s c\u00f3mo contribuir al c\u00f3digo fuente de Phoenix, c\u00f3mo informar de errores y c\u00f3mo colaborar con otros desarrolladores en la comunidad de Phoenix.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"phoenix_2/sr/contribuyendo_a_phoenix/#palabras-clave-y-definiciones","text":"Contribuci\u00f3n: aportar al desarrollo de una plataforma o proyecto de manera activa y voluntaria. C\u00f3digo fuente: el conjunto de instrucciones escritas en un lenguaje de programaci\u00f3n que conforman un programa o aplicaci\u00f3n. Error: un problema o fallo en el funcionamiento de una aplicaci\u00f3n. Comunidad: grupo de personas que comparten intereses y trabajan juntas en un proyecto o causa com\u00fan. Pull request: una solicitud para que los cambios realizados en el c\u00f3digo fuente sean incorporados al repositorio principal. Fork: una copia del repositorio de c\u00f3digo fuente de un proyecto que se puede modificar y utilizar de manera independiente.","title":"Palabras clave y definiciones"},{"location":"phoenix_2/sr/contribuyendo_a_phoenix/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es una contribuci\u00f3n en el contexto de desarrollo de software? \u00bfCu\u00e1l es el lenguaje de programaci\u00f3n en el que est\u00e1 escrito Phoenix? \u00bfCu\u00e1l es el patr\u00f3n de arquitectura en el que se basa Phoenix? \u00bfCu\u00e1les son las caracter\u00edsticas principales de Phoenix? \u00bfQu\u00e9 es un pull request en el contexto de contribuci\u00f3n a Phoenix? \u00bfQu\u00e9 es un fork en el contexto de contribuci\u00f3n a Phoenix?","title":"Preguntas de repaso"},{"location":"phoenix_2/sr/contribuyendo_a_phoenix/#ejemplos-de-codigo-en-phoenix-framework","text":"","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix_2/sr/contribuyendo_a_phoenix/#instalacion-de-phoenix","text":"Para contribuir a Phoenix, primero debes tenerlo instalado en tu sistema. Puedes seguir los siguientes pasos para instalar Phoenix en una m\u00e1quina con Linux o Mac: Instala Elixir en tu sistema. Instala Hex, el administrador de paquetes de Elixir, ejecutando mix local.hex en tu terminal. Instala Phoenix con el comando mix archive.install hex phx_new . Verifica que la instalaci\u00f3n fue exitosa con phx_new -v .","title":"Instalaci\u00f3n de Phoenix"},{"location":"phoenix_2/sr/contribuyendo_a_phoenix/#creacion-de-una-nueva-aplicacion","text":"Una vez que tengas Phoenix instalado, puedes crear una nueva aplicaci\u00f3n para empezar a contribuir. Puedes hacerlo con el siguiente comando: mix phx.new my_app Esto crear\u00e1 una nueva aplicaci\u00f3n llamada my_app en el directorio actual.","title":"Creaci\u00f3n de una nueva aplicaci\u00f3n"},{"location":"phoenix_2/sr/contribuyendo_a_phoenix/#agregando-una-nueva-funcionalidad","text":"Supongamos que queremos agregar una nueva funcionalidad a nuestra aplicaci\u00f3n que permita a los usuarios autenticarse con Google. Podemos hacerlo siguiendo estos pasos: Instalar la biblioteca oauth2 con mix deps.get . Crear un controlador AuthController con el comando mix phx.gen.controller Auth auth google (reemplaza google con el proveedor de autenticaci\u00f3n que quieras). Agregar la l\u00f3gica de autenticaci\u00f3n en el controlador y las rutas correspondientes en el archivo router.ex . Actualizar las vistas necesarias para mostrar los botones de autenticaci\u00f3n. Modificar el modelo User para almacenar la informaci\u00f3n del usuario autenticado. Realizar pruebas para asegurarse de que la funcionalidad funciona correctamente.","title":"Agregando una nueva funcionalidad"},{"location":"phoenix_2/sr/contribuyendo_a_phoenix/#ejercicios-practicos-con-instrucciones-claras","text":"Crea un fork del repositorio de Phoenix en GitHub. Realiza los cambios que consideres necesarios en tu fork. Crea un pull request con tus cambios en el repositorio principal. Contribuye a la documentaci\u00f3n de Phoenix en el repositorio oficial o en la wiki de la comunidad. Busca y reporta errores en la aplicaci\u00f3n de ejemplo de Phoenix (disponible en la documentaci\u00f3n oficial). Participa en discusiones y debates en el foro de la comunidad de Phoenix.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"phoenix_2/sr/contribuyendo_a_phoenix/#consejos-o-mejores-practicas","text":"Antes de contribuir, aseg\u00farate de leer las pautas y recomendaciones de contribuci\u00f3n del proyecto. Siempre incluye pruebas para tus cambios y aseg\u00farate de que todas las pruebas existentes pasen correctamente. Utiliza comentarios y documentaci\u00f3n clara y concisa en tu c\u00f3digo para facilitar la revisi\u00f3n de tu contribuci\u00f3n. Participa en la comunidad de Phoenix, comparte tus conocimientos y aprende de otros desarrolladores. No tengas miedo de pedir ayuda o hacer preguntas si tienes dudas o problemas durante el proceso de contribuci\u00f3n. La comunidad de Phoenix es muy amigable y siempre est\u00e1 dispuesta a ayudar.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix_2/sr/debugging_y_troubleshooting/","text":"Debugging y troubleshooting en Phoenix Framework \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 Debugging y troubleshooting son dos conceptos importantes en el desarrollo de aplicaciones, ya que nos permiten identificar y solucionar problemas que puedan surgir durante el proceso de desarrollo o en producci\u00f3n. En Phoenix Framework, al igual que en cualquier otro framework, es posible que se presenten errores y comportamientos inesperados en nuestra aplicaci\u00f3n. Por lo tanto, es fundamental conocer herramientas y t\u00e9cnicas avanzadas para poder identificar y solucionar estos problemas de manera eficiente. El proceso de debugging consiste en buscar y corregir errores en nuestro c\u00f3digo, mientras que el troubleshooting se enfoca en identificar y resolver problemas que pueden surgir en el funcionamiento de nuestra aplicaci\u00f3n. Palabras clave y su definici\u00f3n \u00b6 Debugging: Proceso de b\u00fasqueda y correcci\u00f3n de errores en el c\u00f3digo de una aplicaci\u00f3n. Troubleshooting: Proceso de identificaci\u00f3n y soluci\u00f3n de problemas en el funcionamiento de una aplicaci\u00f3n. Consola de Phoenix: Herramienta de l\u00ednea de comandos que permite interactuar con nuestra aplicaci\u00f3n Phoenix. Logger: Registro de eventos y mensajes que nos permite hacer un seguimiento del funcionamiento de nuestra aplicaci\u00f3n. Debugger: Herramienta que nos permite detener la ejecuci\u00f3n de nuestro c\u00f3digo en puntos espec\u00edficos para analizar su estado y comportamiento. ExUnit: Framework de pruebas unitarias incluido en Phoenix Framework. Preguntas de repaso \u00b6 \u00bfCu\u00e1l es la diferencia entre debugging y troubleshooting? \u00bfQu\u00e9 es la Consola de Phoenix y para qu\u00e9 se utiliza? \u00bfCu\u00e1l es la funci\u00f3n del Logger en una aplicaci\u00f3n Phoenix? \u00bfC\u00f3mo funciona un Debugger en Phoenix Framework? \u00bfQu\u00e9 es ExUnit y para qu\u00e9 se utiliza? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 Utilizando el Logger en una aplicaci\u00f3n Phoenix \u00b6 # Configuraci\u00f3n del logger en el archivo config/config.exs config :logger , level : :debug , handle_otp_reports : true , handle_sasl_reports : true # Ejemplo de uso del logger en un controlador defmodule MyApp.UserController do use MyApp.Web , :controller def index ( conn , _params ) do Logger . debug ( \"Accediendo al recurso de usuarios\" ) # Resto del c\u00f3digo end end Uso de Debugger en una aplicaci\u00f3n Phoenix \u00b6 # Utilizando el m\u00f3dulo IEx.pry en un controlador defmodule MyApp.UserController do use MyApp.Web , :controller def show ( conn , %{ \"id\" => id }) do user = Repo . get ( User , id ) require IEx ; IEx . pry # Aqu\u00ed se detendr\u00e1 la ejecuci\u00f3n y podremos inspeccionar la variable user # Resto del c\u00f3digo end end Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 En una aplicaci\u00f3n Phoenix, crea un endpoint que imprima un mensaje en el logger cada vez que se acceda a \u00e9l. Utilizando el Debugger, det\u00e9n la ejecuci\u00f3n de un controlador y revisa el contenido de una variable. Crea una prueba unitaria en ExUnit que verifique el funcionamiento de una funci\u00f3n en un m\u00f3dulo de tu aplicaci\u00f3n. Consejos o mejores pr\u00e1cticas \u00b6 Utilizar el Logger de forma estrat\u00e9gica para registrar eventos y mensajes importantes en el funcionamiento de la aplicaci\u00f3n. Familiarizarse con las herramientas de debugging y troubleshooting disponibles en Phoenix Framework. Realizar pruebas unitarias de manera regular para detectar posibles problemas en el c\u00f3digo. En caso de no poder solucionar un problema, buscar ayuda en la comunidad de Phoenix Framework o en la documentaci\u00f3n oficial.","title":"Debugging y troubleshooting"},{"location":"phoenix_2/sr/debugging_y_troubleshooting/#debugging-y-troubleshooting-en-phoenix-framework","text":"","title":"Debugging y troubleshooting en Phoenix Framework"},{"location":"phoenix_2/sr/debugging_y_troubleshooting/#explicacion-teorica","text":"Debugging y troubleshooting son dos conceptos importantes en el desarrollo de aplicaciones, ya que nos permiten identificar y solucionar problemas que puedan surgir durante el proceso de desarrollo o en producci\u00f3n. En Phoenix Framework, al igual que en cualquier otro framework, es posible que se presenten errores y comportamientos inesperados en nuestra aplicaci\u00f3n. Por lo tanto, es fundamental conocer herramientas y t\u00e9cnicas avanzadas para poder identificar y solucionar estos problemas de manera eficiente. El proceso de debugging consiste en buscar y corregir errores en nuestro c\u00f3digo, mientras que el troubleshooting se enfoca en identificar y resolver problemas que pueden surgir en el funcionamiento de nuestra aplicaci\u00f3n.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix_2/sr/debugging_y_troubleshooting/#palabras-clave-y-su-definicion","text":"Debugging: Proceso de b\u00fasqueda y correcci\u00f3n de errores en el c\u00f3digo de una aplicaci\u00f3n. Troubleshooting: Proceso de identificaci\u00f3n y soluci\u00f3n de problemas en el funcionamiento de una aplicaci\u00f3n. Consola de Phoenix: Herramienta de l\u00ednea de comandos que permite interactuar con nuestra aplicaci\u00f3n Phoenix. Logger: Registro de eventos y mensajes que nos permite hacer un seguimiento del funcionamiento de nuestra aplicaci\u00f3n. Debugger: Herramienta que nos permite detener la ejecuci\u00f3n de nuestro c\u00f3digo en puntos espec\u00edficos para analizar su estado y comportamiento. ExUnit: Framework de pruebas unitarias incluido en Phoenix Framework.","title":"Palabras clave y su definici\u00f3n"},{"location":"phoenix_2/sr/debugging_y_troubleshooting/#preguntas-de-repaso","text":"\u00bfCu\u00e1l es la diferencia entre debugging y troubleshooting? \u00bfQu\u00e9 es la Consola de Phoenix y para qu\u00e9 se utiliza? \u00bfCu\u00e1l es la funci\u00f3n del Logger en una aplicaci\u00f3n Phoenix? \u00bfC\u00f3mo funciona un Debugger en Phoenix Framework? \u00bfQu\u00e9 es ExUnit y para qu\u00e9 se utiliza?","title":"Preguntas de repaso"},{"location":"phoenix_2/sr/debugging_y_troubleshooting/#ejemplos-de-codigo-en-phoenix-framework","text":"","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix_2/sr/debugging_y_troubleshooting/#utilizando-el-logger-en-una-aplicacion-phoenix","text":"# Configuraci\u00f3n del logger en el archivo config/config.exs config :logger , level : :debug , handle_otp_reports : true , handle_sasl_reports : true # Ejemplo de uso del logger en un controlador defmodule MyApp.UserController do use MyApp.Web , :controller def index ( conn , _params ) do Logger . debug ( \"Accediendo al recurso de usuarios\" ) # Resto del c\u00f3digo end end","title":"Utilizando el Logger en una aplicaci\u00f3n Phoenix"},{"location":"phoenix_2/sr/debugging_y_troubleshooting/#uso-de-debugger-en-una-aplicacion-phoenix","text":"# Utilizando el m\u00f3dulo IEx.pry en un controlador defmodule MyApp.UserController do use MyApp.Web , :controller def show ( conn , %{ \"id\" => id }) do user = Repo . get ( User , id ) require IEx ; IEx . pry # Aqu\u00ed se detendr\u00e1 la ejecuci\u00f3n y podremos inspeccionar la variable user # Resto del c\u00f3digo end end","title":"Uso de Debugger en una aplicaci\u00f3n Phoenix"},{"location":"phoenix_2/sr/debugging_y_troubleshooting/#ejercicios-practicos-con-instrucciones-claras","text":"En una aplicaci\u00f3n Phoenix, crea un endpoint que imprima un mensaje en el logger cada vez que se acceda a \u00e9l. Utilizando el Debugger, det\u00e9n la ejecuci\u00f3n de un controlador y revisa el contenido de una variable. Crea una prueba unitaria en ExUnit que verifique el funcionamiento de una funci\u00f3n en un m\u00f3dulo de tu aplicaci\u00f3n.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"phoenix_2/sr/debugging_y_troubleshooting/#consejos-o-mejores-practicas","text":"Utilizar el Logger de forma estrat\u00e9gica para registrar eventos y mensajes importantes en el funcionamiento de la aplicaci\u00f3n. Familiarizarse con las herramientas de debugging y troubleshooting disponibles en Phoenix Framework. Realizar pruebas unitarias de manera regular para detectar posibles problemas en el c\u00f3digo. En caso de no poder solucionar un problema, buscar ayuda en la comunidad de Phoenix Framework o en la documentaci\u00f3n oficial.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix_2/sr/extensibilidad_de_phoenix/","text":"Extensibilidad de Phoenix \u00b6 Descripci\u00f3n del m\u00f3dulo \u00b6 El m\u00f3dulo de extensibilidad de Phoenix tiene como objetivo ense\u00f1ar a los estudiantes c\u00f3mo personalizar y extender el framework Phoenix para adaptarlo a sus necesidades espec\u00edficas. A trav\u00e9s de la utilizaci\u00f3n de macros, plug-ins y generadores personalizados, los desarrolladores podr\u00e1n crear aplicaciones m\u00e1s flexibles y escalables utilizando las herramientas proporcionadas por Phoenix. Explicaci\u00f3n te\u00f3rica \u00b6 Phoenix es un framework web dise\u00f1ado para el desarrollo r\u00e1pido y escalable de aplicaciones en Elixir. Una de las principales ventajas de Phoenix es su extensibilidad, lo que permite a los desarrolladores personalizar y agregar funcionalidades a sus aplicaciones de forma sencilla y eficiente. Esto se logra a trav\u00e9s de la utilizaci\u00f3n de diferentes herramientas, como macros, plug-ins y generadores personalizados. Las macros son una forma de encapsular y reutilizar c\u00f3digo en Phoenix. Se definen como funciones que generan c\u00f3digo en tiempo de compilaci\u00f3n, lo que permite a los desarrolladores escribir menos c\u00f3digo y aumentar la legibilidad y mantenibilidad de sus aplicaciones. Algunos ejemplos de macros en Phoenix son plug , scope y pipeline . Los plug-ins son paquetes de c\u00f3digo que se pueden agregar a una aplicaci\u00f3n de Phoenix para extender su funcionalidad. Estos pueden ser desarrollados por la comunidad o por el propio equipo de Phoenix Framework. Algunos ejemplos de plug-ins populares son phoenix_live_view , phoenix_html y phoenix_pubsub . Por \u00faltimo, los generadores personalizados permiten a los desarrolladores crear sus propias plantillas de c\u00f3digo para la generaci\u00f3n de m\u00f3dulos y controladores en Phoenix. Esto facilita la creaci\u00f3n de aplicaciones m\u00e1s r\u00e1pidamente y con un c\u00f3digo m\u00e1s estandarizado. Palabras clave y su definici\u00f3n \u00b6 Extensibilidad: Capacidad de un sistema para ser modificado y adaptado en funci\u00f3n de las necesidades espec\u00edficas de un usuario o aplicaci\u00f3n. Macros: Funciones que generan c\u00f3digo en tiempo de compilaci\u00f3n para encapsular y reutilizar c\u00f3digo. Plug-ins: Paquetes de c\u00f3digo que se pueden agregar a una aplicaci\u00f3n para extender su funcionalidad. Generadores personalizados: Plantillas de c\u00f3digo para la generaci\u00f3n de m\u00f3dulos y controladores personalizados en Phoenix. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es la extensibilidad en el contexto de Phoenix? \u00bfQu\u00e9 son las macros y c\u00f3mo se utilizan en Phoenix? Menciona algunos ejemplos de macros en Phoenix. \u00bfQu\u00e9 son los plug-ins y c\u00f3mo se pueden utilizar en una aplicaci\u00f3n de Phoenix? \u00bfQu\u00e9 son los generadores personalizados y para qu\u00e9 se utilizan en Phoenix? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 Macros \u00b6 # Definici\u00f3n de una macro defmacro add_two_numbers(a, b) do quote do unquote(a) + unquote(b) end end # Uso de la macro result = add_two_numbers(2, 3) IO.puts result # Output: 5 Plug-ins \u00b6 # Instalaci\u00f3n de un plug-in mix deps.get phoenix_live_view # Uso del plug-in defmodule MyAppWeb do use Phoenix.LiveView end Generadores personalizados \u00b6 # Creaci \u00f3 n de un generador personalizado mix phx . gen . html User users name : string age : integer # Uso del generador personalizado defmodule MyAppWeb . UserController do use MyAppWeb , : controller end Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una macro que multiplique dos n\u00fameros y \u00fasala en tu aplicaci\u00f3n de Phoenix. Instala el plug-in phoenix_html y utiliza su funcionalidad en una vista de tu aplicaci\u00f3n. Crea un generador personalizado que genere un m\u00f3dulo con un atributo adicional y util\u00edzalo en tu aplicaci\u00f3n. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza macros para encapsular y reutilizar c\u00f3digo en tu aplicaci\u00f3n de Phoenix. Investiga y utiliza plug-ins desarrollados por la comunidad para agregar funcionalidades a tu aplicaci\u00f3n. Crea tus propios generadores personalizados para generar c\u00f3digo de forma m\u00e1s r\u00e1pida y estandarizada. Siempre verifica la documentaci\u00f3n oficial de Phoenix para conocer las mejores pr\u00e1cticas al utilizar macros, plug-ins y generadores personalizados.","title":"Extensibilidad de Phoenix"},{"location":"phoenix_2/sr/extensibilidad_de_phoenix/#extensibilidad-de-phoenix","text":"","title":"Extensibilidad de Phoenix"},{"location":"phoenix_2/sr/extensibilidad_de_phoenix/#descripcion-del-modulo","text":"El m\u00f3dulo de extensibilidad de Phoenix tiene como objetivo ense\u00f1ar a los estudiantes c\u00f3mo personalizar y extender el framework Phoenix para adaptarlo a sus necesidades espec\u00edficas. A trav\u00e9s de la utilizaci\u00f3n de macros, plug-ins y generadores personalizados, los desarrolladores podr\u00e1n crear aplicaciones m\u00e1s flexibles y escalables utilizando las herramientas proporcionadas por Phoenix.","title":"Descripci\u00f3n del m\u00f3dulo"},{"location":"phoenix_2/sr/extensibilidad_de_phoenix/#explicacion-teorica","text":"Phoenix es un framework web dise\u00f1ado para el desarrollo r\u00e1pido y escalable de aplicaciones en Elixir. Una de las principales ventajas de Phoenix es su extensibilidad, lo que permite a los desarrolladores personalizar y agregar funcionalidades a sus aplicaciones de forma sencilla y eficiente. Esto se logra a trav\u00e9s de la utilizaci\u00f3n de diferentes herramientas, como macros, plug-ins y generadores personalizados. Las macros son una forma de encapsular y reutilizar c\u00f3digo en Phoenix. Se definen como funciones que generan c\u00f3digo en tiempo de compilaci\u00f3n, lo que permite a los desarrolladores escribir menos c\u00f3digo y aumentar la legibilidad y mantenibilidad de sus aplicaciones. Algunos ejemplos de macros en Phoenix son plug , scope y pipeline . Los plug-ins son paquetes de c\u00f3digo que se pueden agregar a una aplicaci\u00f3n de Phoenix para extender su funcionalidad. Estos pueden ser desarrollados por la comunidad o por el propio equipo de Phoenix Framework. Algunos ejemplos de plug-ins populares son phoenix_live_view , phoenix_html y phoenix_pubsub . Por \u00faltimo, los generadores personalizados permiten a los desarrolladores crear sus propias plantillas de c\u00f3digo para la generaci\u00f3n de m\u00f3dulos y controladores en Phoenix. Esto facilita la creaci\u00f3n de aplicaciones m\u00e1s r\u00e1pidamente y con un c\u00f3digo m\u00e1s estandarizado.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix_2/sr/extensibilidad_de_phoenix/#palabras-clave-y-su-definicion","text":"Extensibilidad: Capacidad de un sistema para ser modificado y adaptado en funci\u00f3n de las necesidades espec\u00edficas de un usuario o aplicaci\u00f3n. Macros: Funciones que generan c\u00f3digo en tiempo de compilaci\u00f3n para encapsular y reutilizar c\u00f3digo. Plug-ins: Paquetes de c\u00f3digo que se pueden agregar a una aplicaci\u00f3n para extender su funcionalidad. Generadores personalizados: Plantillas de c\u00f3digo para la generaci\u00f3n de m\u00f3dulos y controladores personalizados en Phoenix.","title":"Palabras clave y su definici\u00f3n"},{"location":"phoenix_2/sr/extensibilidad_de_phoenix/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es la extensibilidad en el contexto de Phoenix? \u00bfQu\u00e9 son las macros y c\u00f3mo se utilizan en Phoenix? Menciona algunos ejemplos de macros en Phoenix. \u00bfQu\u00e9 son los plug-ins y c\u00f3mo se pueden utilizar en una aplicaci\u00f3n de Phoenix? \u00bfQu\u00e9 son los generadores personalizados y para qu\u00e9 se utilizan en Phoenix?","title":"Preguntas de repaso"},{"location":"phoenix_2/sr/extensibilidad_de_phoenix/#ejemplos-de-codigo-en-phoenix-framework","text":"","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix_2/sr/extensibilidad_de_phoenix/#macros","text":"# Definici\u00f3n de una macro defmacro add_two_numbers(a, b) do quote do unquote(a) + unquote(b) end end # Uso de la macro result = add_two_numbers(2, 3) IO.puts result # Output: 5","title":"Macros"},{"location":"phoenix_2/sr/extensibilidad_de_phoenix/#plug-ins","text":"# Instalaci\u00f3n de un plug-in mix deps.get phoenix_live_view # Uso del plug-in defmodule MyAppWeb do use Phoenix.LiveView end","title":"Plug-ins"},{"location":"phoenix_2/sr/extensibilidad_de_phoenix/#generadores-personalizados","text":"# Creaci \u00f3 n de un generador personalizado mix phx . gen . html User users name : string age : integer # Uso del generador personalizado defmodule MyAppWeb . UserController do use MyAppWeb , : controller end","title":"Generadores personalizados"},{"location":"phoenix_2/sr/extensibilidad_de_phoenix/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una macro que multiplique dos n\u00fameros y \u00fasala en tu aplicaci\u00f3n de Phoenix. Instala el plug-in phoenix_html y utiliza su funcionalidad en una vista de tu aplicaci\u00f3n. Crea un generador personalizado que genere un m\u00f3dulo con un atributo adicional y util\u00edzalo en tu aplicaci\u00f3n.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"phoenix_2/sr/extensibilidad_de_phoenix/#consejos-o-mejores-practicas","text":"Utiliza macros para encapsular y reutilizar c\u00f3digo en tu aplicaci\u00f3n de Phoenix. Investiga y utiliza plug-ins desarrollados por la comunidad para agregar funcionalidades a tu aplicaci\u00f3n. Crea tus propios generadores personalizados para generar c\u00f3digo de forma m\u00e1s r\u00e1pida y estandarizada. Siempre verifica la documentaci\u00f3n oficial de Phoenix para conocer las mejores pr\u00e1cticas al utilizar macros, plug-ins y generadores personalizados.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix_2/sr/internals_de_phoenix/","text":"Internals de Phoenix \u00b6 Introducci\u00f3n \u00b6 Phoenix Framework es un framework web escrito en el lenguaje de programaci\u00f3n Elixir, que se basa en el patr\u00f3n de arquitectura Modelo-Vista-Controlador (MVC). Fue creado para ser r\u00e1pido, escalable y confiable, y est\u00e1 desarrollado por el equipo de Elixir de la empresa de consultor\u00eda tecnol\u00f3gica Plataformatec. En esta lecci\u00f3n, profundizaremos en los entresijos de Phoenix, incluyendo su arquitectura interna y c\u00f3mo funciona el enrutamiento. Aprenderemos sobre la estructura de un proyecto Phoenix, c\u00f3mo se manejan las solicitudes HTTP y c\u00f3mo se realiza el enrutamiento de las mismas. Tambi\u00e9n cubriremos algunas palabras clave importantes y consejos para aprovechar al m\u00e1ximo Phoenix. Estructura de un proyecto Phoenix \u00b6 Un proyecto Phoenix sigue una estructura de directorios y archivos com\u00fan, que es similar a otros frameworks web como Ruby on Rails. Al crear un nuevo proyecto Phoenix, se generan autom\u00e1ticamente los siguientes directorios: config : contiene la configuraci\u00f3n del proyecto, como las credenciales de la base de datos y la configuraci\u00f3n del servidor web. lib : contiene el c\u00f3digo fuente del proyecto, incluyendo los modelos, controladores y vistas. priv : contiene recursos privados del proyecto, como los archivos est\u00e1ticos y las plantillas HTML. test : contiene los casos de prueba del proyecto. web : contiene los archivos relacionados con la interfaz web del proyecto, incluyendo el enrutador y los controladores. Enrutamiento en Phoenix \u00b6 Phoenix utiliza un enrutador para manejar las solicitudes HTTP entrantes y dirigirlas a los controladores correspondientes. El enrutador se encuentra en el directorio web y se llama router.ex . Este archivo contiene una funci\u00f3n scope que define la ruta base para todas las solicitudes entrantes. Dentro de esta funci\u00f3n, se pueden definir rutas espec\u00edficas utilizando el m\u00e9todo get o post , que especifican el m\u00e9todo HTTP correspondiente, la ruta y el controlador al que se debe dirigir. Por ejemplo, si tenemos una solicitud GET a la ruta /hola , el enrutador buscar\u00e1 una funci\u00f3n hola en el controlador correspondiente y ejecutar\u00e1 el c\u00f3digo dentro de ella. Palabras clave importantes \u00b6 Controlador: un m\u00f3dulo que maneja las solicitudes HTTP y responde con una vista o una API. Vista: un m\u00f3dulo que genera una respuesta HTTP, ya sea una p\u00e1gina HTML o un JSON. Modelo: un m\u00f3dulo que representa una entidad de la base de datos y maneja la l\u00f3gica de negocio relacionada con ella. Enrutador: un m\u00f3dulo que maneja las solicitudes entrantes y las dirige al controlador correspondiente. Plug: una funci\u00f3n que se ejecuta antes o despu\u00e9s de una solicitud y permite realizar operaciones de middleware, como autenticaci\u00f3n o compresi\u00f3n de respuestas. Preguntas de repaso \u00b6 \u00bfCu\u00e1l es la estructura de un proyecto Phoenix? \u00bfQu\u00e9 es un enrutador y cu\u00e1l es su funci\u00f3n en Phoenix? \u00bfQu\u00e9 es un controlador y qu\u00e9 tipo de operaciones se pueden realizar en \u00e9l? \u00bfQu\u00e9 es un plug y c\u00f3mo se utiliza en Phoenix? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 Definir una ruta en el enrutador: get \"/usuarios\" , UserController , :index Crear una funci\u00f3n en el controlador para manejar la solicitud: def index ( conn , _params ) do usuarios = Repo . all ( Usuario ) render ( conn , \"index.html\" , usuarios : usuarios ) end Crear una vista para generar una respuesta HTML: defmodule MyApp.UsuarioView do use MyApp.Web , :view def render ( \"index.html\" , %{ usuarios : usuarios }) do # Generar una lista de usuarios usuarios_html = for usuario <- usuarios do \"<li> #{ usuario . nombre } </li>\" end # Renderizar la p\u00e1gina con la lista de usuarios render_layout ( \"app.html\" , usuarios_html : usuarios_html ) end end Ejercicios pr\u00e1cticos \u00b6 Crea una nueva ruta en el enrutador que maneje una solicitud POST a la ruta /usuarios y la dirija al controlador correspondiente. En el controlador, crea una funci\u00f3n para manejar la solicitud y agregar un nuevo usuario a la base de datos utilizando el modelo correspondiente. En la vista, genera una respuesta de \u00e9xito si el usuario se ha creado correctamente o una respuesta de error si ha fallado. Consejos y mejores pr\u00e1cticas \u00b6 Utiliza los recursos de la comunidad de Elixir y Phoenix, como la documentaci\u00f3n oficial, foros y grupos de discusi\u00f3n, para obtener ayuda y aprender de otros desarrolladores. Sigue los principios de dise\u00f1o web y los patrones de arquitectura MVC para mantener un c\u00f3digo limpio y escalable. Utiliza los plugs para realizar tareas comunes como autenticaci\u00f3n y manejo de errores en lugar de repetir c\u00f3digo en los controladores. Aprovecha las caracter\u00edsticas de Elixir, como el enrutamiento de patrones y la concurrencia, para mejorar el rendimiento de tu aplicaci\u00f3n. Practica y experimenta con diferentes aspectos de Phoenix para familiarizarte con su funcionamiento y mejorar tus habilidades como desarrollador. Conclusi\u00f3n \u00b6 En esta lecci\u00f3n, hemos aprendido sobre los entresijos de Phoenix, incluyendo su arquitectura interna y c\u00f3mo funciona el enrutamiento. Hemos cubierto la estructura de un proyecto Phoenix, c\u00f3mo se manejan las solicitudes HTTP y las palabras clave importantes. Tambi\u00e9n hemos visto ejemplos de c\u00f3digo y ejercicios pr\u00e1cticos para que puedas poner en pr\u00e1ctica lo que has aprendido. Sigue practicando y explorando Phoenix para convertirte en un experto en este potente framework web.","title":"Internals de Phoenix"},{"location":"phoenix_2/sr/internals_de_phoenix/#internals-de-phoenix","text":"","title":"Internals de Phoenix"},{"location":"phoenix_2/sr/internals_de_phoenix/#introduccion","text":"Phoenix Framework es un framework web escrito en el lenguaje de programaci\u00f3n Elixir, que se basa en el patr\u00f3n de arquitectura Modelo-Vista-Controlador (MVC). Fue creado para ser r\u00e1pido, escalable y confiable, y est\u00e1 desarrollado por el equipo de Elixir de la empresa de consultor\u00eda tecnol\u00f3gica Plataformatec. En esta lecci\u00f3n, profundizaremos en los entresijos de Phoenix, incluyendo su arquitectura interna y c\u00f3mo funciona el enrutamiento. Aprenderemos sobre la estructura de un proyecto Phoenix, c\u00f3mo se manejan las solicitudes HTTP y c\u00f3mo se realiza el enrutamiento de las mismas. Tambi\u00e9n cubriremos algunas palabras clave importantes y consejos para aprovechar al m\u00e1ximo Phoenix.","title":"Introducci\u00f3n"},{"location":"phoenix_2/sr/internals_de_phoenix/#estructura-de-un-proyecto-phoenix","text":"Un proyecto Phoenix sigue una estructura de directorios y archivos com\u00fan, que es similar a otros frameworks web como Ruby on Rails. Al crear un nuevo proyecto Phoenix, se generan autom\u00e1ticamente los siguientes directorios: config : contiene la configuraci\u00f3n del proyecto, como las credenciales de la base de datos y la configuraci\u00f3n del servidor web. lib : contiene el c\u00f3digo fuente del proyecto, incluyendo los modelos, controladores y vistas. priv : contiene recursos privados del proyecto, como los archivos est\u00e1ticos y las plantillas HTML. test : contiene los casos de prueba del proyecto. web : contiene los archivos relacionados con la interfaz web del proyecto, incluyendo el enrutador y los controladores.","title":"Estructura de un proyecto Phoenix"},{"location":"phoenix_2/sr/internals_de_phoenix/#enrutamiento-en-phoenix","text":"Phoenix utiliza un enrutador para manejar las solicitudes HTTP entrantes y dirigirlas a los controladores correspondientes. El enrutador se encuentra en el directorio web y se llama router.ex . Este archivo contiene una funci\u00f3n scope que define la ruta base para todas las solicitudes entrantes. Dentro de esta funci\u00f3n, se pueden definir rutas espec\u00edficas utilizando el m\u00e9todo get o post , que especifican el m\u00e9todo HTTP correspondiente, la ruta y el controlador al que se debe dirigir. Por ejemplo, si tenemos una solicitud GET a la ruta /hola , el enrutador buscar\u00e1 una funci\u00f3n hola en el controlador correspondiente y ejecutar\u00e1 el c\u00f3digo dentro de ella.","title":"Enrutamiento en Phoenix"},{"location":"phoenix_2/sr/internals_de_phoenix/#palabras-clave-importantes","text":"Controlador: un m\u00f3dulo que maneja las solicitudes HTTP y responde con una vista o una API. Vista: un m\u00f3dulo que genera una respuesta HTTP, ya sea una p\u00e1gina HTML o un JSON. Modelo: un m\u00f3dulo que representa una entidad de la base de datos y maneja la l\u00f3gica de negocio relacionada con ella. Enrutador: un m\u00f3dulo que maneja las solicitudes entrantes y las dirige al controlador correspondiente. Plug: una funci\u00f3n que se ejecuta antes o despu\u00e9s de una solicitud y permite realizar operaciones de middleware, como autenticaci\u00f3n o compresi\u00f3n de respuestas.","title":"Palabras clave importantes"},{"location":"phoenix_2/sr/internals_de_phoenix/#preguntas-de-repaso","text":"\u00bfCu\u00e1l es la estructura de un proyecto Phoenix? \u00bfQu\u00e9 es un enrutador y cu\u00e1l es su funci\u00f3n en Phoenix? \u00bfQu\u00e9 es un controlador y qu\u00e9 tipo de operaciones se pueden realizar en \u00e9l? \u00bfQu\u00e9 es un plug y c\u00f3mo se utiliza en Phoenix?","title":"Preguntas de repaso"},{"location":"phoenix_2/sr/internals_de_phoenix/#ejemplos-de-codigo-en-phoenix-framework","text":"Definir una ruta en el enrutador: get \"/usuarios\" , UserController , :index Crear una funci\u00f3n en el controlador para manejar la solicitud: def index ( conn , _params ) do usuarios = Repo . all ( Usuario ) render ( conn , \"index.html\" , usuarios : usuarios ) end Crear una vista para generar una respuesta HTML: defmodule MyApp.UsuarioView do use MyApp.Web , :view def render ( \"index.html\" , %{ usuarios : usuarios }) do # Generar una lista de usuarios usuarios_html = for usuario <- usuarios do \"<li> #{ usuario . nombre } </li>\" end # Renderizar la p\u00e1gina con la lista de usuarios render_layout ( \"app.html\" , usuarios_html : usuarios_html ) end end","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix_2/sr/internals_de_phoenix/#ejercicios-practicos","text":"Crea una nueva ruta en el enrutador que maneje una solicitud POST a la ruta /usuarios y la dirija al controlador correspondiente. En el controlador, crea una funci\u00f3n para manejar la solicitud y agregar un nuevo usuario a la base de datos utilizando el modelo correspondiente. En la vista, genera una respuesta de \u00e9xito si el usuario se ha creado correctamente o una respuesta de error si ha fallado.","title":"Ejercicios pr\u00e1cticos"},{"location":"phoenix_2/sr/internals_de_phoenix/#consejos-y-mejores-practicas","text":"Utiliza los recursos de la comunidad de Elixir y Phoenix, como la documentaci\u00f3n oficial, foros y grupos de discusi\u00f3n, para obtener ayuda y aprender de otros desarrolladores. Sigue los principios de dise\u00f1o web y los patrones de arquitectura MVC para mantener un c\u00f3digo limpio y escalable. Utiliza los plugs para realizar tareas comunes como autenticaci\u00f3n y manejo de errores en lugar de repetir c\u00f3digo en los controladores. Aprovecha las caracter\u00edsticas de Elixir, como el enrutamiento de patrones y la concurrencia, para mejorar el rendimiento de tu aplicaci\u00f3n. Practica y experimenta con diferentes aspectos de Phoenix para familiarizarte con su funcionamiento y mejorar tus habilidades como desarrollador.","title":"Consejos y mejores pr\u00e1cticas"},{"location":"phoenix_2/sr/internals_de_phoenix/#conclusion","text":"En esta lecci\u00f3n, hemos aprendido sobre los entresijos de Phoenix, incluyendo su arquitectura interna y c\u00f3mo funciona el enrutamiento. Hemos cubierto la estructura de un proyecto Phoenix, c\u00f3mo se manejan las solicitudes HTTP y las palabras clave importantes. Tambi\u00e9n hemos visto ejemplos de c\u00f3digo y ejercicios pr\u00e1cticos para que puedas poner en pr\u00e1ctica lo que has aprendido. Sigue practicando y explorando Phoenix para convertirte en un experto en este potente framework web.","title":"Conclusi\u00f3n"},{"location":"phoenix_2/sr/migraci%C3%B3n_de_una_aplicaci%C3%B3n_existente_a_phoenix/","text":"Migraci\u00f3n de una aplicaci\u00f3n existente a Phoenix \u00b6 Explicaci\u00f3n te\u00f3rica \u00b6 Phoenix Framework es un framework de aplicaciones web escrito en Elixir, un lenguaje de programaci\u00f3n funcional que se ejecuta en la m\u00e1quina virtual de Erlang. Phoenix se basa en el patr\u00f3n de arquitectura de software Modelo-Vista-Controlador (MVC) y est\u00e1 dise\u00f1ado para crear aplicaciones escalables y de alto rendimiento. Migrar una aplicaci\u00f3n existente a Phoenix puede ser un proceso desafiante, pero tambi\u00e9n puede ser muy beneficioso ya que Phoenix ofrece una gran cantidad de funcionalidades y herramientas que pueden mejorar la eficiencia y el rendimiento de la aplicaci\u00f3n. En esta lecci\u00f3n, aprenderemos algunos consejos y mejores pr\u00e1cticas para migrar una aplicaci\u00f3n existente a Phoenix y aprovechar al m\u00e1ximo su potencial. Palabras clave y su definici\u00f3n \u00b6 Phoenix Framework: Es un framework de aplicaciones web escrito en Elixir. Elixir: Es un lenguaje de programaci\u00f3n funcional que se ejecuta en la m\u00e1quina virtual de Erlang. Modelo-Vista-Controlador (MVC): Es un patr\u00f3n de arquitectura de software que separa la aplicaci\u00f3n en tres componentes: el modelo (la l\u00f3gica de negocio), la vista (la interfaz de usuario) y el controlador (la gesti\u00f3n de las solicitudes del usuario). Escalabilidad: Se refiere a la capacidad de una aplicaci\u00f3n para manejar un aumento en la carga de trabajo sin afectar su rendimiento. Rendimiento: Se refiere a la velocidad y eficiencia con la que una aplicaci\u00f3n puede realizar sus funciones. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es Phoenix Framework? \u00bfEn qu\u00e9 lenguaje de programaci\u00f3n est\u00e1 escrito Phoenix? \u00bfCu\u00e1l es el patr\u00f3n de arquitectura de software utilizado por Phoenix? \u00bfQu\u00e9 es la escalabilidad en una aplicaci\u00f3n? \u00bfQu\u00e9 es el rendimiento en una aplicaci\u00f3n? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 A continuaci\u00f3n, se muestra un ejemplo de c\u00f3digo en Phoenix Framework para crear una ruta y un controlador para una p\u00e1gina de inicio: En el archivo router.ex : defmodule MyApp.Router do use Phoenix.Router get \"/\" , PageController , :index end En el archivo page_controller.ex : defmodule MyApp.PageController do use MyApp.Web , :controller def index ( conn , _params ) do render ( conn , \"index.html\" ) end end En el archivo index.html.eex : < h1 > Bienvenido a mi aplicaci\u00f3n! </ h1 > Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Crea una nueva aplicaci\u00f3n Phoenix usando el comando mix phx.new y n\u00f3mbrala como quieras. Agrega una nueva ruta y un controlador para una p\u00e1gina de contacto en tu aplicaci\u00f3n. Crea una vista en HTML para mostrar la p\u00e1gina de contacto. Agrega un formulario en la p\u00e1gina de contacto para que los usuarios puedan enviar mensajes. Configura la base de datos para almacenar los mensajes enviados desde el formulario. Agrega una funcionalidad para enviar un correo electr\u00f3nico de confirmaci\u00f3n al usuario despu\u00e9s de enviar el formulario de contacto. Consejos o mejores pr\u00e1cticas \u00b6 Antes de migrar la aplicaci\u00f3n existente a Phoenix, aseg\u00farate de entender bien la arquitectura de Phoenix y c\u00f3mo funciona. Comienza por migrar una parte de la aplicaci\u00f3n y aseg\u00farate de que todo funcione correctamente antes de continuar con la migraci\u00f3n completa. Aprovecha las funcionalidades de Phoenix como el enrutamiento autom\u00e1tico, el sistema de vistas y el manejo de errores para mejorar la eficiencia de la aplicaci\u00f3n. Utiliza las migraciones de base de datos para actualizar la estructura de la base de datos al modelo de datos de Phoenix. Revisa y optimiza el c\u00f3digo existente para que se adapte mejor al estilo de programaci\u00f3n funcional de Elixir. Aprovecha las librer\u00edas y paquetes de terceros disponibles en Hex, el repositorio de paquetes de Elixir, para a\u00f1adir funcionalidades a tu aplicaci\u00f3n. Realiza pruebas exhaustivas despu\u00e9s de la migraci\u00f3n para asegurarte de que todo funciona correctamente. Considera la posibilidad de refactorizar o reescribir partes de la aplicaci\u00f3n para aprovechar al m\u00e1ximo las funcionalidades de Phoenix. En resumen, migrar una aplicaci\u00f3n existente a Phoenix puede ser un proceso desafiante, pero con los consejos y mejores pr\u00e1cticas adecuados, puede ser muy beneficioso para mejorar la eficiencia y el rendimiento de la aplicaci\u00f3n. Aseg\u00farate de tener un buen entendimiento de Phoenix y su arquitectura antes de comenzar la migraci\u00f3n, y aprovecha las funcionalidades y herramientas que Phoenix ofrece para obtener los mejores resultados.","title":"Migraci\u00f3n de una aplicaci\u00f3n existente a Phoenix"},{"location":"phoenix_2/sr/migraci%C3%B3n_de_una_aplicaci%C3%B3n_existente_a_phoenix/#migracion-de-una-aplicacion-existente-a-phoenix","text":"","title":"Migraci\u00f3n de una aplicaci\u00f3n existente a Phoenix"},{"location":"phoenix_2/sr/migraci%C3%B3n_de_una_aplicaci%C3%B3n_existente_a_phoenix/#explicacion-teorica","text":"Phoenix Framework es un framework de aplicaciones web escrito en Elixir, un lenguaje de programaci\u00f3n funcional que se ejecuta en la m\u00e1quina virtual de Erlang. Phoenix se basa en el patr\u00f3n de arquitectura de software Modelo-Vista-Controlador (MVC) y est\u00e1 dise\u00f1ado para crear aplicaciones escalables y de alto rendimiento. Migrar una aplicaci\u00f3n existente a Phoenix puede ser un proceso desafiante, pero tambi\u00e9n puede ser muy beneficioso ya que Phoenix ofrece una gran cantidad de funcionalidades y herramientas que pueden mejorar la eficiencia y el rendimiento de la aplicaci\u00f3n. En esta lecci\u00f3n, aprenderemos algunos consejos y mejores pr\u00e1cticas para migrar una aplicaci\u00f3n existente a Phoenix y aprovechar al m\u00e1ximo su potencial.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix_2/sr/migraci%C3%B3n_de_una_aplicaci%C3%B3n_existente_a_phoenix/#palabras-clave-y-su-definicion","text":"Phoenix Framework: Es un framework de aplicaciones web escrito en Elixir. Elixir: Es un lenguaje de programaci\u00f3n funcional que se ejecuta en la m\u00e1quina virtual de Erlang. Modelo-Vista-Controlador (MVC): Es un patr\u00f3n de arquitectura de software que separa la aplicaci\u00f3n en tres componentes: el modelo (la l\u00f3gica de negocio), la vista (la interfaz de usuario) y el controlador (la gesti\u00f3n de las solicitudes del usuario). Escalabilidad: Se refiere a la capacidad de una aplicaci\u00f3n para manejar un aumento en la carga de trabajo sin afectar su rendimiento. Rendimiento: Se refiere a la velocidad y eficiencia con la que una aplicaci\u00f3n puede realizar sus funciones.","title":"Palabras clave y su definici\u00f3n"},{"location":"phoenix_2/sr/migraci%C3%B3n_de_una_aplicaci%C3%B3n_existente_a_phoenix/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Phoenix Framework? \u00bfEn qu\u00e9 lenguaje de programaci\u00f3n est\u00e1 escrito Phoenix? \u00bfCu\u00e1l es el patr\u00f3n de arquitectura de software utilizado por Phoenix? \u00bfQu\u00e9 es la escalabilidad en una aplicaci\u00f3n? \u00bfQu\u00e9 es el rendimiento en una aplicaci\u00f3n?","title":"Preguntas de repaso"},{"location":"phoenix_2/sr/migraci%C3%B3n_de_una_aplicaci%C3%B3n_existente_a_phoenix/#ejemplos-de-codigo-en-phoenix-framework","text":"A continuaci\u00f3n, se muestra un ejemplo de c\u00f3digo en Phoenix Framework para crear una ruta y un controlador para una p\u00e1gina de inicio: En el archivo router.ex : defmodule MyApp.Router do use Phoenix.Router get \"/\" , PageController , :index end En el archivo page_controller.ex : defmodule MyApp.PageController do use MyApp.Web , :controller def index ( conn , _params ) do render ( conn , \"index.html\" ) end end En el archivo index.html.eex : < h1 > Bienvenido a mi aplicaci\u00f3n! </ h1 >","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix_2/sr/migraci%C3%B3n_de_una_aplicaci%C3%B3n_existente_a_phoenix/#ejercicios-practicos-con-instrucciones-claras","text":"Crea una nueva aplicaci\u00f3n Phoenix usando el comando mix phx.new y n\u00f3mbrala como quieras. Agrega una nueva ruta y un controlador para una p\u00e1gina de contacto en tu aplicaci\u00f3n. Crea una vista en HTML para mostrar la p\u00e1gina de contacto. Agrega un formulario en la p\u00e1gina de contacto para que los usuarios puedan enviar mensajes. Configura la base de datos para almacenar los mensajes enviados desde el formulario. Agrega una funcionalidad para enviar un correo electr\u00f3nico de confirmaci\u00f3n al usuario despu\u00e9s de enviar el formulario de contacto.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"phoenix_2/sr/migraci%C3%B3n_de_una_aplicaci%C3%B3n_existente_a_phoenix/#consejos-o-mejores-practicas","text":"Antes de migrar la aplicaci\u00f3n existente a Phoenix, aseg\u00farate de entender bien la arquitectura de Phoenix y c\u00f3mo funciona. Comienza por migrar una parte de la aplicaci\u00f3n y aseg\u00farate de que todo funcione correctamente antes de continuar con la migraci\u00f3n completa. Aprovecha las funcionalidades de Phoenix como el enrutamiento autom\u00e1tico, el sistema de vistas y el manejo de errores para mejorar la eficiencia de la aplicaci\u00f3n. Utiliza las migraciones de base de datos para actualizar la estructura de la base de datos al modelo de datos de Phoenix. Revisa y optimiza el c\u00f3digo existente para que se adapte mejor al estilo de programaci\u00f3n funcional de Elixir. Aprovecha las librer\u00edas y paquetes de terceros disponibles en Hex, el repositorio de paquetes de Elixir, para a\u00f1adir funcionalidades a tu aplicaci\u00f3n. Realiza pruebas exhaustivas despu\u00e9s de la migraci\u00f3n para asegurarte de que todo funciona correctamente. Considera la posibilidad de refactorizar o reescribir partes de la aplicaci\u00f3n para aprovechar al m\u00e1ximo las funcionalidades de Phoenix. En resumen, migrar una aplicaci\u00f3n existente a Phoenix puede ser un proceso desafiante, pero con los consejos y mejores pr\u00e1cticas adecuados, puede ser muy beneficioso para mejorar la eficiencia y el rendimiento de la aplicaci\u00f3n. Aseg\u00farate de tener un buen entendimiento de Phoenix y su arquitectura antes de comenzar la migraci\u00f3n, y aprovecha las funcionalidades y herramientas que Phoenix ofrece para obtener los mejores resultados.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix_2/sr/phoenix_sin_servidor/","text":"Phoenix sin servidor \u00b6 En la actualidad, existen diversas opciones para desplegar aplicaciones web sin la necesidad de tener un servidor dedicado o virtual. Una de estas opciones es el uso de AWS Lambda, un servicio de computaci\u00f3n en la nube que permite ejecutar c\u00f3digo de manera eficiente y econ\u00f3mica. En este m\u00f3dulo, exploraremos c\u00f3mo utilizar AWS Lambda para desplegar aplicaciones Phoenix sin la necesidad de un servidor. Explicaci\u00f3n te\u00f3rica \u00b6 AWS Lambda es un servicio de computaci\u00f3n en la nube que permite ejecutar c\u00f3digo de manera eficiente y econ\u00f3mica, sin la necesidad de tener un servidor dedicado o virtual. Funciona bajo el modelo de \"pago por uso\", es decir, solo se paga por el tiempo de ejecuci\u00f3n del c\u00f3digo. Esto lo hace una opci\u00f3n atractiva para desplegar aplicaciones web que no requieren una gran cantidad de recursos. Para utilizar AWS Lambda con una aplicaci\u00f3n Phoenix, es necesario utilizar un framework de servidor sin estado, como Plug, que permita ejecutar c\u00f3digo en respuesta a eventos. En este caso, el evento ser\u00eda una solicitud HTTP a una ruta espec\u00edfica de la aplicaci\u00f3n. Una vez configurado el proyecto de Phoenix para utilizar Plug, se debe crear una funci\u00f3n en AWS Lambda que se encargue de recibir las solicitudes HTTP y ejecutar el c\u00f3digo correspondiente. Esta funci\u00f3n puede estar escrita en cualquier lenguaje de programaci\u00f3n compatible con AWS Lambda, como Node.js o Python. Una vez que la funci\u00f3n est\u00e1 configurada, se debe crear un API Gateway en AWS que se encargue de recibir las solicitudes HTTP y redirigirlas a la funci\u00f3n de Lambda correspondiente. De esta manera, cuando una solicitud HTTP llegue al API Gateway, ser\u00e1 redirigida a la funci\u00f3n de Lambda que ejecutar\u00e1 el c\u00f3digo de la aplicaci\u00f3n Phoenix. Palabras clave y definici\u00f3n \u00b6 AWS Lambda: Servicio de computaci\u00f3n en la nube que permite ejecutar c\u00f3digo de manera eficiente y econ\u00f3mica, sin la necesidad de tener un servidor dedicado o virtual. Servidor sin estado: Framework de servidor que no almacena informaci\u00f3n sobre las solicitudes anteriores, lo que lo hace ideal para ser utilizado con AWS Lambda. Plug: Framework de servidor para Phoenix que permite ejecutar c\u00f3digo en respuesta a eventos. API Gateway: Servicio de AWS que permite crear, publicar, mantener, monitorear y proteger APIs. Evento: Acci\u00f3n que desencadena la ejecuci\u00f3n de una funci\u00f3n en AWS Lambda. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es AWS Lambda? \u00bfQu\u00e9 es un servidor sin estado? \u00bfQu\u00e9 es Plug? \u00bfQu\u00e9 es API Gateway? \u00bfQu\u00e9 es un evento en el contexto de AWS Lambda? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 # Configuraci\u00f3n de Plug en el proyecto de Phoenix # lib/my_app/endpoint.ex defmodule MyApp.Endpoint do use Phoenix.Endpoint , otp_app : :my_app # Configuraci\u00f3n de Plug plug Plug.RequestId plug Plug.Logger # Resto de la configuraci\u00f3n end // Funci\u00f3n de AWS Lambda para recibir solicitudes HTTP // index.js exports . handler = function ( event , context , callback ) { // L\u00f3gica para manejar la solicitud HTTP } Ejercicios pr\u00e1cticos \u00b6 Configura una aplicaci\u00f3n Phoenix para utilizar Plug. Crea una funci\u00f3n en AWS Lambda para recibir solicitudes HTTP. Configura un API Gateway en AWS para redirigir las solicitudes al Lambda. Realiza una solicitud HTTP a la aplicaci\u00f3n Phoenix desplegada en AWS Lambda. Consejos o mejores pr\u00e1cticas \u00b6 Antes de desplegar una aplicaci\u00f3n Phoenix en AWS Lambda, es importante asegurarse de que se utiliza un servidor sin estado y se ha configurado correctamente para utilizar Plug. Utilizar una herramienta de configuraci\u00f3n de infraestructura, como Terraform o CloudFormation, puede facilitar y automatizar el proceso de despliegue en AWS. Monitorear y optimizar el rendimiento de la funci\u00f3n de Lambda puede ayudar a reducir los costos y mejorar la experiencia del usuario. Utilizar un sistema de cach\u00e9, como Redis, puede mejorar el rendimiento de la aplicaci\u00f3n y reducir la cantidad de solicitudes a la funci\u00f3n de Lambda.","title":"Phoenix sin servidor"},{"location":"phoenix_2/sr/phoenix_sin_servidor/#phoenix-sin-servidor","text":"En la actualidad, existen diversas opciones para desplegar aplicaciones web sin la necesidad de tener un servidor dedicado o virtual. Una de estas opciones es el uso de AWS Lambda, un servicio de computaci\u00f3n en la nube que permite ejecutar c\u00f3digo de manera eficiente y econ\u00f3mica. En este m\u00f3dulo, exploraremos c\u00f3mo utilizar AWS Lambda para desplegar aplicaciones Phoenix sin la necesidad de un servidor.","title":"Phoenix sin servidor"},{"location":"phoenix_2/sr/phoenix_sin_servidor/#explicacion-teorica","text":"AWS Lambda es un servicio de computaci\u00f3n en la nube que permite ejecutar c\u00f3digo de manera eficiente y econ\u00f3mica, sin la necesidad de tener un servidor dedicado o virtual. Funciona bajo el modelo de \"pago por uso\", es decir, solo se paga por el tiempo de ejecuci\u00f3n del c\u00f3digo. Esto lo hace una opci\u00f3n atractiva para desplegar aplicaciones web que no requieren una gran cantidad de recursos. Para utilizar AWS Lambda con una aplicaci\u00f3n Phoenix, es necesario utilizar un framework de servidor sin estado, como Plug, que permita ejecutar c\u00f3digo en respuesta a eventos. En este caso, el evento ser\u00eda una solicitud HTTP a una ruta espec\u00edfica de la aplicaci\u00f3n. Una vez configurado el proyecto de Phoenix para utilizar Plug, se debe crear una funci\u00f3n en AWS Lambda que se encargue de recibir las solicitudes HTTP y ejecutar el c\u00f3digo correspondiente. Esta funci\u00f3n puede estar escrita en cualquier lenguaje de programaci\u00f3n compatible con AWS Lambda, como Node.js o Python. Una vez que la funci\u00f3n est\u00e1 configurada, se debe crear un API Gateway en AWS que se encargue de recibir las solicitudes HTTP y redirigirlas a la funci\u00f3n de Lambda correspondiente. De esta manera, cuando una solicitud HTTP llegue al API Gateway, ser\u00e1 redirigida a la funci\u00f3n de Lambda que ejecutar\u00e1 el c\u00f3digo de la aplicaci\u00f3n Phoenix.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix_2/sr/phoenix_sin_servidor/#palabras-clave-y-definicion","text":"AWS Lambda: Servicio de computaci\u00f3n en la nube que permite ejecutar c\u00f3digo de manera eficiente y econ\u00f3mica, sin la necesidad de tener un servidor dedicado o virtual. Servidor sin estado: Framework de servidor que no almacena informaci\u00f3n sobre las solicitudes anteriores, lo que lo hace ideal para ser utilizado con AWS Lambda. Plug: Framework de servidor para Phoenix que permite ejecutar c\u00f3digo en respuesta a eventos. API Gateway: Servicio de AWS que permite crear, publicar, mantener, monitorear y proteger APIs. Evento: Acci\u00f3n que desencadena la ejecuci\u00f3n de una funci\u00f3n en AWS Lambda.","title":"Palabras clave y definici\u00f3n"},{"location":"phoenix_2/sr/phoenix_sin_servidor/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es AWS Lambda? \u00bfQu\u00e9 es un servidor sin estado? \u00bfQu\u00e9 es Plug? \u00bfQu\u00e9 es API Gateway? \u00bfQu\u00e9 es un evento en el contexto de AWS Lambda?","title":"Preguntas de repaso"},{"location":"phoenix_2/sr/phoenix_sin_servidor/#ejemplos-de-codigo-en-phoenix-framework","text":"# Configuraci\u00f3n de Plug en el proyecto de Phoenix # lib/my_app/endpoint.ex defmodule MyApp.Endpoint do use Phoenix.Endpoint , otp_app : :my_app # Configuraci\u00f3n de Plug plug Plug.RequestId plug Plug.Logger # Resto de la configuraci\u00f3n end // Funci\u00f3n de AWS Lambda para recibir solicitudes HTTP // index.js exports . handler = function ( event , context , callback ) { // L\u00f3gica para manejar la solicitud HTTP }","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix_2/sr/phoenix_sin_servidor/#ejercicios-practicos","text":"Configura una aplicaci\u00f3n Phoenix para utilizar Plug. Crea una funci\u00f3n en AWS Lambda para recibir solicitudes HTTP. Configura un API Gateway en AWS para redirigir las solicitudes al Lambda. Realiza una solicitud HTTP a la aplicaci\u00f3n Phoenix desplegada en AWS Lambda.","title":"Ejercicios pr\u00e1cticos"},{"location":"phoenix_2/sr/phoenix_sin_servidor/#consejos-o-mejores-practicas","text":"Antes de desplegar una aplicaci\u00f3n Phoenix en AWS Lambda, es importante asegurarse de que se utiliza un servidor sin estado y se ha configurado correctamente para utilizar Plug. Utilizar una herramienta de configuraci\u00f3n de infraestructura, como Terraform o CloudFormation, puede facilitar y automatizar el proceso de despliegue en AWS. Monitorear y optimizar el rendimiento de la funci\u00f3n de Lambda puede ayudar a reducir los costos y mejorar la experiencia del usuario. Utilizar un sistema de cach\u00e9, como Redis, puede mejorar el rendimiento de la aplicaci\u00f3n y reducir la cantidad de solicitudes a la funci\u00f3n de Lambda.","title":"Consejos o mejores pr\u00e1cticas"},{"location":"phoenix_2/sr/profundizando_en_ecto/","text":"Profundizando en Ecto \u00b6 En esta lecci\u00f3n, continuaremos explorando Ecto, la capa de persistencia de datos en Phoenix Framework. Aprenderemos sobre sus capacidades avanzadas, incluyendo consultas complejas y transacciones. Explicaci\u00f3n te\u00f3rica \u00b6 Ecto es un m\u00f3dulo de Phoenix Framework que se encarga de interactuar con la base de datos. Utiliza el patr\u00f3n de dise\u00f1o de repositorio y proporciona una interfaz sencilla y f\u00e1cil de usar para realizar operaciones en la base de datos. Una de las principales ventajas de Ecto es su capacidad para generar consultas complejas y optimizadas. Esto se debe a que utiliza una sintaxis similar a SQL pero con una capa de abstracci\u00f3n que permite escribir consultas de manera m\u00e1s legible y eficiente. Ecto tambi\u00e9n ofrece la posibilidad de realizar transacciones, lo que permite realizar varias operaciones en la base de datos de manera at\u00f3mica, es decir, todas las operaciones se realizan o ninguna se realiza. Palabras clave y su definici\u00f3n \u00b6 Repositorio: es una abstracci\u00f3n que nos permite interactuar con la base de datos utilizando Ecto. Consultas complejas: son consultas que involucran m\u00faltiples tablas y filtros. Transacciones: son un conjunto de operaciones que se realizan en la base de datos de manera at\u00f3mica. Sintaxis similar a SQL: Ecto utiliza una sintaxis inspirada en SQL para escribir consultas, pero con una capa de abstracci\u00f3n que facilita su lectura y escritura. Preguntas de repaso \u00b6 \u00bfQu\u00e9 es Ecto y cu\u00e1l es su funci\u00f3n en Phoenix Framework? \u00bfQu\u00e9 patr\u00f3n de dise\u00f1o utiliza Ecto? \u00bfCu\u00e1l es la ventaja de utilizar Ecto para generar consultas complejas? \u00bfQu\u00e9 es una transacci\u00f3n y por qu\u00e9 es \u00fatil en la base de datos? \u00bfC\u00f3mo se escribe una consulta en Ecto? Ejemplos de c\u00f3digo en Phoenix Framework \u00b6 # Consulta utilizando Ecto para obtener todos los usuarios ordenados por su nombre Repo . all ( from u in User , order_by : u . name ) # Consulta utilizando Ecto para obtener un usuario espec\u00edfico Repo . get ( User , 1 ) # Transacci\u00f3n en Ecto para crear un nuevo usuario y su respectivo perfil Repo . transaction ( fn -> user = Repo . insert ! ( % User { name : \"John\" }) profile = Repo . insert ! ( % Profile { user_id : user . id }) end) Ejercicios pr\u00e1cticos con instrucciones claras \u00b6 Utilizando Ecto, crea una consulta que obtenga todos los productos con un precio mayor a $50 y que est\u00e9n disponibles en el inventario. Escribe una consulta en Ecto que obtenga el n\u00famero total de usuarios registrados en la base de datos. Implementa una transacci\u00f3n en Ecto para actualizar la cantidad de un producto en el inventario y crear un nuevo registro de venta en la tabla de registros de ventas. Consejos o mejores pr\u00e1cticas \u00b6 Utiliza la sintaxis de Ecto para escribir consultas complejas en lugar de SQL puro. Siempre utiliza transacciones en operaciones que involucren m\u00faltiples cambios en la base de datos. Aprovecha las funciones de agregaci\u00f3n y ordenamiento de Ecto para realizar operaciones m\u00e1s eficientes en la base de datos.","title":"Profundizando en Ecto"},{"location":"phoenix_2/sr/profundizando_en_ecto/#profundizando-en-ecto","text":"En esta lecci\u00f3n, continuaremos explorando Ecto, la capa de persistencia de datos en Phoenix Framework. Aprenderemos sobre sus capacidades avanzadas, incluyendo consultas complejas y transacciones.","title":"Profundizando en Ecto"},{"location":"phoenix_2/sr/profundizando_en_ecto/#explicacion-teorica","text":"Ecto es un m\u00f3dulo de Phoenix Framework que se encarga de interactuar con la base de datos. Utiliza el patr\u00f3n de dise\u00f1o de repositorio y proporciona una interfaz sencilla y f\u00e1cil de usar para realizar operaciones en la base de datos. Una de las principales ventajas de Ecto es su capacidad para generar consultas complejas y optimizadas. Esto se debe a que utiliza una sintaxis similar a SQL pero con una capa de abstracci\u00f3n que permite escribir consultas de manera m\u00e1s legible y eficiente. Ecto tambi\u00e9n ofrece la posibilidad de realizar transacciones, lo que permite realizar varias operaciones en la base de datos de manera at\u00f3mica, es decir, todas las operaciones se realizan o ninguna se realiza.","title":"Explicaci\u00f3n te\u00f3rica"},{"location":"phoenix_2/sr/profundizando_en_ecto/#palabras-clave-y-su-definicion","text":"Repositorio: es una abstracci\u00f3n que nos permite interactuar con la base de datos utilizando Ecto. Consultas complejas: son consultas que involucran m\u00faltiples tablas y filtros. Transacciones: son un conjunto de operaciones que se realizan en la base de datos de manera at\u00f3mica. Sintaxis similar a SQL: Ecto utiliza una sintaxis inspirada en SQL para escribir consultas, pero con una capa de abstracci\u00f3n que facilita su lectura y escritura.","title":"Palabras clave y su definici\u00f3n"},{"location":"phoenix_2/sr/profundizando_en_ecto/#preguntas-de-repaso","text":"\u00bfQu\u00e9 es Ecto y cu\u00e1l es su funci\u00f3n en Phoenix Framework? \u00bfQu\u00e9 patr\u00f3n de dise\u00f1o utiliza Ecto? \u00bfCu\u00e1l es la ventaja de utilizar Ecto para generar consultas complejas? \u00bfQu\u00e9 es una transacci\u00f3n y por qu\u00e9 es \u00fatil en la base de datos? \u00bfC\u00f3mo se escribe una consulta en Ecto?","title":"Preguntas de repaso"},{"location":"phoenix_2/sr/profundizando_en_ecto/#ejemplos-de-codigo-en-phoenix-framework","text":"# Consulta utilizando Ecto para obtener todos los usuarios ordenados por su nombre Repo . all ( from u in User , order_by : u . name ) # Consulta utilizando Ecto para obtener un usuario espec\u00edfico Repo . get ( User , 1 ) # Transacci\u00f3n en Ecto para crear un nuevo usuario y su respectivo perfil Repo . transaction ( fn -> user = Repo . insert ! ( % User { name : \"John\" }) profile = Repo . insert ! ( % Profile { user_id : user . id }) end)","title":"Ejemplos de c\u00f3digo en Phoenix Framework"},{"location":"phoenix_2/sr/profundizando_en_ecto/#ejercicios-practicos-con-instrucciones-claras","text":"Utilizando Ecto, crea una consulta que obtenga todos los productos con un precio mayor a $50 y que est\u00e9n disponibles en el inventario. Escribe una consulta en Ecto que obtenga el n\u00famero total de usuarios registrados en la base de datos. Implementa una transacci\u00f3n en Ecto para actualizar la cantidad de un producto en el inventario y crear un nuevo registro de venta en la tabla de registros de ventas.","title":"Ejercicios pr\u00e1cticos con instrucciones claras"},{"location":"phoenix_2/sr/profundizando_en_ecto/#consejos-o-mejores-practicas","text":"Utiliza la sintaxis de Ecto para escribir consultas complejas en lugar de SQL puro. Siempre utiliza transacciones en operaciones que involucren m\u00faltiples cambios en la base de datos. Aprovecha las funciones de agregaci\u00f3n y ordenamiento de Ecto para realizar operaciones m\u00e1s eficientes en la base de datos.","title":"Consejos o mejores pr\u00e1cticas"}]}